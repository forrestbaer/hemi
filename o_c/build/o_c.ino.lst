
/private/var/folders/mc/n3pd5t1j6md4_7svscwk5bfr0000gn/T/arduino/sketches/8B31106EE3162608BF422FAFB6EF4BD7/o_c.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
/*static*/
void DAC::set_default_channel_calibration_data(uint8_t channel_id) {
  
  SERIAL_PRINTLN("reset to core/default calibration data ... (channel: %d)", channel_id + 1);
  
  if (channel_id < DAC_CHANNEL_LAST) {
       0:	00 80 00 20 bd 01 00 00 11 a2 01 00 dd a1 01 00     ... ............

    // reset data
    for (int i = 0; i < OCTAVES + 1; i++) 
      calibration_data_->calibrated_octaves[channel_id][i] = OC::calibration_data.dac.calibrated_octaves[channel_id][i];
      10:	dd a1 01 00 dd a1 01 00 dd a1 01 00 dd a1 01 00     ................
    // + update info
    OC::Autotune_data *autotune_data = &OC::auto_calibration_data[channel_id];
    if (autotune_data->use_auto_calibration_ == 0xFF || autotune_data->use_auto_calibration_ == 0x01)
      20:	dd a1 01 00 dd a1 01 00 dd a1 01 00 11 a2 01 00     ................
      autotune_data->use_auto_calibration_ = 0xFF; // = data available, but not used
      30:	11 a2 01 00 dd a1 01 00 1d b4 01 00 21 b4 01 00     ............!...
    else 
      autotune_data->use_auto_calibration_ = 0x00;
  }
}
      40:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
  text_x_ += dx;
  text_y_ += dy;
}

inline uint8_t *Graphics::get_frame_ptr(const coord_t x, const coord_t  y) {
  return frame_ + ((y >>3) << 7) + x;
      50:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
      60:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
  return frame_ + ((y >>3) << 7) + x;
      70:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
      80:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
      90:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
  return frame_ + ((y >>3) << 7) + x;
      a0:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
      b0:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
      graphics.setPixel(64 + x, 0 + averaged_scope_history[DAC_CHANNEL_B][index]);
      graphics.setPixel(x, 32 + averaged_scope_history[DAC_CHANNEL_C][index]);
      graphics.setPixel(64 + x, 32 + averaged_scope_history[DAC_CHANNEL_D][index]);
    #endif
  }
}
      c0:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................

    *PDB0_CHnC1 = PDB_CHnC1_TOS_1 | PDB_CHnC1_EN_1; // enable pretrigger 0 (SC1A)

    NVIC_ENABLE_IRQ(IRQ_PDB);

}
      d0:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
                prescaler = 3;
      e0:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
                mult = 2;
      f0:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
                prescaler = 6;
     100:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
                mult = 2;
     110:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
    uint8_t prescaler = 0; // from 0 to 7: factor of 1, 2, 4, 8, 16, 32, 64 or 128
     120:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
     130:	11 a2 01 00 11 a2 01 00 11 a2 01 00 cd 8e 01 00     ................
     140:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
     150:	35 9e 01 00 4d 9e 01 00 65 9e 01 00 7d 9e 01 00     5...M...e...}...
    *   \return the last converted value.
    *   If single-ended and 16 bits it's necessary to typecast it to an unsigned type (like uint16_t),
    *   otherwise values larger than 3.3/2 V are interpreted as negative!
    */
    int analogReadContinuous() __attribute__((always_inline)) {
        return (int16_t)(int32_t)*ADC_RA;
     160:	11 a2 01 00 49 a6 01 00 11 a2 01 00 11 a2 01 00     ....I...........


    // if we interrupted a conversion, set it again
    if (wasADC0InUse) {
        //digitalWriteFast(LED_BUILTIN, !digitalReadFast(LED_BUILTIN) );
        adc0->loadConfig(&old_adc0_config);
     170:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
    }
    if (wasADC1InUse) {
        //digitalWriteFast(LED_BUILTIN, !digitalReadFast(LED_BUILTIN) );
        adc1->loadConfig(&old_adc1_config);
     180:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
        adc0->fail_flag |= ADC_ERROR_COMPARISON;
     190:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................
        adc1->fail_flag |= ADC_ERROR_COMPARISON;
     1a0:	11 a2 01 00 11 a2 01 00 11 a2 01 00 11 a2 01 00     ................

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
     1b0:	11 a2 01 00 11 a2 01 00 11 a2 01 00                 ............

000001bc <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1bc:	4b58      	ldr	r3, [pc, #352]	; (320 <ResetHandler+0x164>)
     1be:	f24c 5220 	movw	r2, #50464	; 0xc520
{
     1c2:	b510      	push	{r4, lr}
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1c4:	81da      	strh	r2, [r3, #14]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1c6:	f64d 1228 	movw	r2, #55592	; 0xd928
     1ca:	81da      	strh	r2, [r3, #14]
	__asm__ volatile ("nop");
     1cc:	bf00      	nop
	__asm__ volatile ("nop");
     1ce:	bf00      	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1d0:	f01a f822 	bl	1a218 <startup_early_hook>
	// enable clocks to always-used peripherals
#if defined(__MK20DX128__)
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
     1d4:	4b53      	ldr	r3, [pc, #332]	; (324 <ResetHandler+0x168>)
     1d6:	f04f 6210 	mov.w	r2, #150994944	; 0x9000000
     1da:	631a      	str	r2, [r3, #48]	; 0x30
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1dc:	4a52      	ldr	r2, [pc, #328]	; (328 <ResetHandler+0x16c>)
     1de:	639a      	str	r2, [r3, #56]	; 0x38
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1e0:	4a52      	ldr	r2, [pc, #328]	; (32c <ResetHandler+0x170>)
     1e2:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if defined(KINETISK) && !defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started early.
	// But don't do this early on Teensy 3.6 - RTC_CR depends on 3.3V+VBAT
	// which may be ~0.4V "behind" 3.3V if the power ramps up slowly.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     1e4:	4a52      	ldr	r2, [pc, #328]	; (330 <ResetHandler+0x174>)
     1e6:	6913      	ldr	r3, [r2, #16]
     1e8:	f413 7380 	ands.w	r3, r3, #256	; 0x100
		RTC_SR = 0;
     1ec:	bf02      	ittt	eq
     1ee:	6153      	streq	r3, [r2, #20]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     1f0:	f44f 53a8 	moveq.w	r3, #5376	; 0x1500
     1f4:	6113      	streq	r3, [r2, #16]
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     1f6:	4b4f      	ldr	r3, [pc, #316]	; (334 <ResetHandler+0x178>)
     1f8:	789a      	ldrb	r2, [r3, #2]
     1fa:	0710      	lsls	r0, r2, #28
     1fc:	bf48      	it	mi
     1fe:	789a      	ldrbmi	r2, [r3, #2]
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     200:	484d      	ldr	r0, [pc, #308]	; (338 <ResetHandler+0x17c>)
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     202:	bf44      	itt	mi
     204:	f042 0208 	orrmi.w	r2, r2, #8
     208:	709a      	strbmi	r2, [r3, #2]
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     20a:	4b4c      	ldr	r3, [pc, #304]	; (33c <ResetHandler+0x180>)
     20c:	222a      	movs	r2, #42	; 0x2a
     20e:	701a      	strb	r2, [r3, #0]
	while (dest < &_edata) *dest++ = *src++;
     210:	4b4b      	ldr	r3, [pc, #300]	; (340 <ResetHandler+0x184>)
     212:	1cda      	adds	r2, r3, #3
     214:	1a12      	subs	r2, r2, r0
     216:	1ec1      	subs	r1, r0, #3
     218:	f022 0203 	bic.w	r2, r2, #3
     21c:	4299      	cmp	r1, r3
     21e:	bf88      	it	hi
     220:	2200      	movhi	r2, #0
     222:	4948      	ldr	r1, [pc, #288]	; (344 <ResetHandler+0x188>)
     224:	f019 fee4 	bl	19ff0 <memcpy>
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     228:	4b47      	ldr	r3, [pc, #284]	; (348 <ResetHandler+0x18c>)
     22a:	4848      	ldr	r0, [pc, #288]	; (34c <ResetHandler+0x190>)
     22c:	1cda      	adds	r2, r3, #3
     22e:	1a12      	subs	r2, r2, r0
     230:	1ec1      	subs	r1, r0, #3
     232:	f022 0203 	bic.w	r2, r2, #3
     236:	4299      	cmp	r1, r3
     238:	bf88      	it	hi
     23a:	2200      	movhi	r2, #0
     23c:	2100      	movs	r1, #0
     23e:	f019 ffab 	bl	1a198 <memset>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     242:	4943      	ldr	r1, [pc, #268]	; (350 <ResetHandler+0x194>)
     244:	4843      	ldr	r0, [pc, #268]	; (354 <ResetHandler+0x198>)
     246:	f44f 72de 	mov.w	r2, #444	; 0x1bc
     24a:	f019 fed1 	bl	19ff0 <memcpy>
     24e:	4b42      	ldr	r3, [pc, #264]	; (358 <ResetHandler+0x19c>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     250:	4a42      	ldr	r2, [pc, #264]	; (35c <ResetHandler+0x1a0>)
     252:	2180      	movs	r1, #128	; 0x80
     254:	f803 1b01 	strb.w	r1, [r3], #1
     258:	4293      	cmp	r3, r2
     25a:	d1fb      	bne.n	254 <ResetHandler+0x98>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     25c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     260:	4a3c      	ldr	r2, [pc, #240]	; (354 <ResetHandler+0x198>)
     262:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     266:	4b3e      	ldr	r3, [pc, #248]	; (360 <ResetHandler+0x1a4>)
     268:	228a      	movs	r2, #138	; 0x8a
     26a:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26c:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     270:	2224      	movs	r2, #36	; 0x24
     272:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     274:	22a0      	movs	r2, #160	; 0xa0
     276:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     278:	799a      	ldrb	r2, [r3, #6]
     27a:	0791      	lsls	r1, r2, #30
     27c:	d5fc      	bpl.n	278 <ResetHandler+0xbc>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     27e:	799a      	ldrb	r2, [r3, #6]
     280:	06d2      	lsls	r2, r2, #27
     282:	d4fc      	bmi.n	27e <ResetHandler+0xc2>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     284:	4b37      	ldr	r3, [pc, #220]	; (364 <ResetHandler+0x1a8>)
     286:	799a      	ldrb	r2, [r3, #6]
     288:	f002 020c 	and.w	r2, r2, #12
     28c:	2a08      	cmp	r2, #8
     28e:	d1fa      	bne.n	286 <ResetHandler+0xca>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
     290:	2203      	movs	r2, #3
     292:	711a      	strb	r2, [r3, #4]
    #if F_CPU == 168000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(18); // config PLL for 168 MHz output
    #elif F_CPU == 144000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(12); // config PLL for 144 MHz output
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
     294:	2246      	movs	r2, #70	; 0x46
     296:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     298:	799a      	ldrb	r2, [r3, #6]
     29a:	0694      	lsls	r4, r2, #26
     29c:	d5fc      	bpl.n	298 <ResetHandler+0xdc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     29e:	4931      	ldr	r1, [pc, #196]	; (364 <ResetHandler+0x1a8>)
     2a0:	798b      	ldrb	r3, [r1, #6]
     2a2:	0658      	lsls	r0, r3, #25
     2a4:	d5fc      	bpl.n	2a0 <ResetHandler+0xe4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(2);
#elif F_CPU == 120000000
	// config divisors: 120 MHz core, 60 MHz bus, 24 MHz flash, USB = 128 * 2 / 5
	#if F_BUS == 60000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(4);
     2a6:	4b1f      	ldr	r3, [pc, #124]	; (324 <ResetHandler+0x168>)
     2a8:	f04f 7282 	mov.w	r2, #17039360	; 0x1040000
     2ac:	645a      	str	r2, [r3, #68]	; 0x44
	#elif F_BUS == 120000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(4);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
     2ae:	2209      	movs	r2, #9
     2b0:	649a      	str	r2, [r3, #72]	; 0x48
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b2:	2220      	movs	r2, #32
     2b4:	700a      	strb	r2, [r1, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2b6:	798a      	ldrb	r2, [r1, #6]
     2b8:	f002 020c 	and.w	r2, r2, #12
     2bc:	2a0c      	cmp	r2, #12
     2be:	d1fa      	bne.n	2b6 <ResetHandler+0xfa>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c0:	4a29      	ldr	r2, [pc, #164]	; (368 <ResetHandler+0x1ac>)
     2c2:	605a      	str	r2, [r3, #4]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2c4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     2c8:	4a28      	ldr	r2, [pc, #160]	; (36c <ResetHandler+0x1b0>)
     2ca:	615a      	str	r2, [r3, #20]
	SYST_CVR = 0;
     2cc:	2200      	movs	r2, #0
     2ce:	619a      	str	r2, [r3, #24]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2d0:	2207      	movs	r2, #7
     2d2:	611a      	str	r2, [r3, #16]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2d4:	4a26      	ldr	r2, [pc, #152]	; (370 <ResetHandler+0x1b4>)
     2d6:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20

	//init_pins();
	__enable_irq();
     2da:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     2dc:	f019 fff6 	bl	1a2cc <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2e0:	4b13      	ldr	r3, [pc, #76]	; (330 <ResetHandler+0x174>)
     2e2:	695b      	ldr	r3, [r3, #20]
     2e4:	07da      	lsls	r2, r3, #31
     2e6:	d505      	bpl.n	2f4 <ResetHandler+0x138>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2e8:	4822      	ldr	r0, [pc, #136]	; (374 <ResetHandler+0x1b8>)
     2ea:	f019 ffe3 	bl	1a2b4 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     2ee:	4b22      	ldr	r3, [pc, #136]	; (378 <ResetHandler+0x1bc>)
     2f0:	4a22      	ldr	r2, [pc, #136]	; (37c <ResetHandler+0x1c0>)
     2f2:	61da      	str	r2, [r3, #28]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     2f4:	4b22      	ldr	r3, [pc, #136]	; (380 <ResetHandler+0x1c4>)
     2f6:	781b      	ldrb	r3, [r3, #0]
     2f8:	065b      	lsls	r3, r3, #25
     2fa:	d509      	bpl.n	310 <ResetHandler+0x154>
     2fc:	4c1e      	ldr	r4, [pc, #120]	; (378 <ResetHandler+0x1bc>)
     2fe:	4b1f      	ldr	r3, [pc, #124]	; (37c <ResetHandler+0x1c0>)
     300:	69e2      	ldr	r2, [r4, #28]
     302:	429a      	cmp	r2, r3
     304:	d104      	bne.n	310 <ResetHandler+0x154>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     306:	481b      	ldr	r0, [pc, #108]	; (374 <ResetHandler+0x1b8>)
     308:	f019 ffd4 	bl	1a2b4 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     30c:	2300      	movs	r3, #0
     30e:	61e3      	str	r3, [r4, #28]
	}
#endif

	startup_late_hook();
     310:	f019 ff88 	bl	1a224 <startup_late_hook>
	__libc_init_array();
     314:	f01d fa6e 	bl	1d7f4 <__libc_init_array>

	main();
     318:	f019 fe62 	bl	19fe0 <main>
	
	while (1) ;
     31c:	e7fe      	b.n	31c <ResetHandler+0x160>
     31e:	bf00      	nop
     320:	40052000 	.word	0x40052000
     324:	40048000 	.word	0x40048000
     328:	00043f82 	.word	0x00043f82
     32c:	2b000001 	.word	0x2b000001
     330:	4003d000 	.word	0x4003d000
     334:	4007d000 	.word	0x4007d000
     338:	1fff8c30 	.word	0x1fff8c30
     33c:	4007e000 	.word	0x4007e000
     340:	1fffa324 	.word	0x1fffa324
     344:	000280c8 	.word	0x000280c8
     348:	20006a14 	.word	0x20006a14
     34c:	1fffa328 	.word	0x1fffa328
     350:	00000000 	.word	0x00000000
     354:	1fff8200 	.word	0x1fff8200
     358:	e000e400 	.word	0xe000e400
     35c:	e000e45f 	.word	0xe000e45f
     360:	40065000 	.word	0x40065000
     364:	40064000 	.word	0x40064000
     368:	000510c0 	.word	0x000510c0
     36c:	0001d4bf 	.word	0x0001d4bf
     370:	20200000 	.word	0x20200000
     374:	65721bed 	.word	0x65721bed
     378:	4003e000 	.word	0x4003e000
     37c:	5a94c3a5 	.word	0x5a94c3a5
     380:	4007f000 	.word	0x4007f000
     384:	ffffffff 	.word	0xffffffff
     388:	ffffffff 	.word	0xffffffff
     38c:	ffffffff 	.word	0xffffffff
     390:	ffffffff 	.word	0xffffffff
     394:	ffffffff 	.word	0xffffffff
     398:	ffffffff 	.word	0xffffffff
     39c:	ffffffff 	.word	0xffffffff
     3a0:	ffffffff 	.word	0xffffffff
     3a4:	ffffffff 	.word	0xffffffff
     3a8:	ffffffff 	.word	0xffffffff
     3ac:	ffffffff 	.word	0xffffffff
     3b0:	ffffffff 	.word	0xffffffff
     3b4:	ffffffff 	.word	0xffffffff
     3b8:	ffffffff 	.word	0xffffffff
     3bc:	ffffffff 	.word	0xffffffff
     3c0:	ffffffff 	.word	0xffffffff
     3c4:	ffffffff 	.word	0xffffffff
     3c8:	ffffffff 	.word	0xffffffff
     3cc:	ffffffff 	.word	0xffffffff
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <register_tm_clones>:
     410:	4805      	ldr	r0, [pc, #20]	; (428 <register_tm_clones+0x18>)
     412:	4b06      	ldr	r3, [pc, #24]	; (42c <register_tm_clones+0x1c>)
     414:	1a1b      	subs	r3, r3, r0
     416:	0fd9      	lsrs	r1, r3, #31
     418:	eb01 01a3 	add.w	r1, r1, r3, asr #2
     41c:	1049      	asrs	r1, r1, #1
     41e:	d002      	beq.n	426 <register_tm_clones+0x16>
     420:	4b03      	ldr	r3, [pc, #12]	; (430 <register_tm_clones+0x20>)
     422:	b103      	cbz	r3, 426 <register_tm_clones+0x16>
     424:	4718      	bx	r3
     426:	4770      	bx	lr
     428:	1fffa324 	.word	0x1fffa324
     42c:	1fffa324 	.word	0x1fffa324
     430:	00000000 	.word	0x00000000

00000434 <frame_dummy>:
     434:	b508      	push	{r3, lr}
     436:	4b05      	ldr	r3, [pc, #20]	; (44c <frame_dummy+0x18>)
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4905      	ldr	r1, [pc, #20]	; (450 <frame_dummy+0x1c>)
     43c:	4805      	ldr	r0, [pc, #20]	; (454 <frame_dummy+0x20>)
     43e:	f3af 8000 	nop.w
     442:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     446:	f7ff bfe3 	b.w	410 <register_tm_clones>
     44a:	bf00      	nop
     44c:	00000000 	.word	0x00000000
     450:	1fffa328 	.word	0x1fffa328
     454:	000280c8 	.word	0x000280c8

00000458 <OC::ADC::Init(OC::ADC::CalibrationData*)>:
/*static*/ uint32_t ADC::smoothed_[ADC_CHANNEL_LAST];
#ifdef ENABLE_ADC_DEBUG
/*static*/ volatile uint32_t ADC::busy_waits_;
#endif

/*static*/ void ADC::Init(CalibrationData *calibration_data) {
     458:	b570      	push	{r4, r5, r6, lr}
  //pinMode(ChannelDesc<ADC_CHANNEL_1>::PIN, INPUT);
  //pinMode(ChannelDesc<ADC_CHANNEL_2>::PIN, INPUT);
  //pinMode(ChannelDesc<ADC_CHANNEL_3>::PIN, INPUT);
  //pinMode(ChannelDesc<ADC_CHANNEL_4>::PIN, INPUT);

  adc_.setReference(ADC_REF_3V3);
     45a:	4c23      	ldr	r4, [pc, #140]	; (4e8 <OC::ADC::Init(OC::ADC::CalibrationData*)+0x90>)
/*static*/ void ADC::Init(CalibrationData *calibration_data) {
     45c:	4606      	mov	r6, r0
  adc_.setReference(ADC_REF_3V3);
     45e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     462:	4620      	mov	r0, r4
     464:	2100      	movs	r1, #0
     466:	f018 fc1f 	bl	18ca8 <ADC::setReference(unsigned char, signed char)>
  adc_.setResolution(kAdcScanResolution);
     46a:	4620      	mov	r0, r4
     46c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     470:	2110      	movs	r1, #16
     472:	f018 fc21 	bl	18cb8 <ADC::setResolution(unsigned char, signed char)>
  adc_.setConversionSpeed(kAdcConversionSpeed);
     476:	4620      	mov	r0, r4
     478:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     47c:	2104      	movs	r1, #4
     47e:	f018 fc23 	bl	18cc8 <ADC::setConversionSpeed(unsigned char, signed char)>
  adc_.setSamplingSpeed(kAdcSamplingSpeed);
     482:	4620      	mov	r0, r4
     484:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     488:	2103      	movs	r1, #3
     48a:	f018 fc25 	bl	18cd8 <ADC::setSamplingSpeed(unsigned char, signed char)>
  adc_.setAveraging(kAdcScanAverages);
     48e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     492:	4620      	mov	r0, r4
     494:	2110      	movs	r1, #16
     496:	f018 fc27 	bl	18ce8 <ADC::setAveraging(unsigned char, signed char)>
  adc_.disableDMA();
     49a:	4620      	mov	r0, r4
     49c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
     4a0:	f018 fc32 	bl	18d08 <ADC::disableDMA(signed char)>
  adc_.disableInterrupts();
     4a4:	4620      	mov	r0, r4
     4a6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
     4aa:	f018 fc25 	bl	18cf8 <ADC::disableInterrupts(signed char)>
  adc_.disableCompare();
     4ae:	4620      	mov	r0, r4
     4b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
     4b4:	f018 fc30 	bl	18d18 <ADC::disableCompare(signed char)>

  scan_channel_ = ADC_CHANNEL_1;
     4b8:	4b0c      	ldr	r3, [pc, #48]	; (4ec <OC::ADC::Init(OC::ADC::CalibrationData*)+0x94>)
     4ba:	2500      	movs	r5, #0
  adc_.startSingleRead(ChannelDesc<ADC_CHANNEL_1>::PIN);
     4bc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     4c0:	2111      	movs	r1, #17
     4c2:	4620      	mov	r0, r4
  scan_channel_ = ADC_CHANNEL_1;
     4c4:	601d      	str	r5, [r3, #0]
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
	      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
	*__first = __tmp;
     4c6:	2410      	movs	r4, #16
  adc_.startSingleRead(ChannelDesc<ADC_CHANNEL_1>::PIN);
     4c8:	f018 fc2e 	bl	18d28 <ADC::startSingleRead(unsigned char, signed char)>

  calibration_data_ = calibration_data;
     4cc:	4b08      	ldr	r3, [pc, #32]	; (4f0 <OC::ADC::Init(OC::ADC::CalibrationData*)+0x98>)
     4ce:	4809      	ldr	r0, [pc, #36]	; (4f4 <OC::ADC::Init(OC::ADC::CalibrationData*)+0x9c>)
     4d0:	601e      	str	r6, [r3, #0]
     4d2:	4622      	mov	r2, r4
     4d4:	4629      	mov	r1, r5
     4d6:	f019 fe5f 	bl	1a198 <memset>
     4da:	4622      	mov	r2, r4
     4dc:	4629      	mov	r1, r5
     4de:	4806      	ldr	r0, [pc, #24]	; (4f8 <OC::ADC::Init(OC::ADC::CalibrationData*)+0xa0>)
  std::fill(raw_, raw_ + ADC_CHANNEL_LAST, 0);
  std::fill(smoothed_, smoothed_ + ADC_CHANNEL_LAST, 0);
#ifdef ENABLE_ADC_DEBUG
  busy_waits_ = 0;
#endif
}
     4e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     4e4:	f019 be58 	b.w	1a198 <memset>
     4e8:	1fffa348 	.word	0x1fffa348
     4ec:	1fffa340 	.word	0x1fffa340
     4f0:	1fffa344 	.word	0x1fffa344
     4f4:	1fffa4ac 	.word	0x1fffa4ac
     4f8:	1fffa4bc 	.word	0x1fffa4bc

000004fc <OC::ADC::CalibratePitch(long, long)>:
/*static*/ void ADC::CalibratePitch(int32_t c2, int32_t c4) {
  // This is the method used by the Mutable Instruments calibration and
  // extrapolates from two octaves. I guess an alternative would be to get the
  // lowest (-3v) and highest (+6v) and interpolate between them
  // *vague handwaving*
  if (c2 < c4) {
     4fc:	4288      	cmp	r0, r1
     4fe:	da07      	bge.n	510 <OC::ADC::CalibratePitch(long, long)+0x14>
    int32_t scale = (24 * 128 * 4096L) / (c4 - c2);
    calibration_data_->pitch_cv_scale = scale;
     500:	4b04      	ldr	r3, [pc, #16]	; (514 <OC::ADC::CalibratePitch(long, long)+0x18>)
     502:	681a      	ldr	r2, [r3, #0]
    int32_t scale = (24 * 128 * 4096L) / (c4 - c2);
     504:	1a09      	subs	r1, r1, r0
     506:	f44f 0340 	mov.w	r3, #12582912	; 0xc00000
     50a:	fbb3 f3f1 	udiv	r3, r3, r1
    calibration_data_->pitch_cv_scale = scale;
     50e:	8113      	strh	r3, [r2, #8]
  }
}
     510:	4770      	bx	lr
     512:	bf00      	nop
     514:	1fffa344 	.word	0x1fffa344

00000518 <_GLOBAL__sub_I__ZN2OC3ADC4adc_E>:
/*static*/ ::ADC ADC::adc_;
     518:	4801      	ldr	r0, [pc, #4]	; (520 <_GLOBAL__sub_I__ZN2OC3ADC4adc_E+0x8>)
     51a:	f018 bb99 	b.w	18c50 <ADC::ADC()>
     51e:	bf00      	nop
     520:	1fffa348 	.word	0x1fffa348

00000524 <OC::DAC::set_auto_channel_calibration_data(unsigned char)>:
  if (channel_id < DAC_CHANNEL_LAST) {
     524:	2803      	cmp	r0, #3
void DAC::set_auto_channel_calibration_data(uint8_t channel_id) {
     526:	b510      	push	{r4, lr}
     528:	4604      	mov	r4, r0
  if (channel_id < DAC_CHANNEL_LAST) {
     52a:	d815      	bhi.n	558 <OC::DAC::set_auto_channel_calibration_data(unsigned char)+0x34>
    if (_autotune_data->use_auto_calibration_ == 0xFF)  { // = data available ?
     52c:	2318      	movs	r3, #24
     52e:	4a0b      	ldr	r2, [pc, #44]	; (55c <OC::DAC::set_auto_channel_calibration_data(unsigned char)+0x38>)
     530:	4343      	muls	r3, r0
     532:	5cd1      	ldrb	r1, [r2, r3]
     534:	29ff      	cmp	r1, #255	; 0xff
     536:	d10f      	bne.n	558 <OC::DAC::set_auto_channel_calibration_data(unsigned char)+0x34>
        _autotune_data->use_auto_calibration_ = 0x01; // = use auto data 
     538:	2101      	movs	r1, #1
     53a:	54d1      	strb	r1, [r2, r3]
        const OC::Autotune_data &autotune_data = OC::AUTOTUNE::GetAutotune_data(channel_id);
     53c:	f000 fac4 	bl	ac8 <OC::AUTOTUNE::GetAutotune_data(int)>
        for (int i = 0; i < OCTAVES + 1; i++)
     540:	4b07      	ldr	r3, [pc, #28]	; (560 <OC::DAC::set_auto_channel_calibration_data(unsigned char)+0x3c>)
     542:	681b      	ldr	r3, [r3, #0]
     544:	2216      	movs	r2, #22
     546:	fb04 3302 	mla	r3, r4, r2, r3
     54a:	1882      	adds	r2, r0, r2
          calibration_data_->calibrated_octaves[channel_id][i] = autotune_data.auto_calibrated_octaves[i];
     54c:	f830 1f02 	ldrh.w	r1, [r0, #2]!
     550:	f823 1b02 	strh.w	r1, [r3], #2
        for (int i = 0; i < OCTAVES + 1; i++)
     554:	4290      	cmp	r0, r2
     556:	d1f9      	bne.n	54c <OC::DAC::set_auto_channel_calibration_data(unsigned char)+0x28>
}
     558:	bd10      	pop	{r4, pc}
     55a:	bf00      	nop
     55c:	1fffa528 	.word	0x1fffa528
     560:	1fffa4d4 	.word	0x1fffa4d4

00000564 <OC::DAC::reset_auto_channel_calibration_data(unsigned char)>:
}
/*static*/
void DAC::reset_auto_channel_calibration_data(uint8_t channel_id) {
  
  // reset data
  if (channel_id < DAC_CHANNEL_LAST) {
     564:	2803      	cmp	r0, #3
void DAC::reset_auto_channel_calibration_data(uint8_t channel_id) {
     566:	b410      	push	{r4}
  if (channel_id < DAC_CHANNEL_LAST) {
     568:	d80f      	bhi.n	58a <OC::DAC::reset_auto_channel_calibration_data(unsigned char)+0x26>
    SERIAL_PRINTLN("reset channel# %d calibration data", (int)(channel_id + 1));
    OC::Autotune_data *autotune_data = &OC::auto_calibration_data[channel_id];
    autotune_data->use_auto_calibration_ = 0x0;
     56a:	2218      	movs	r2, #24
     56c:	fb02 f100 	mul.w	r1, r2, r0
     570:	4b07      	ldr	r3, [pc, #28]	; (590 <OC::DAC::reset_auto_channel_calibration_data(unsigned char)+0x2c>)
     572:	2400      	movs	r4, #0
     574:	545c      	strb	r4, [r3, r1]
    for (int i = 0; i < OCTAVES + 1; i++)
      autotune_data->auto_calibrated_octaves[i] = OC::calibration_data.dac.calibrated_octaves[channel_id][i];
     576:	4907      	ldr	r1, [pc, #28]	; (594 <OC::DAC::reset_auto_channel_calibration_data(unsigned char)+0x30>)
  }
}
     578:	bc10      	pop	{r4}
      autotune_data->auto_calibrated_octaves[i] = OC::calibration_data.dac.calibrated_octaves[channel_id][i];
     57a:	fb02 3300 	mla	r3, r2, r0, r3
     57e:	2216      	movs	r2, #22
     580:	fb00 1102 	mla	r1, r0, r2, r1
     584:	1c98      	adds	r0, r3, #2
     586:	f019 bd33 	b.w	19ff0 <memcpy>
}
     58a:	bc10      	pop	{r4}
     58c:	4770      	bx	lr
     58e:	bf00      	nop
     590:	1fffa528 	.word	0x1fffa528
     594:	20004294 	.word	0x20004294

00000598 <OC::DAC::choose_calibration_data()>:
void DAC::reset_all_auto_channel_calibration_data(){
   for (int i = 0; i < DAC_CHANNEL_LAST; i++)
      reset_auto_channel_calibration_data(i);
}
/*static*/
void DAC::choose_calibration_data() {
     598:	b510      	push	{r4, lr}
  
  // at this point, global settings are restored
  for (int i = 0; i < DAC_CHANNEL_LAST; i++) {
     59a:	2400      	movs	r4, #0
    
    const OC::Autotune_data &autotune_data = OC::AUTOTUNE::GetAutotune_data(i);
     59c:	4620      	mov	r0, r4
     59e:	f000 fa93 	bl	ac8 <OC::AUTOTUNE::GetAutotune_data(int)>

    if (autotune_data.use_auto_calibration_ == 0x0) { 
     5a2:	7803      	ldrb	r3, [r0, #0]
     5a4:	b933      	cbnz	r3, 5b4 <OC::DAC::choose_calibration_data()+0x1c>
    // no autotune_data yet, so we use defaults:
      reset_auto_channel_calibration_data(i);
     5a6:	b2e0      	uxtb	r0, r4
     5a8:	f7ff ffdc 	bl	564 <OC::DAC::reset_auto_channel_calibration_data(unsigned char)>
  for (int i = 0; i < DAC_CHANNEL_LAST; i++) {
     5ac:	3401      	adds	r4, #1
     5ae:	2c04      	cmp	r4, #4
     5b0:	d1f4      	bne.n	59c <OC::DAC::choose_calibration_data()+0x4>
    // use autotune_data
      set_auto_channel_calibration_data(i);
    }
    // ... else use default calibration
  }
}
     5b2:	bd10      	pop	{r4, pc}
    else if (autotune_data.use_auto_calibration_ == 0xFF) {
     5b4:	2bff      	cmp	r3, #255	; 0xff
     5b6:	d1f9      	bne.n	5ac <OC::DAC::choose_calibration_data()+0x14>
      set_auto_channel_calibration_data(i);
     5b8:	b2e0      	uxtb	r0, r4
     5ba:	f7ff ffb3 	bl	524 <OC::DAC::set_auto_channel_calibration_data(unsigned char)>
     5be:	e7f5      	b.n	5ac <OC::DAC::choose_calibration_data()+0x14>

000005c0 <OC::DAC::get_voltage_scaling(unsigned char)>:
/*static*/
uint8_t DAC::get_voltage_scaling(uint8_t channel_id) {
  return DAC_scaling[channel_id];
}
     5c0:	4b01      	ldr	r3, [pc, #4]	; (5c8 <OC::DAC::get_voltage_scaling(unsigned char)+0x8>)
     5c2:	5c18      	ldrb	r0, [r3, r0]
     5c4:	4770      	bx	lr
     5c6:	bf00      	nop
     5c8:	1fffa4cc 	.word	0x1fffa4cc

000005cc <OC::DAC::set_scaling(unsigned char, unsigned char)>:
/*static*/
void DAC::set_scaling(uint8_t scaling, uint8_t channel_id) {

  if (channel_id < DAC_CHANNEL_LAST)
     5cc:	2903      	cmp	r1, #3
    DAC_scaling[channel_id] = scaling;
     5ce:	bf9c      	itt	ls
     5d0:	4b01      	ldrls	r3, [pc, #4]	; (5d8 <OC::DAC::set_scaling(unsigned char, unsigned char)+0xc>)
     5d2:	5458      	strbls	r0, [r3, r1]
}
     5d4:	4770      	bx	lr
     5d6:	bf00      	nop
     5d8:	1fffa4cc 	.word	0x1fffa4cc

000005dc <OC::DAC::restore_scaling(unsigned long)>:
/*static*/
void DAC::restore_scaling(uint32_t scaling) {
     5dc:	b510      	push	{r4, lr}
  
  // restore scaling from global settings
  for (int i = 0; i < DAC_CHANNEL_LAST; i++) {
     5de:	2200      	movs	r2, #0
void DAC::restore_scaling(uint32_t scaling) {
     5e0:	4604      	mov	r4, r0
    uint8_t _scaling = (scaling >> (i * 8)) & 0xFF;
     5e2:	00d3      	lsls	r3, r2, #3
     5e4:	fa24 f303 	lsr.w	r3, r4, r3
    set_scaling(_scaling, i);
     5e8:	b2d1      	uxtb	r1, r2
     5ea:	b2d8      	uxtb	r0, r3
  for (int i = 0; i < DAC_CHANNEL_LAST; i++) {
     5ec:	3201      	adds	r2, #1
    set_scaling(_scaling, i);
     5ee:	f7ff ffed 	bl	5cc <OC::DAC::set_scaling(unsigned char, unsigned char)>
  for (int i = 0; i < DAC_CHANNEL_LAST; i++) {
     5f2:	2a04      	cmp	r2, #4
     5f4:	d1f5      	bne.n	5e2 <OC::DAC::restore_scaling(unsigned long)+0x6>
  }
}
     5f6:	bd10      	pop	{r4, pc}

000005f8 <OC::DAC::store_scaling()>:
uint32_t DAC::store_scaling() {

  uint32_t _scaling = 0;
  // merge values into uint32_t : 
  for (int i = 0; i < DAC_CHANNEL_LAST; i++)
    _scaling |= (DAC_scaling[i] << (i * 8)); 
     5f8:	4a05      	ldr	r2, [pc, #20]	; (610 <OC::DAC::store_scaling()+0x18>)
     5fa:	7851      	ldrb	r1, [r2, #1]
     5fc:	7813      	ldrb	r3, [r2, #0]
     5fe:	78d0      	ldrb	r0, [r2, #3]
     600:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
     604:	7891      	ldrb	r1, [r2, #2]
     606:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  return _scaling;
}
     60a:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
     60e:	4770      	bx	lr
     610:	1fffa4cc 	.word	0x1fffa4cc

00000614 <OC::DAC::init_Vbias()>:
/*static*/ 
void DAC::init_Vbias() {
  /* using MK20 DAC0 for Vbias*/
  VREF_TRM = 0x60; VREF_SC = 0xE1; // enable 1v2 reference
     614:	4b07      	ldr	r3, [pc, #28]	; (634 <OC::DAC::init_Vbias()+0x20>)
     616:	2260      	movs	r2, #96	; 0x60
     618:	701a      	strb	r2, [r3, #0]
     61a:	22e1      	movs	r2, #225	; 0xe1
     61c:	705a      	strb	r2, [r3, #1]
  SIM_SCGC2 |= SIM_SCGC2_DAC0; // DAC clock
     61e:	4a06      	ldr	r2, [pc, #24]	; (638 <OC::DAC::init_Vbias()+0x24>)
     620:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     622:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
     626:	62d3      	str	r3, [r2, #44]	; 0x2c
  DAC0_C0 = DAC_C0_DACEN; // enable module + use internal 1v2 reference
     628:	4b04      	ldr	r3, [pc, #16]	; (63c <OC::DAC::init_Vbias()+0x28>)
     62a:	2280      	movs	r2, #128	; 0x80
     62c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
}
     630:	4770      	bx	lr
     632:	bf00      	nop
     634:	40074000 	.word	0x40074000
     638:	40048000 	.word	0x40048000
     63c:	400cc000 	.word	0x400cc000

00000640 <OC::DAC::set_Vbias(unsigned long)>:
/*static*/ 
void DAC::set_Vbias(uint32_t data) {
  *(volatile int16_t *)&(DAC0_DAT0L) = data;
     640:	4b01      	ldr	r3, [pc, #4]	; (648 <OC::DAC::set_Vbias(unsigned long)+0x8>)
     642:	b200      	sxth	r0, r0
     644:	8018      	strh	r0, [r3, #0]
}
     646:	4770      	bx	lr
     648:	400cc000 	.word	0x400cc000

0000064c <set8565_CHA(unsigned long)>:
volatile size_t DAC::history_tail_;
/*static*/ 
uint8_t DAC::DAC_scaling[DAC_CHANNEL_LAST];
}; // namespace OC

void set8565_CHA(uint32_t data) {
     64c:	b510      	push	{r4, lr}
		pcs = p;
		clear();
		SPCR.enable_pins();
	}
	inline void write(uint32_t b, uint32_t cont=0) __attribute__((always_inline)) {
		uint32_t pcsbits = pcs << 16;
     64e:	4926      	ldr	r1, [pc, #152]	; (6e8 <set8565_CHA(unsigned long)+0x9c>)
     650:	4a26      	ldr	r2, [pc, #152]	; (6ec <set8565_CHA(unsigned long)+0xa0>)
     652:	780c      	ldrb	r4, [r1, #0]
  #ifdef BUCHLA_cOC
  uint32_t _data = data;
  #else
  uint32_t _data = OC::DAC::MAX_VALUE - data;
     654:	f5c0 407f 	rsb	r0, r0, #65280	; 0xff00
     658:	30ff      	adds	r0, #255	; 0xff
		if (pcsbits) {
     65a:	0423      	lsls	r3, r4, #16
     65c:	b1fc      	cbz	r4, 69e <set8565_CHA(unsigned long)+0x52>
			KINETISK_SPI0.PUSHR = (b & 0xFF) | pcsbits | (cont ? SPI_PUSHR_CONT : 0);
     65e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     662:	f043 0316 	orr.w	r3, r3, #22
     666:	6353      	str	r3, [r2, #52]	; 0x34
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ; // wait if FIFO full
     668:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     66a:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     66e:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     672:	d8f9      	bhi.n	668 <set8565_CHA(unsigned long)+0x1c>
				*reg = 1;
			}
		}
	}
	inline void write16(uint32_t b, uint32_t cont=0) __attribute__((always_inline)) {
		uint32_t pcsbits = pcs << 16;
     674:	7809      	ldrb	r1, [r1, #0]
		if (pcsbits) {
     676:	4a1d      	ldr	r2, [pc, #116]	; (6ec <set8565_CHA(unsigned long)+0xa0>)
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     678:	b280      	uxth	r0, r0
		if (pcsbits) {
     67a:	040b      	lsls	r3, r1, #16
     67c:	b9f1      	cbnz	r1, 6bc <set8565_CHA(unsigned long)+0x70>
				(cont ? SPI_PUSHR_CONT : 0) | SPI_PUSHR_CTAS(1);
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
		} else {
			*reg = 0;
     67e:	491c      	ldr	r1, [pc, #112]	; (6f0 <set8565_CHA(unsigned long)+0xa4>)
     680:	680c      	ldr	r4, [r1, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (cont ? 0 : SPI_PUSHR_EOQ) | SPI_PUSHR_CTAS(1);
     682:	f040 50c0 	orr.w	r0, r0, #402653184	; 0x18000000
			*reg = 0;
     686:	7023      	strb	r3, [r4, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
     688:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     68c:	62d3      	str	r3, [r2, #44]	; 0x2c
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (cont ? 0 : SPI_PUSHR_EOQ) | SPI_PUSHR_CTAS(1);
     68e:	6350      	str	r0, [r2, #52]	; 0x34
			if (cont) {
				while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
			} else {
				while (!(KINETISK_SPI0.SR & SPI_SR_EOQF)) ;
     690:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     692:	00db      	lsls	r3, r3, #3
     694:	d5fc      	bpl.n	690 <set8565_CHA(unsigned long)+0x44>
				*reg = 1;
     696:	680b      	ldr	r3, [r1, #0]
     698:	2201      	movs	r2, #1
     69a:	701a      	strb	r2, [r3, #0]
     69c:	e018      	b.n	6d0 <set8565_CHA(unsigned long)+0x84>
			*reg = 0;
     69e:	4c14      	ldr	r4, [pc, #80]	; (6f0 <set8565_CHA(unsigned long)+0xa4>)
     6a0:	6824      	ldr	r4, [r4, #0]
     6a2:	7023      	strb	r3, [r4, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
     6a4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     6a8:	62d3      	str	r3, [r2, #44]	; 0x2c
			KINETISK_SPI0.PUSHR = (b & 0xFF) | (cont ? 0 : SPI_PUSHR_EOQ);
     6aa:	2316      	movs	r3, #22
     6ac:	6353      	str	r3, [r2, #52]	; 0x34
				while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
     6ae:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     6b0:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     6b4:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     6b8:	d8f9      	bhi.n	6ae <set8565_CHA(unsigned long)+0x62>
     6ba:	e7db      	b.n	674 <set8565_CHA(unsigned long)+0x28>
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     6bc:	4303      	orrs	r3, r0
				(cont ? SPI_PUSHR_CONT : 0) | SPI_PUSHR_CTAS(1);
     6be:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     6c2:	6353      	str	r3, [r2, #52]	; 0x34
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
     6c4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     6c6:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     6ca:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     6ce:	d8f9      	bhi.n	6c4 <set8565_CHA(unsigned long)+0x78>
			}
		}
	}
	inline uint32_t read(void) __attribute__((always_inline)) {
		while ((KINETISK_SPI0.SR & (15 << 4)) == 0) ;  // TODO, could wait forever
     6d0:	4b06      	ldr	r3, [pc, #24]	; (6ec <set8565_CHA(unsigned long)+0xa0>)
     6d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     6d4:	f012 0ff0 	tst.w	r2, #240	; 0xf0
     6d8:	d0fb      	beq.n	6d2 <set8565_CHA(unsigned long)+0x86>
		return KINETISK_SPI0.POPR;
     6da:	6b9a      	ldr	r2, [r3, #56]	; 0x38
		while ((KINETISK_SPI0.SR & (15 << 4)) == 0) ;  // TODO, could wait forever
     6dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     6de:	f012 0ff0 	tst.w	r2, #240	; 0xf0
     6e2:	d0fb      	beq.n	6dc <set8565_CHA(unsigned long)+0x90>
		return KINETISK_SPI0.POPR;
     6e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  SPIFIFO.write(0b00010000, SPI_CONTINUE);
  #endif
  SPIFIFO.write16(_data);
  SPIFIFO.read();
  SPIFIFO.read();
}
     6e6:	bd10      	pop	{r4, pc}
     6e8:	200065f4 	.word	0x200065f4
     6ec:	4002c000 	.word	0x4002c000
     6f0:	200065f8 	.word	0x200065f8

000006f4 <set8565_CHB(unsigned long)>:

void set8565_CHB(uint32_t data) {
     6f4:	b510      	push	{r4, lr}
		uint32_t pcsbits = pcs << 16;
     6f6:	4926      	ldr	r1, [pc, #152]	; (790 <set8565_CHB(unsigned long)+0x9c>)
     6f8:	4a26      	ldr	r2, [pc, #152]	; (794 <set8565_CHB(unsigned long)+0xa0>)
     6fa:	780c      	ldrb	r4, [r1, #0]
  #ifdef BUCHLA_cOC
  uint32_t _data = data;
  #else
  uint32_t _data = OC::DAC::MAX_VALUE - data;
     6fc:	f5c0 407f 	rsb	r0, r0, #65280	; 0xff00
     700:	30ff      	adds	r0, #255	; 0xff
		if (pcsbits) {
     702:	0423      	lsls	r3, r4, #16
     704:	b1fc      	cbz	r4, 746 <set8565_CHB(unsigned long)+0x52>
			KINETISK_SPI0.PUSHR = (b & 0xFF) | pcsbits | (cont ? SPI_PUSHR_CONT : 0);
     706:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     70a:	f043 0314 	orr.w	r3, r3, #20
     70e:	6353      	str	r3, [r2, #52]	; 0x34
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ; // wait if FIFO full
     710:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     712:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     716:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     71a:	d8f9      	bhi.n	710 <set8565_CHB(unsigned long)+0x1c>
		uint32_t pcsbits = pcs << 16;
     71c:	7809      	ldrb	r1, [r1, #0]
		if (pcsbits) {
     71e:	4a1d      	ldr	r2, [pc, #116]	; (794 <set8565_CHB(unsigned long)+0xa0>)
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     720:	b280      	uxth	r0, r0
		if (pcsbits) {
     722:	040b      	lsls	r3, r1, #16
     724:	b9f1      	cbnz	r1, 764 <set8565_CHB(unsigned long)+0x70>
			*reg = 0;
     726:	491c      	ldr	r1, [pc, #112]	; (798 <set8565_CHB(unsigned long)+0xa4>)
     728:	680c      	ldr	r4, [r1, #0]
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (cont ? 0 : SPI_PUSHR_EOQ) | SPI_PUSHR_CTAS(1);
     72a:	f040 50c0 	orr.w	r0, r0, #402653184	; 0x18000000
			*reg = 0;
     72e:	7023      	strb	r3, [r4, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
     730:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     734:	62d3      	str	r3, [r2, #44]	; 0x2c
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (cont ? 0 : SPI_PUSHR_EOQ) | SPI_PUSHR_CTAS(1);
     736:	6350      	str	r0, [r2, #52]	; 0x34
				while (!(KINETISK_SPI0.SR & SPI_SR_EOQF)) ;
     738:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     73a:	00db      	lsls	r3, r3, #3
     73c:	d5fc      	bpl.n	738 <set8565_CHB(unsigned long)+0x44>
				*reg = 1;
     73e:	680b      	ldr	r3, [r1, #0]
     740:	2201      	movs	r2, #1
     742:	701a      	strb	r2, [r3, #0]
     744:	e018      	b.n	778 <set8565_CHB(unsigned long)+0x84>
			*reg = 0;
     746:	4c14      	ldr	r4, [pc, #80]	; (798 <set8565_CHB(unsigned long)+0xa4>)
     748:	6824      	ldr	r4, [r4, #0]
     74a:	7023      	strb	r3, [r4, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
     74c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     750:	62d3      	str	r3, [r2, #44]	; 0x2c
			KINETISK_SPI0.PUSHR = (b & 0xFF) | (cont ? 0 : SPI_PUSHR_EOQ);
     752:	2314      	movs	r3, #20
     754:	6353      	str	r3, [r2, #52]	; 0x34
				while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
     756:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     758:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     75c:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     760:	d8f9      	bhi.n	756 <set8565_CHB(unsigned long)+0x62>
     762:	e7db      	b.n	71c <set8565_CHB(unsigned long)+0x28>
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     764:	4303      	orrs	r3, r0
				(cont ? SPI_PUSHR_CONT : 0) | SPI_PUSHR_CTAS(1);
     766:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     76a:	6353      	str	r3, [r2, #52]	; 0x34
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
     76c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     76e:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     772:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     776:	d8f9      	bhi.n	76c <set8565_CHB(unsigned long)+0x78>
		while ((KINETISK_SPI0.SR & (15 << 4)) == 0) ;  // TODO, could wait forever
     778:	4b06      	ldr	r3, [pc, #24]	; (794 <set8565_CHB(unsigned long)+0xa0>)
     77a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     77c:	f012 0ff0 	tst.w	r2, #240	; 0xf0
     780:	d0fb      	beq.n	77a <set8565_CHB(unsigned long)+0x86>
		return KINETISK_SPI0.POPR;
     782:	6b9a      	ldr	r2, [r3, #56]	; 0x38
		while ((KINETISK_SPI0.SR & (15 << 4)) == 0) ;  // TODO, could wait forever
     784:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     786:	f012 0ff0 	tst.w	r2, #240	; 0xf0
     78a:	d0fb      	beq.n	784 <set8565_CHB(unsigned long)+0x90>
		return KINETISK_SPI0.POPR;
     78c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  SPIFIFO.write(0b00010010, SPI_CONTINUE);
  #endif
  SPIFIFO.write16(_data);
  SPIFIFO.read();
  SPIFIFO.read();
}
     78e:	bd10      	pop	{r4, pc}
     790:	200065f4 	.word	0x200065f4
     794:	4002c000 	.word	0x4002c000
     798:	200065f8 	.word	0x200065f8

0000079c <set8565_CHC(unsigned long)>:

void set8565_CHC(uint32_t data) {
     79c:	b510      	push	{r4, lr}
		uint32_t pcsbits = pcs << 16;
     79e:	4926      	ldr	r1, [pc, #152]	; (838 <set8565_CHC(unsigned long)+0x9c>)
     7a0:	4a26      	ldr	r2, [pc, #152]	; (83c <set8565_CHC(unsigned long)+0xa0>)
     7a2:	780c      	ldrb	r4, [r1, #0]
  #ifdef BUCHLA_cOC
  uint32_t _data = data;
  #else
  uint32_t _data = OC::DAC::MAX_VALUE - data;
     7a4:	f5c0 407f 	rsb	r0, r0, #65280	; 0xff00
     7a8:	30ff      	adds	r0, #255	; 0xff
		if (pcsbits) {
     7aa:	0423      	lsls	r3, r4, #16
     7ac:	b1fc      	cbz	r4, 7ee <set8565_CHC(unsigned long)+0x52>
			KINETISK_SPI0.PUSHR = (b & 0xFF) | pcsbits | (cont ? SPI_PUSHR_CONT : 0);
     7ae:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     7b2:	f043 0312 	orr.w	r3, r3, #18
     7b6:	6353      	str	r3, [r2, #52]	; 0x34
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ; // wait if FIFO full
     7b8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     7ba:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     7be:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     7c2:	d8f9      	bhi.n	7b8 <set8565_CHC(unsigned long)+0x1c>
		uint32_t pcsbits = pcs << 16;
     7c4:	7809      	ldrb	r1, [r1, #0]
		if (pcsbits) {
     7c6:	4a1d      	ldr	r2, [pc, #116]	; (83c <set8565_CHC(unsigned long)+0xa0>)
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     7c8:	b280      	uxth	r0, r0
		if (pcsbits) {
     7ca:	040b      	lsls	r3, r1, #16
     7cc:	b9f1      	cbnz	r1, 80c <set8565_CHC(unsigned long)+0x70>
			*reg = 0;
     7ce:	491c      	ldr	r1, [pc, #112]	; (840 <set8565_CHC(unsigned long)+0xa4>)
     7d0:	680c      	ldr	r4, [r1, #0]
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (cont ? 0 : SPI_PUSHR_EOQ) | SPI_PUSHR_CTAS(1);
     7d2:	f040 50c0 	orr.w	r0, r0, #402653184	; 0x18000000
			*reg = 0;
     7d6:	7023      	strb	r3, [r4, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
     7d8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     7dc:	62d3      	str	r3, [r2, #44]	; 0x2c
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (cont ? 0 : SPI_PUSHR_EOQ) | SPI_PUSHR_CTAS(1);
     7de:	6350      	str	r0, [r2, #52]	; 0x34
				while (!(KINETISK_SPI0.SR & SPI_SR_EOQF)) ;
     7e0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     7e2:	00db      	lsls	r3, r3, #3
     7e4:	d5fc      	bpl.n	7e0 <set8565_CHC(unsigned long)+0x44>
				*reg = 1;
     7e6:	680b      	ldr	r3, [r1, #0]
     7e8:	2201      	movs	r2, #1
     7ea:	701a      	strb	r2, [r3, #0]
     7ec:	e018      	b.n	820 <set8565_CHC(unsigned long)+0x84>
			*reg = 0;
     7ee:	4c14      	ldr	r4, [pc, #80]	; (840 <set8565_CHC(unsigned long)+0xa4>)
     7f0:	6824      	ldr	r4, [r4, #0]
     7f2:	7023      	strb	r3, [r4, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
     7f4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     7f8:	62d3      	str	r3, [r2, #44]	; 0x2c
			KINETISK_SPI0.PUSHR = (b & 0xFF) | (cont ? 0 : SPI_PUSHR_EOQ);
     7fa:	2312      	movs	r3, #18
     7fc:	6353      	str	r3, [r2, #52]	; 0x34
				while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
     7fe:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     800:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     804:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     808:	d8f9      	bhi.n	7fe <set8565_CHC(unsigned long)+0x62>
     80a:	e7db      	b.n	7c4 <set8565_CHC(unsigned long)+0x28>
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     80c:	4303      	orrs	r3, r0
				(cont ? SPI_PUSHR_CONT : 0) | SPI_PUSHR_CTAS(1);
     80e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     812:	6353      	str	r3, [r2, #52]	; 0x34
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
     814:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     816:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     81a:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     81e:	d8f9      	bhi.n	814 <set8565_CHC(unsigned long)+0x78>
		while ((KINETISK_SPI0.SR & (15 << 4)) == 0) ;  // TODO, could wait forever
     820:	4b06      	ldr	r3, [pc, #24]	; (83c <set8565_CHC(unsigned long)+0xa0>)
     822:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     824:	f012 0ff0 	tst.w	r2, #240	; 0xf0
     828:	d0fb      	beq.n	822 <set8565_CHC(unsigned long)+0x86>
		return KINETISK_SPI0.POPR;
     82a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
		while ((KINETISK_SPI0.SR & (15 << 4)) == 0) ;  // TODO, could wait forever
     82c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     82e:	f012 0ff0 	tst.w	r2, #240	; 0xf0
     832:	d0fb      	beq.n	82c <set8565_CHC(unsigned long)+0x90>
		return KINETISK_SPI0.POPR;
     834:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  SPIFIFO.write(0b00010100, SPI_CONTINUE);
  #endif
  SPIFIFO.write16(_data);
  SPIFIFO.read();
  SPIFIFO.read(); 
}
     836:	bd10      	pop	{r4, pc}
     838:	200065f4 	.word	0x200065f4
     83c:	4002c000 	.word	0x4002c000
     840:	200065f8 	.word	0x200065f8

00000844 <set8565_CHD(unsigned long)>:

void set8565_CHD(uint32_t data) {
     844:	b510      	push	{r4, lr}
		uint32_t pcsbits = pcs << 16;
     846:	4926      	ldr	r1, [pc, #152]	; (8e0 <set8565_CHD(unsigned long)+0x9c>)
     848:	4a26      	ldr	r2, [pc, #152]	; (8e4 <set8565_CHD(unsigned long)+0xa0>)
     84a:	780c      	ldrb	r4, [r1, #0]
  #ifdef BUCHLA_cOC
  uint32_t _data = data;
  #else
  uint32_t _data = OC::DAC::MAX_VALUE - data;
     84c:	f5c0 407f 	rsb	r0, r0, #65280	; 0xff00
     850:	30ff      	adds	r0, #255	; 0xff
		if (pcsbits) {
     852:	0423      	lsls	r3, r4, #16
     854:	b1fc      	cbz	r4, 896 <set8565_CHD(unsigned long)+0x52>
			KINETISK_SPI0.PUSHR = (b & 0xFF) | pcsbits | (cont ? SPI_PUSHR_CONT : 0);
     856:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     85a:	f043 0310 	orr.w	r3, r3, #16
     85e:	6353      	str	r3, [r2, #52]	; 0x34
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ; // wait if FIFO full
     860:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     862:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     866:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     86a:	d8f9      	bhi.n	860 <set8565_CHD(unsigned long)+0x1c>
		uint32_t pcsbits = pcs << 16;
     86c:	7809      	ldrb	r1, [r1, #0]
		if (pcsbits) {
     86e:	4a1d      	ldr	r2, [pc, #116]	; (8e4 <set8565_CHD(unsigned long)+0xa0>)
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     870:	b280      	uxth	r0, r0
		if (pcsbits) {
     872:	040b      	lsls	r3, r1, #16
     874:	b9f1      	cbnz	r1, 8b4 <set8565_CHD(unsigned long)+0x70>
			*reg = 0;
     876:	491c      	ldr	r1, [pc, #112]	; (8e8 <set8565_CHD(unsigned long)+0xa4>)
     878:	680c      	ldr	r4, [r1, #0]
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (cont ? 0 : SPI_PUSHR_EOQ) | SPI_PUSHR_CTAS(1);
     87a:	f040 50c0 	orr.w	r0, r0, #402653184	; 0x18000000
			*reg = 0;
     87e:	7023      	strb	r3, [r4, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
     880:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     884:	62d3      	str	r3, [r2, #44]	; 0x2c
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (cont ? 0 : SPI_PUSHR_EOQ) | SPI_PUSHR_CTAS(1);
     886:	6350      	str	r0, [r2, #52]	; 0x34
				while (!(KINETISK_SPI0.SR & SPI_SR_EOQF)) ;
     888:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     88a:	00db      	lsls	r3, r3, #3
     88c:	d5fc      	bpl.n	888 <set8565_CHD(unsigned long)+0x44>
				*reg = 1;
     88e:	680b      	ldr	r3, [r1, #0]
     890:	2201      	movs	r2, #1
     892:	701a      	strb	r2, [r3, #0]
     894:	e018      	b.n	8c8 <set8565_CHD(unsigned long)+0x84>
			*reg = 0;
     896:	4c14      	ldr	r4, [pc, #80]	; (8e8 <set8565_CHD(unsigned long)+0xa4>)
     898:	6824      	ldr	r4, [r4, #0]
     89a:	7023      	strb	r3, [r4, #0]
			KINETISK_SPI0.SR = SPI_SR_EOQF;
     89c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     8a0:	62d3      	str	r3, [r2, #44]	; 0x2c
			KINETISK_SPI0.PUSHR = (b & 0xFF) | (cont ? 0 : SPI_PUSHR_EOQ);
     8a2:	2310      	movs	r3, #16
     8a4:	6353      	str	r3, [r2, #52]	; 0x34
				while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
     8a6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     8a8:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     8ac:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     8b0:	d8f9      	bhi.n	8a6 <set8565_CHD(unsigned long)+0x62>
     8b2:	e7db      	b.n	86c <set8565_CHD(unsigned long)+0x28>
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     8b4:	4303      	orrs	r3, r0
				(cont ? SPI_PUSHR_CONT : 0) | SPI_PUSHR_CTAS(1);
     8b6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
			KINETISK_SPI0.PUSHR = (b & 0xFFFF) | (pcs << 16) |
     8ba:	6353      	str	r3, [r2, #52]	; 0x34
			while (((KINETISK_SPI0.SR) & (15 << 12)) > (3 << 12)) ;
     8bc:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     8be:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
     8c2:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
     8c6:	d8f9      	bhi.n	8bc <set8565_CHD(unsigned long)+0x78>
		while ((KINETISK_SPI0.SR & (15 << 4)) == 0) ;  // TODO, could wait forever
     8c8:	4b06      	ldr	r3, [pc, #24]	; (8e4 <set8565_CHD(unsigned long)+0xa0>)
     8ca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     8cc:	f012 0ff0 	tst.w	r2, #240	; 0xf0
     8d0:	d0fb      	beq.n	8ca <set8565_CHD(unsigned long)+0x86>
		return KINETISK_SPI0.POPR;
     8d2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
		while ((KINETISK_SPI0.SR & (15 << 4)) == 0) ;  // TODO, could wait forever
     8d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     8d6:	f012 0ff0 	tst.w	r2, #240	; 0xf0
     8da:	d0fb      	beq.n	8d4 <set8565_CHD(unsigned long)+0x90>
		return KINETISK_SPI0.POPR;
     8dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  SPIFIFO.write(0b00010110, SPI_CONTINUE);
  #endif
  SPIFIFO.write16(_data);
  SPIFIFO.read();
  SPIFIFO.read();
}
     8de:	bd10      	pop	{r4, pc}
     8e0:	200065f4 	.word	0x200065f4
     8e4:	4002c000 	.word	0x4002c000
     8e8:	200065f8 	.word	0x200065f8

000008ec <OC::DAC::Update()>:

  static uint32_t get_octave_offset(DAC_CHANNEL channel, int octave) {
    return calibration_data_->calibrated_octaves[channel][kOctaveZero + octave];
  }

  static void Update() {
     8ec:	b538      	push	{r3, r4, r5, lr}

    set8565_CHA(values_[DAC_CHANNEL_A]);
     8ee:	4c13      	ldr	r4, [pc, #76]	; (93c <OC::DAC::Update()+0x50>)
     8f0:	6820      	ldr	r0, [r4, #0]
     8f2:	f7ff feab 	bl	64c <set8565_CHA(unsigned long)>
    set8565_CHB(values_[DAC_CHANNEL_B]);
     8f6:	6860      	ldr	r0, [r4, #4]
     8f8:	f7ff fefc 	bl	6f4 <set8565_CHB(unsigned long)>
    set8565_CHC(values_[DAC_CHANNEL_C]);
     8fc:	68a0      	ldr	r0, [r4, #8]
     8fe:	f7ff ff4d 	bl	79c <set8565_CHC(unsigned long)>
    set8565_CHD(values_[DAC_CHANNEL_D]);
     902:	68e0      	ldr	r0, [r4, #12]
     904:	f7ff ff9e 	bl	844 <set8565_CHD(unsigned long)>

    size_t tail = history_tail_;
     908:	490d      	ldr	r1, [pc, #52]	; (940 <OC::DAC::Update()+0x54>)
    history_[DAC_CHANNEL_A][tail] = values_[DAC_CHANNEL_A];
     90a:	4a0e      	ldr	r2, [pc, #56]	; (944 <OC::DAC::Update()+0x58>)
    size_t tail = history_tail_;
     90c:	680b      	ldr	r3, [r1, #0]
    history_[DAC_CHANNEL_A][tail] = values_[DAC_CHANNEL_A];
     90e:	6820      	ldr	r0, [r4, #0]
     910:	f822 0013 	strh.w	r0, [r2, r3, lsl #1]
    history_[DAC_CHANNEL_B][tail] = values_[DAC_CHANNEL_B];
     914:	f103 0008 	add.w	r0, r3, #8
     918:	6865      	ldr	r5, [r4, #4]
     91a:	f822 5010 	strh.w	r5, [r2, r0, lsl #1]
    history_[DAC_CHANNEL_C][tail] = values_[DAC_CHANNEL_C];
     91e:	f103 0010 	add.w	r0, r3, #16
     922:	68a5      	ldr	r5, [r4, #8]
     924:	f822 5010 	strh.w	r5, [r2, r0, lsl #1]
    history_[DAC_CHANNEL_D][tail] = values_[DAC_CHANNEL_D];
     928:	f103 0018 	add.w	r0, r3, #24
    history_tail_ = (tail + 1) % kHistoryDepth;
     92c:	3301      	adds	r3, #1
    history_[DAC_CHANNEL_D][tail] = values_[DAC_CHANNEL_D];
     92e:	68e4      	ldr	r4, [r4, #12]
     930:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
    history_tail_ = (tail + 1) % kHistoryDepth;
     934:	f003 0307 	and.w	r3, r3, #7
     938:	600b      	str	r3, [r1, #0]
  }
     93a:	bd38      	pop	{r3, r4, r5, pc}
     93c:	1fffa4d8 	.word	0x1fffa4d8
     940:	1fffa4d0 	.word	0x1fffa4d0
     944:	1fffa4e8 	.word	0x1fffa4e8

00000948 <OC::DAC::Init(OC::DAC::CalibrationData*)>:
  calibration_data_ = calibration_data;
     948:	4b30      	ldr	r3, [pc, #192]	; (a0c <OC::DAC::Init(OC::DAC::CalibrationData*)+0xc4>)
void DAC::Init(CalibrationData *calibration_data) {
     94a:	b510      	push	{r4, lr}
  calibration_data_ = calibration_data;
     94c:	6018      	str	r0, [r3, #0]
  restore_scaling(0x0);
     94e:	2000      	movs	r0, #0
     950:	f7ff fe44 	bl	5dc <OC::DAC::restore_scaling(unsigned long)>
void inline pinMode(uint8_t pin, uint8_t mode) {
  
    volatile uint32_t *config;
  
    if (pin >= CORE_NUM_DIGITAL) return;
    config = portConfigRegister(pin);
     954:	4a2e      	ldr	r2, [pc, #184]	; (a10 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xc8>)
     956:	6d53      	ldr	r3, [r2, #84]	; 0x54
  
    if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
  #ifdef KINETISK
      *portModeRegister(pin) = 1;
     958:	6d12      	ldr	r2, [r2, #80]	; 0x50
     95a:	2401      	movs	r4, #1
     95c:	f882 4280 	strb.w	r4, [r2, #640]	; 0x280
  #else
      *portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
  #endif
      /* use fast slew rate for output */
      *config = PORT_PCR_DSE | PORT_PCR_MUX(1);
     960:	f44f 72a0 	mov.w	r2, #320	; 0x140
     964:	601a      	str	r2, [r3, #0]
      if (mode == OUTPUT_OPENDRAIN) {
          *config |= PORT_PCR_ODE;
      } else {
          *config &= ~PORT_PCR_ODE;
     966:	681a      	ldr	r2, [r3, #0]
     968:	f022 0220 	bic.w	r2, r2, #32
     96c:	601a      	str	r2, [r3, #0]
  delay(10);
     96e:	200a      	movs	r0, #10
  init_Vbias();
     970:	f7ff fe50 	bl	614 <OC::DAC::init_Vbias()>
  delay(10);
     974:	f019 fd88 	bl	1a488 <delay>
  history_tail_ = 0;
     978:	4b26      	ldr	r3, [pc, #152]	; (a14 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xcc>)
  memset(history_, 0, sizeof(uint16_t) * kHistoryDepth * DAC_CHANNEL_LAST);
     97a:	4827      	ldr	r0, [pc, #156]	; (a18 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xd0>)
  history_tail_ = 0;
     97c:	2100      	movs	r1, #0
  memset(history_, 0, sizeof(uint16_t) * kHistoryDepth * DAC_CHANNEL_LAST);
     97e:	2240      	movs	r2, #64	; 0x40
  history_tail_ = 0;
     980:	6019      	str	r1, [r3, #0]
  memset(history_, 0, sizeof(uint16_t) * kHistoryDepth * DAC_CHANNEL_LAST);
     982:	f019 fc09 	bl	1a198 <memset>
		SIM_SCGC6 |= SIM_SCGC6_SPI0;
     986:	4a25      	ldr	r2, [pc, #148]	; (a1c <OC::DAC::Init(OC::DAC::CalibrationData*)+0xd4>)
			CORE_PIN10_CONFIG = PORT_PCR_MUX(2);
     988:	4925      	ldr	r1, [pc, #148]	; (a20 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xd8>)
		SIM_SCGC6 |= SIM_SCGC6_SPI0;
     98a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
		pcs = p;
     98c:	4825      	ldr	r0, [pc, #148]	; (a24 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xdc>)
		SIM_SCGC6 |= SIM_SCGC6_SPI0;
     98e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
     992:	63d3      	str	r3, [r2, #60]	; 0x3c
		KINETISK_SPI0.MCR = SPI_MCR_MSTR | SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
     994:	4b24      	ldr	r3, [pc, #144]	; (a28 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xe0>)
     996:	4a25      	ldr	r2, [pc, #148]	; (a2c <OC::DAC::Init(OC::DAC::CalibrationData*)+0xe4>)
     998:	601a      	str	r2, [r3, #0]
		KINETISK_SPI0.CTAR0 = ctar | SPI_CTAR_FMSZ(7);
     99a:	f04f 4238 	mov.w	r2, #3087007744	; 0xb8000000
     99e:	60da      	str	r2, [r3, #12]
		KINETISK_SPI0.CTAR1 = ctar | SPI_CTAR_FMSZ(15);
     9a0:	f04f 4278 	mov.w	r2, #4160749568	; 0xf8000000
     9a4:	611a      	str	r2, [r3, #16]
			CORE_PIN10_CONFIG = PORT_PCR_MUX(2);
     9a6:	f44f 7200 	mov.w	r2, #512	; 0x200
     9aa:	610a      	str	r2, [r1, #16]
		pcs = p;
     9ac:	7004      	strb	r4, [r0, #0]
	}
	inline void clear(void) __attribute__((always_inline)) {
		KINETISK_SPI0.MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F) | SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF;
     9ae:	4820      	ldr	r0, [pc, #128]	; (a30 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xe8>)
     9b0:	6018      	str	r0, [r3, #0]
			case 0: CORE_PIN13_CONFIG =  PORT_PCR_DSE | PORT_PCR_MUX(2); break;
			case 0x10: CORE_PIN14_CONFIG = PORT_PCR_MUX(2); break;
			default: CORE_PIN27_CONFIG = PORT_PCR_MUX(2);
		}
#else
		if ((pinout & 1) == 0) {
     9b2:	4b20      	ldr	r3, [pc, #128]	; (a34 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xec>)
     9b4:	7818      	ldrb	r0, [r3, #0]
     9b6:	07c0      	lsls	r0, r0, #31
			CORE_PIN11_CONFIG = PORT_PCR_DSE | PORT_PCR_MUX(2); // DOUT/MOSI = 11 (PTC6)
		} else {
			CORE_PIN7_CONFIG = PORT_PCR_MUX(2); // DOUT/MOSI = 7 (PTD2)
     9b8:	bf4d      	iteet	mi
     9ba:	491f      	ldrmi	r1, [pc, #124]	; (a38 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xf0>)
			CORE_PIN11_CONFIG = PORT_PCR_DSE | PORT_PCR_MUX(2); // DOUT/MOSI = 11 (PTC6)
     9bc:	f44f 7210 	movpl.w	r2, #576	; 0x240
     9c0:	618a      	strpl	r2, [r1, #24]
			CORE_PIN7_CONFIG = PORT_PCR_MUX(2); // DOUT/MOSI = 7 (PTD2)
     9c2:	608a      	strmi	r2, [r1, #8]
		}
		if ((pinout & 2) == 0) {
     9c4:	781a      	ldrb	r2, [r3, #0]
     9c6:	f012 0f02 	tst.w	r2, #2
			CORE_PIN12_CONFIG = PORT_PCR_MUX(2);  // DIN/MISO = 12 (PTC7)
     9ca:	bf0c      	ite	eq
     9cc:	4914      	ldreq	r1, [pc, #80]	; (a20 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xd8>)
		} else {
			CORE_PIN8_CONFIG = PORT_PCR_MUX(2);  // DIN/MISO = 8 (PTD3)
     9ce:	491a      	ldrne	r1, [pc, #104]	; (a38 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xf0>)
     9d0:	f44f 7200 	mov.w	r2, #512	; 0x200
			CORE_PIN12_CONFIG = PORT_PCR_MUX(2);  // DIN/MISO = 12 (PTC7)
     9d4:	bf0c      	ite	eq
     9d6:	61ca      	streq	r2, [r1, #28]
			CORE_PIN8_CONFIG = PORT_PCR_MUX(2);  // DIN/MISO = 8 (PTD3)
     9d8:	60ca      	strne	r2, [r1, #12]
		}
		if ((pinout & 4) == 0) {
     9da:	781b      	ldrb	r3, [r3, #0]
     9dc:	075b      	lsls	r3, r3, #29
			CORE_PIN13_CONFIG = PORT_PCR_DSE | PORT_PCR_MUX(2); // SCK = 13 (PTC5)
     9de:	bf55      	itete	pl
     9e0:	4b0f      	ldrpl	r3, [pc, #60]	; (a20 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xd8>)
		} else {
			CORE_PIN14_CONFIG = PORT_PCR_MUX(2); // SCK = 14 (PTD1)
     9e2:	4b15      	ldrmi	r3, [pc, #84]	; (a38 <OC::DAC::Init(OC::DAC::CalibrationData*)+0xf0>)
			CORE_PIN13_CONFIG = PORT_PCR_DSE | PORT_PCR_MUX(2); // SCK = 13 (PTC5)
     9e4:	f44f 7210 	movpl.w	r2, #576	; 0x240
			CORE_PIN14_CONFIG = PORT_PCR_MUX(2); // SCK = 14 (PTD1)
     9e8:	f44f 7200 	movmi.w	r2, #512	; 0x200
			CORE_PIN13_CONFIG = PORT_PCR_DSE | PORT_PCR_MUX(2); // SCK = 13 (PTC5)
     9ec:	bf54      	ite	pl
     9ee:	615a      	strpl	r2, [r3, #20]
			CORE_PIN14_CONFIG = PORT_PCR_MUX(2); // SCK = 14 (PTD1)
     9f0:	605a      	strmi	r2, [r3, #4]
      values_[i] = USAT16(value);
     9f2:	4a12      	ldr	r2, [pc, #72]	; (a3c <OC::DAC::Init(OC::DAC::CalibrationData*)+0xf4>)
  FAST_FP_MOD(n, div, 8)

inline uint32_t USAT16(uint32_t value) __attribute__((always_inline));
inline uint32_t USAT16(uint32_t value) {
  uint32_t result;
  __asm("usat %0, %1, %2" : "=r" (result) : "I" (16), "r" (value));
     9f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
     9f8:	f383 0310 	usat	r3, #16, r3
     9fc:	6013      	str	r3, [r2, #0]
     9fe:	6053      	str	r3, [r2, #4]
     a00:	6093      	str	r3, [r2, #8]
     a02:	60d3      	str	r3, [r2, #12]
  Update();
     a04:	f7ff ff72 	bl	8ec <OC::DAC::Update()>
}
     a08:	bd10      	pop	{r4, pc}
     a0a:	bf00      	nop
     a0c:	1fffa4d4 	.word	0x1fffa4d4
     a10:	00027b0c 	.word	0x00027b0c
     a14:	1fffa4d0 	.word	0x1fffa4d0
     a18:	1fffa4e8 	.word	0x1fffa4e8
     a1c:	40048000 	.word	0x40048000
     a20:	4004b000 	.word	0x4004b000
     a24:	200065f4 	.word	0x200065f4
     a28:	4002c000 	.word	0x4002c000
     a2c:	801f4001 	.word	0x801f4001
     a30:	801f0c00 	.word	0x801f0c00
     a34:	200065fc 	.word	0x200065fc
     a38:	4004c000 	.word	0x4004c000
     a3c:	1fffa4d8 	.word	0x1fffa4d8

00000a40 <SPI_init()>:

void SPI_init() {

  uint32_t ctar0, ctar1;

  SIM_SCGC6 |= SIM_SCGC6_SPI0;
     a40:	4a13      	ldr	r2, [pc, #76]	; (a90 <SPI_init()+0x50>)
     a42:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
     a44:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
     a48:	63d3      	str	r3, [r2, #60]	; 0x3c
  CORE_PIN11_CONFIG = PORT_PCR_DSE | PORT_PCR_MUX(2);
     a4a:	4b12      	ldr	r3, [pc, #72]	; (a94 <SPI_init()+0x54>)
     a4c:	f44f 7210 	mov.w	r2, #576	; 0x240
     a50:	619a      	str	r2, [r3, #24]
  CORE_PIN13_CONFIG = PORT_PCR_DSE | PORT_PCR_MUX(2);
     a52:	615a      	str	r2, [r3, #20]
      ctar0 = (SPI_CTAR_PBR(0) | SPI_CTAR_BR(0) | SPI_CTAR_DBR); //(48 / 2) * ((1+1)/2) = 24 MHz          
  #endif
  ctar1 = ctar0;
  ctar0 |= SPI_CTAR_FMSZ(7);
  ctar1 |= SPI_CTAR_FMSZ(15);
  SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
     a54:	f5a3 33f8 	sub.w	r3, r3, #126976	; 0x1f000
     a58:	4a0f      	ldr	r2, [pc, #60]	; (a98 <SPI_init()+0x58>)
     a5a:	601a      	str	r2, [r3, #0]
  SPI0_MCR |= SPI_MCR_CLR_RXF | SPI_MCR_CLR_TXF;
     a5c:	681a      	ldr	r2, [r3, #0]
     a5e:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
     a62:	601a      	str	r2, [r3, #0]

  // update ctars
  uint32_t mcr = SPI0_MCR;
     a64:	681a      	ldr	r2, [r3, #0]
  if (mcr & SPI_MCR_MDIS) {
     a66:	f412 4f80 	tst.w	r2, #16384	; 0x4000
     a6a:	f04f 4038 	mov.w	r0, #3087007744	; 0xb8000000
     a6e:	d004      	beq.n	a7a <SPI_init()+0x3a>
    SPI0_CTAR0 = ctar0;
    SPI0_CTAR1 = ctar1;
     a70:	f04f 4278 	mov.w	r2, #4160749568	; 0xf8000000
    SPI0_CTAR0 = ctar0;
     a74:	60d8      	str	r0, [r3, #12]
    SPI0_CTAR1 = ctar1;
     a76:	611a      	str	r2, [r3, #16]
     a78:	4770      	bx	lr
  } else {
    SPI0_MCR = mcr | SPI_MCR_MDIS | SPI_MCR_HALT;
     a7a:	f442 4180 	orr.w	r1, r2, #16384	; 0x4000
     a7e:	f041 0101 	orr.w	r1, r1, #1
     a82:	6019      	str	r1, [r3, #0]
    SPI0_CTAR0 = ctar0;
    SPI0_CTAR1 = ctar1;
     a84:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
    SPI0_CTAR0 = ctar0;
     a88:	60d8      	str	r0, [r3, #12]
    SPI0_CTAR1 = ctar1;
     a8a:	6119      	str	r1, [r3, #16]
    SPI0_MCR = mcr;
     a8c:	601a      	str	r2, [r3, #0]
  }
}
     a8e:	4770      	bx	lr
     a90:	40048000 	.word	0x40048000
     a94:	4004b000 	.word	0x4004b000
     a98:	801f0000 	.word	0x801f0000

00000a9c <_GLOBAL__sub_I__ZN2OC3DAC4InitEPNS0_15CalibrationDataE>:
***/

struct EEPROMClass{

#if defined(__arm__) && defined(TEENSYDUINO)
    EEPROMClass()                        { eeprom_initialize(); }
     a9c:	f019 ba3a 	b.w	19f14 <eeprom_initialize>

00000aa0 <OC::AUTOTUNE::Init()>:

    /*static*/
    const int AUTOTUNE::NUM_DAC_CHANNELS = DAC_CHANNEL_LAST;

    /*static*/
    void AUTOTUNE::Init() {
     aa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
      for (size_t i = 0; i < DAC_CHANNEL_LAST; i++)
        memcpy(&auto_calibration_data[i], &OC::autotune_data_default[0], sizeof(Autotune_data));
     aa2:	4d07      	ldr	r5, [pc, #28]	; (ac0 <OC::AUTOTUNE::Init()+0x20>)
     aa4:	4f07      	ldr	r7, [pc, #28]	; (ac4 <OC::AUTOTUNE::Init()+0x24>)
      for (size_t i = 0; i < DAC_CHANNEL_LAST; i++)
     aa6:	2400      	movs	r4, #0
        memcpy(&auto_calibration_data[i], &OC::autotune_data_default[0], sizeof(Autotune_data));
     aa8:	2618      	movs	r6, #24
     aaa:	fb06 5004 	mla	r0, r6, r4, r5
     aae:	2218      	movs	r2, #24
     ab0:	4639      	mov	r1, r7
      for (size_t i = 0; i < DAC_CHANNEL_LAST; i++)
     ab2:	3401      	adds	r4, #1
        memcpy(&auto_calibration_data[i], &OC::autotune_data_default[0], sizeof(Autotune_data));
     ab4:	f019 fa9c 	bl	19ff0 <memcpy>
      for (size_t i = 0; i < DAC_CHANNEL_LAST; i++)
     ab8:	2c04      	cmp	r4, #4
     aba:	d1f6      	bne.n	aaa <OC::AUTOTUNE::Init()+0xa>
    }
     abc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     abe:	bf00      	nop
     ac0:	1fffa528 	.word	0x1fffa528
     ac4:	0001dfd0 	.word	0x0001dfd0

00000ac8 <OC::AUTOTUNE::GetAutotune_data(int)>:
    /*static*/
    const Autotune_data &AUTOTUNE::GetAutotune_data(int channel) {
        return auto_calibration_data[channel];
    }
     ac8:	4b02      	ldr	r3, [pc, #8]	; (ad4 <OC::AUTOTUNE::GetAutotune_data(int)+0xc>)
     aca:	2218      	movs	r2, #24
     acc:	fb02 3000 	mla	r0, r2, r0, r3
     ad0:	4770      	bx	lr
     ad2:	bf00      	nop
     ad4:	1fffa528 	.word	0x1fffa528

00000ad8 <OC::debug_menu_core()>:
    debug::CycleMeasurement::Init();
    DebugPins::Init();
  }
}; // namespace DEBUG

static void debug_menu_core() {
     ad8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  text_x_ = x;
     ada:	4c24      	ldr	r4, [pc, #144]	; (b6c <OC::debug_menu_core()+0x94>)

  graphics.setPrintPos(2, 12);
  graphics.printf("%uMHz %uus+%uus", F_CPU / 1000 / 1000, OC_CORE_TIMER_RATE, OC_UI_TIMER_RATE);
     adc:	4924      	ldr	r1, [pc, #144]	; (b70 <OC::debug_menu_core()+0x98>)
static inline uint32_t multiply_u32xu32_rshift32(uint32_t a, uint32_t b) __attribute__((always_inline));
static inline uint32_t multiply_u32xu32_rshift32(uint32_t a, uint32_t b)
{
#if defined(KINETISK)
  uint32_t out, tmp;
  asm volatile("umull %0, %1, %2, %3" : "=r" (tmp), "=r" (out) : "r" (a), "r" (b));
     ade:	4d25      	ldr	r5, [pc, #148]	; (b74 <OC::debug_menu_core()+0x9c>)
  text_y_ = y;
     ae0:	230c      	movs	r3, #12
     ae2:	60a3      	str	r3, [r4, #8]
     ae4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  text_x_ = x;
     ae8:	2602      	movs	r6, #2
     aea:	9300      	str	r3, [sp, #0]
     aec:	2278      	movs	r2, #120	; 0x78
     aee:	233c      	movs	r3, #60	; 0x3c
     af0:	4620      	mov	r0, r4
     af2:	6066      	str	r6, [r4, #4]
     af4:	f019 f81a 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>

  uint32_t value_;
  uint32_t min_, max_;

  uint32_t value() const {
    return value_;
     af8:	491f      	ldr	r1, [pc, #124]	; (b78 <OC::debug_menu_core()+0xa0>)
     afa:	6066      	str	r6, [r4, #4]
  text_y_ = y;
     afc:	2316      	movs	r3, #22
     afe:	60a3      	str	r3, [r4, #8]
     b00:	680b      	ldr	r3, [r1, #0]
     b02:	fba3 2305 	umull	r2, r3, r3, r5
     b06:	684a      	ldr	r2, [r1, #4]
     b08:	fba2 0205 	umull	r0, r2, r2, r5
     b0c:	6889      	ldr	r1, [r1, #8]
     b0e:	fba1 1005 	umull	r1, r0, r1, r5
  uint32_t isr_us = debug::cycles_to_us(DEBUG::ISR_cycles.value());
  graphics.printf("CORE%3u/%3u/%3u %2u%%",
                  debug::cycles_to_us(DEBUG::ISR_cycles.min_value()),
                  isr_us,
                  debug::cycles_to_us(DEBUG::ISR_cycles.max_value()),
                  (isr_us * 100) /  OC_CORE_TIMER_RATE);
     b12:	2164      	movs	r1, #100	; 0x64
     b14:	4359      	muls	r1, r3
  graphics.printf("CORE%3u/%3u/%3u %2u%%",
     b16:	273c      	movs	r7, #60	; 0x3c
     b18:	fbb1 f1f7 	udiv	r1, r1, r7
     b1c:	e9cd 0100 	strd	r0, r1, [sp]
     b20:	4916      	ldr	r1, [pc, #88]	; (b7c <OC::debug_menu_core()+0xa4>)
     b22:	4620      	mov	r0, r4
     b24:	f019 f802 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>
  }

  uint32_t min_value() const {
    return min_;
     b28:	4915      	ldr	r1, [pc, #84]	; (b80 <OC::debug_menu_core()+0xa8>)
  text_x_ = x;
     b2a:	6066      	str	r6, [r4, #4]
  text_y_ = y;
     b2c:	2320      	movs	r3, #32
     b2e:	684a      	ldr	r2, [r1, #4]
     b30:	60a3      	str	r3, [r4, #8]
     b32:	fba2 3205 	umull	r3, r2, r2, r5
     b36:	680b      	ldr	r3, [r1, #0]
     b38:	fba3 0305 	umull	r0, r3, r3, r5
     b3c:	6889      	ldr	r1, [r1, #8]
     b3e:	fba1 1505 	umull	r1, r5, r1, r5

  graphics.setPrintPos(2, 32);
  graphics.printf("POLL%3u/%3u/%3u",
     b42:	4910      	ldr	r1, [pc, #64]	; (b84 <OC::debug_menu_core()+0xac>)
     b44:	9500      	str	r5, [sp, #0]
     b46:	4620      	mov	r0, r4
     b48:	f018 fff0 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>
     b4c:	232a      	movs	r3, #42	; 0x2a
     b4e:	60a3      	str	r3, [r4, #8]
                  debug::cycles_to_us(DEBUG::UI_cycles.value()),
                  debug::cycles_to_us(DEBUG::UI_cycles.max_value()));

#ifdef OC_UI_DEBUG
  graphics.setPrintPos(2, 42);
  graphics.printf("UI   !%u #%u", DEBUG::UI_queue_overflow, DEBUG::UI_event_count);
     b50:	4a0d      	ldr	r2, [pc, #52]	; (b88 <OC::debug_menu_core()+0xb0>)
     b52:	4b0e      	ldr	r3, [pc, #56]	; (b8c <OC::debug_menu_core()+0xb4>)
     b54:	6812      	ldr	r2, [r2, #0]
     b56:	681b      	ldr	r3, [r3, #0]
     b58:	490d      	ldr	r1, [pc, #52]	; (b90 <OC::debug_menu_core()+0xb8>)
  text_x_ = x;
     b5a:	6066      	str	r6, [r4, #4]
     b5c:	4620      	mov	r0, r4
     b5e:	f018 ffe5 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>
  text_y_ = y;
     b62:	2334      	movs	r3, #52	; 0x34
  text_x_ = x;
     b64:	6066      	str	r6, [r4, #4]
  text_y_ = y;
     b66:	60a3      	str	r3, [r4, #8]
  graphics.setPrintPos(2, 52);
#endif
}
     b68:	b003      	add	sp, #12
     b6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     b6c:	200065e0 	.word	0x200065e0
     b70:	0001e00b 	.word	0x0001e00b
     b74:	02222222 	.word	0x02222222
     b78:	1fffa588 	.word	0x1fffa588
     b7c:	0001e01b 	.word	0x0001e01b
     b80:	1fffa5a8 	.word	0x1fffa5a8
     b84:	0001e031 	.word	0x0001e031
     b88:	1fffa5a4 	.word	0x1fffa5a4
     b8c:	1fffa594 	.word	0x1fffa594
     b90:	0001e041 	.word	0x0001e041

00000b94 <OC::debug_menu_adc()>:
                  debug::cycles_to_us(DEBUG::MENU_draw_cycles.min_value()),
                  debug::cycles_to_us(DEBUG::MENU_draw_cycles.value()),
                  debug::cycles_to_us(DEBUG::MENU_draw_cycles.max_value()));
}

static void debug_menu_adc() {
     b94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  // ISR timing restrictions.
  static void Scan();

  template <ADC_CHANNEL channel>
  static int32_t value() {
    return calibration_data_->offset[channel] - (smoothed_[channel] >> kAdcValueShift);
     b98:	4e21      	ldr	r6, [pc, #132]	; (c20 <OC::debug_menu_adc()+0x8c>)
  text_x_ = x;
     b9a:	4c22      	ldr	r4, [pc, #136]	; (c24 <OC::debug_menu_adc()+0x90>)
  static int32_t value(ADC_CHANNEL channel) {
    return calibration_data_->offset[channel] - (smoothed_[channel] >> kAdcValueShift);
  }

  static uint32_t raw_value(ADC_CHANNEL channel) {
    return raw_[channel] >> kAdcValueShift;
     b9c:	4f22      	ldr	r7, [pc, #136]	; (c28 <OC::debug_menu_adc()+0x94>)
    return calibration_data_->offset[channel] - (smoothed_[channel] >> kAdcValueShift);
     b9e:	4d23      	ldr	r5, [pc, #140]	; (c2c <OC::debug_menu_adc()+0x98>)
     ba0:	6832      	ldr	r2, [r6, #0]
  text_y_ = y;
     ba2:	230c      	movs	r3, #12
     ba4:	8811      	ldrh	r1, [r2, #0]
     ba6:	60a3      	str	r3, [r4, #8]
     ba8:	682a      	ldr	r2, [r5, #0]
    return raw_[channel] >> kAdcValueShift;
     baa:	683b      	ldr	r3, [r7, #0]
  text_x_ = x;
     bac:	f04f 0802 	mov.w	r8, #2
  graphics.setPrintPos(2, 12);
  graphics.printf("CV1 %5d %5u", ADC::value<ADC_CHANNEL_1>(), ADC::raw_value(ADC_CHANNEL_1));
     bb0:	eba1 2212 	sub.w	r2, r1, r2, lsr #8
     bb4:	4620      	mov	r0, r4
     bb6:	491e      	ldr	r1, [pc, #120]	; (c30 <OC::debug_menu_adc()+0x9c>)
     bb8:	f8c4 8004 	str.w	r8, [r4, #4]
     bbc:	0a1b      	lsrs	r3, r3, #8
     bbe:	f018 ffb5 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>
    return calibration_data_->offset[channel] - (smoothed_[channel] >> kAdcValueShift);
     bc2:	6832      	ldr	r2, [r6, #0]
     bc4:	f8c4 8004 	str.w	r8, [r4, #4]
  text_y_ = y;
     bc8:	2316      	movs	r3, #22
     bca:	8851      	ldrh	r1, [r2, #2]
     bcc:	60a3      	str	r3, [r4, #8]
     bce:	686a      	ldr	r2, [r5, #4]
    return raw_[channel] >> kAdcValueShift;
     bd0:	687b      	ldr	r3, [r7, #4]

  graphics.setPrintPos(2, 22);
  graphics.printf("CV2 %5d %5u", ADC::value<ADC_CHANNEL_2>(), ADC::raw_value(ADC_CHANNEL_2));
     bd2:	eba1 2212 	sub.w	r2, r1, r2, lsr #8
     bd6:	4620      	mov	r0, r4
     bd8:	4916      	ldr	r1, [pc, #88]	; (c34 <OC::debug_menu_adc()+0xa0>)
     bda:	0a1b      	lsrs	r3, r3, #8
     bdc:	f018 ffa6 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>
    return calibration_data_->offset[channel] - (smoothed_[channel] >> kAdcValueShift);
     be0:	6832      	ldr	r2, [r6, #0]
  text_x_ = x;
     be2:	f8c4 8004 	str.w	r8, [r4, #4]
  text_y_ = y;
     be6:	2320      	movs	r3, #32
     be8:	8891      	ldrh	r1, [r2, #4]
     bea:	60a3      	str	r3, [r4, #8]
     bec:	68aa      	ldr	r2, [r5, #8]
    return raw_[channel] >> kAdcValueShift;
     bee:	68bb      	ldr	r3, [r7, #8]

  graphics.setPrintPos(2, 32);
  graphics.printf("CV3 %5d %5u", ADC::value<ADC_CHANNEL_3>(), ADC::raw_value(ADC_CHANNEL_3));
     bf0:	eba1 2212 	sub.w	r2, r1, r2, lsr #8
     bf4:	4620      	mov	r0, r4
     bf6:	4910      	ldr	r1, [pc, #64]	; (c38 <OC::debug_menu_adc()+0xa4>)
     bf8:	0a1b      	lsrs	r3, r3, #8
     bfa:	f018 ff97 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>
    return calibration_data_->offset[channel] - (smoothed_[channel] >> kAdcValueShift);
     bfe:	6832      	ldr	r2, [r6, #0]
  text_x_ = x;
     c00:	f8c4 8004 	str.w	r8, [r4, #4]
  text_y_ = y;
     c04:	232a      	movs	r3, #42	; 0x2a
     c06:	88d1      	ldrh	r1, [r2, #6]
     c08:	60a3      	str	r3, [r4, #8]
     c0a:	68ea      	ldr	r2, [r5, #12]
    return raw_[channel] >> kAdcValueShift;
     c0c:	68fb      	ldr	r3, [r7, #12]

  graphics.setPrintPos(2, 42);
  graphics.printf("CV4 %5d %5u", ADC::value<ADC_CHANNEL_4>(), ADC::raw_value(ADC_CHANNEL_4));
     c0e:	eba1 2212 	sub.w	r2, r1, r2, lsr #8
     c12:	4620      	mov	r0, r4
     c14:	4909      	ldr	r1, [pc, #36]	; (c3c <OC::debug_menu_adc()+0xa8>)

//      graphics.setPrintPos(2, 42);
//      graphics.print((long)ADC::busy_waits());
//      graphics.setPrintPos(2, 42); graphics.print(ADC::fail_flag0());
//      graphics.setPrintPos(2, 52); graphics.print(ADC::fail_flag1());
}
     c16:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  graphics.printf("CV4 %5d %5u", ADC::value<ADC_CHANNEL_4>(), ADC::raw_value(ADC_CHANNEL_4));
     c1a:	0a1b      	lsrs	r3, r3, #8
     c1c:	f018 bf86 	b.w	19b2c <weegfx::Graphics::printf(char const*, ...)>
     c20:	1fffa344 	.word	0x1fffa344
     c24:	200065e0 	.word	0x200065e0
     c28:	1fffa4ac 	.word	0x1fffa4ac
     c2c:	1fffa4bc 	.word	0x1fffa4bc
     c30:	0001e04e 	.word	0x0001e04e
     c34:	0001e05a 	.word	0x0001e05a
     c38:	0001e066 	.word	0x0001e066
     c3c:	0001e072 	.word	0x0001e072

00000c40 <OC::debug_menu_gfx()>:
static void debug_menu_gfx() {
     c40:	b537      	push	{r0, r1, r2, r4, r5, lr}
  graphics.drawFrame(0, 0, 128, 64);
     c42:	4c13      	ldr	r4, [pc, #76]	; (c90 <OC::debug_menu_gfx()+0x50>)
     c44:	2200      	movs	r2, #0
     c46:	2340      	movs	r3, #64	; 0x40
     c48:	4611      	mov	r1, r2
     c4a:	9300      	str	r3, [sp, #0]
     c4c:	4620      	mov	r0, r4
     c4e:	2380      	movs	r3, #128	; 0x80
     c50:	f018 fcd3 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
  text_x_ = x;
     c54:	2300      	movs	r3, #0
     c56:	6063      	str	r3, [r4, #4]
  graphics.print("W");
     c58:	4620      	mov	r0, r4
  text_y_ = y;
     c5a:	230c      	movs	r3, #12
     c5c:	490d      	ldr	r1, [pc, #52]	; (c94 <OC::debug_menu_gfx()+0x54>)
     c5e:	60a3      	str	r3, [r4, #8]
     c60:	f018 ff39 	bl	19ad6 <weegfx::Graphics::print(char const*)>
     c64:	480c      	ldr	r0, [pc, #48]	; (c98 <OC::debug_menu_gfx()+0x58>)
     c66:	490d      	ldr	r1, [pc, #52]	; (c9c <OC::debug_menu_gfx()+0x5c>)
     c68:	6842      	ldr	r2, [r0, #4]
  text_x_ = x;
     c6a:	2302      	movs	r3, #2
     c6c:	6063      	str	r3, [r4, #4]
  text_y_ = y;
     c6e:	2316      	movs	r3, #22
     c70:	60a3      	str	r3, [r4, #8]
     c72:	fba2 3201 	umull	r3, r2, r2, r1
     c76:	6803      	ldr	r3, [r0, #0]
     c78:	fba3 5301 	umull	r5, r3, r3, r1
     c7c:	6880      	ldr	r0, [r0, #8]
     c7e:	fba0 0101 	umull	r0, r1, r0, r1
  graphics.printf("MENU %3u/%3u/%3u",
     c82:	9100      	str	r1, [sp, #0]
     c84:	4620      	mov	r0, r4
     c86:	4906      	ldr	r1, [pc, #24]	; (ca0 <OC::debug_menu_gfx()+0x60>)
     c88:	f018 ff50 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>
}
     c8c:	b003      	add	sp, #12
     c8e:	bd30      	pop	{r4, r5, pc}
     c90:	200065e0 	.word	0x200065e0
     c94:	0001e458 	.word	0x0001e458
     c98:	1fffa598 	.word	0x1fffa598
     c9c:	02222222 	.word	0x02222222
     ca0:	0001e07e 	.word	0x0001e07e

00000ca4 <OC::DEBUG::Init()>:
    ARM_DEMCR |= ARM_DEMCR_TRCENA;
     ca4:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
  void Init() {
     ca8:	b510      	push	{r4, lr}
     caa:	f8d2 3dfc 	ldr.w	r3, [r2, #3580]	; 0xdfc
     cae:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
     cb2:	f8c2 3dfc 	str.w	r3, [r2, #3580]	; 0xdfc
    ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
     cb6:	f5a2 4250 	sub.w	r2, r2, #53248	; 0xd000
      *portModeRegister(pin) = 1;
     cba:	2401      	movs	r4, #1
     cbc:	6813      	ldr	r3, [r2, #0]
     cbe:	f043 0301 	orr.w	r3, r3, #1
     cc2:	6013      	str	r3, [r2, #0]
    config = portConfigRegister(pin);
     cc4:	4b0f      	ldr	r3, [pc, #60]	; (d04 <OC::DEBUG::Init()+0x60>)
     cc6:	f8d3 20c4 	ldr.w	r2, [r3, #196]	; 0xc4
      *portModeRegister(pin) = 1;
     cca:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
      *config = PORT_PCR_DSE | PORT_PCR_MUX(1);
     cce:	f44f 70a0 	mov.w	r0, #320	; 0x140
      *portModeRegister(pin) = 1;
     cd2:	f881 4280 	strb.w	r4, [r1, #640]	; 0x280
      *config = PORT_PCR_DSE | PORT_PCR_MUX(1);
     cd6:	6010      	str	r0, [r2, #0]
          *config &= ~PORT_PCR_ODE;
     cd8:	6811      	ldr	r1, [r2, #0]
     cda:	f021 0120 	bic.w	r1, r1, #32
     cde:	6011      	str	r1, [r2, #0]
    config = portConfigRegister(pin);
     ce0:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
      *portModeRegister(pin) = 1;
     ce4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
     ce8:	f883 4280 	strb.w	r4, [r3, #640]	; 0x280
      *config = PORT_PCR_DSE | PORT_PCR_MUX(1);
     cec:	6010      	str	r0, [r2, #0]
          *config &= ~PORT_PCR_ODE;
     cee:	6813      	ldr	r3, [r2, #0]
     cf0:	f023 0320 	bic.w	r3, r3, #32
     cf4:	6013      	str	r3, [r2, #0]
			} else if (pin == 22) {
				CORE_PIN22_PORTCLEAR = CORE_PIN22_BITMASK;
			} else if (pin == 23) {
				CORE_PIN23_PORTCLEAR = CORE_PIN23_BITMASK;
			} else if (pin == 24) {
				CORE_PIN24_PORTCLEAR = CORE_PIN24_BITMASK;
     cf6:	4b04      	ldr	r3, [pc, #16]	; (d08 <OC::DEBUG::Init()+0x64>)
     cf8:	2220      	movs	r2, #32
     cfa:	609a      	str	r2, [r3, #8]
			} else if (pin == 25) {
				CORE_PIN25_PORTCLEAR = CORE_PIN25_BITMASK;
     cfc:	f44f 2200 	mov.w	r2, #524288	; 0x80000
     d00:	649a      	str	r2, [r3, #72]	; 0x48
  }
     d02:	bd10      	pop	{r4, pc}
     d04:	00027b0c 	.word	0x00027b0c
     d08:	400ff000 	.word	0x400ff000

00000d0c <OC::Ui::DebugStats()>:
  { " ASR", ASR_debug },
#endif // ASR_DEBUG
 { nullptr, nullptr }
};

void Ui::DebugStats() {
     d0c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  SERIAL_PRINTLN("DEBUG/STATS MENU");

  const DebugMenu *current_menu = &debug_menus[0];
     d10:	4d31      	ldr	r5, [pc, #196]	; (dd8 <OC::Ui::DebugStats()+0xcc>)
  size_t writeable() const {
    return frames - readable();
  }

  size_t readable() const {
    return write_ptr_ - read_ptr_;
     d12:	4e32      	ldr	r6, [pc, #200]	; (ddc <OC::Ui::DebugStats()+0xd0>)
  bool exit_loop = false;
  while (!exit_loop) {

    GRAPHICS_BEGIN_FRAME(false);
     d14:	4f32      	ldr	r7, [pc, #200]	; (de0 <OC::Ui::DebugStats()+0xd4>)
void Ui::DebugStats() {
     d16:	4604      	mov	r4, r0
     d18:	46a8      	mov	r8, r5
     d1a:	f8d6 2808 	ldr.w	r2, [r6, #2056]	; 0x808
     d1e:	f8d6 380c 	ldr.w	r3, [r6, #2060]	; 0x80c
    GRAPHICS_BEGIN_FRAME(false);
     d22:	1a9b      	subs	r3, r3, r2
     d24:	3302      	adds	r3, #2
     d26:	d026      	beq.n	d76 <OC::Ui::DebugStats()+0x6a>
    return frame_buffers_[read_ptr_ % frames];
  }

  // @return next writeable frame (assumes one exists)
  uint8_t *writeable_frame() {
    return frame_buffers_[write_ptr_ % frames];
     d28:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
     d2c:	f003 0301 	and.w	r3, r3, #1
     d30:	f503 7300 	add.w	r3, r3, #512	; 0x200
     d34:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
     d38:	b1e9      	cbz	r1, d76 <OC::Ui::DebugStats()+0x6a>
     d3a:	4829      	ldr	r0, [pc, #164]	; (de0 <OC::Ui::DebugStats()+0xd4>)
     d3c:	2201      	movs	r2, #1
     d3e:	f018 fa98 	bl	19272 <weegfx::Graphics::Begin(unsigned char*, bool)>
      graphics.setPrintPos(2, 2);
      graphics.printf("%d/%u", (int)(current_menu - &debug_menus[0]) + 1, ARRAY_SIZE(debug_menus) - 1);
     d42:	eba5 0208 	sub.w	r2, r5, r8
  text_x_ = x;
     d46:	2302      	movs	r3, #2
     d48:	10d2      	asrs	r2, r2, #3
     d4a:	3201      	adds	r2, #1
     d4c:	4925      	ldr	r1, [pc, #148]	; (de4 <OC::Ui::DebugStats()+0xd8>)
     d4e:	4824      	ldr	r0, [pc, #144]	; (de0 <OC::Ui::DebugStats()+0xd4>)
     d50:	607b      	str	r3, [r7, #4]
  text_y_ = y;
     d52:	60bb      	str	r3, [r7, #8]
     d54:	2303      	movs	r3, #3
     d56:	f018 fee9 	bl	19b2c <weegfx::Graphics::printf(char const*, ...)>
      graphics.print(current_menu->title);
     d5a:	6829      	ldr	r1, [r5, #0]
     d5c:	4820      	ldr	r0, [pc, #128]	; (de0 <OC::Ui::DebugStats()+0xd4>)
     d5e:	f018 feba 	bl	19ad6 <weegfx::Graphics::print(char const*)>
      current_menu->display_fn();
     d62:	686b      	ldr	r3, [r5, #4]
     d64:	4798      	blx	r3
    GRAPHICS_END_FRAME();
     d66:	481e      	ldr	r0, [pc, #120]	; (de0 <OC::Ui::DebugStats()+0xd4>)
     d68:	f018 fa91 	bl	1928e <weegfx::Graphics::End()>
  void read() {
    ++read_ptr_;
  }

  void written() {
    ++write_ptr_;
     d6c:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
     d70:	3301      	adds	r3, #1
     d72:	f8c6 3808 	str.w	r3, [r6, #2056]	; 0x808
      if (CONTROL_BUTTON_R == event.control) {
        exit_loop = true;
      } else if (CONTROL_BUTTON_L == event.control) {
        ++current_menu;
        if (!current_menu->title || !current_menu->display_fn)
          current_menu = &debug_menus[0];
     d76:	2100      	movs	r1, #0
  void Init() {
    write_ptr_ = read_ptr_ = poke_ptr_ = 0;
  }

  inline size_t readable() const {
    return write_ptr_ - read_ptr_;
     d78:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
     d7c:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    while (event_queue_.available()) {
     d80:	429a      	cmp	r2, r3
     d82:	d10f      	bne.n	da4 <OC::Ui::DebugStats()+0x98>
  while (!exit_loop) {
     d84:	2900      	cmp	r1, #0
     d86:	d0c8      	beq.n	d1a <OC::Ui::DebugStats()+0xe>
    buffer_[write_ptr & (size - 1)] = value;
    poke_ptr_ = write_ptr_ = write_ptr + 1;
  }

  inline void Flush() {
    write_ptr_ = read_ptr_ = 0;
     d88:	2300      	movs	r3, #0
     d8a:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
     d8e:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     d92:	4b15      	ldr	r3, [pc, #84]	; (de8 <OC::Ui::DebugStats()+0xdc>)
     d94:	681b      	ldr	r3, [r3, #0]
     d96:	9301      	str	r3, [sp, #4]
	return ret;
     d98:	9b01      	ldr	r3, [sp, #4]
  inline Event PullEvent() {
    return events_.Read();
  }

  inline void Poke() {
    last_event_time_ = millis();
     d9a:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
    }
  }

  event_queue_.Flush();
  event_queue_.Poke();
}
     d9e:	b002      	add	sp, #8
     da0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    size_t read_ptr = read_ptr_;
     da4:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    T value = buffer_[read_ptr & (size - 1)];
     da8:	f003 020f 	and.w	r2, r3, #15
     dac:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    read_ptr_ = read_ptr + 1;
     db0:	3301      	adds	r3, #1
    T value = buffer_[read_ptr & (size - 1)];
     db2:	f8b2 206e 	ldrh.w	r2, [r2, #110]	; 0x6e
    read_ptr_ = read_ptr + 1;
     db6:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
      if (CONTROL_BUTTON_R == event.control) {
     dba:	2a08      	cmp	r2, #8
     dbc:	d007      	beq.n	dce <OC::Ui::DebugStats()+0xc2>
      } else if (CONTROL_BUTTON_L == event.control) {
     dbe:	2a04      	cmp	r2, #4
     dc0:	d1da      	bne.n	d78 <OC::Ui::DebugStats()+0x6c>
        if (!current_menu->title || !current_menu->display_fn)
     dc2:	68ab      	ldr	r3, [r5, #8]
     dc4:	b12b      	cbz	r3, dd2 <OC::Ui::DebugStats()+0xc6>
     dc6:	68eb      	ldr	r3, [r5, #12]
     dc8:	b11b      	cbz	r3, dd2 <OC::Ui::DebugStats()+0xc6>
        ++current_menu;
     dca:	3508      	adds	r5, #8
     dcc:	e7d4      	b.n	d78 <OC::Ui::DebugStats()+0x6c>
        exit_loop = true;
     dce:	2101      	movs	r1, #1
     dd0:	e7d2      	b.n	d78 <OC::Ui::DebugStats()+0x6c>
          current_menu = &debug_menus[0];
     dd2:	4d01      	ldr	r5, [pc, #4]	; (dd8 <OC::Ui::DebugStats()+0xcc>)
     dd4:	e7d0      	b.n	d78 <OC::Ui::DebugStats()+0x6c>
     dd6:	bf00      	nop
     dd8:	0001e0a8 	.word	0x0001e0a8
     ddc:	20005dc8 	.word	0x20005dc8
     de0:	200065e0 	.word	0x200065e0
     de4:	0001e08f 	.word	0x0001e08f
     de8:	20006600 	.word	0x20006600

00000dec <_GLOBAL__sub_I__ZN2OC5DEBUG10ISR_cyclesE>:
  AveragedCycles() : value_(0), min_(0xffffffff), max_(0) { }
     dec:	4a07      	ldr	r2, [pc, #28]	; (e0c <_GLOBAL__sub_I__ZN2OC5DEBUG10ISR_cyclesE+0x20>)
     dee:	2300      	movs	r3, #0
     df0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
     df4:	6013      	str	r3, [r2, #0]
     df6:	6051      	str	r1, [r2, #4]
     df8:	6093      	str	r3, [r2, #8]
     dfa:	4a05      	ldr	r2, [pc, #20]	; (e10 <_GLOBAL__sub_I__ZN2OC5DEBUG10ISR_cyclesE+0x24>)
     dfc:	6013      	str	r3, [r2, #0]
     dfe:	6051      	str	r1, [r2, #4]
     e00:	6093      	str	r3, [r2, #8]
     e02:	4a04      	ldr	r2, [pc, #16]	; (e14 <_GLOBAL__sub_I__ZN2OC5DEBUG10ISR_cyclesE+0x28>)
     e04:	6013      	str	r3, [r2, #0]
     e06:	6051      	str	r1, [r2, #4]
     e08:	6093      	str	r3, [r2, #8]

}; // namespace OC
     e0a:	4770      	bx	lr
     e0c:	1fffa588 	.word	0x1fffa588
     e10:	1fffa5a8 	.word	0x1fffa5a8
     e14:	1fffa598 	.word	0x1fffa598

00000e18 <OC::DigitalInputs::Init()>:
void FASTRUN tr4_ISR() {
  OC::DigitalInputs::clock<OC::DIGITAL_INPUT_4>();
}

/*static*/
void OC::DigitalInputs::Init() {
     e18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    {TR2, tr2_ISR},
    {TR3, tr3_ISR},
    {TR4, tr4_ISR},
  };

  for (auto pin : pins) {
     e1c:	4d11      	ldr	r5, [pc, #68]	; (e64 <OC::DigitalInputs::Init()+0x4c>)
    config = portConfigRegister(pin);
     e1e:	4e12      	ldr	r6, [pc, #72]	; (e68 <OC::DigitalInputs::Init()+0x50>)
void OC::DigitalInputs::Init() {
     e20:	2404      	movs	r4, #4
                  }
    } else {
  #ifdef KINETISK
      *portModeRegister(pin) = 0;
     e22:	2700      	movs	r7, #0
      *portModeRegister(pin) &= ~digitalPinToBitMask(pin);
  #endif
      if (mode == INPUT) {
        *config = PORT_PCR_MUX(1);
      } else if (mode == INPUT_PULLUP) {
        *config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
     e24:	f240 1803 	movw	r8, #259	; 0x103
  for (auto pin : pins) {
     e28:	7828      	ldrb	r0, [r5, #0]
     e2a:	6869      	ldr	r1, [r5, #4]
    if (pin >= CORE_NUM_DIGITAL) return;
     e2c:	2821      	cmp	r0, #33	; 0x21
     e2e:	d808      	bhi.n	e42 <OC::DigitalInputs::Init()+0x2a>
    config = portConfigRegister(pin);
     e30:	eb06 03c0 	add.w	r3, r6, r0, lsl #3
     e34:	685a      	ldr	r2, [r3, #4]
      *portModeRegister(pin) = 0;
     e36:	f856 3030 	ldr.w	r3, [r6, r0, lsl #3]
     e3a:	f883 7280 	strb.w	r7, [r3, #640]	; 0x280
        *config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
     e3e:	f8c2 8000 	str.w	r8, [r2]
    pinMode(pin.pin, OC_GPIO_TRx_PINMODE);
    attachInterrupt(pin.pin, pin.isr_fn, FALLING);
     e42:	2202      	movs	r2, #2
     e44:	f019 fabe 	bl	1a3c4 <attachInterrupt>
  for (auto pin : pins) {
     e48:	3c01      	subs	r4, #1
     e4a:	f105 0508 	add.w	r5, r5, #8
     e4e:	d1eb      	bne.n	e28 <OC::DigitalInputs::Init()+0x10>
  }

  clocked_mask_ = 0;
     e50:	4b06      	ldr	r3, [pc, #24]	; (e6c <OC::DigitalInputs::Init()+0x54>)
     e52:	601c      	str	r4, [r3, #0]
     e54:	4b06      	ldr	r3, [pc, #24]	; (e70 <OC::DigitalInputs::Init()+0x58>)
     e56:	601c      	str	r4, [r3, #0]
     e58:	605c      	str	r4, [r3, #4]
     e5a:	609c      	str	r4, [r3, #8]
     e5c:	60dc      	str	r4, [r3, #12]
  // exactly simultaneously though, but that's micro-timing dependent even if
  // the pins have higher prio.

  //  NVIC_SET_PRIORITY(IRQ_PORTB, 0); // TR1 = 0 = PTB16
  // Defaults is 0, or set OC_GPIO_ISR_PRIO for all ports
}
     e5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     e62:	bf00      	nop
     e64:	0001e0c8 	.word	0x0001e0c8
     e68:	00027b0c 	.word	0x00027b0c
     e6c:	1fffa5b4 	.word	0x1fffa5b4
     e70:	1fffa5b8 	.word	0x1fffa5b8

00000e74 <OC::DigitalInputs::reInit()>:
    config = portConfigRegister(pin);
     e74:	4b06      	ldr	r3, [pc, #24]	; (e90 <OC::DigitalInputs::reInit()+0x1c>)
     e76:	69da      	ldr	r2, [r3, #28]
      *portModeRegister(pin) = 0;
     e78:	699b      	ldr	r3, [r3, #24]
     e7a:	2100      	movs	r1, #0
     e7c:	f883 1280 	strb.w	r1, [r3, #640]	; 0x280
        *config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
     e80:	f240 1303 	movw	r3, #259	; 0x103
     e84:	6013      	str	r3, [r2, #0]

void OC::DigitalInputs::reInit() {
  // re-init TR4, to avoid conflict with the FTM
  #ifdef FLIP_180
    pinMode(TR1, OC_GPIO_TRx_PINMODE);
    attachInterrupt(TR1, tr1_ISR, FALLING);
     e86:	4903      	ldr	r1, [pc, #12]	; (e94 <OC::DigitalInputs::reInit()+0x20>)
     e88:	2202      	movs	r2, #2
     e8a:	2003      	movs	r0, #3
     e8c:	f019 ba9a 	b.w	1a3c4 <attachInterrupt>
     e90:	00027b0c 	.word	0x00027b0c
     e94:	1fff8cfd 	.word	0x1fff8cfd

00000e98 <OC::DigitalInputs::Scan()>:
  static uint32_t clocked_mask_;
  static volatile uint32_t clocked_[DIGITAL_INPUT_LAST];

  template <DigitalInput input>
  static uint32_t ScanInput() {
    if (clocked_[input]) {
     e98:	4a0d      	ldr	r2, [pc, #52]	; (ed0 <OC::DigitalInputs::Scan()+0x38>)
     e9a:	6811      	ldr	r1, [r2, #0]
     e9c:	b111      	cbz	r1, ea4 <OC::DigitalInputs::Scan()+0xc>
      clocked_[input] = 0;
     e9e:	2300      	movs	r3, #0
     ea0:	6013      	str	r3, [r2, #0]
      return DIGITAL_INPUT_MASK(input);
     ea2:	2101      	movs	r1, #1
    if (clocked_[input]) {
     ea4:	6853      	ldr	r3, [r2, #4]
     ea6:	b113      	cbz	r3, eae <OC::DigitalInputs::Scan()+0x16>
      clocked_[input] = 0;
     ea8:	2300      	movs	r3, #0
     eaa:	6053      	str	r3, [r2, #4]
      return DIGITAL_INPUT_MASK(input);
     eac:	2302      	movs	r3, #2
}

/*static*/
void OC::DigitalInputs::Scan() {
  clocked_mask_ =
    ScanInput<DIGITAL_INPUT_1>() |
     eae:	430b      	orrs	r3, r1
    if (clocked_[input]) {
     eb0:	6891      	ldr	r1, [r2, #8]
     eb2:	b111      	cbz	r1, eba <OC::DigitalInputs::Scan()+0x22>
      clocked_[input] = 0;
     eb4:	2100      	movs	r1, #0
     eb6:	6091      	str	r1, [r2, #8]
      return DIGITAL_INPUT_MASK(input);
     eb8:	2104      	movs	r1, #4
    ScanInput<DIGITAL_INPUT_2>() |
     eba:	430b      	orrs	r3, r1
    if (clocked_[input]) {
     ebc:	68d1      	ldr	r1, [r2, #12]
     ebe:	b111      	cbz	r1, ec6 <OC::DigitalInputs::Scan()+0x2e>
      clocked_[input] = 0;
     ec0:	2100      	movs	r1, #0
     ec2:	60d1      	str	r1, [r2, #12]
      return DIGITAL_INPUT_MASK(input);
     ec4:	2108      	movs	r1, #8
  clocked_mask_ =
     ec6:	4a03      	ldr	r2, [pc, #12]	; (ed4 <OC::DigitalInputs::Scan()+0x3c>)
    ScanInput<DIGITAL_INPUT_3>() |
     ec8:	430b      	orrs	r3, r1
  clocked_mask_ =
     eca:	6013      	str	r3, [r2, #0]
    ScanInput<DIGITAL_INPUT_4>();
}
     ecc:	4770      	bx	lr
     ece:	bf00      	nop
     ed0:	1fffa5b8 	.word	0x1fffa5b8
     ed4:	1fffa5b4 	.word	0x1fffa5b4

00000ed8 <OC::menu::Init()>:
void Init() {
     ed8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     edc:	4d16      	ldr	r5, [pc, #88]	; (f38 <OC::menu::Init()+0x60>)
    float rads = ((i + 12 - 3) % 12) * semitone_radians;
     ede:	f8df 905c 	ldr.w	r9, [pc, #92]	; f3c <OC::menu::Init()+0x64>
    float x = note_circle_r * cos(rads);
     ee2:	f8df 805c 	ldr.w	r8, [pc, #92]	; f40 <OC::menu::Init()+0x68>
void Init() {
     ee6:	2409      	movs	r4, #9
    float rads = ((i + 12 - 3) % 12) * semitone_radians;
     ee8:	f04f 0a0c 	mov.w	sl, #12
     eec:	fbb4 f0fa 	udiv	r0, r4, sl
     ef0:	fb0a 4010 	mls	r0, sl, r0, r4
     ef4:	f01c f8e0 	bl	1d0b8 <__aeabi_i2f>
     ef8:	4649      	mov	r1, r9
     efa:	f01c f931 	bl	1d160 <__aeabi_fmul>
     efe:	4606      	mov	r6, r0
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
     f00:	f01a fb3e 	bl	1b580 <cosf>
     f04:	4607      	mov	r7, r0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
     f06:	4630      	mov	r0, r6
     f08:	f01a fb6c 	bl	1b5e4 <sinf>
    float x = note_circle_r * cos(rads);
     f0c:	4641      	mov	r1, r8
     f0e:	4606      	mov	r6, r0
     f10:	4638      	mov	r0, r7
     f12:	f01c f925 	bl	1d160 <__aeabi_fmul>
    circle_pos_lut[i].x = x;
     f16:	f01c faff 	bl	1d518 <__aeabi_f2iz>
    float y = note_circle_r * sin(rads);
     f1a:	4641      	mov	r1, r8
    circle_pos_lut[i].x = x;
     f1c:	6028      	str	r0, [r5, #0]
    float y = note_circle_r * sin(rads);
     f1e:	4630      	mov	r0, r6
     f20:	f01c f91e 	bl	1d160 <__aeabi_fmul>
    circle_pos_lut[i].y = y;
     f24:	f01c faf8 	bl	1d518 <__aeabi_f2iz>
  for (int i = 0; i < 12; ++i) {
     f28:	3401      	adds	r4, #1
     f2a:	2c15      	cmp	r4, #21
    circle_pos_lut[i].y = y;
     f2c:	6068      	str	r0, [r5, #4]
  for (int i = 0; i < 12; ++i) {
     f2e:	f105 0508 	add.w	r5, r5, #8
     f32:	d1db      	bne.n	eec <OC::menu::Init()+0x14>
};
     f34:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     f38:	1fffa5c8 	.word	0x1fffa5c8
     f3c:	3f060a92 	.word	0x3f060a92
     f40:	41e00000 	.word	0x41e00000

00000f44 <OC::Scales::Init()>:

/*static*/
const int Scales::NUM_SCALES = OC::Scales::SCALE_USER_LAST + sizeof(braids::scales) / sizeof(braids::scales[0]);

/*static*/
void Scales::Init() {
     f44:	b5f0      	push	{r4, r5, r6, r7, lr}
  for (size_t i = 0; i < SCALE_USER_LAST; ++i)
    memcpy(&user_scales[i], &braids::scales[1], sizeof(Scale));
     f46:	4f09      	ldr	r7, [pc, #36]	; (f6c <OC::Scales::Init()+0x28>)
  for (size_t i = 0; i < SCALE_USER_LAST; ++i)
     f48:	2600      	movs	r6, #0
    memcpy(&user_scales[i], &braids::scales[1], sizeof(Scale));
     f4a:	f04f 0c28 	mov.w	ip, #40	; 0x28
     f4e:	4d08      	ldr	r5, [pc, #32]	; (f70 <OC::Scales::Init()+0x2c>)
     f50:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     f52:	fb0c 7406 	mla	r4, ip, r6, r7
     f56:	c40f      	stmia	r4!, {r0, r1, r2, r3}
     f58:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     f5a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
     f5c:	e895 0003 	ldmia.w	r5, {r0, r1}
  for (size_t i = 0; i < SCALE_USER_LAST; ++i)
     f60:	3601      	adds	r6, #1
     f62:	2e04      	cmp	r6, #4
    memcpy(&user_scales[i], &braids::scales[1], sizeof(Scale));
     f64:	e884 0003 	stmia.w	r4, {r0, r1}
  for (size_t i = 0; i < SCALE_USER_LAST; ++i)
     f68:	d1f1      	bne.n	f4e <OC::Scales::Init()+0xa>
}
     f6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     f6c:	1fffa728 	.word	0x1fffa728
     f70:	0001e72c 	.word	0x0001e72c

00000f74 <OC::Scales::GetScale(int)>:

/*static*/
const Scale &Scales::GetScale(int index) {
  if (index < SCALE_USER_LAST)
     f74:	2803      	cmp	r0, #3
    return user_scales[index];
     f76:	bfd4      	ite	le
     f78:	4a04      	ldrle	r2, [pc, #16]	; (f8c <OC::Scales::GetScale(int)+0x18>)
  else
    return braids::scales[index - SCALE_USER_LAST];
     f7a:	4a05      	ldrgt	r2, [pc, #20]	; (f90 <OC::Scales::GetScale(int)+0x1c>)
     f7c:	f04f 0328 	mov.w	r3, #40	; 0x28
     f80:	bfc8      	it	gt
     f82:	3804      	subgt	r0, #4
     f84:	fb03 2000 	mla	r0, r3, r0, r2
}
     f88:	4770      	bx	lr
     f8a:	bf00      	nop
     f8c:	1fffa728 	.word	0x1fffa728
     f90:	0001e704 	.word	0x0001e704

00000f94 <OC::Ui::~Ui()>:
  UI_MODE_MENU,
  UI_MODE_APP_SETTINGS,
  UI_MODE_CALIBRATE
};

class Ui {
     f94:	4770      	bx	lr
     f96:	Address 0x0000000000000f96 is out of bounds.


00000f98 <UI::Button::Poll()>:
		return *portInputRegister(pin);
     f98:	7802      	ldrb	r2, [r0, #0]
     f9a:	4b07      	ldr	r3, [pc, #28]	; (fb8 <UI::Button::Poll()+0x20>)
     f9c:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    state_ = 0xff;
  }

  // @return True if pressed
  uint8_t Poll() {
    uint8_t state = (state_ << 1) | digitalReadFast(pin_);
     fa0:	7902      	ldrb	r2, [r0, #4]
     fa2:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
     fa6:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
     faa:	b2db      	uxtb	r3, r3
    state_ = state;
     fac:	7103      	strb	r3, [r0, #4]
    return !(state & 0x01);
     fae:	43d8      	mvns	r0, r3
  }
     fb0:	f000 0001 	and.w	r0, r0, #1
     fb4:	4770      	bx	lr
     fb6:	bf00      	nop
     fb8:	00027b0c 	.word	0x00027b0c

00000fbc <OC::Ui::configure_encoders(OC::EncoderConfig)>:
}

void Ui::configure_encoders(EncoderConfig encoder_config) {
  SERIAL_PRINTLN("Configuring encoders: %s (%x)", OC::Strings::encoder_config_strings[encoder_config], encoder_config);

  encoder_right_.reverse(encoder_config & ENCODER_CONFIG_R_REVERSED);
     fbc:	f001 0301 	and.w	r3, r1, #1
  encoder_left_.reverse(encoder_config & ENCODER_CONFIG_L_REVERSED);
     fc0:	f3c1 0140 	ubfx	r1, r1, #1, #1
  encoder_right_.reverse(encoder_config & ENCODER_CONFIG_R_REVERSED);
     fc4:	f880 304d 	strb.w	r3, [r0, #77]	; 0x4d
      acceleration_ = 0;
    }
  }

  void reverse(bool reversed) {
    reversed_ = reversed;
     fc8:	f880 105d 	strb.w	r1, [r0, #93]	; 0x5d
}
     fcc:	4770      	bx	lr
     fce:	Address 0x0000000000000fce is out of bounds.


00000fd0 <OC::Ui::DispatchEvents(OC::App*)>:
    PushEvent(UI::EVENT_ENCODER, CONTROL_ENCODER_L, increment, button_state);

  button_state_ = button_state;
}

UiMode Ui::DispatchEvents(App *app) {
     fd0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
        app->HandleEncoderEvent(event);
        break;
      default:
        break;
    }
    MENU_REDRAW = 1;
     fd4:	f8df 8124 	ldr.w	r8, [pc, #292]	; 10fc <OC::Ui::DispatchEvents(OC::App*)+0x12c>
    static const int BI = 0;
    static const int ASYM = 1;
    static const int UNI = 2;

    static VBiasManager *get() {
        if (!instance) instance = new VBiasManager;
     fd8:	4f49      	ldr	r7, [pc, #292]	; (1100 <OC::Ui::DispatchEvents(OC::App*)+0x130>)
UiMode Ui::DispatchEvents(App *app) {
     fda:	4604      	mov	r4, r0
     fdc:	460e      	mov	r6, r1
    return write_ptr_ - read_ptr_;
     fde:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
     fe2:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
  while (event_queue_.available()) {
     fe6:	429a      	cmp	r2, r3
     fe8:	d115      	bne.n	1016 <OC::Ui::DispatchEvents(OC::App*)+0x46>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     fea:	4b46      	ldr	r3, [pc, #280]	; (1104 <OC::Ui::DispatchEvents(OC::App*)+0x134>)
  }

  // Turning screensaver seconds into screen-blanking minutes with the * 60 (chysn 9/2/2018)
  if (idle_time() > (screensaver_timeout() * 60))
     fec:	6862      	ldr	r2, [r4, #4]
     fee:	681b      	ldr	r3, [r3, #0]
     ff0:	9300      	str	r3, [sp, #0]
     ff2:	213c      	movs	r1, #60	; 0x3c
     ff4:	434a      	muls	r2, r1
	return ret;
     ff6:	9b00      	ldr	r3, [sp, #0]
  }

  inline uint32_t idle_time() const {
    return millis() - last_event_time_;
     ff8:	f8d4 10f8 	ldr.w	r1, [r4, #248]	; 0xf8
     ffc:	1a5b      	subs	r3, r3, r1
     ffe:	429a      	cmp	r2, r3
    screensaver_ = true;
    1000:	bf3c      	itt	cc
    1002:	2301      	movcc	r3, #1
    1004:	f884 3048 	strbcc.w	r3, [r4, #72]	; 0x48

  if (screensaver_)
    1008:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
          return UI_MODE_APP_SETTINGS;
    100c:	f080 0001 	eor.w	r0, r0, #1
    return UI_MODE_SCREENSAVER;
  else
    return UI_MODE_MENU;
}
    1010:	b002      	add	sp, #8
    1012:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    size_t read_ptr = read_ptr_;
    1016:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    T value = buffer_[read_ptr & (size - 1)];
    101a:	f003 000f 	and.w	r0, r3, #15
    101e:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    1022:	466a      	mov	r2, sp
    1024:	6f01      	ldr	r1, [r0, #112]	; 0x70
    1026:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
    1028:	e882 0003 	stmia.w	r2, {r0, r1}
    read_ptr_ = read_ptr + 1;
    102c:	3301      	adds	r3, #1
    event_queue_.PushEvent(t, c, v, m);
  }

  bool IgnoreEvent(const UI::Event &event) {
    bool ignore = false;
    if (button_ignore_mask_ & event.control) {
    102e:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
    1032:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
    if (IgnoreEvent(event))
    1036:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    103a:	ea13 0501 	ands.w	r5, r3, r1
      button_ignore_mask_ &= ~event.control;
    103e:	bf1c      	itt	ne
    1040:	4399      	bicne	r1, r3
    1042:	f8a4 1046 	strhne.w	r1, [r4, #70]	; 0x46
      ignore = true;
    }
    if (screensaver_) {
    1046:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
      ignore = true;
    104a:	bf18      	it	ne
    104c:	2501      	movne	r5, #1
    if (screensaver_) {
    104e:	b119      	cbz	r1, 1058 <OC::Ui::DispatchEvents(OC::App*)+0x88>
      screensaver_ = false;
    1050:	2300      	movs	r3, #0
    1052:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
      ignore = true;
    }

    return ignore;
    1056:	e7c2      	b.n	fde <OC::Ui::DispatchEvents(OC::App*)+0xe>
    1058:	2d00      	cmp	r5, #0
    105a:	d1c0      	bne.n	fde <OC::Ui::DispatchEvents(OC::App*)+0xe>
    switch (event.type) {
    105c:	f89d 0000 	ldrb.w	r0, [sp]
    1060:	2802      	cmp	r0, #2
    1062:	d039      	beq.n	10d8 <OC::Ui::DispatchEvents(OC::App*)+0x108>
    1064:	2803      	cmp	r0, #3
    1066:	d046      	beq.n	10f6 <OC::Ui::DispatchEvents(OC::App*)+0x126>
    1068:	2801      	cmp	r0, #1
    106a:	d12e      	bne.n	10ca <OC::Ui::DispatchEvents(OC::App*)+0xfa>
        if (OC::CONTROL_BUTTON_M == event.control) {
    106c:	2b10      	cmp	r3, #16
    106e:	d13e      	bne.n	10ee <OC::Ui::DispatchEvents(OC::App*)+0x11e>
    1070:	683b      	ldr	r3, [r7, #0]
    1072:	b92b      	cbnz	r3, 1080 <OC::Ui::DispatchEvents(OC::App*)+0xb0>
    1074:	2008      	movs	r0, #8
    1076:	f019 f8ed 	bl	1a254 <operator new(unsigned int)>
        bias_state = 0;
    107a:	6005      	str	r5, [r0, #0]
        last_advance_tick = 0;
    107c:	6045      	str	r5, [r0, #4]
        if (!instance) instance = new VBiasManager;
    107e:	6038      	str	r0, [r7, #0]
        return instance;
    1080:	f8d7 9000 	ldr.w	r9, [r7]
     * Advance to the next state, when the button is pushed
     */
    void AdvanceBias() {
        // Only advance the bias if it's been less than a second since the last button press.
        // This is so that the first button press shows the popup without changing anything.
        if (OC::CORE::ticks - last_advance_tick < BIAS_EDITOR_TIMEOUT) {
    1084:	f8df a080 	ldr.w	sl, [pc, #128]	; 1108 <OC::Ui::DispatchEvents(OC::App*)+0x138>
    1088:	f8d9 2004 	ldr.w	r2, [r9, #4]
    108c:	f8da 3000 	ldr.w	r3, [sl]
    1090:	1a9b      	subs	r3, r3, r2
    1092:	f244 1219 	movw	r2, #16665	; 0x4119
    1096:	4293      	cmp	r3, r2
    1098:	d813      	bhi.n	10c2 <OC::Ui::DispatchEvents(OC::App*)+0xf2>
            if (++bias_state > 2) bias_state = 0;
    109a:	f8d9 5000 	ldr.w	r5, [r9]
     *     vbias_m->ChangeBiasToState(VBiasManager::BI);
     * #endif
     *
     */
    void ChangeBiasToState(int new_bias_state) {
        int new_bias_value = OC::calibration_data.v_bias & 0xFFFF; // Bipolar = lower 2 bytes
    109e:	4b1b      	ldr	r3, [pc, #108]	; (110c <OC::Ui::DispatchEvents(OC::App*)+0x13c>)
            if (++bias_state > 2) bias_state = 0;
    10a0:	3501      	adds	r5, #1
    10a2:	2d03      	cmp	r5, #3
    10a4:	bfa8      	it	ge
    10a6:	2500      	movge	r5, #0
    10a8:	f8c9 5000 	str.w	r5, [r9]
        if (new_bias_state == VBiasManager::UNI) new_bias_value = OC::DAC::VBiasUnipolar;
    10ac:	2d02      	cmp	r5, #2
        int new_bias_value = OC::calibration_data.v_bias & 0xFFFF; // Bipolar = lower 2 bytes
    10ae:	6f18      	ldr	r0, [r3, #112]	; 0x70
        if (new_bias_state == VBiasManager::UNI) new_bias_value = OC::DAC::VBiasUnipolar;
    10b0:	d00f      	beq.n	10d2 <OC::Ui::DispatchEvents(OC::App*)+0x102>
        if (new_bias_state == VBiasManager::ASYM) new_bias_value = (OC::calibration_data.v_bias >> 16); // asym. = upper 2 bytes
    10b2:	2d01      	cmp	r5, #1
        int new_bias_value = OC::calibration_data.v_bias & 0xFFFF; // Bipolar = lower 2 bytes
    10b4:	bf14      	ite	ne
    10b6:	b280      	uxthne	r0, r0
        if (new_bias_state == VBiasManager::ASYM) new_bias_value = (OC::calibration_data.v_bias >> 16); // asym. = upper 2 bytes
    10b8:	0c00      	lsreq	r0, r0, #16
        OC::DAC::set_Vbias(new_bias_value);
    10ba:	f7ff fac1 	bl	640 <OC::DAC::set_Vbias(unsigned long)>
        bias_state = new_bias_state;
    10be:	f8c9 5000 	str.w	r5, [r9]
        last_advance_tick = OC::CORE::ticks;
    10c2:	f8da 3000 	ldr.w	r3, [sl]
    10c6:	f8c9 3004 	str.w	r3, [r9, #4]
    MENU_REDRAW = 1;
    10ca:	2301      	movs	r3, #1
    10cc:	f8c8 3000 	str.w	r3, [r8]
    10d0:	e785      	b.n	fde <OC::Ui::DispatchEvents(OC::App*)+0xe>
        if (new_bias_state == VBiasManager::UNI) new_bias_value = OC::DAC::VBiasUnipolar;
    10d2:	f640 703c 	movw	r0, #3900	; 0xf3c
    10d6:	e7f0      	b.n	10ba <OC::Ui::DispatchEvents(OC::App*)+0xea>
        if (OC::CONTROL_BUTTON_UP == event.control) {
    10d8:	2b01      	cmp	r3, #1
    10da:	d106      	bne.n	10ea <OC::Ui::DispatchEvents(OC::App*)+0x11a>
            if (!preempt_screensaver_) screensaver_ = true;
    10dc:	f894 2049 	ldrb.w	r2, [r4, #73]	; 0x49
    10e0:	2a00      	cmp	r2, #0
    10e2:	d1f2      	bne.n	10ca <OC::Ui::DispatchEvents(OC::App*)+0xfa>
    10e4:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    10e8:	e7ef      	b.n	10ca <OC::Ui::DispatchEvents(OC::App*)+0xfa>
        else if (OC::CONTROL_BUTTON_R == event.control)
    10ea:	2b08      	cmp	r3, #8
    10ec:	d090      	beq.n	1010 <OC::Ui::DispatchEvents(OC::App*)+0x40>
          app->HandleButtonEvent(event);
    10ee:	6ab3      	ldr	r3, [r6, #40]	; 0x28
        app->HandleEncoderEvent(event);
    10f0:	4610      	mov	r0, r2
    10f2:	4798      	blx	r3
        break;
    10f4:	e7e9      	b.n	10ca <OC::Ui::DispatchEvents(OC::App*)+0xfa>
        app->HandleEncoderEvent(event);
    10f6:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    10f8:	e7fa      	b.n	10f0 <OC::Ui::DispatchEvents(OC::App*)+0x120>
    10fa:	bf00      	nop
    10fc:	1fff9324 	.word	0x1fff9324
    1100:	1fffa7c8 	.word	0x1fffa7c8
    1104:	20006600 	.word	0x20006600
    1108:	200046cc 	.word	0x200046cc
    110c:	20004294 	.word	0x20004294

00001110 <OC::Ui::Splashscreen(bool&)>:

UiMode Ui::Splashscreen(bool &reset_settings) {
    1110:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1114:	4f2c      	ldr	r7, [pc, #176]	; (11c8 <OC::Ui::Splashscreen(bool&)+0xb8>)
    return write_ptr_ - read_ptr_;
    1116:	4d2d      	ldr	r5, [pc, #180]	; (11cc <OC::Ui::Splashscreen(bool&)+0xbc>)
    1118:	683b      	ldr	r3, [r7, #0]
    111a:	9300      	str	r3, [sp, #0]
	return ret;
    111c:	f8dd 8000 	ldr.w	r8, [sp]

    now = millis();

    // This graphics frame is necessary for the keys to be read. I don't know why this is the case,
    // since the keys are read above, but I don't have time to figure that out right now. --jj
    GRAPHICS_BEGIN_FRAME(true);
    1120:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 11d0 <OC::Ui::Splashscreen(bool&)+0xc0>
UiMode Ui::Splashscreen(bool &reset_settings) {
    1124:	4604      	mov	r4, r0
    1126:	460e      	mov	r6, r1
    return button_state_ & control;
    1128:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
      mode = UI_MODE_CALIBRATE;
    112c:	f013 0f04 	tst.w	r3, #4
    1130:	bf14      	ite	ne
    1132:	f04f 0903 	movne.w	r9, #3
    1136:	f04f 0901 	moveq.w	r9, #1
      mode = UI_MODE_APP_SETTINGS;
    113a:	f013 0f08 	tst.w	r3, #8
       read_immediate(CONTROL_BUTTON_UP) && read_immediate(CONTROL_BUTTON_DOWN);
    113e:	f003 0303 	and.w	r3, r3, #3
    1142:	f1a3 0203 	sub.w	r2, r3, #3
      mode = UI_MODE_APP_SETTINGS;
    1146:	bf18      	it	ne
    1148:	f04f 0902 	movne.w	r9, #2
       read_immediate(CONTROL_BUTTON_UP) && read_immediate(CONTROL_BUTTON_DOWN);
    114c:	4253      	negs	r3, r2
    114e:	4153      	adcs	r3, r2
    1150:	7033      	strb	r3, [r6, #0]
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1152:	683b      	ldr	r3, [r7, #0]
    1154:	9301      	str	r3, [sp, #4]
	return ret;
    1156:	f8dd b004 	ldr.w	fp, [sp, #4]
    115a:	f8d5 2808 	ldr.w	r2, [r5, #2056]	; 0x808
    115e:	f8d5 380c 	ldr.w	r3, [r5, #2060]	; 0x80c
    GRAPHICS_BEGIN_FRAME(true);
    1162:	1a9b      	subs	r3, r3, r2
    1164:	3302      	adds	r3, #2
    1166:	d0f8      	beq.n	115a <OC::Ui::Splashscreen(bool&)+0x4a>
    return frame_buffers_[write_ptr_ % frames];
    1168:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
    116c:	f003 0301 	and.w	r3, r3, #1
    1170:	f503 7300 	add.w	r3, r3, #512	; 0x200
    1174:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
    1178:	2900      	cmp	r1, #0
    117a:	d0ee      	beq.n	115a <OC::Ui::Splashscreen(bool&)+0x4a>
    117c:	2201      	movs	r2, #1
    117e:	4650      	mov	r0, sl
    1180:	f018 f877 	bl	19272 <weegfx::Graphics::Begin(unsigned char*, bool)>
    return write_ptr_ - read_ptr_;
    1184:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
    1188:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0

    /* fixes spurious button presses when booting ? */
    while (event_queue_.available())
    118c:	429a      	cmp	r2, r3
    118e:	d114      	bne.n	11ba <OC::Ui::Splashscreen(bool&)+0xaa>
      (void)event_queue_.PullEvent();

    GRAPHICS_END_FRAME();
    1190:	4650      	mov	r0, sl
    1192:	f018 f87c 	bl	1928e <weegfx::Graphics::End()>
    ++write_ptr_;
    1196:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808

  } while (now - start < SPLASHSCREEN_DELAY_MS);
    119a:	ebab 0b08 	sub.w	fp, fp, r8
    119e:	3301      	adds	r3, #1
    11a0:	f1bb 0f63 	cmp.w	fp, #99	; 0x63
    11a4:	f8c5 3808 	str.w	r3, [r5, #2056]	; 0x808
    11a8:	d9be      	bls.n	1128 <OC::Ui::Splashscreen(bool&)+0x18>
    button_ignore_mask_ = button_state_;
    11aa:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
    11ae:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46

  SetButtonIgnoreMask();
  return mode;
}
    11b2:	4648      	mov	r0, r9
    11b4:	b003      	add	sp, #12
    11b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    size_t read_ptr = read_ptr_;
    11ba:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    read_ptr_ = read_ptr + 1;
    11be:	3301      	adds	r3, #1
    11c0:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
    11c4:	e7de      	b.n	1184 <OC::Ui::Splashscreen(bool&)+0x74>
    11c6:	bf00      	nop
    11c8:	20006600 	.word	0x20006600
    11cc:	20005dc8 	.word	0x20005dc8
    11d0:	200065e0 	.word	0x200065e0

000011d4 <UI::EventQueue<16u>::Poke()>:
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    11d4:	4b04      	ldr	r3, [pc, #16]	; (11e8 <UI::EventQueue<16u>::Poke()+0x14>)
  inline void Poke() {
    11d6:	b082      	sub	sp, #8
    11d8:	681b      	ldr	r3, [r3, #0]
    11da:	9301      	str	r3, [sp, #4]
	return ret;
    11dc:	9b01      	ldr	r3, [sp, #4]
    last_event_time_ = millis();
    11de:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  }
    11e2:	b002      	add	sp, #8
    11e4:	4770      	bx	lr
    11e6:	bf00      	nop
    11e8:	20006600 	.word	0x20006600

000011ec <OC::Ui::set_screensaver_timeout(unsigned long)>:
void Ui::set_screensaver_timeout(uint32_t seconds) {
    11ec:	b508      	push	{r3, lr}
  uint32_t timeout = seconds * 1000U;
    11ee:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    11f2:	4359      	muls	r1, r3
  screensaver_timeout_ = timeout;
    11f4:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
    11f8:	bf38      	it	cc
    11fa:	f44f 61fa 	movcc.w	r1, #2000	; 0x7d0
    11fe:	6041      	str	r1, [r0, #4]
  event_queue_.Poke();
    1200:	306c      	adds	r0, #108	; 0x6c
    1202:	f7ff ffe7 	bl	11d4 <UI::EventQueue<16u>::Poke()>
}
    1206:	bd08      	pop	{r3, pc}

00001208 <OC::Ui::PushEvent(UI::EventType, unsigned short, short, unsigned short)>:
  inline void PushEvent(UI::EventType t, uint16_t c, int16_t v, uint16_t m) {
    1208:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    return write_ptr_ - read_ptr_;
    120a:	f8d0 50ec 	ldr.w	r5, [r0, #236]	; 0xec
    120e:	4604      	mov	r4, r0
    1210:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
    if (!event_queue_.writable())
    1214:	1b40      	subs	r0, r0, r5
    1216:	3010      	adds	r0, #16
      ++DEBUG::UI_queue_overflow;
    1218:	bf01      	itttt	eq
    121a:	4d0f      	ldreq	r5, [pc, #60]	; (1258 <OC::Ui::PushEvent(UI::EventType, unsigned short, short, unsigned short)+0x50>)
    121c:	6828      	ldreq	r0, [r5, #0]
    121e:	3001      	addeq	r0, #1
    1220:	6028      	streq	r0, [r5, #0]
    ++DEBUG::UI_event_count;
    1222:	4d0e      	ldr	r5, [pc, #56]	; (125c <OC::Ui::PushEvent(UI::EventType, unsigned short, short, unsigned short)+0x54>)
    1224:	6828      	ldr	r0, [r5, #0]
    1226:	3001      	adds	r0, #1
    1228:	6028      	str	r0, [r5, #0]
    size_t write_ptr = write_ptr_;
    122a:	f8d4 50ec 	ldr.w	r5, [r4, #236]	; 0xec
    event_queue_.PushEvent(t, c, v, m);
    122e:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    buffer_[write_ptr & (size - 1)] = value;
    1232:	f005 070f 	and.w	r7, r5, #15
    1236:	eb00 06c7 	add.w	r6, r0, r7, lsl #3
    123a:	f800 1037 	strb.w	r1, [r0, r7, lsl #3]
    poke_ptr_ = write_ptr_ = write_ptr + 1;
    123e:	3501      	adds	r5, #1
    buffer_[write_ptr & (size - 1)] = value;
    1240:	80b3      	strh	r3, [r6, #4]
    1242:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    1246:	8072      	strh	r2, [r6, #2]
    1248:	80f3      	strh	r3, [r6, #6]
    poke_ptr_ = write_ptr_ = write_ptr + 1;
    124a:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
    124e:	f8c4 50f4 	str.w	r5, [r4, #244]	; 0xf4
    Poke();
    1252:	f7ff ffbf 	bl	11d4 <UI::EventQueue<16u>::Poke()>
  }
    1256:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1258:	1fffa5a4 	.word	0x1fffa5a4
    125c:	1fffa594 	.word	0x1fffa594

00001260 <OC::Ui::Init()>:
  ticks_ = 0;
    1260:	2300      	movs	r3, #0
void Ui::Init() {
    1262:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  ticks_ = 0;
    1266:	6003      	str	r3, [r0, #0]
  screensaver_timeout_ = timeout;
    1268:	f246 13a8 	movw	r3, #25000	; 0x61a8
void Ui::Init() {
    126c:	4604      	mov	r4, r0
  screensaver_timeout_ = timeout;
    126e:	6043      	str	r3, [r0, #4]
  event_queue_.Poke();
    1270:	306c      	adds	r0, #108	; 0x6c
    1272:	f7ff ffaf 	bl	11d4 <UI::EventQueue<16u>::Poke()>
  for (size_t i = 0; i < CONTROL_BUTTON_LAST; ++i) {
    1276:	4e22      	ldr	r6, [pc, #136]	; (1300 <OC::Ui::Init()+0xa0>)
    1278:	4625      	mov	r5, r4
    127a:	f104 0728 	add.w	r7, r4, #40	; 0x28
    state_ = 0xff;
    127e:	f04f 08ff 	mov.w	r8, #255	; 0xff
    buttons_[i].Init(button_pins[i], OC_GPIO_BUTTON_PINMODE);
    1282:	f856 0b04 	ldr.w	r0, [r6], #4
    pin_ = pin;
    1286:	b2c0      	uxtb	r0, r0
    1288:	60a8      	str	r0, [r5, #8]
    pinMode(pin, pin_mode);
    128a:	2102      	movs	r1, #2
    128c:	f019 f86c 	bl	1a368 <pinMode>
  for (size_t i = 0; i < CONTROL_BUTTON_LAST; ++i) {
    1290:	3508      	adds	r5, #8
    state_ = 0xff;
    1292:	f885 8004 	strb.w	r8, [r5, #4]
    1296:	42af      	cmp	r7, r5
    1298:	d1f3      	bne.n	1282 <OC::Ui::Init()+0x22>
  button_state_ = 0;
    129a:	2500      	movs	r5, #0
    129c:	2210      	movs	r2, #16
    129e:	2100      	movs	r1, #0
    12a0:	f104 0030 	add.w	r0, r4, #48	; 0x30
    12a4:	f018 ff78 	bl	1a198 <memset>
    pinMode(PINA, pin_mode);
    12a8:	2102      	movs	r1, #2
    12aa:	2016      	movs	r0, #22
    12ac:	6465      	str	r5, [r4, #68]	; 0x44
  screensaver_ = false;
    12ae:	f8a4 5048 	strh.w	r5, [r4, #72]	; 0x48
    12b2:	f019 f859 	bl	1a368 <pinMode>
    pin_state_[0] = pin_state_[1] = 0xff;
    12b6:	f64f 76ff 	movw	r6, #65535	; 0xffff
    pinMode(PINB, pin_mode);
    12ba:	2102      	movs	r1, #2
    12bc:	2015      	movs	r0, #21
    12be:	f019 f853 	bl	1a368 <pinMode>
    pinMode(PINA, pin_mode);
    12c2:	2102      	movs	r1, #2
    12c4:	2010      	movs	r0, #16
    acceleration_enabled_ = acceleration_enabled;
    12c6:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
    last_dir_ = 0;
    12ca:	6525      	str	r5, [r4, #80]	; 0x50
    acceleration_ = 0;
    12cc:	6565      	str	r5, [r4, #84]	; 0x54
    pin_state_[0] = pin_state_[1] = 0xff;
    12ce:	f8a4 6058 	strh.w	r6, [r4, #88]	; 0x58
    pinMode(PINA, pin_mode);
    12d2:	f019 f849 	bl	1a368 <pinMode>
    pinMode(PINB, pin_mode);
    12d6:	2102      	movs	r1, #2
    12d8:	200f      	movs	r0, #15
    12da:	f019 f845 	bl	1a368 <pinMode>
    write_ptr_ = read_ptr_ = poke_ptr_ = 0;
    12de:	f8c4 50f4 	str.w	r5, [r4, #244]	; 0xf4
    acceleration_enabled_ = acceleration_enabled;
    12e2:	f8a4 505c 	strh.w	r5, [r4, #92]	; 0x5c
    12e6:	f8c4 50f0 	str.w	r5, [r4, #240]	; 0xf0
    last_dir_ = 0;
    12ea:	6625      	str	r5, [r4, #96]	; 0x60
    acceleration_ = 0;
    12ec:	6665      	str	r5, [r4, #100]	; 0x64
    pin_state_[0] = pin_state_[1] = 0xff;
    12ee:	f8a4 6068 	strh.w	r6, [r4, #104]	; 0x68
    12f2:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
    last_event_time_ = 0;
    12f6:	f8c4 50f8 	str.w	r5, [r4, #248]	; 0xf8
}
    12fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    12fe:	bf00      	nop
    1300:	0001f3ac 	.word	0x0001f3ac

00001304 <_GLOBAL__sub_I__ZN12VBiasManager8instanceE>:

} // namespace OC
    1304:	b508      	push	{r3, lr}
    1306:	f018 fe05 	bl	19f14 <eeprom_initialize>
    130a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
Ui ui;
    130e:	4a02      	ldr	r2, [pc, #8]	; (1318 <_GLOBAL__sub_I__ZN12VBiasManager8instanceE+0x14>)
    1310:	4902      	ldr	r1, [pc, #8]	; (131c <_GLOBAL__sub_I__ZN12VBiasManager8instanceE+0x18>)
    1312:	4803      	ldr	r0, [pc, #12]	; (1320 <_GLOBAL__sub_I__ZN12VBiasManager8instanceE+0x1c>)
    1314:	f01b b9d2 	b.w	1c6bc <__aeabi_atexit>
    1318:	1fff9320 	.word	0x1fff9320
    131c:	00000f95 	.word	0x00000f95
    1320:	1fffa7cc 	.word	0x1fffa7cc

00001324 <EuclideanPattern(unsigned char, unsigned char, unsigned char)>:
  uint8_t position = clock % (num_steps + 1) ;
  return static_cast<bool>(pattern & (0x01 << position)) ;
}

uint32_t EuclideanPattern(uint8_t num_steps, uint8_t num_beats, uint8_t rotation) {
  if (num_beats > (num_steps + 1)) {
    1324:	1c43      	adds	r3, r0, #1
uint32_t EuclideanPattern(uint8_t num_steps, uint8_t num_beats, uint8_t rotation) {
    1326:	b530      	push	{r4, r5, lr}
  if (num_beats > (num_steps + 1)) {
    1328:	4299      	cmp	r1, r3
    num_beats = num_steps + 1;
  }
  uint32_t pattern = bjorklund_patterns[((num_steps - 1) * 33) + num_beats]; 
    132a:	f100 34ff 	add.w	r4, r0, #4294967295	; 0xffffffff
    num_beats = num_steps + 1;
    132e:	bfc8      	it	gt
    1330:	b2d9      	uxtbgt	r1, r3
  uint32_t pattern = bjorklund_patterns[((num_steps - 1) * 33) + num_beats]; 
    1332:	eb04 1444 	add.w	r4, r4, r4, lsl #5
uint32_t EuclideanPattern(uint8_t num_steps, uint8_t num_beats, uint8_t rotation) {
    1336:	4605      	mov	r5, r0
  uint32_t pattern = bjorklund_patterns[((num_steps - 1) * 33) + num_beats]; 
    1338:	4421      	add	r1, r4
    133a:	4809      	ldr	r0, [pc, #36]	; (1360 <EuclideanPattern(unsigned char, unsigned char, unsigned char)+0x3c>)
    133c:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
  if (rotation) {
    1340:	b16a      	cbz	r2, 135e <EuclideanPattern(unsigned char, unsigned char, unsigned char)+0x3a>
    rotation = rotation % (num_steps + 1);
    1342:	fbb2 f1f3 	udiv	r1, r2, r3
    1346:	fb03 2211 	mls	r2, r3, r1, r2
//  return (n<<c) | (n>>( (-c)&mask ));
//}

inline uint32_t rotl32(uint32_t input, unsigned int length, unsigned int count) __attribute__((always_inline));
inline uint32_t rotl32(uint32_t input, unsigned int length, unsigned int count) {
  input &= ~(0xffffffff << length);
    134a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    134e:	40a9      	lsls	r1, r5
    1350:	ea20 0001 	bic.w	r0, r0, r1
  return (input << count) | (input >> (length - count + 1)); // off-by-ones or parenthesis mismatch likely
    1354:	1a9b      	subs	r3, r3, r2
    1356:	fa20 f303 	lsr.w	r3, r0, r3
    135a:	4090      	lsls	r0, r2
    135c:	4318      	orrs	r0, r3
    pattern = rotl32(pattern, num_steps, rotation) ;
  }
  return pattern;
}
    135e:	bd30      	pop	{r4, r5, pc}
    1360:	0001f3c0 	.word	0x0001f3c0

00001364 <braids::Quantizer::Init()>:
  std::sort(scale.notes, scale.notes + scale.num_notes);
}


void Quantizer::Init() {
  enabled_ = true;
    1364:	2301      	movs	r3, #1
    1366:	7003      	strb	r3, [r0, #0]
  codeword_ = 0;
    1368:	2300      	movs	r3, #0
    136a:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
  transpose_ = 0;
    136e:	f8c0 3128 	str.w	r3, [r0, #296]	; 0x128
  previous_boundary_ = 0;
    1372:	f8c0 312c 	str.w	r3, [r0, #300]	; 0x12c
  next_boundary_ = 0;
    1376:	f8c0 3130 	str.w	r3, [r0, #304]	; 0x130
  for (int16_t i = 0; i < 128; ++i) {
    137a:	3020      	adds	r0, #32
  next_boundary_ = 0;
    137c:	f44f 4360 	mov.w	r3, #57344	; 0xe000
    codebook_[i] = (i - 64) << 7;
    1380:	f820 3f02 	strh.w	r3, [r0, #2]!
  for (int16_t i = 0; i < 128; ++i) {
    1384:	3380      	adds	r3, #128	; 0x80
    1386:	b29b      	uxth	r3, r3
    1388:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    138c:	d1f8      	bne.n	1380 <braids::Quantizer::Init()+0x1c>
  }
}
    138e:	4770      	bx	lr

00001390 <braids::Quantizer::Process(long, long, long)>:

int32_t Quantizer::Process(int32_t pitch, int32_t root, int32_t transpose) {
    1390:	b5f0      	push	{r4, r5, r6, r7, lr}
    1392:	4604      	mov	r4, r0
    1394:	4608      	mov	r0, r1
  if (!enabled_) {
    1396:	7821      	ldrb	r1, [r4, #0]
    1398:	b1b1      	cbz	r1, 13c8 <braids::Quantizer::Process(long, long, long)+0x38>
    return pitch;
  }

  pitch -= root;
    139a:	1a81      	subs	r1, r0, r2
  #ifdef BUCHLA_4U
    pitch -= ((12 << 7) << 2);
  #else
    pitch -= ((12 << 7) << 1);
  #endif
  if (!requantize_ && (pitch >= previous_boundary_ && pitch <= next_boundary_ && transpose == transpose_)) {
    139c:	f894 0136 	ldrb.w	r0, [r4, #310]	; 0x136
    pitch -= ((12 << 7) << 1);
    13a0:	f5a1 6140 	sub.w	r1, r1, #3072	; 0xc00
  if (!requantize_ && (pitch >= previous_boundary_ && pitch <= next_boundary_ && transpose == transpose_)) {
    13a4:	b988      	cbnz	r0, 13ca <braids::Quantizer::Process(long, long, long)+0x3a>
    13a6:	f8d4 012c 	ldr.w	r0, [r4, #300]	; 0x12c
    13aa:	4288      	cmp	r0, r1
    13ac:	dc0d      	bgt.n	13ca <braids::Quantizer::Process(long, long, long)+0x3a>
    13ae:	f8d4 0130 	ldr.w	r0, [r4, #304]	; 0x130
    13b2:	4288      	cmp	r0, r1
    13b4:	db09      	blt.n	13ca <braids::Quantizer::Process(long, long, long)+0x3a>
    13b6:	f8d4 0128 	ldr.w	r0, [r4, #296]	; 0x128
    13ba:	4298      	cmp	r0, r3
    13bc:	d105      	bne.n	13ca <braids::Quantizer::Process(long, long, long)+0x3a>
    // We're still in the voronoi cell for the active codeword.
    pitch = codeword_;
    13be:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
    note_number_ = q;
    codeword_ = codebook_[q];
    transpose_ = transpose;
    pitch = codeword_;
  }
  pitch += root;
    13c2:	4410      	add	r0, r2
  #ifdef BUCHLA_4U
    pitch += ((12 << 7) << 2);
  #else
    pitch += ((12 << 7) << 1);
    13c4:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
  #endif
  return pitch;
}
    13c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        static_cast<int16_t>(pitch)) - &codebook_[0];
    13ca:	fa0f fc81 	sxth.w	ip, r1
    int16_t upper_bound_index = std::upper_bound(
    13ce:	f104 0528 	add.w	r5, r4, #40	; 0x28
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
    13d2:	207b      	movs	r0, #123	; 0x7b
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
    13d4:	2800      	cmp	r0, #0
    13d6:	dc35      	bgt.n	1444 <braids::Quantizer::Process(long, long, long)+0xb4>
        static_cast<int16_t>(pitch)) - &codebook_[0];
    13d8:	f104 0022 	add.w	r0, r4, #34	; 0x22
    13dc:	1a28      	subs	r0, r5, r0
    13de:	1045      	asrs	r5, r0, #1
    int16_t lower_bound_index = upper_bound_index - 2;
    13e0:	3d02      	subs	r5, #2
        static_cast<int16_t>(pitch)) - &codebook_[0];
    13e2:	f340 074f 	sbfx	r7, r0, #1, #16
    int16_t lower_bound_index = upper_bound_index - 2;
    13e6:	b22d      	sxth	r5, r5
    int16_t q = -1;
    13e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    int16_t best_distance = 16384;
    13ec:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
    for (int16_t i = lower_bound_index; i <= upper_bound_index; ++i) {
    13f0:	42bd      	cmp	r5, r7
    13f2:	dd35      	ble.n	1460 <braids::Quantizer::Process(long, long, long)+0xd0>
    previous_boundary_ = (9 * codebook_[q - 1] + 7 * codebook_[q]) >> 4;
    13f4:	eb04 0640 	add.w	r6, r4, r0, lsl #1
    13f8:	2709      	movs	r7, #9
    13fa:	f9b6 5022 	ldrsh.w	r5, [r6, #34]	; 0x22
    13fe:	8c31      	ldrh	r1, [r6, #32]
    1400:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
    1404:	fb11 5107 	smlabb	r1, r1, r7, r5
    1408:	1109      	asrs	r1, r1, #4
    140a:	f8c4 112c 	str.w	r1, [r4, #300]	; 0x12c
    next_boundary_ = (9 * codebook_[q + 1] + 7 * codebook_[q]) >> 4;
    140e:	f9b6 1024 	ldrsh.w	r1, [r6, #36]	; 0x24
    1412:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
    1416:	4429      	add	r1, r5
    1418:	1109      	asrs	r1, r1, #4
    141a:	f8c4 1130 	str.w	r1, [r4, #304]	; 0x130
    q += transpose;
    141e:	1819      	adds	r1, r3, r0
    if (q < 1) q = 1;
    1420:	b209      	sxth	r1, r1
    1422:	297e      	cmp	r1, #126	; 0x7e
    1424:	bfa8      	it	ge
    1426:	217e      	movge	r1, #126	; 0x7e
    1428:	2901      	cmp	r1, #1
    142a:	bfb8      	it	lt
    142c:	2101      	movlt	r1, #1
    note_number_ = q;
    142e:	f8a4 1134 	strh.w	r1, [r4, #308]	; 0x134
    codeword_ = codebook_[q];
    1432:	eb04 0141 	add.w	r1, r4, r1, lsl #1
    1436:	f9b1 0022 	ldrsh.w	r0, [r1, #34]	; 0x22
    143a:	f8c4 0124 	str.w	r0, [r4, #292]	; 0x124
    transpose_ = transpose;
    143e:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
    pitch = codeword_;
    1442:	e7be      	b.n	13c2 <braids::Quantizer::Process(long, long, long)+0x32>
	{
	  _DistanceType __half = __len >> 1;
    1444:	1046      	asrs	r6, r0, #1
      if (__builtin_constant_p(__n) && __n == 1)
	++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
	--__i;
      else
	__i += __n;
    1446:	f020 0701 	bic.w	r7, r0, #1
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__val, __middle))
    144a:	f935 e016 	ldrsh.w	lr, [r5, r6, lsl #1]
    144e:	45e6      	cmp	lr, ip
    1450:	442f      	add	r7, r5
	    __len = __half;
	  else
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
    1452:	bfdd      	ittte	le
    1454:	1b80      	suble	r0, r0, r6
	      ++__first;
    1456:	1cbd      	addle	r5, r7, #2
	      __len = __len - __half - 1;
    1458:	f100 30ff 	addle.w	r0, r0, #4294967295	; 0xffffffff
	  _DistanceType __half = __len >> 1;
    145c:	4630      	movgt	r0, r6
    145e:	e7b9      	b.n	13d4 <braids::Quantizer::Process(long, long, long)+0x44>
      int16_t distance = abs(pitch - codebook_[i]);
    1460:	eb04 0645 	add.w	r6, r4, r5, lsl #1
    1464:	f9b6 6022 	ldrsh.w	r6, [r6, #34]	; 0x22
    1468:	1b8e      	subs	r6, r1, r6
    146a:	2e00      	cmp	r6, #0
    146c:	bfb8      	it	lt
    146e:	4276      	neglt	r6, r6
    1470:	b236      	sxth	r6, r6
      if (distance < best_distance) {
    1472:	45b4      	cmp	ip, r6
    1474:	bfc8      	it	gt
    1476:	4628      	movgt	r0, r5
    1478:	f105 0501 	add.w	r5, r5, #1
    147c:	bfc8      	it	gt
    147e:	46b4      	movgt	ip, r6
    for (int16_t i = lower_bound_index; i <= upper_bound_index; ++i) {
    1480:	b22d      	sxth	r5, r5
    1482:	e7b5      	b.n	13f0 <braids::Quantizer::Process(long, long, long)+0x60>

00001484 <braids::Quantizer::Lookup(long) const>:

int32_t Quantizer::Lookup(int32_t index) const {
  if (index < 0)
    1484:	2900      	cmp	r1, #0
    1486:	da02      	bge.n	148e <braids::Quantizer::Lookup(long) const+0xa>
    return codebook_[0];
  else if (index > 127)
    return codebook_[127];
  else
    return codebook_[index];
    1488:	f9b0 0022 	ldrsh.w	r0, [r0, #34]	; 0x22
}
    148c:	4770      	bx	lr
  else if (index > 127)
    148e:	297f      	cmp	r1, #127	; 0x7f
    1490:	dd02      	ble.n	1498 <braids::Quantizer::Lookup(long) const+0x14>
    return codebook_[127];
    1492:	f9b0 0120 	ldrsh.w	r0, [r0, #288]	; 0x120
    1496:	4770      	bx	lr
    return codebook_[index];
    1498:	eb00 0041 	add.w	r0, r0, r1, lsl #1
    149c:	e7f4      	b.n	1488 <braids::Quantizer::Lookup(long) const+0x4>

0000149e <braids::Quantizer::Requantize()>:

void Quantizer::Requantize() {
    requantize_ = 1;
    149e:	2301      	movs	r3, #1
    14a0:	f880 3136 	strb.w	r3, [r0, #310]	; 0x136
}
    14a4:	4770      	bx	lr

000014a6 <Backup_init()>:
    
};

Backup Backup_instance;

void Backup_init() {}
    14a6:	4770      	bx	lr

000014a8 <Backup_storageSize()>:
void Backup_menu() {Backup_instance.View();}
void Backup_isr() {Backup_instance.Controller();}

// Storage not used for this app
size_t Backup_storageSize() {return 0;}
    14a8:	2000      	movs	r0, #0
    14aa:	4770      	bx	lr

000014ac <Backup_save(void*)>:
size_t Backup_save(void *storage) {return 0;}
    14ac:	2000      	movs	r0, #0
    14ae:	4770      	bx	lr

000014b0 <Backup_handleAppEvent(OC::AppEvent)>:
size_t Backup_restore(const void *storage) {return 0;}

void Backup_handleAppEvent(OC::AppEvent event) {
    if (event == OC::APP_EVENT_RESUME) Backup_instance.Resume();
    14b0:	2801      	cmp	r0, #1
        receiving = 0;
    14b2:	bf02      	ittt	eq
    14b4:	4b01      	ldreq	r3, [pc, #4]	; (14bc <Backup_handleAppEvent(OC::AppEvent)+0xc>)
    14b6:	2200      	moveq	r2, #0
    14b8:	80da      	strheq	r2, [r3, #6]
}
    14ba:	4770      	bx	lr
    14bc:	1fffb1c0 	.word	0x1fffb1c0

000014c0 <EnigmaTMWS_storageSize()>:
    EnigmaTMWS_instance.BaseStart();
}

size_t EnigmaTMWS_storageSize() {
    return EnigmaTMWS::storageSize();
}
    14c0:	4b01      	ldr	r3, [pc, #4]	; (14c8 <EnigmaTMWS_storageSize()+0x8>)
    14c2:	6818      	ldr	r0, [r3, #0]
    14c4:	4770      	bx	lr
    14c6:	bf00      	nop
    14c8:	200046d4 	.word	0x200046d4

000014cc <HEMISPHERE_storageSize()>:
    manager.Init();
}

size_t HEMISPHERE_storageSize() {
    return HemisphereManager::storageSize();
}
    14cc:	4b01      	ldr	r3, [pc, #4]	; (14d4 <HEMISPHERE_storageSize()+0x8>)
    14ce:	6818      	ldr	r0, [r3, #0]
    14d0:	4770      	bx	lr
    14d2:	bf00      	nop
    14d4:	200046e0 	.word	0x200046e0

000014d8 <MIDI_storageSize()>:
    captain_midi_instance.Start();
}

size_t MIDI_storageSize() {
    return CaptainMIDI::storageSize();
}
    14d8:	4b01      	ldr	r3, [pc, #4]	; (14e0 <MIDI_storageSize()+0x8>)
    14da:	6818      	ldr	r0, [r3, #0]
    14dc:	4770      	bx	lr
    14de:	bf00      	nop
    14e0:	200046d8 	.word	0x200046d8

000014e4 <NeuralNetwork::Start()>:

class NeuralNetwork : public HSApplication, public SystemExclusiveHandler,
    public settings::SettingsBase<NeuralNetwork, NN_SETTING_LAST> {
public:
    void Start() {
        for (int ch = 0; ch < 16; ch++) output_neuron[ch] = ch % 4;
    14e4:	f500 60eb 	add.w	r0, r0, #1880	; 0x758
    14e8:	2300      	movs	r3, #0
    14ea:	f003 0203 	and.w	r2, r3, #3
    14ee:	3301      	adds	r3, #1
    14f0:	2b10      	cmp	r3, #16
    14f2:	f840 2f04 	str.w	r2, [r0, #4]!
    14f6:	d1f8      	bne.n	14ea <NeuralNetwork::Start()+0x6>
    }
    14f8:	4770      	bx	lr
    14fa:	Address 0x00000000000014fa is out of bounds.


000014fc <NeuralNetwork_storageSize()>:
// App stubs
void NeuralNetwork_init() {
    NeuralNetwork_instance.BaseStart();
}

size_t NeuralNetwork_storageSize() {return NeuralNetwork::storageSize();}
    14fc:	4b01      	ldr	r3, [pc, #4]	; (1504 <NeuralNetwork_storageSize()+0x8>)
    14fe:	6818      	ldr	r0, [r3, #0]
    1500:	4770      	bx	lr
    1502:	bf00      	nop
    1504:	200046dc 	.word	0x200046dc

00001508 <PONGGAME_isr()>:

	/* I'm using the ISR for keeping track of object timing. The interrupt is timer-based, so each
	 * timer cycle is about 60 microseconds.
	 */
	void ISR() {
		ball_countdown--;
    1508:	4b06      	ldr	r3, [pc, #24]	; (1524 <PONGGAME_isr()+0x1c>)
    150a:	685a      	ldr	r2, [r3, #4]
    150c:	3a01      	subs	r2, #1
    150e:	605a      	str	r2, [r3, #4]
		paddle_countdown--;
    1510:	689a      	ldr	r2, [r3, #8]
    1512:	3a01      	subs	r2, #1
    1514:	609a      	str	r2, [r3, #8]
		return_countdown--;
    1516:	68da      	ldr	r2, [r3, #12]
    1518:	3a01      	subs	r2, #1
    151a:	60da      	str	r2, [r3, #12]
		bounce_countdown--;
    151c:	691a      	ldr	r2, [r3, #16]
    151e:	3a01      	subs	r2, #1
    1520:	611a      	str	r2, [r3, #16]
	return 0;
}

void PONGGAME_isr() {
	pong_instance.ISR();
}
    1522:	4770      	bx	lr
    1524:	20005a20 	.word	0x20005a20

00001528 <PONGGAME_handleAppEvent(OC::AppEvent)>:

void PONGGAME_handleAppEvent(OC::AppEvent event) {

}
    1528:	4770      	bx	lr

0000152a <ScaleEditor::Resume()>:
        tinynumbers.Init(SegmentSize::TINY_SEGMENTS);
	}

	void Resume() {

	}
    152a:	4770      	bx	lr

0000152c <Settings::Start()>:
*/

class Settings : public HSApplication {
public:
	void Start() {
	}
    152c:	4770      	bx	lr

0000152e <Settings::Resume()>:
	
	void Resume() {
	}
    152e:	4770      	bx	lr

00001530 <Settings::Controller()>:

    void Controller() {
    }
    1530:	4770      	bx	lr

00001532 <Settings_handleEncoderEvent(UI::Event const&)>:
    // Left encoder turned
    if (event.control == OC::CONTROL_ENCODER_L) Settings_instance.OnLeftEncoderMove(event.value);

    // Right encoder turned
    if (event.control == OC::CONTROL_ENCODER_R) Settings_instance.OnRightEncoderMove(event.value);
}
    1532:	4770      	bx	lr

00001534 <TheDarkestTimeline_storageSize()>:
    TheDarkestTimeline_instance.BaseStart();
}

size_t TheDarkestTimeline_storageSize() {
    return TheDarkestTimeline::storageSize();
}
    1534:	4b01      	ldr	r3, [pc, #4]	; (153c <TheDarkestTimeline_storageSize()+0x8>)
    1536:	6818      	ldr	r0, [r3, #0]
    1538:	4770      	bx	lr
    153a:	bf00      	nop
    153c:	200046e4 	.word	0x200046e4

00001540 <ADEG::applet_name()>:
class ADEG : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "AD EG";
    }
    1540:	4800      	ldr	r0, [pc, #0]	; (1544 <ADEG::applet_name()+0x4>)
    1542:	4770      	bx	lr
    1544:	000203bc 	.word	0x000203bc

00001548 <ADEG::Start()>:

    void Start() {
        signal = 0;
    1548:	2300      	movs	r3, #0
    154a:	66c3      	str	r3, [r0, #108]	; 0x6c
        phase = 0;
    154c:	6703      	str	r3, [r0, #112]	; 0x70
        attack = 50;
    154e:	2332      	movs	r3, #50	; 0x32
    1550:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
        decay = 50;
    1554:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    }
    1558:	4770      	bx	lr
    155a:	Address 0x000000000000155a is out of bounds.


0000155c <ADEG::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Trg 2=Trg Revers";
    155c:	4b04      	ldr	r3, [pc, #16]	; (1570 <ADEG::SetHelp()+0x14>)
    155e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=A mod 2=D mod";
    1560:	4b04      	ldr	r3, [pc, #16]	; (1574 <ADEG::SetHelp()+0x18>)
    1562:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Output B=EOC";
    1564:	4b04      	ldr	r3, [pc, #16]	; (1578 <ADEG::SetHelp()+0x1c>)
    1566:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Attack/Decay";
    1568:	4b04      	ldr	r3, [pc, #16]	; (157c <ADEG::SetHelp()+0x20>)
    156a:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    156c:	4770      	bx	lr
    156e:	bf00      	nop
    1570:	000203c2 	.word	0x000203c2
    1574:	000203d5 	.word	0x000203d5
    1578:	000203e5 	.word	0x000203e5
    157c:	000203f4 	.word	0x000203f4

00001580 <ADEG_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    1580:	4b04      	ldr	r3, [pc, #16]	; (1594 <ADEG_OnButtonPress(bool)+0x14>)
    1582:	2290      	movs	r2, #144	; 0x90
    1584:	fb02 3000 	mla	r0, r2, r0, r3
    1588:	6f43      	ldr	r3, [r0, #116]	; 0x74
    158a:	f1c3 0301 	rsb	r3, r3, #1
    158e:	6743      	str	r3, [r0, #116]	; 0x74
ADEG ADEG_instance[2];

void ADEG_Start(bool hemisphere) {ADEG_instance[hemisphere].BaseStart(hemisphere);}
void ADEG_Controller(bool hemisphere, bool forwarding) {ADEG_instance[hemisphere].BaseController(forwarding);}
void ADEG_View(bool hemisphere) {ADEG_instance[hemisphere].BaseView();}
void ADEG_OnButtonPress(bool hemisphere) {ADEG_instance[hemisphere].OnButtonPress();}
    1590:	4770      	bx	lr
    1592:	bf00      	nop
    1594:	1fffa8c8 	.word	0x1fffa8c8

00001598 <ADEG_OnEncoderMove(bool, int)>:
        if (cursor == 0) {
    1598:	4a14      	ldr	r2, [pc, #80]	; (15ec <ADEG_OnEncoderMove(bool, int)+0x54>)
    159a:	2390      	movs	r3, #144	; 0x90
    159c:	fb03 2300 	mla	r3, r3, r0, r2
void ADEG_OnEncoderMove(bool hemisphere, int direction) {ADEG_instance[hemisphere].OnEncoderMove(direction);}
    15a0:	b510      	push	{r4, lr}
        if (cursor == 0) {
    15a2:	6f5c      	ldr	r4, [r3, #116]	; 0x74
    15a4:	b9cc      	cbnz	r4, 15da <ADEG_OnEncoderMove(bool, int)+0x42>
            attack = constrain(attack += direction, 0, HEM_ADEG_MAX_VALUE);
    15a6:	f8d3 4088 	ldr.w	r4, [r3, #136]	; 0x88
    15aa:	4421      	add	r1, r4
    15ac:	f381 0108 	usat	r1, #8, r1
    15b0:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
     *
     * Out(ch, Proportion(value, 100, HEMISPHERE_MAX_CV));
     *
     */
    int Proportion(int numerator, int denominator, int max_value) {
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    15b4:	038b      	lsls	r3, r1, #14
    15b6:	21ff      	movs	r1, #255	; 0xff
    15b8:	fbb3 f3f1 	udiv	r3, r3, r1
        int scaled = simfloat2int(proportion * max_value);
    15bc:	f248 2135 	movw	r1, #33333	; 0x8235
    15c0:	434b      	muls	r3, r1
    15c2:	139b      	asrs	r3, r3, #14
            last_ms_value = Proportion(decay, HEM_ADEG_MAX_VALUE, HEM_ADEG_MAX_TICKS) / 17;
    15c4:	2111      	movs	r1, #17
    15c6:	fbb3 f3f1 	udiv	r3, r3, r1
            last_ms_value = Proportion(attack, HEM_ADEG_MAX_VALUE, HEM_ADEG_MAX_TICKS) / 17;
    15ca:	2190      	movs	r1, #144	; 0x90
    15cc:	fb01 2200 	mla	r2, r1, r0, r2
    15d0:	6793      	str	r3, [r2, #120]	; 0x78
        last_change_ticks = OC::CORE::ticks;
    15d2:	4b07      	ldr	r3, [pc, #28]	; (15f0 <ADEG_OnEncoderMove(bool, int)+0x58>)
    15d4:	681b      	ldr	r3, [r3, #0]
    15d6:	67d3      	str	r3, [r2, #124]	; 0x7c
void ADEG_OnEncoderMove(bool hemisphere, int direction) {ADEG_instance[hemisphere].OnEncoderMove(direction);}
    15d8:	bd10      	pop	{r4, pc}
            decay = constrain(decay += direction, 0, HEM_ADEG_MAX_VALUE);
    15da:	f8d3 408c 	ldr.w	r4, [r3, #140]	; 0x8c
    15de:	4421      	add	r1, r4
    15e0:	f381 0108 	usat	r1, #8, r1
    15e4:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
    15e8:	e7e4      	b.n	15b4 <ADEG_OnEncoderMove(bool, int)+0x1c>
    15ea:	bf00      	nop
    15ec:	1fffa8c8 	.word	0x1fffa8c8
    15f0:	200046cc 	.word	0x200046cc

000015f4 <ADEG_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    15f4:	4b04      	ldr	r3, [pc, #16]	; (1608 <ADEG_ToggleHelpScreen(bool)+0x14>)
    15f6:	2290      	movs	r2, #144	; 0x90
    15f8:	fb02 3000 	mla	r0, r2, r0, r3
    15fc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    15fe:	f1c3 0301 	rsb	r3, r3, #1
    1602:	65c3      	str	r3, [r0, #92]	; 0x5c
void ADEG_ToggleHelpScreen(bool hemisphere) {ADEG_instance[hemisphere].HelpScreen();}
    1604:	4770      	bx	lr
    1606:	bf00      	nop
    1608:	1fffa8c8 	.word	0x1fffa8c8

0000160c <ADEG_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, decay);
    160c:	4b05      	ldr	r3, [pc, #20]	; (1624 <ADEG_OnDataRequest(bool)+0x18>)
    160e:	2290      	movs	r2, #144	; 0x90
    1610:	fb02 3300 	mla	r3, r2, r0, r3
        return prop;
    }

    /* Add value to a 32-bit storage unit at the specified location */
    void Pack(uint32_t &data, PackLocation p, uint32_t value) {
        data |= (value << p.location);
    1614:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
    1618:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
uint32_t ADEG_OnDataRequest(bool hemisphere) {return ADEG_instance[hemisphere].OnDataRequest();}
    161c:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    1620:	4770      	bx	lr
    1622:	bf00      	nop
    1624:	1fffa8c8 	.word	0x1fffa8c8

00001628 <ADSREG::applet_name()>:
class ADSREG : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "ADSR EG";
    }
    1628:	4800      	ldr	r0, [pc, #0]	; (162c <ADSREG::applet_name()+0x4>)
    162a:	4770      	bx	lr
    162c:	00020401 	.word	0x00020401

00001630 <ADSREG::Start()>:

    void Start() {
        edit_stage = 0;
        attack = 20;
    1630:	2214      	movs	r2, #20
    1632:	6702      	str	r2, [r0, #112]	; 0x70
        decay = 30;
    1634:	221e      	movs	r2, #30
    1636:	6742      	str	r2, [r0, #116]	; 0x74
        sustain = 120;
    1638:	2278      	movs	r2, #120	; 0x78
    163a:	6782      	str	r2, [r0, #120]	; 0x78
        release = 25;
    163c:	2219      	movs	r2, #25
        edit_stage = 0;
    163e:	2300      	movs	r3, #0
        release = 25;
    1640:	67c2      	str	r2, [r0, #124]	; 0x7c
        ForEachChannel(ch)
        {
            stage_ticks[ch] = 0;
            gated[ch] = 0;
            stage[ch] = HEM_EG_NO_STAGE;
    1642:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        edit_stage = 0;
    1646:	66c3      	str	r3, [r0, #108]	; 0x6c
            stage[ch] = HEM_EG_NO_STAGE;
    1648:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
    164c:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
            stage_ticks[ch] = 0;
    1650:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
    1654:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
            gated[ch] = 0;
    1658:	f8a0 3098 	strh.w	r3, [r0, #152]	; 0x98
        }
    }
    165c:	4770      	bx	lr
    165e:	Address 0x000000000000165e is out of bounds.


00001660 <ADSREG::SetHelp()>:
    }

protected:
    /* Set help text. Each help section can have up to 18 characters. Be concise! */
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "Gate 1=Ch1 2=Ch2";
    1660:	4b04      	ldr	r3, [pc, #16]	; (1674 <ADSREG::SetHelp()+0x14>)
    1662:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "Mod 1=Att 2=Rel";
    1664:	4b04      	ldr	r3, [pc, #16]	; (1678 <ADSREG::SetHelp()+0x18>)
    1666:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "Amp A=Ch1 B=Ch2";
    1668:	4b04      	ldr	r3, [pc, #16]	; (167c <ADSREG::SetHelp()+0x1c>)
    166a:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "A/D/S/R";
    166c:	4b04      	ldr	r3, [pc, #16]	; (1680 <ADSREG::SetHelp()+0x20>)
    166e:	6143      	str	r3, [r0, #20]
    }
    1670:	4770      	bx	lr
    1672:	bf00      	nop
    1674:	00020409 	.word	0x00020409
    1678:	0002041a 	.word	0x0002041a
    167c:	0002042a 	.word	0x0002042a
    1680:	0002043a 	.word	0x0002043a

00001684 <ADSREG_OnButtonPress(bool)>:
        if (++edit_stage > HEM_EG_RELEASE) {edit_stage = HEM_EG_ATTACK;}
    1684:	4b05      	ldr	r3, [pc, #20]	; (169c <ADSREG_OnButtonPress(bool)+0x18>)
    1686:	22a4      	movs	r2, #164	; 0xa4
    1688:	fb02 3000 	mla	r0, r2, r0, r3
    168c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    168e:	3301      	adds	r3, #1
    1690:	2b04      	cmp	r3, #4
    1692:	bfa8      	it	ge
    1694:	2300      	movge	r3, #0
    1696:	66c3      	str	r3, [r0, #108]	; 0x6c
    ADSREG_instance[hemisphere].BaseView();
}

void ADSREG_OnButtonPress(bool hemisphere) {
    ADSREG_instance[hemisphere].OnButtonPress();
}
    1698:	4770      	bx	lr
    169a:	bf00      	nop
    169c:	1fffa9e8 	.word	0x1fffa9e8

000016a0 <ADSREG_OnEncoderMove(bool, int)>:
        int adsr[4] = {attack, decay, sustain, release};
    16a0:	4b12      	ldr	r3, [pc, #72]	; (16ec <ADSREG_OnEncoderMove(bool, int)+0x4c>)
    16a2:	22a4      	movs	r2, #164	; 0xa4
    16a4:	fb02 3000 	mla	r0, r2, r0, r3

void ADSREG_OnEncoderMove(bool hemisphere, int direction) {
    16a8:	b084      	sub	sp, #16
        int adsr[4] = {attack, decay, sustain, release};
    16aa:	6f03      	ldr	r3, [r0, #112]	; 0x70
    16ac:	9300      	str	r3, [sp, #0]
    16ae:	6f43      	ldr	r3, [r0, #116]	; 0x74
    16b0:	9301      	str	r3, [sp, #4]
    16b2:	6f83      	ldr	r3, [r0, #120]	; 0x78
    16b4:	9302      	str	r3, [sp, #8]
        adsr[edit_stage] = constrain(adsr[edit_stage] += direction, 1, HEM_EG_MAX_VALUE);
    16b6:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
        int adsr[4] = {attack, decay, sustain, release};
    16b8:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
    16ba:	9303      	str	r3, [sp, #12]
        adsr[edit_stage] = constrain(adsr[edit_stage] += direction, 1, HEM_EG_MAX_VALUE);
    16bc:	ab04      	add	r3, sp, #16
    16be:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    16c2:	f852 3c10 	ldr.w	r3, [r2, #-16]
    16c6:	440b      	add	r3, r1
    16c8:	2bff      	cmp	r3, #255	; 0xff
    16ca:	bfa8      	it	ge
    16cc:	23ff      	movge	r3, #255	; 0xff
    16ce:	2b01      	cmp	r3, #1
    16d0:	bfb8      	it	lt
    16d2:	2301      	movlt	r3, #1
    16d4:	f842 3c10 	str.w	r3, [r2, #-16]
        attack = adsr[HEM_EG_ATTACK];
    16d8:	9b00      	ldr	r3, [sp, #0]
    16da:	6703      	str	r3, [r0, #112]	; 0x70
        decay = adsr[HEM_EG_DECAY];
    16dc:	9b01      	ldr	r3, [sp, #4]
    16de:	6743      	str	r3, [r0, #116]	; 0x74
        sustain = adsr[HEM_EG_SUSTAIN];
    16e0:	9b02      	ldr	r3, [sp, #8]
    16e2:	6783      	str	r3, [r0, #120]	; 0x78
        release = adsr[HEM_EG_RELEASE];
    16e4:	9b03      	ldr	r3, [sp, #12]
    16e6:	67c3      	str	r3, [r0, #124]	; 0x7c
    ADSREG_instance[hemisphere].OnEncoderMove(direction);
}
    16e8:	b004      	add	sp, #16
    16ea:	4770      	bx	lr
    16ec:	1fffa9e8 	.word	0x1fffa9e8

000016f0 <ADSREG_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    16f0:	4b04      	ldr	r3, [pc, #16]	; (1704 <ADSREG_ToggleHelpScreen(bool)+0x14>)
    16f2:	22a4      	movs	r2, #164	; 0xa4
    16f4:	fb02 3000 	mla	r0, r2, r0, r3
    16f8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    16fa:	f1c3 0301 	rsb	r3, r3, #1
    16fe:	65c3      	str	r3, [r0, #92]	; 0x5c

void ADSREG_ToggleHelpScreen(bool hemisphere) {
    ADSREG_instance[hemisphere].HelpScreen();
}
    1700:	4770      	bx	lr
    1702:	bf00      	nop
    1704:	1fffa9e8 	.word	0x1fffa9e8

00001708 <ADSREG_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, decay);
    1708:	4b07      	ldr	r3, [pc, #28]	; (1728 <ADSREG_OnDataRequest(bool)+0x20>)
    170a:	22a4      	movs	r2, #164	; 0xa4
    170c:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    1710:	6f83      	ldr	r3, [r0, #120]	; 0x78
    1712:	6f42      	ldr	r2, [r0, #116]	; 0x74
    1714:	041b      	lsls	r3, r3, #16
    1716:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    171a:	6f02      	ldr	r2, [r0, #112]	; 0x70
    171c:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
    171e:	4313      	orrs	r3, r2

uint32_t ADSREG_OnDataRequest(bool hemisphere) {
    return ADSREG_instance[hemisphere].OnDataRequest();
}
    1720:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
    1724:	4770      	bx	lr
    1726:	bf00      	nop
    1728:	1fffa9e8 	.word	0x1fffa9e8

0000172c <ASR::applet_name()>:
class ASR : public HemisphereApplet {
public:

    const char* applet_name() {
        return "\"A\"SR";
    }
    172c:	4800      	ldr	r0, [pc, #0]	; (1730 <ASR::applet_name()+0x4>)
    172e:	4770      	bx	lr
    1730:	00020442 	.word	0x00020442

00001734 <ASR::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Freeze";
    1734:	4b04      	ldr	r3, [pc, #16]	; (1748 <ASR::SetHelp()+0x14>)
    1736:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=CV 2=Mod index";
    1738:	4b04      	ldr	r3, [pc, #16]	; (174c <ASR::SetHelp()+0x18>)
    173a:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Outputs";
    173c:	4b04      	ldr	r3, [pc, #16]	; (1750 <ASR::SetHelp()+0x1c>)
    173e:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Index/Scale";
    1740:	4b04      	ldr	r3, [pc, #16]	; (1754 <ASR::SetHelp()+0x20>)
    1742:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    1744:	4770      	bx	lr
    1746:	bf00      	nop
    1748:	00020448 	.word	0x00020448
    174c:	00020459 	.word	0x00020459
    1750:	0002116b 	.word	0x0002116b
    1754:	0002046a 	.word	0x0002046a

00001758 <ASR_OnButtonPress(bool)>:
        if (++cursor > 1) cursor = 0;
    1758:	4b05      	ldr	r3, [pc, #20]	; (1770 <ASR_OnButtonPress(bool)+0x18>)
    175a:	f44f 72da 	mov.w	r2, #436	; 0x1b4
    175e:	fb02 3000 	mla	r0, r2, r0, r3
    1762:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    1764:	3301      	adds	r3, #1
    1766:	2b02      	cmp	r3, #2
    1768:	bfa8      	it	ge
    176a:	2300      	movge	r3, #0
    176c:	66c3      	str	r3, [r0, #108]	; 0x6c
ASR ASR_instance[2];

void ASR_Start(bool hemisphere) {ASR_instance[hemisphere].BaseStart(hemisphere);}
void ASR_Controller(bool hemisphere, bool forwarding) {ASR_instance[hemisphere].BaseController(forwarding);}
void ASR_View(bool hemisphere) {ASR_instance[hemisphere].BaseView();}
void ASR_OnButtonPress(bool hemisphere) {ASR_instance[hemisphere].OnButtonPress();}
    176e:	4770      	bx	lr
    1770:	1fffab30 	.word	0x1fffab30

00001774 <ASR_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    1774:	4b04      	ldr	r3, [pc, #16]	; (1788 <ASR_ToggleHelpScreen(bool)+0x14>)
    1776:	f44f 72da 	mov.w	r2, #436	; 0x1b4
    177a:	fb02 3000 	mla	r0, r2, r0, r3
    177e:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1780:	f1c3 0301 	rsb	r3, r3, #1
    1784:	65c3      	str	r3, [r0, #92]	; 0x5c
void ASR_OnEncoderMove(bool hemisphere, int direction) {ASR_instance[hemisphere].OnEncoderMove(direction);}
void ASR_ToggleHelpScreen(bool hemisphere) {ASR_instance[hemisphere].HelpScreen();}
    1786:	4770      	bx	lr
    1788:	1fffab30 	.word	0x1fffab30

0000178c <ASR_OnDataRequest(bool)>:
        byte ix = buffer_m->GetIndex();
    178c:	4b06      	ldr	r3, [pc, #24]	; (17a8 <ASR_OnDataRequest(bool)+0x1c>)
    178e:	f44f 72da 	mov.w	r2, #436	; 0x1b4
    1792:	fb02 3300 	mla	r3, r2, r0, r3
        return r;
    }

    void SetIndex(byte ix) {index = ix;}

    byte GetIndex() {return index;}
    1796:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        data |= (value << p.location);
    1798:	f8d3 01ac 	ldr.w	r0, [r3, #428]	; 0x1ac
        Pack(data, PackLocation {0,8}, ix);
    179c:	f892 2401 	ldrb.w	r2, [r2, #1025]	; 0x401
uint32_t ASR_OnDataRequest(bool hemisphere) {return ASR_instance[hemisphere].OnDataRequest();}
    17a0:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    17a4:	4770      	bx	lr
    17a6:	bf00      	nop
    17a8:	1fffab30 	.word	0x1fffab30

000017ac <AnnularFusion::applet_name()>:
class AnnularFusion : public HemisphereApplet {
public:

    const char* applet_name() {
        return "AnnularFu";
    }
    17ac:	4800      	ldr	r0, [pc, #0]	; (17b0 <AnnularFusion::applet_name()+0x4>)
    17ae:	4770      	bx	lr
    17b0:	00020476 	.word	0x00020476

000017b4 <AnnularFusion::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Reset";
    17b4:	4b04      	ldr	r3, [pc, #16]	; (17c8 <AnnularFusion::SetHelp()+0x14>)
    17b6:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "Rotate 1=Ch1 2=Ch2";
    17b8:	4b04      	ldr	r3, [pc, #16]	; (17cc <AnnularFusion::SetHelp()+0x18>)
    17ba:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Clock A=Ch1 B=Ch2";
    17bc:	4b04      	ldr	r3, [pc, #16]	; (17d0 <AnnularFusion::SetHelp()+0x1c>)
    17be:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Length/Hits Ch1,2";
    17c0:	4b04      	ldr	r3, [pc, #16]	; (17d4 <AnnularFusion::SetHelp()+0x20>)
    17c2:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    17c4:	4770      	bx	lr
    17c6:	bf00      	nop
    17c8:	00020480 	.word	0x00020480
    17cc:	00020490 	.word	0x00020490
    17d0:	000204a3 	.word	0x000204a3
    17d4:	000204b5 	.word	0x000204b5

000017d8 <AnnularFusion_OnButtonPress(bool)>:
void AnnularFusion_View(bool hemisphere) {
    AnnularFusion_instance[hemisphere].BaseView();
}

void AnnularFusion_OnButtonPress(bool hemisphere) {
    AnnularFusion_instance[hemisphere].OnButtonPress();
    17d8:	4b08      	ldr	r3, [pc, #32]	; (17fc <AnnularFusion_OnButtonPress(bool)+0x24>)
    17da:	f44f 728a 	mov.w	r2, #276	; 0x114
    17de:	fb02 3000 	mla	r0, r2, r0, r3
        display_timeout = AF_DISPLAY_TIMEOUT;
    17e2:	4b07      	ldr	r3, [pc, #28]	; (1800 <AnnularFusion_OnButtonPress(bool)+0x28>)
    17e4:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
        if (++cursor > 3) cursor = 0;
    17e8:	6f03      	ldr	r3, [r0, #112]	; 0x70
    17ea:	3301      	adds	r3, #1
    17ec:	2b04      	cmp	r3, #4
    17ee:	bfa8      	it	ge
    17f0:	2300      	movge	r3, #0
    17f2:	6703      	str	r3, [r0, #112]	; 0x70
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    17f4:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    17f8:	6483      	str	r3, [r0, #72]	; 0x48
}
    17fa:	4770      	bx	lr
    17fc:	1fffae98 	.word	0x1fffae98
    1800:	00050910 	.word	0x00050910

00001804 <AnnularFusion_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    1804:	4b04      	ldr	r3, [pc, #16]	; (1818 <AnnularFusion_ToggleHelpScreen(bool)+0x14>)
    1806:	f44f 728a 	mov.w	r2, #276	; 0x114
    180a:	fb02 3000 	mla	r0, r2, r0, r3
    180e:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1810:	f1c3 0301 	rsb	r3, r3, #1
    1814:	65c3      	str	r3, [r0, #92]	; 0x5c
    AnnularFusion_instance[hemisphere].OnEncoderMove(direction);
}

void AnnularFusion_ToggleHelpScreen(bool hemisphere) {
    AnnularFusion_instance[hemisphere].HelpScreen();
}
    1816:	4770      	bx	lr
    1818:	1fffae98 	.word	0x1fffae98

0000181c <AnnularFusion_OnDataRequest(bool)>:
        Pack(data, PackLocation {4,4}, beats[0] - 1);
    181c:	4b0b      	ldr	r3, [pc, #44]	; (184c <AnnularFusion_OnDataRequest(bool)+0x30>)
    181e:	f44f 728a 	mov.w	r2, #276	; 0x114
    1822:	fb02 3000 	mla	r0, r2, r0, r3
    1826:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
    182a:	1e5a      	subs	r2, r3, #1
        Pack(data, PackLocation {8,4}, length[1] - 1);
    182c:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
    1830:	3b01      	subs	r3, #1
        data |= (value << p.location);
    1832:	021b      	lsls	r3, r3, #8
    1834:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
        Pack(data, PackLocation {0,4}, length[0] - 1);
    1838:	f8d0 2104 	ldr.w	r2, [r0, #260]	; 0x104
        Pack(data, PackLocation {12,4}, beats[1] - 1);
    183c:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
        Pack(data, PackLocation {0,4}, length[0] - 1);
    1840:	3a01      	subs	r2, #1
    1842:	4313      	orrs	r3, r2
        Pack(data, PackLocation {12,4}, beats[1] - 1);
    1844:	3801      	subs	r0, #1

uint32_t AnnularFusion_OnDataRequest(bool hemisphere) {
    return AnnularFusion_instance[hemisphere].OnDataRequest();
}
    1846:	ea43 3000 	orr.w	r0, r3, r0, lsl #12
    184a:	4770      	bx	lr
    184c:	1fffae98 	.word	0x1fffae98

00001850 <AttenuateOffset::applet_name()>:
class AttenuateOffset : public HemisphereApplet {
public:

    const char* applet_name() {
        return "AttenOff";
    }
    1850:	4800      	ldr	r0, [pc, #0]	; (1854 <AttenuateOffset::applet_name()+0x4>)
    1852:	4770      	bx	lr
    1854:	000204c7 	.word	0x000204c7

00001858 <AttenuateOffset::Start()>:

    void Start() {
        ForEachChannel(ch) level[ch] = 63;
    1858:	233f      	movs	r3, #63	; 0x3f
    185a:	6703      	str	r3, [r0, #112]	; 0x70
    185c:	6743      	str	r3, [r0, #116]	; 0x74
    }
    185e:	4770      	bx	lr

00001860 <AttenuateOffset::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    1860:	4b04      	ldr	r3, [pc, #16]	; (1874 <AttenuateOffset::SetHelp()+0x14>)
    1862:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "CV Inputs 1,2";
    1864:	4b04      	ldr	r3, [pc, #16]	; (1878 <AttenuateOffset::SetHelp()+0x18>)
    1866:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Outputs A,B";
    1868:	4b04      	ldr	r3, [pc, #16]	; (187c <AttenuateOffset::SetHelp()+0x1c>)
    186a:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Offset V / Level %";
    186c:	4b04      	ldr	r3, [pc, #16]	; (1880 <AttenuateOffset::SetHelp()+0x20>)
    186e:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    1870:	4770      	bx	lr
    1872:	bf00      	nop
    1874:	000211c8 	.word	0x000211c8
    1878:	000204d0 	.word	0x000204d0
    187c:	000204de 	.word	0x000204de
    1880:	000204ea 	.word	0x000204ea

00001884 <AttenuateOffset_OnButtonPress(bool)>:
AttenuateOffset AttenuateOffset_instance[2];

void AttenuateOffset_Start(bool hemisphere) {AttenuateOffset_instance[hemisphere].BaseStart(hemisphere);}
void AttenuateOffset_Controller(bool hemisphere, bool forwarding) {AttenuateOffset_instance[hemisphere].BaseController(forwarding);}
void AttenuateOffset_View(bool hemisphere) {AttenuateOffset_instance[hemisphere].BaseView();}
void AttenuateOffset_OnButtonPress(bool hemisphere) {AttenuateOffset_instance[hemisphere].OnButtonPress();}
    1884:	4b06      	ldr	r3, [pc, #24]	; (18a0 <AttenuateOffset_OnButtonPress(bool)+0x1c>)
    1886:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
        if (++cursor > 3) cursor = 0;
    188a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    188c:	3301      	adds	r3, #1
    188e:	2b04      	cmp	r3, #4
    1890:	bfa8      	it	ge
    1892:	2300      	movge	r3, #0
    1894:	66c3      	str	r3, [r0, #108]	; 0x6c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    1896:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    189a:	6483      	str	r3, [r0, #72]	; 0x48
void AttenuateOffset_OnButtonPress(bool hemisphere) {AttenuateOffset_instance[hemisphere].OnButtonPress();}
    189c:	4770      	bx	lr
    189e:	bf00      	nop
    18a0:	1fffb0c0 	.word	0x1fffb0c0

000018a4 <AttenuateOffset_OnEncoderMove(bool, int)>:
        uint8_t ch = cursor / 2;
    18a4:	4b13      	ldr	r3, [pc, #76]	; (18f4 <AttenuateOffset_OnEncoderMove(bool, int)+0x50>)
    18a6:	eb03 12c0 	add.w	r2, r3, r0, lsl #7
void AttenuateOffset_OnEncoderMove(bool hemisphere, int direction) {AttenuateOffset_instance[hemisphere].OnEncoderMove(direction);}
    18aa:	b510      	push	{r4, lr}
        uint8_t ch = cursor / 2;
    18ac:	6ed4      	ldr	r4, [r2, #108]	; 0x6c
    18ae:	eb04 72d4 	add.w	r2, r4, r4, lsr #31
    18b2:	f3c2 0247 	ubfx	r2, r2, #1, #8
    18b6:	0140      	lsls	r0, r0, #5
        if (cursor == 0 || cursor == 2) {
    18b8:	f034 0402 	bics.w	r4, r4, #2
            offset[ch] = constrain(offset[ch] + direction, min, max);
    18bc:	4410      	add	r0, r2
        if (cursor == 0 || cursor == 2) {
    18be:	d10f      	bne.n	18e0 <AttenuateOffset_OnEncoderMove(bool, int)+0x3c>
            offset[ch] = constrain(offset[ch] + direction, min, max);
    18c0:	301e      	adds	r0, #30
    18c2:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    18c6:	440a      	add	r2, r1
    18c8:	2a3c      	cmp	r2, #60	; 0x3c
    18ca:	bfa8      	it	ge
    18cc:	223c      	movge	r2, #60	; 0x3c
    18ce:	f06f 013b 	mvn.w	r1, #59	; 0x3b
    18d2:	428a      	cmp	r2, r1
    18d4:	bfac      	ite	ge
    18d6:	f843 2020 	strge.w	r2, [r3, r0, lsl #2]
    18da:	f843 1020 	strlt.w	r1, [r3, r0, lsl #2]
void AttenuateOffset_OnEncoderMove(bool hemisphere, int direction) {AttenuateOffset_instance[hemisphere].OnEncoderMove(direction);}
    18de:	bd10      	pop	{r4, pc}
            level[ch] = constrain(level[ch] + direction, 0, 63);
    18e0:	301c      	adds	r0, #28
    18e2:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    18e6:	440a      	add	r2, r1
    18e8:	f382 0206 	usat	r2, #6, r2
    18ec:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
void AttenuateOffset_OnEncoderMove(bool hemisphere, int direction) {AttenuateOffset_instance[hemisphere].OnEncoderMove(direction);}
    18f0:	e7f5      	b.n	18de <AttenuateOffset_OnEncoderMove(bool, int)+0x3a>
    18f2:	bf00      	nop
    18f4:	1fffb0c0 	.word	0x1fffb0c0

000018f8 <AttenuateOffset_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    18f8:	4b03      	ldr	r3, [pc, #12]	; (1908 <AttenuateOffset_ToggleHelpScreen(bool)+0x10>)
    18fa:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    18fe:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1900:	f1c3 0301 	rsb	r3, r3, #1
    1904:	65c3      	str	r3, [r0, #92]	; 0x5c
void AttenuateOffset_ToggleHelpScreen(bool hemisphere) {AttenuateOffset_instance[hemisphere].HelpScreen();}
    1906:	4770      	bx	lr
    1908:	1fffb0c0 	.word	0x1fffb0c0

0000190c <AttenuateOffset_OnDataRequest(bool)>:
        Pack(data, PackLocation {0,9}, offset[0] + 256);
    190c:	4b08      	ldr	r3, [pc, #32]	; (1930 <AttenuateOffset_OnDataRequest(bool)+0x24>)
    190e:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    1912:	6f83      	ldr	r3, [r0, #120]	; 0x78
        data |= (value << p.location);
    1914:	6f02      	ldr	r2, [r0, #112]	; 0x70
    1916:	f503 7380 	add.w	r3, r3, #256	; 0x100
    191a:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
    191e:	6f42      	ldr	r2, [r0, #116]	; 0x74
        Pack(data, PackLocation {10,9}, offset[1] + 256);
    1920:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
    1922:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
    1926:	f500 7080 	add.w	r0, r0, #256	; 0x100
uint32_t AttenuateOffset_OnDataRequest(bool hemisphere) {return AttenuateOffset_instance[hemisphere].OnDataRequest();}
    192a:	ea43 2080 	orr.w	r0, r3, r0, lsl #10
    192e:	4770      	bx	lr
    1930:	1fffb0c0 	.word	0x1fffb0c0

00001934 <Binary::applet_name()>:
class Binary : public HemisphereApplet {
public:

    const char* applet_name() {
        return "BinaryCtr";
    }
    1934:	4800      	ldr	r0, [pc, #0]	; (1938 <Binary::applet_name()+0x4>)
    1936:	4770      	bx	lr
    1938:	000204fd 	.word	0x000204fd

0000193c <Binary::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Bit 3 2=Bit 2";
    193c:	4b04      	ldr	r3, [pc, #16]	; (1950 <Binary::SetHelp()+0x14>)
    193e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Bit 1 2=Bit 0";
    1940:	4b04      	ldr	r3, [pc, #16]	; (1954 <Binary::SetHelp()+0x18>)
    1942:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Binary B=Count";
    1944:	4b04      	ldr	r3, [pc, #16]	; (1958 <Binary::SetHelp()+0x1c>)
    1946:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "";
    1948:	4b04      	ldr	r3, [pc, #16]	; (195c <Binary::SetHelp()+0x20>)
    194a:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    194c:	4770      	bx	lr
    194e:	bf00      	nop
    1950:	00020507 	.word	0x00020507
    1954:	00020517 	.word	0x00020517
    1958:	00020527 	.word	0x00020527
    195c:	000211c8 	.word	0x000211c8

00001960 <Binary_OnButtonPress(bool)>:
    Binary_instance[hemisphere].BaseView();
}

void Binary_OnButtonPress(bool hemisphere) {
    Binary_instance[hemisphere].OnButtonPress();
}
    1960:	4770      	bx	lr

00001962 <Binary_OnEncoderMove(bool, int)>:

void Binary_OnEncoderMove(bool hemisphere, int direction) {
    Binary_instance[hemisphere].OnEncoderMove(direction);
}
    1962:	4770      	bx	lr

00001964 <Binary_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    1964:	4b04      	ldr	r3, [pc, #16]	; (1978 <Binary_ToggleHelpScreen(bool)+0x14>)
    1966:	22e4      	movs	r2, #228	; 0xe4
    1968:	fb02 3000 	mla	r0, r2, r0, r3
    196c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    196e:	f1c3 0301 	rsb	r3, r3, #1
    1972:	65c3      	str	r3, [r0, #92]	; 0x5c

void Binary_ToggleHelpScreen(bool hemisphere) {
    Binary_instance[hemisphere].HelpScreen();
}
    1974:	4770      	bx	lr
    1976:	bf00      	nop
    1978:	1fffb1c8 	.word	0x1fffb1c8

0000197c <Binary_OnDataRequest(bool)>:

uint32_t Binary_OnDataRequest(bool hemisphere) {
    return Binary_instance[hemisphere].OnDataRequest();
}
    197c:	2000      	movs	r0, #0
    197e:	4770      	bx	lr

00001980 <Binary_OnDataReceive(bool, unsigned long)>:

void Binary_OnDataReceive(bool hemisphere, uint32_t data) {
    Binary_instance[hemisphere].OnDataReceive(data);
}
    1980:	4770      	bx	lr
    1982:	Address 0x0000000000001982 is out of bounds.


00001984 <BootsNCat::applet_name()>:
class BootsNCat : public HemisphereApplet {
public:

    const char* applet_name() {
        return "BootsNCat";
    }
    1984:	4800      	ldr	r0, [pc, #0]	; (1988 <BootsNCat::applet_name()+0x4>)
    1986:	4770      	bx	lr
    1988:	00020538 	.word	0x00020538

0000198c <BootsNCat::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1,2 Play";
    198c:	4b04      	ldr	r3, [pc, #16]	; (19a0 <BootsNCat::SetHelp()+0x14>)
    198e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "Atten. 1=BD 2=SD";
    1990:	4b04      	ldr	r3, [pc, #16]	; (19a4 <BootsNCat::SetHelp()+0x18>)
    1992:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Left B=Right";
    1994:	4b04      	ldr	r3, [pc, #16]	; (19a8 <BootsNCat::SetHelp()+0x1c>)
    1996:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Preset/Pan";
    1998:	4b04      	ldr	r3, [pc, #16]	; (19ac <BootsNCat::SetHelp()+0x20>)
    199a:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    199c:	4770      	bx	lr
    199e:	bf00      	nop
    19a0:	00020542 	.word	0x00020542
    19a4:	0002054b 	.word	0x0002054b
    19a8:	0002055c 	.word	0x0002055c
    19ac:	0002056b 	.word	0x0002056b

000019b0 <BootsNCat_OnButtonPress(bool)>:
        if (++cursor > 4) cursor = 0;
    19b0:	4b05      	ldr	r3, [pc, #20]	; (19c8 <BootsNCat_OnButtonPress(bool)+0x18>)
    19b2:	f44f 72b6 	mov.w	r2, #364	; 0x16c
    19b6:	fb02 3000 	mla	r0, r2, r0, r3
    19ba:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    19bc:	3301      	adds	r3, #1
    19be:	2b05      	cmp	r3, #5
    19c0:	bfa8      	it	ge
    19c2:	2300      	movge	r3, #0
    19c4:	66c3      	str	r3, [r0, #108]	; 0x6c
BootsNCat BootsNCat_instance[2];

void BootsNCat_Start(bool hemisphere) {BootsNCat_instance[hemisphere].BaseStart(hemisphere);}
void BootsNCat_Controller(bool hemisphere, bool forwarding) {BootsNCat_instance[hemisphere].BaseController(forwarding);}
void BootsNCat_View(bool hemisphere) {BootsNCat_instance[hemisphere].BaseView();}
void BootsNCat_OnButtonPress(bool hemisphere) {BootsNCat_instance[hemisphere].OnButtonPress();}
    19c6:	4770      	bx	lr
    19c8:	1fffb390 	.word	0x1fffb390

000019cc <BootsNCat_ToggleHelpScreen(bool)>:
    19cc:	4b04      	ldr	r3, [pc, #16]	; (19e0 <BootsNCat_ToggleHelpScreen(bool)+0x14>)
    19ce:	f44f 72b6 	mov.w	r2, #364	; 0x16c
    19d2:	fb02 3000 	mla	r0, r2, r0, r3
    19d6:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    19d8:	f1c3 0301 	rsb	r3, r3, #1
    19dc:	65c3      	str	r3, [r0, #92]	; 0x5c
void BootsNCat_OnEncoderMove(bool hemisphere, int direction) {BootsNCat_instance[hemisphere].OnEncoderMove(direction);}
void BootsNCat_ToggleHelpScreen(bool hemisphere) {BootsNCat_instance[hemisphere].HelpScreen();}
    19de:	4770      	bx	lr
    19e0:	1fffb390 	.word	0x1fffb390

000019e4 <BootsNCat_OnDataRequest(bool)>:
        Pack(data, PackLocation {6,6}, decay[0]);
    19e4:	4b0b      	ldr	r3, [pc, #44]	; (1a14 <BootsNCat_OnDataRequest(bool)+0x30>)
    19e6:	f44f 72b6 	mov.w	r2, #364	; 0x16c
    19ea:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    19ee:	f8d0 315c 	ldr.w	r3, [r0, #348]	; 0x15c
    19f2:	f8d0 2160 	ldr.w	r2, [r0, #352]	; 0x160
    19f6:	031b      	lsls	r3, r3, #12
    19f8:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    19fc:	f8d0 2158 	ldr.w	r2, [r0, #344]	; 0x158
    1a00:	4313      	orrs	r3, r2
    1a02:	f8d0 2164 	ldr.w	r2, [r0, #356]	; 0x164
        Pack(data, PackLocation {24,6}, blend);
    1a06:	f990 0168 	ldrsb.w	r0, [r0, #360]	; 0x168
    1a0a:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
uint32_t BootsNCat_OnDataRequest(bool hemisphere) {return BootsNCat_instance[hemisphere].OnDataRequest();}
    1a0e:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
    1a12:	4770      	bx	lr
    1a14:	1fffb390 	.word	0x1fffb390

00001a18 <Brancher::applet_name()>:
class Brancher : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Brancher";
    }
    1a18:	4800      	ldr	r0, [pc, #0]	; (1a1c <Brancher::applet_name()+0x4>)
    1a1a:	4770      	bx	lr
    1a1c:	00020576 	.word	0x00020576

00001a20 <Brancher::Start()>:

    void Start() {
    	    p = 50;
    1a20:	2332      	movs	r3, #50	; 0x32
    1a22:	66c3      	str	r3, [r0, #108]	; 0x6c
    	    choice = 0;
    1a24:	2300      	movs	r3, #0
    1a26:	6703      	str	r3, [r0, #112]	; 0x70
    }
    1a28:	4770      	bx	lr
    1a2a:	Address 0x0000000000001a2a is out of bounds.


00001a2c <Brancher::SetHelp()>:
        p = Unpack(data, PackLocation {0,7});
    }

protected:
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock/Gate";
    1a2c:	4b04      	ldr	r3, [pc, #16]	; (1a40 <Brancher::SetHelp()+0x14>)
    1a2e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "1=p Mod";
    1a30:	4b04      	ldr	r3, [pc, #16]	; (1a44 <Brancher::SetHelp()+0x18>)
    1a32:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "A,B=Clock/Gate";
    1a34:	4b04      	ldr	r3, [pc, #16]	; (1a48 <Brancher::SetHelp()+0x1c>)
    1a36:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "Set p";
    1a38:	4b04      	ldr	r3, [pc, #16]	; (1a4c <Brancher::SetHelp()+0x20>)
    1a3a:	6143      	str	r3, [r0, #20]
    }
    1a3c:	4770      	bx	lr
    1a3e:	bf00      	nop
    1a40:	0002057f 	.word	0x0002057f
    1a44:	0002058c 	.word	0x0002058c
    1a48:	00020594 	.word	0x00020594
    1a4c:	000205a3 	.word	0x000205a3

00001a50 <Brancher_OnButtonPress(bool)>:
    		choice = 1 - choice;
    1a50:	4b04      	ldr	r3, [pc, #16]	; (1a64 <Brancher_OnButtonPress(bool)+0x14>)
    1a52:	2274      	movs	r2, #116	; 0x74
    1a54:	fb02 3000 	mla	r0, r2, r0, r3
    1a58:	6f03      	ldr	r3, [r0, #112]	; 0x70
    1a5a:	f1c3 0301 	rsb	r3, r3, #1
    1a5e:	6703      	str	r3, [r0, #112]	; 0x70
    Brancher_instance[hemisphere].BaseView();
}

void Brancher_OnButtonPress(bool hemisphere) {
    Brancher_instance[hemisphere].OnButtonPress();
}
    1a60:	4770      	bx	lr
    1a62:	bf00      	nop
    1a64:	1fffb668 	.word	0x1fffb668

00001a68 <Brancher_OnEncoderMove(bool, int)>:
        p = constrain(p += direction, 0, 100);
    1a68:	4b06      	ldr	r3, [pc, #24]	; (1a84 <Brancher_OnEncoderMove(bool, int)+0x1c>)
    1a6a:	2274      	movs	r2, #116	; 0x74
    1a6c:	fb02 3000 	mla	r0, r2, r0, r3
    1a70:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    1a72:	440b      	add	r3, r1
    1a74:	2b64      	cmp	r3, #100	; 0x64
    1a76:	bfa8      	it	ge
    1a78:	2364      	movge	r3, #100	; 0x64
    1a7a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    1a7e:	66c3      	str	r3, [r0, #108]	; 0x6c

void Brancher_OnEncoderMove(bool hemisphere, int direction) {
    Brancher_instance[hemisphere].OnEncoderMove(direction);
}
    1a80:	4770      	bx	lr
    1a82:	bf00      	nop
    1a84:	1fffb668 	.word	0x1fffb668

00001a88 <Brancher_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    1a88:	4b04      	ldr	r3, [pc, #16]	; (1a9c <Brancher_ToggleHelpScreen(bool)+0x14>)
    1a8a:	2274      	movs	r2, #116	; 0x74
    1a8c:	fb02 3000 	mla	r0, r2, r0, r3
    1a90:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1a92:	f1c3 0301 	rsb	r3, r3, #1
    1a96:	65c3      	str	r3, [r0, #92]	; 0x5c

void Brancher_ToggleHelpScreen(bool hemisphere) {
    Brancher_instance[hemisphere].HelpScreen();
}
    1a98:	4770      	bx	lr
    1a9a:	bf00      	nop
    1a9c:	1fffb668 	.word	0x1fffb668

00001aa0 <Brancher_OnDataRequest(bool)>:
        Pack(data, PackLocation {0,7}, p);
    1aa0:	4b02      	ldr	r3, [pc, #8]	; (1aac <Brancher_OnDataRequest(bool)+0xc>)
    1aa2:	2274      	movs	r2, #116	; 0x74
    1aa4:	fb02 3300 	mla	r3, r2, r0, r3

uint32_t Brancher_OnDataRequest(bool hemisphere) {
    return Brancher_instance[hemisphere].OnDataRequest();
}
    1aa8:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
    1aaa:	4770      	bx	lr
    1aac:	1fffb668 	.word	0x1fffb668

00001ab0 <Burst::applet_name()>:
class Burst : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Burst";
    }
    1ab0:	4800      	ldr	r0, [pc, #0]	; (1ab4 <Burst::applet_name()+0x4>)
    1ab2:	4770      	bx	lr
    1ab4:	000205b3 	.word	0x000205b3

00001ab8 <Burst::Start()>:

    void Start() {
        cursor = 0;
        number = 4;
    1ab8:	2204      	movs	r2, #4
    1aba:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
        div = 1;
    1abe:	2201      	movs	r2, #1
        cursor = 0;
    1ac0:	2300      	movs	r3, #0
        div = 1;
    1ac2:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
        spacing = 50;
    1ac6:	2232      	movs	r2, #50	; 0x32
        cursor = 0;
    1ac8:	66c3      	str	r3, [r0, #108]	; 0x6c
        spacing = 50;
    1aca:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
        bursts_to_go = 0;
    1ace:	6743      	str	r3, [r0, #116]	; 0x74
        clocked = 0;
    1ad0:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
        last_number_cv_tick = 0;
    1ad4:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    }
    1ad8:	4770      	bx	lr
    1ada:	Address 0x0000000000001ada is out of bounds.


00001adc <Burst::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Burst";
    1adc:	4b04      	ldr	r3, [pc, #16]	; (1af0 <Burst::SetHelp()+0x14>)
    1ade:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Number 2=Spacing";
    1ae0:	4b04      	ldr	r3, [pc, #16]	; (1af4 <Burst::SetHelp()+0x18>)
    1ae2:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "1=Burst 2=Gate";
    1ae4:	4b04      	ldr	r3, [pc, #16]	; (1af8 <Burst::SetHelp()+0x1c>)
    1ae6:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Number/Spacing/Div";
    1ae8:	4b04      	ldr	r3, [pc, #16]	; (1afc <Burst::SetHelp()+0x20>)
    1aea:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    1aec:	4770      	bx	lr
    1aee:	bf00      	nop
    1af0:	000205a9 	.word	0x000205a9
    1af4:	000205b9 	.word	0x000205b9
    1af8:	000205cc 	.word	0x000205cc
    1afc:	000205db 	.word	0x000205db

00001b00 <Burst_ToggleHelpScreen(bool)>:
    1b00:	4b04      	ldr	r3, [pc, #16]	; (1b14 <Burst_ToggleHelpScreen(bool)+0x14>)
    1b02:	2290      	movs	r2, #144	; 0x90
    1b04:	fb02 3000 	mla	r0, r2, r0, r3
    1b08:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1b0a:	f1c3 0301 	rsb	r3, r3, #1
    1b0e:	65c3      	str	r3, [r0, #92]	; 0x5c
    Burst_instance[hemisphere].OnEncoderMove(direction);
}

void Burst_ToggleHelpScreen(bool hemisphere) {
    Burst_instance[hemisphere].HelpScreen();
}
    1b10:	4770      	bx	lr
    1b12:	bf00      	nop
    1b14:	1fffb750 	.word	0x1fffb750

00001b18 <Burst_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, spacing);
    1b18:	4b07      	ldr	r3, [pc, #28]	; (1b38 <Burst_OnDataRequest(bool)+0x20>)
    1b1a:	2290      	movs	r2, #144	; 0x90
    1b1c:	fb02 3300 	mla	r3, r2, r0, r3
        data |= (value << p.location);
    1b20:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    1b24:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
        Pack(data, PackLocation {16,8}, div + 8);
    1b28:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    1b2c:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
    1b30:	3308      	adds	r3, #8

uint32_t Burst_OnDataRequest(bool hemisphere) {
    return Burst_instance[hemisphere].OnDataRequest();
}
    1b32:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
    1b36:	4770      	bx	lr
    1b38:	1fffb750 	.word	0x1fffb750

00001b3c <CVRecV2::applet_name()>:
class CVRecV2 : public HemisphereApplet {
public:

    const char* applet_name() {
        return "CVRec";
    }
    1b3c:	4800      	ldr	r0, [pc, #0]	; (1b40 <CVRecV2::applet_name()+0x4>)
    1b3e:	4770      	bx	lr
    1b40:	000205ee 	.word	0x000205ee

00001b44 <CVRecV2::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Reset";
    1b44:	4b04      	ldr	r3, [pc, #16]	; (1b58 <CVRecV2::SetHelp()+0x14>)
    1b46:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "Rec: 1=Tr1 2=Tr2";
    1b48:	4b04      	ldr	r3, [pc, #16]	; (1b5c <CVRecV2::SetHelp()+0x18>)
    1b4a:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Play: A=Tr1 B=Tr2";
    1b4c:	4b04      	ldr	r3, [pc, #16]	; (1b60 <CVRecV2::SetHelp()+0x1c>)
    1b4e:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Range/Smooth/Rec";
    1b50:	4b04      	ldr	r3, [pc, #16]	; (1b64 <CVRecV2::SetHelp()+0x20>)
    1b52:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    1b54:	4770      	bx	lr
    1b56:	bf00      	nop
    1b58:	00020480 	.word	0x00020480
    1b5c:	000205f4 	.word	0x000205f4
    1b60:	00020605 	.word	0x00020605
    1b64:	00020617 	.word	0x00020617

00001b68 <CVRecV2_OnButtonPress(bool)>:
CVRecV2 CVRecV2_instance[2];

void CVRecV2_Start(bool hemisphere) {CVRecV2_instance[hemisphere].BaseStart(hemisphere);}
void CVRecV2_Controller(bool hemisphere, bool forwarding) {CVRecV2_instance[hemisphere].BaseController(forwarding);}
void CVRecV2_View(bool hemisphere) {CVRecV2_instance[hemisphere].BaseView();}
void CVRecV2_OnButtonPress(bool hemisphere) {CVRecV2_instance[hemisphere].OnButtonPress();}
    1b68:	b530      	push	{r4, r5, lr}
    1b6a:	4910      	ldr	r1, [pc, #64]	; (1bac <CVRecV2_OnButtonPress(bool)+0x44>)
    1b6c:	f240 63fc 	movw	r3, #1788	; 0x6fc
    1b70:	fb03 1300 	mla	r3, r3, r0, r1
        if (cursor == 3) {
    1b74:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    1b76:	2a03      	cmp	r2, #3
    1b78:	d10b      	bne.n	1b92 <CVRecV2_OnButtonPress(bool)+0x2a>
            if (mode > 0) punch_out = end - start;
    1b7a:	f8d3 46f0 	ldr.w	r4, [r3, #1776]	; 0x6f0
    1b7e:	2c00      	cmp	r4, #0
    1b80:	bfc5      	ittet	gt
    1b82:	f8b3 46f6 	ldrhgt.w	r4, [r3, #1782]	; 0x6f6
    1b86:	f8b3 56f4 	ldrhgt.w	r5, [r3, #1780]	; 0x6f4
            else punch_out = 0;
    1b8a:	2400      	movle	r4, #0
            if (mode > 0) punch_out = end - start;
    1b8c:	1b64      	subgt	r4, r4, r5
            else punch_out = 0;
    1b8e:	f8a3 46fa 	strh.w	r4, [r3, #1786]	; 0x6fa
        if (++cursor > 3) cursor = 0;
    1b92:	3201      	adds	r2, #1
    1b94:	f240 64fc 	movw	r4, #1788	; 0x6fc
    1b98:	2a04      	cmp	r2, #4
    1b9a:	fb04 1100 	mla	r1, r4, r0, r1
    1b9e:	bfa8      	it	ge
    1ba0:	2200      	movge	r2, #0
    1ba2:	66ca      	str	r2, [r1, #108]	; 0x6c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    1ba4:	f642 62e0 	movw	r2, #12000	; 0x2ee0
    1ba8:	649a      	str	r2, [r3, #72]	; 0x48
void CVRecV2_OnButtonPress(bool hemisphere) {CVRecV2_instance[hemisphere].OnButtonPress();}
    1baa:	bd30      	pop	{r4, r5, pc}
    1bac:	1fffb878 	.word	0x1fffb878

00001bb0 <CVRecV2_OnEncoderMove(bool, int)>:
void CVRecV2_OnEncoderMove(bool hemisphere, int direction) {CVRecV2_instance[hemisphere].OnEncoderMove(direction);}
    1bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1bb2:	4c2a      	ldr	r4, [pc, #168]	; (1c5c <CVRecV2_OnEncoderMove(bool, int)+0xac>)
    1bb4:	f240 63fc 	movw	r3, #1788	; 0x6fc
    1bb8:	fb03 4300 	mla	r3, r3, r0, r4
        if (cursor == 0) {
    1bbc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    1bbe:	b9e2      	cbnz	r2, 1bfa <CVRecV2_OnEncoderMove(bool, int)+0x4a>
            int16_t fs = start; // Former start value
    1bc0:	f9b3 66f4 	ldrsh.w	r6, [r3, #1780]	; 0x6f4
            start = constrain(start + direction, 0, end - 1);
    1bc4:	f9b3 76f6 	ldrsh.w	r7, [r3, #1782]	; 0x6f6
    1bc8:	1875      	adds	r5, r6, r1
    1bca:	d403      	bmi.n	1bd4 <CVRecV2_OnEncoderMove(bool, int)+0x24>
    1bcc:	1e7a      	subs	r2, r7, #1
    1bce:	42aa      	cmp	r2, r5
    1bd0:	bfa8      	it	ge
    1bd2:	462a      	movge	r2, r5
    1bd4:	f240 65fc 	movw	r5, #1788	; 0x6fc
    1bd8:	b212      	sxth	r2, r2
    1bda:	fb05 4000 	mla	r0, r5, r0, r4
            if (fs != start && punch_out) punch_out -= direction;
    1bde:	4296      	cmp	r6, r2
            start = constrain(start + direction, 0, end - 1);
    1be0:	f8a0 26f4 	strh.w	r2, [r0, #1780]	; 0x6f4
            if (fs != start && punch_out) punch_out -= direction;
    1be4:	d005      	beq.n	1bf2 <CVRecV2_OnEncoderMove(bool, int)+0x42>
    1be6:	f9b0 26fa 	ldrsh.w	r2, [r0, #1786]	; 0x6fa
    1bea:	b112      	cbz	r2, 1bf2 <CVRecV2_OnEncoderMove(bool, int)+0x42>
    1bec:	1a52      	subs	r2, r2, r1
            if (fe != end && punch_out) punch_out += direction;
    1bee:	f8a0 26fa 	strh.w	r2, [r0, #1786]	; 0x6fa
    1bf2:	f642 62e0 	movw	r2, #12000	; 0x2ee0
    1bf6:	649a      	str	r2, [r3, #72]	; 0x48
void CVRecV2_OnEncoderMove(bool hemisphere, int direction) {CVRecV2_instance[hemisphere].OnEncoderMove(direction);}
    1bf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (cursor == 1) {
    1bfa:	2a01      	cmp	r2, #1
    1bfc:	d00b      	beq.n	1c16 <CVRecV2_OnEncoderMove(bool, int)+0x66>
        if (cursor == 2) smooth = direction > 0 ? 1 : 0;
    1bfe:	2a02      	cmp	r2, #2
    1c00:	d025      	beq.n	1c4e <CVRecV2_OnEncoderMove(bool, int)+0x9e>
        if (cursor == 3) mode = constrain(mode + direction, 0, 3);
    1c02:	2a03      	cmp	r2, #3
    1c04:	d1f5      	bne.n	1bf2 <CVRecV2_OnEncoderMove(bool, int)+0x42>
    1c06:	f8d3 26f0 	ldr.w	r2, [r3, #1776]	; 0x6f0
    1c0a:	440a      	add	r2, r1
    1c0c:	f382 0202 	usat	r2, #2, r2
    1c10:	f8c3 26f0 	str.w	r2, [r3, #1776]	; 0x6f0
    1c14:	e7ed      	b.n	1bf2 <CVRecV2_OnEncoderMove(bool, int)+0x42>
            int16_t fe = end; // Former end value
    1c16:	f9b3 56f6 	ldrsh.w	r5, [r3, #1782]	; 0x6f6
            end = constrain(end + direction, start + 1, CVREC_MAX_STEP - 1);
    1c1a:	f9b3 26f4 	ldrsh.w	r2, [r3, #1780]	; 0x6f4
    1c1e:	186e      	adds	r6, r5, r1
    1c20:	3201      	adds	r2, #1
    1c22:	4296      	cmp	r6, r2
    1c24:	db04      	blt.n	1c30 <CVRecV2_OnEncoderMove(bool, int)+0x80>
    1c26:	f240 127f 	movw	r2, #383	; 0x17f
    1c2a:	42b2      	cmp	r2, r6
    1c2c:	bfa8      	it	ge
    1c2e:	4632      	movge	r2, r6
    1c30:	f240 66fc 	movw	r6, #1788	; 0x6fc
    1c34:	b212      	sxth	r2, r2
    1c36:	fb06 4000 	mla	r0, r6, r0, r4
            if (fe != end && punch_out) punch_out += direction;
    1c3a:	4295      	cmp	r5, r2
            end = constrain(end + direction, start + 1, CVREC_MAX_STEP - 1);
    1c3c:	f8a0 26f6 	strh.w	r2, [r0, #1782]	; 0x6f6
            if (fe != end && punch_out) punch_out += direction;
    1c40:	d0d7      	beq.n	1bf2 <CVRecV2_OnEncoderMove(bool, int)+0x42>
    1c42:	f9b0 26fa 	ldrsh.w	r2, [r0, #1786]	; 0x6fa
    1c46:	2a00      	cmp	r2, #0
    1c48:	d0d3      	beq.n	1bf2 <CVRecV2_OnEncoderMove(bool, int)+0x42>
    1c4a:	440a      	add	r2, r1
    1c4c:	e7cf      	b.n	1bee <CVRecV2_OnEncoderMove(bool, int)+0x3e>
        if (cursor == 2) smooth = direction > 0 ? 1 : 0;
    1c4e:	2900      	cmp	r1, #0
    1c50:	bfd4      	ite	le
    1c52:	2100      	movle	r1, #0
    1c54:	2101      	movgt	r1, #1
    1c56:	f883 16ec 	strb.w	r1, [r3, #1772]	; 0x6ec
        if (cursor == 3) mode = constrain(mode + direction, 0, 3);
    1c5a:	e7ca      	b.n	1bf2 <CVRecV2_OnEncoderMove(bool, int)+0x42>
    1c5c:	1fffb878 	.word	0x1fffb878

00001c60 <CVRecV2_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    1c60:	4b04      	ldr	r3, [pc, #16]	; (1c74 <CVRecV2_ToggleHelpScreen(bool)+0x14>)
    1c62:	f240 62fc 	movw	r2, #1788	; 0x6fc
    1c66:	fb02 3000 	mla	r0, r2, r0, r3
    1c6a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1c6c:	f1c3 0301 	rsb	r3, r3, #1
    1c70:	65c3      	str	r3, [r0, #92]	; 0x5c
void CVRecV2_ToggleHelpScreen(bool hemisphere) {CVRecV2_instance[hemisphere].HelpScreen();}
    1c72:	4770      	bx	lr
    1c74:	1fffb878 	.word	0x1fffb878

00001c78 <CVRecV2_OnDataRequest(bool)>:
        Pack(data, PackLocation {9,9}, end);
    1c78:	4b07      	ldr	r3, [pc, #28]	; (1c98 <CVRecV2_OnDataRequest(bool)+0x20>)
    1c7a:	f240 62fc 	movw	r2, #1788	; 0x6fc
    1c7e:	fb02 3000 	mla	r0, r2, r0, r3
        Pack(data, PackLocation {18,1}, smooth);
    1c82:	f890 36ec 	ldrb.w	r3, [r0, #1772]	; 0x6ec
        Pack(data, PackLocation {9,9}, end);
    1c86:	f9b0 26f6 	ldrsh.w	r2, [r0, #1782]	; 0x6f6
        Pack(data, PackLocation {0,9}, start);
    1c8a:	f9b0 06f4 	ldrsh.w	r0, [r0, #1780]	; 0x6f4
        data |= (value << p.location);
    1c8e:	049b      	lsls	r3, r3, #18
    1c90:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
uint32_t CVRecV2_OnDataRequest(bool hemisphere) {return CVRecV2_instance[hemisphere].OnDataRequest();}
    1c94:	4318      	orrs	r0, r3
    1c96:	4770      	bx	lr
    1c98:	1fffb878 	.word	0x1fffb878

00001c9c <hem_MIN(int, int)>:
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Arithmetic functions and typedef to function pointer
#define HEMISPHERE_NUMBER_OF_CALC 7
int hem_MIN(int v1, int v2) {return (v1 < v2) ? v1 : v2;}
    1c9c:	4288      	cmp	r0, r1
    1c9e:	bfa8      	it	ge
    1ca0:	4608      	movge	r0, r1
    1ca2:	4770      	bx	lr

00001ca4 <hem_MAX(int, int)>:
int hem_MAX(int v1, int v2) {return (v1 > v2) ? v1 : v2;}
    1ca4:	4288      	cmp	r0, r1
    1ca6:	bfb8      	it	lt
    1ca8:	4608      	movlt	r0, r1
    1caa:	4770      	bx	lr

00001cac <hem_SUM(int, int)>:
int hem_SUM(int v1, int v2) {return constrain(v1 + v2, 0, HEMISPHERE_MAX_CV);}
    1cac:	4408      	add	r0, r1
    1cae:	f5b0 5ff0 	cmp.w	r0, #7680	; 0x1e00
    1cb2:	bfa8      	it	ge
    1cb4:	f44f 50f0 	movge.w	r0, #7680	; 0x1e00
    1cb8:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    1cbc:	4770      	bx	lr

00001cbe <hem_DIFF(int, int)>:
int hem_DIFF(int v1, int v2) {return hem_MAX(v1, v2) - hem_MIN(v1, v2);}
    1cbe:	4288      	cmp	r0, r1
    1cc0:	4603      	mov	r3, r0
    1cc2:	bfa8      	it	ge
    1cc4:	460b      	movge	r3, r1
    1cc6:	4288      	cmp	r0, r1
    1cc8:	bfac      	ite	ge
    1cca:	ebc3 0000 	rsbge	r0, r3, r0
    1cce:	ebc3 0001 	rsblt	r0, r3, r1
    1cd2:	4770      	bx	lr

00001cd4 <hem_MEAN(int, int)>:
int hem_MEAN(int v1, int v2) {return (v1 + v2) / 2;}
    1cd4:	4408      	add	r0, r1
    1cd6:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    1cda:	1040      	asrs	r0, r0, #1
    1cdc:	4770      	bx	lr
    1cde:	Address 0x0000000000001cde is out of bounds.


00001ce0 <Calculate::applet_name()>:
class Calculate : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Calculate";
    }
    1ce0:	4800      	ldr	r0, [pc, #0]	; (1ce4 <Calculate::applet_name()+0x4>)
    1ce2:	4770      	bx	lr
    1ce4:	00020628 	.word	0x00020628

00001ce8 <Calculate::Start()>:

    void Start() {
    1ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
        ForEachChannel(ch)
        {
            operation[ch] = ch;
            rand_clocked[ch] = 0;
        }
        const char * op_name_list[] = {"Min", "Max", "Sum", "Diff", "Mean", "S&H", "Rnd"};
    1cea:	4c16      	ldr	r4, [pc, #88]	; (1d44 <Calculate::Start()+0x5c>)
            operation[ch] = ch;
    1cec:	2300      	movs	r3, #0
    1cee:	2201      	movs	r2, #1
        const char * op_name_list[] = {"Min", "Max", "Sum", "Diff", "Mean", "S&H", "Rnd"};
    1cf0:	4626      	mov	r6, r4
    void Start() {
    1cf2:	4607      	mov	r7, r0
            operation[ch] = ch;
    1cf4:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
    1cf8:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
        selected = 0;
    1cfc:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
            rand_clocked[ch] = 0;
    1d00:	f8a0 30b8 	strh.w	r3, [r0, #184]	; 0xb8
        const char * op_name_list[] = {"Min", "Max", "Sum", "Diff", "Mean", "S&H", "Rnd"};
    1d04:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    void Start() {
    1d06:	b08f      	sub	sp, #60	; 0x3c
        const char * op_name_list[] = {"Min", "Max", "Sum", "Diff", "Mean", "S&H", "Rnd"};
    1d08:	466d      	mov	r5, sp
    1d0a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1d0c:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
        // hem_MIN goes in the Rand and S&H slots, because those are handled in Controller() and
        // don't need functions. But providing 0 isn't safe because the encoder change can
        // happen any time and cause the system to try to run one of those null functions.
        CalcFunction calc_fn_list[] = {hem_MIN, hem_MAX, hem_SUM, hem_DIFF, hem_MEAN, hem_MIN, hem_MIN};
    1d10:	341c      	adds	r4, #28
        const char * op_name_list[] = {"Min", "Max", "Sum", "Diff", "Mean", "S&H", "Rnd"};
    1d12:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        CalcFunction calc_fn_list[] = {hem_MIN, hem_MAX, hem_SUM, hem_DIFF, hem_MEAN, hem_MIN, hem_MIN};
    1d16:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    1d18:	ad07      	add	r5, sp, #28
    1d1a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1d1c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
        for(int i = 0; i < HEMISPHERE_NUMBER_OF_CALC; i++)
        {
            op_name[i] = op_name_list[i];
    1d20:	241c      	movs	r4, #28
        CalcFunction calc_fn_list[] = {hem_MIN, hem_MAX, hem_SUM, hem_DIFF, hem_MEAN, hem_MIN, hem_MIN};
    1d22:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            op_name[i] = op_name_list[i];
    1d26:	4622      	mov	r2, r4
    1d28:	4669      	mov	r1, sp
    1d2a:	f107 006c 	add.w	r0, r7, #108	; 0x6c
    1d2e:	f018 f95f 	bl	19ff0 <memcpy>
            calc_fn[i] = calc_fn_list[i];
    1d32:	4622      	mov	r2, r4
    1d34:	eb0d 0104 	add.w	r1, sp, r4
    1d38:	f107 0088 	add.w	r0, r7, #136	; 0x88
    1d3c:	f018 f958 	bl	19ff0 <memcpy>
        }
    }
    1d40:	b00f      	add	sp, #60	; 0x3c
    1d42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d44:	0002256c 	.word	0x0002256c

00001d48 <Calculate::SetHelp()>:
    }

protected:
    /* Set help text. Each help section can have up to 18 characters. Be concise! */
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "Hold 1=CV1 2=CV2";
    1d48:	4b04      	ldr	r3, [pc, #16]	; (1d5c <Calculate::SetHelp()+0x14>)
    1d4a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "1=CV1 2=CV2";
    1d4c:	4b04      	ldr	r3, [pc, #16]	; (1d60 <Calculate::SetHelp()+0x18>)
    1d4e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "A=Result1 B=Res2";
    1d50:	4b04      	ldr	r3, [pc, #16]	; (1d64 <Calculate::SetHelp()+0x1c>)
    1d52:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "Operation";
    1d54:	4b04      	ldr	r3, [pc, #16]	; (1d68 <Calculate::SetHelp()+0x20>)
    1d56:	6143      	str	r3, [r0, #20]
    }
    1d58:	4770      	bx	lr
    1d5a:	bf00      	nop
    1d5c:	00020632 	.word	0x00020632
    1d60:	00020637 	.word	0x00020637
    1d64:	00020643 	.word	0x00020643
    1d68:	00020654 	.word	0x00020654

00001d6c <Calculate_OnButtonPress(bool)>:
        selected = 1 - selected;
    1d6c:	4b06      	ldr	r3, [pc, #24]	; (1d88 <Calculate_OnButtonPress(bool)+0x1c>)
    1d6e:	22bc      	movs	r2, #188	; 0xbc
    1d70:	fb02 3000 	mla	r0, r2, r0, r3
    1d74:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4
    1d78:	f1c3 0301 	rsb	r3, r3, #1
    1d7c:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    1d80:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    1d84:	6483      	str	r3, [r0, #72]	; 0x48
    Calculate_instance[hemisphere].BaseView();
}

void Calculate_OnButtonPress(bool hemisphere) {
    Calculate_instance[hemisphere].OnButtonPress();
}
    1d86:	4770      	bx	lr
    1d88:	1fffc670 	.word	0x1fffc670

00001d8c <Calculate_OnEncoderMove(bool, int)>:
        operation[selected] = constrain(operation[selected] += direction, 0, HEMISPHERE_NUMBER_OF_CALC - 1);
    1d8c:	4b0c      	ldr	r3, [pc, #48]	; (1dc0 <Calculate_OnEncoderMove(bool, int)+0x34>)
    1d8e:	22bc      	movs	r2, #188	; 0xbc
    1d90:	fb02 3200 	mla	r2, r2, r0, r3

void Calculate_OnEncoderMove(bool hemisphere, int direction) {
    1d94:	b530      	push	{r4, r5, lr}
        operation[selected] = constrain(operation[selected] += direction, 0, HEMISPHERE_NUMBER_OF_CALC - 1);
    1d96:	f8d2 40b4 	ldr.w	r4, [r2, #180]	; 0xb4
    1d9a:	252f      	movs	r5, #47	; 0x2f
    1d9c:	fb05 4000 	mla	r0, r5, r0, r4
    1da0:	302a      	adds	r0, #42	; 0x2a
    1da2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
        rand_clocked[selected] = 0;
    1da6:	4422      	add	r2, r4
        operation[selected] = constrain(operation[selected] += direction, 0, HEMISPHERE_NUMBER_OF_CALC - 1);
    1da8:	6843      	ldr	r3, [r0, #4]
    1daa:	440b      	add	r3, r1
    1dac:	2b06      	cmp	r3, #6
    1dae:	bfa8      	it	ge
    1db0:	2306      	movge	r3, #6
    1db2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    1db6:	6043      	str	r3, [r0, #4]
        rand_clocked[selected] = 0;
    1db8:	2300      	movs	r3, #0
    1dba:	f882 30b8 	strb.w	r3, [r2, #184]	; 0xb8
    Calculate_instance[hemisphere].OnEncoderMove(direction);
}
    1dbe:	bd30      	pop	{r4, r5, pc}
    1dc0:	1fffc670 	.word	0x1fffc670

00001dc4 <Calculate_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    1dc4:	4b04      	ldr	r3, [pc, #16]	; (1dd8 <Calculate_ToggleHelpScreen(bool)+0x14>)
    1dc6:	22bc      	movs	r2, #188	; 0xbc
    1dc8:	fb02 3000 	mla	r0, r2, r0, r3
    1dcc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1dce:	f1c3 0301 	rsb	r3, r3, #1
    1dd2:	65c3      	str	r3, [r0, #92]	; 0x5c

void Calculate_ToggleHelpScreen(bool hemisphere) {
    Calculate_instance[hemisphere].HelpScreen();
}
    1dd4:	4770      	bx	lr
    1dd6:	bf00      	nop
    1dd8:	1fffc670 	.word	0x1fffc670

00001ddc <Calculate_OnDataRequest(bool)>:
        Pack(data, PackLocation {8, 8}, operation[1]);
    1ddc:	4b05      	ldr	r3, [pc, #20]	; (1df4 <Calculate_OnDataRequest(bool)+0x18>)
    1dde:	22bc      	movs	r2, #188	; 0xbc
    1de0:	fb02 3300 	mla	r3, r2, r0, r3
        data |= (value << p.location);
    1de4:	f8d3 00b0 	ldr.w	r0, [r3, #176]	; 0xb0
    1de8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac

uint32_t Calculate_OnDataRequest(bool hemisphere) {
    return Calculate_instance[hemisphere].OnDataRequest();
}
    1dec:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    1df0:	4770      	bx	lr
    1df2:	bf00      	nop
    1df4:	1fffc670 	.word	0x1fffc670

00001df8 <Carpeggio::applet_name()>:
class Carpeggio : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Carpeggio";
    }
    1df8:	4800      	ldr	r0, [pc, #0]	; (1dfc <Carpeggio::applet_name()+0x4>)
    1dfa:	4770      	bx	lr
    1dfc:	0002065e 	.word	0x0002065e

00001e00 <Carpeggio::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Reset";
    1e00:	4b04      	ldr	r3, [pc, #16]	; (1e14 <Carpeggio::SetHelp()+0x14>)
    1e02:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=X 2=Y";
    1e04:	4b04      	ldr	r3, [pc, #16]	; (1e18 <Carpeggio::SetHelp()+0x18>)
    1e06:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Quant B=(XY)/5V";
    1e08:	4b04      	ldr	r3, [pc, #16]	; (1e1c <Carpeggio::SetHelp()+0x1c>)
    1e0a:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Note/Chord/Trnspos";
    1e0c:	4b04      	ldr	r3, [pc, #16]	; (1e20 <Carpeggio::SetHelp()+0x20>)
    1e0e:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    1e10:	4770      	bx	lr
    1e12:	bf00      	nop
    1e14:	00020480 	.word	0x00020480
    1e18:	00020668 	.word	0x00020668
    1e1c:	00020670 	.word	0x00020670
    1e20:	00020682 	.word	0x00020682

00001e24 <Carpeggio_OnEncoderMove(bool, int)>:

void Carpeggio_OnButtonPress(bool hemisphere) {
    Carpeggio_instance[hemisphere].OnButtonPress();
}

void Carpeggio_OnEncoderMove(bool hemisphere, int direction) {
    1e24:	b530      	push	{r4, r5, lr}
        if (cursor == 0) sequence[step] = constrain(sequence[step] += direction, -24, 60);
    1e26:	4c22      	ldr	r4, [pc, #136]	; (1eb0 <Carpeggio_OnEncoderMove(bool, int)+0x8c>)
    1e28:	23a8      	movs	r3, #168	; 0xa8
    1e2a:	fb03 4300 	mla	r3, r3, r0, r4
    1e2e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    1e30:	bb02      	cbnz	r2, 1e74 <Carpeggio_OnEncoderMove(bool, int)+0x50>
    1e32:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
    1e36:	2554      	movs	r5, #84	; 0x54
    1e38:	fb05 3200 	mla	r2, r5, r0, r3
    1e3c:	eb04 0242 	add.w	r2, r4, r2, lsl #1
    1e40:	f8b2 2072 	ldrh.w	r2, [r2, #114]	; 0x72
    1e44:	4411      	add	r1, r2
    1e46:	b209      	sxth	r1, r1
    1e48:	f111 0f18 	cmn.w	r1, #24
    1e4c:	db0f      	blt.n	1e6e <Carpeggio_OnEncoderMove(bool, int)+0x4a>
    1e4e:	293c      	cmp	r1, #60	; 0x3c
    1e50:	bfa8      	it	ge
    1e52:	213c      	movge	r1, #60	; 0x3c
    1e54:	fb05 3300 	mla	r3, r5, r0, r3
    1e58:	eb04 0343 	add.w	r3, r4, r3, lsl #1
    1e5c:	f8a3 1072 	strh.w	r1, [r3, #114]	; 0x72
        if (cursor != 1) replay = 1;
    1e60:	23a8      	movs	r3, #168	; 0xa8
    1e62:	fb03 4300 	mla	r3, r3, r0, r4
    1e66:	2201      	movs	r2, #1
    1e68:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
    Carpeggio_instance[hemisphere].OnEncoderMove(direction);
}
    1e6c:	e00e      	b.n	1e8c <Carpeggio_OnEncoderMove(bool, int)+0x68>
        if (cursor == 0) sequence[step] = constrain(sequence[step] += direction, -24, 60);
    1e6e:	f06f 0117 	mvn.w	r1, #23
    1e72:	e7ef      	b.n	1e54 <Carpeggio_OnEncoderMove(bool, int)+0x30>
        if (cursor == 1) chord = constrain(chord += direction, 0, Nr_of_arp_chords - 1);
    1e74:	2a01      	cmp	r2, #1
    1e76:	d10a      	bne.n	1e8e <Carpeggio_OnEncoderMove(bool, int)+0x6a>
    1e78:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    1e7c:	440a      	add	r2, r1
    1e7e:	2a36      	cmp	r2, #54	; 0x36
    1e80:	bfa8      	it	ge
    1e82:	2236      	movge	r2, #54	; 0x36
    1e84:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    1e88:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    1e8c:	bd30      	pop	{r4, r5, pc}
        if (cursor == 2) transpose = constrain(transpose += direction, -24, 24);
    1e8e:	2a02      	cmp	r2, #2
    1e90:	d1e6      	bne.n	1e60 <Carpeggio_OnEncoderMove(bool, int)+0x3c>
    1e92:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    1e96:	440a      	add	r2, r1
    1e98:	2a18      	cmp	r2, #24
    1e9a:	bfa8      	it	ge
    1e9c:	2218      	movge	r2, #24
    1e9e:	f06f 0117 	mvn.w	r1, #23
    1ea2:	428a      	cmp	r2, r1
    1ea4:	bfac      	ite	ge
    1ea6:	f8c3 209c 	strge.w	r2, [r3, #156]	; 0x9c
    1eaa:	f8c3 109c 	strlt.w	r1, [r3, #156]	; 0x9c
        if (cursor != 1) replay = 1;
    1eae:	e7d7      	b.n	1e60 <Carpeggio_OnEncoderMove(bool, int)+0x3c>
    1eb0:	1fffc7e8 	.word	0x1fffc7e8

00001eb4 <Carpeggio_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    1eb4:	4b04      	ldr	r3, [pc, #16]	; (1ec8 <Carpeggio_ToggleHelpScreen(bool)+0x14>)
    1eb6:	22a8      	movs	r2, #168	; 0xa8
    1eb8:	fb02 3000 	mla	r0, r2, r0, r3
    1ebc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1ebe:	f1c3 0301 	rsb	r3, r3, #1
    1ec2:	65c3      	str	r3, [r0, #92]	; 0x5c

void Carpeggio_ToggleHelpScreen(bool hemisphere) {
    Carpeggio_instance[hemisphere].HelpScreen();
}
    1ec4:	4770      	bx	lr
    1ec6:	bf00      	nop
    1ec8:	1fffc7e8 	.word	0x1fffc7e8

00001ecc <Carpeggio_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, transpose + 24);
    1ecc:	4b05      	ldr	r3, [pc, #20]	; (1ee4 <Carpeggio_OnDataRequest(bool)+0x18>)
    1ece:	22a8      	movs	r2, #168	; 0xa8
    1ed0:	fb02 3300 	mla	r3, r2, r0, r3
    1ed4:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
        data |= (value << p.location);
    1ed8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    1edc:	3018      	adds	r0, #24

uint32_t Carpeggio_OnDataRequest(bool hemisphere) {
    return Carpeggio_instance[hemisphere].OnDataRequest();
}
    1ede:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    1ee2:	4770      	bx	lr
    1ee4:	1fffc7e8 	.word	0x1fffc7e8

00001ee8 <ClockDivider::applet_name()>:
class ClockDivider : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Clock Div";
    }
    1ee8:	4800      	ldr	r0, [pc, #0]	; (1eec <ClockDivider::applet_name()+0x4>)
    1eea:	4770      	bx	lr
    1eec:	00020695 	.word	0x00020695

00001ef0 <ClockDivider::Start()>:

    void Start() {
        ForEachChannel(ch)
        {
            div[ch] = ch + 1;
    1ef0:	2301      	movs	r3, #1
    1ef2:	66c3      	str	r3, [r0, #108]	; 0x6c
    1ef4:	2202      	movs	r2, #2
            count[ch] = 0;
    1ef6:	2300      	movs	r3, #0
    1ef8:	6743      	str	r3, [r0, #116]	; 0x74
            next_clock[ch] = 0;
    1efa:	67c3      	str	r3, [r0, #124]	; 0x7c
            div[ch] = ch + 1;
    1efc:	6702      	str	r2, [r0, #112]	; 0x70
            count[ch] = 0;
    1efe:	6783      	str	r3, [r0, #120]	; 0x78
            next_clock[ch] = 0;
    1f00:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
        }
        cycle_time = 0;
    1f04:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
        cursor = 0;
    1f08:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    }
    1f0c:	4770      	bx	lr
    1f0e:	Address 0x0000000000001f0e is out of bounds.


00001f10 <ClockDivider::SetHelp()>:
        div[1] = Unpack(data, PackLocation {8,8}) - 32;
    }

protected:
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Reset";
    1f10:	4b04      	ldr	r3, [pc, #16]	; (1f24 <ClockDivider::SetHelp()+0x14>)
    1f12:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "Div/Mult Ch1,Ch2";
    1f14:	4b04      	ldr	r3, [pc, #16]	; (1f28 <ClockDivider::SetHelp()+0x18>)
    1f16:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "Clk A=Ch1 B=Ch2";
    1f18:	4b04      	ldr	r3, [pc, #16]	; (1f2c <ClockDivider::SetHelp()+0x1c>)
    1f1a:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "Div,Mult";
    1f1c:	4b04      	ldr	r3, [pc, #16]	; (1f30 <ClockDivider::SetHelp()+0x20>)
    1f1e:	6143      	str	r3, [r0, #20]
    }
    1f20:	4770      	bx	lr
    1f22:	bf00      	nop
    1f24:	00020480 	.word	0x00020480
    1f28:	0002069f 	.word	0x0002069f
    1f2c:	000206b0 	.word	0x000206b0
    1f30:	000206c0 	.word	0x000206c0

00001f34 <ClockDivider_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    1f34:	4b06      	ldr	r3, [pc, #24]	; (1f50 <ClockDivider_OnButtonPress(bool)+0x1c>)
    1f36:	228c      	movs	r2, #140	; 0x8c
    1f38:	fb02 3000 	mla	r0, r2, r0, r3
    1f3c:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
    1f40:	f1c3 0301 	rsb	r3, r3, #1
    1f44:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    1f48:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    1f4c:	6483      	str	r3, [r0, #72]	; 0x48
    ClockDivider_instance[hemisphere].BaseView();
}

void ClockDivider_OnButtonPress(bool hemisphere) {
    ClockDivider_instance[hemisphere].OnButtonPress();
}
    1f4e:	4770      	bx	lr
    1f50:	1fffc938 	.word	0x1fffc938

00001f54 <ClockDivider_OnEncoderMove(bool, int)>:

void ClockDivider_OnEncoderMove(bool hemisphere, int direction) {
    1f54:	b530      	push	{r4, r5, lr}
        div[cursor] += direction;
    1f56:	4d1c      	ldr	r5, [pc, #112]	; (1fc8 <ClockDivider_OnEncoderMove(bool, int)+0x74>)
    1f58:	238c      	movs	r3, #140	; 0x8c
    1f5a:	fb03 5300 	mla	r3, r3, r0, r5
    1f5e:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
    1f62:	2323      	movs	r3, #35	; 0x23
    1f64:	fb03 4300 	mla	r3, r3, r0, r4
    1f68:	331a      	adds	r3, #26
    1f6a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    1f6e:	685a      	ldr	r2, [r3, #4]
    1f70:	440a      	add	r2, r1
        if (div[cursor] > HEM_CLOCKDIV_MAX) div[cursor] = HEM_CLOCKDIV_MAX;
    1f72:	2a08      	cmp	r2, #8
    1f74:	dc1c      	bgt.n	1fb0 <ClockDivider_OnEncoderMove(bool, int)+0x5c>
        if (div[cursor] < -HEM_CLOCKDIV_MAX) div[cursor] = -HEM_CLOCKDIV_MAX;
    1f76:	f112 0f08 	cmn.w	r2, #8
    1f7a:	605a      	str	r2, [r3, #4]
    1f7c:	db1a      	blt.n	1fb4 <ClockDivider_OnEncoderMove(bool, int)+0x60>
        if (div[cursor] == 0) div[cursor] = direction > 0 ? 1 : -2; // No such thing as 1/1 Multiple
    1f7e:	b1e2      	cbz	r2, 1fba <ClockDivider_OnEncoderMove(bool, int)+0x66>
    1f80:	2323      	movs	r3, #35	; 0x23
    1f82:	fb03 4300 	mla	r3, r3, r0, r4
    1f86:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    1f8a:	66da      	str	r2, [r3, #108]	; 0x6c
        if (div[cursor] == -1) div[cursor] = 1; // Must be moving up to hit -1 (see previous line)
    1f8c:	2323      	movs	r3, #35	; 0x23
    1f8e:	fb03 4400 	mla	r4, r3, r0, r4
    1f92:	f104 031a 	add.w	r3, r4, #26
    1f96:	eb05 0383 	add.w	r3, r5, r3, lsl #2
        count[cursor] = 0; // Start the count over so things aren't missed
    1f9a:	341c      	adds	r4, #28
        if (div[cursor] == -1) div[cursor] = 1; // Must be moving up to hit -1 (see previous line)
    1f9c:	685a      	ldr	r2, [r3, #4]
    1f9e:	1c51      	adds	r1, r2, #1
    1fa0:	bf08      	it	eq
    1fa2:	2201      	moveq	r2, #1
        count[cursor] = 0; // Start the count over so things aren't missed
    1fa4:	eb05 0584 	add.w	r5, r5, r4, lsl #2
    1fa8:	605a      	str	r2, [r3, #4]
    1faa:	2300      	movs	r3, #0
    1fac:	606b      	str	r3, [r5, #4]
    ClockDivider_instance[hemisphere].OnEncoderMove(direction);
}
    1fae:	bd30      	pop	{r4, r5, pc}
        if (div[cursor] > HEM_CLOCKDIV_MAX) div[cursor] = HEM_CLOCKDIV_MAX;
    1fb0:	2208      	movs	r2, #8
    1fb2:	e7e5      	b.n	1f80 <ClockDivider_OnEncoderMove(bool, int)+0x2c>
        if (div[cursor] < -HEM_CLOCKDIV_MAX) div[cursor] = -HEM_CLOCKDIV_MAX;
    1fb4:	f06f 0207 	mvn.w	r2, #7
    1fb8:	e7e2      	b.n	1f80 <ClockDivider_OnEncoderMove(bool, int)+0x2c>
        if (div[cursor] == 0) div[cursor] = direction > 0 ? 1 : -2; // No such thing as 1/1 Multiple
    1fba:	2900      	cmp	r1, #0
    1fbc:	bfcc      	ite	gt
    1fbe:	2201      	movgt	r2, #1
    1fc0:	f06f 0201 	mvnle.w	r2, #1
    1fc4:	605a      	str	r2, [r3, #4]
    1fc6:	e7e1      	b.n	1f8c <ClockDivider_OnEncoderMove(bool, int)+0x38>
    1fc8:	1fffc938 	.word	0x1fffc938

00001fcc <ClockDivider_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    1fcc:	4b04      	ldr	r3, [pc, #16]	; (1fe0 <ClockDivider_ToggleHelpScreen(bool)+0x14>)
    1fce:	228c      	movs	r2, #140	; 0x8c
    1fd0:	fb02 3000 	mla	r0, r2, r0, r3
    1fd4:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    1fd6:	f1c3 0301 	rsb	r3, r3, #1
    1fda:	65c3      	str	r3, [r0, #92]	; 0x5c

void ClockDivider_ToggleHelpScreen(bool hemisphere) {
    ClockDivider_instance[hemisphere].HelpScreen();
}
    1fdc:	4770      	bx	lr
    1fde:	bf00      	nop
    1fe0:	1fffc938 	.word	0x1fffc938

00001fe4 <ClockDivider_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, div[1] + 32);
    1fe4:	4b05      	ldr	r3, [pc, #20]	; (1ffc <ClockDivider_OnDataRequest(bool)+0x18>)
    1fe6:	228c      	movs	r2, #140	; 0x8c
    1fe8:	fb02 3300 	mla	r3, r2, r0, r3
    1fec:	6f18      	ldr	r0, [r3, #112]	; 0x70
        Pack(data, PackLocation {0,8}, div[0] + 32);
    1fee:	6edb      	ldr	r3, [r3, #108]	; 0x6c
        Pack(data, PackLocation {8,8}, div[1] + 32);
    1ff0:	3020      	adds	r0, #32
        Pack(data, PackLocation {0,8}, div[0] + 32);
    1ff2:	3320      	adds	r3, #32

uint32_t ClockDivider_OnDataRequest(bool hemisphere) {
    return ClockDivider_instance[hemisphere].OnDataRequest();
}
    1ff4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    1ff8:	4770      	bx	lr
    1ffa:	bf00      	nop
    1ffc:	1fffc938 	.word	0x1fffc938

00002000 <ClockSetup::applet_name()>:
class ClockSetup : public HemisphereApplet {
public:

    const char* applet_name() {
        return "ClockSet";
    }
    2000:	4800      	ldr	r0, [pc, #0]	; (2004 <ClockSetup::applet_name()+0x4>)
    2002:	4770      	bx	lr
    2004:	000206c9 	.word	0x000206c9

00002008 <ClockSetup::Start()>:

    void Start() { }
    2008:	4770      	bx	lr

0000200a <ClockSetup::Controller()>:

    // When the ClockSetup is active, the selected applets should continue to function, so
    // there's no need to have a controller for ClockSetup.
    void Controller() { }
    200a:	4770      	bx	lr

0000200c <ClockSetup::SetHelp()>:
    void OnDataReceive(uint32_t data) { }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    200c:	4b02      	ldr	r3, [pc, #8]	; (2018 <ClockSetup::SetHelp()+0xc>)
    200e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "";
    2010:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "";
    2012:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "";
    2014:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2016:	4770      	bx	lr
    2018:	000211c8 	.word	0x000211c8

0000201c <ClockSetup_OnButtonPress(bool)>:
        if (++cursor > 2) cursor = 0;
    201c:	4b05      	ldr	r3, [pc, #20]	; (2034 <ClockSetup_OnButtonPress(bool)+0x18>)
    201e:	2274      	movs	r2, #116	; 0x74
    2020:	fb02 3000 	mla	r0, r2, r0, r3
    2024:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    2026:	3301      	adds	r3, #1
    2028:	2b03      	cmp	r3, #3
    202a:	bfa8      	it	ge
    202c:	2300      	movge	r3, #0
    202e:	66c3      	str	r3, [r0, #108]	; 0x6c
ClockSetup ClockSetup_instance[1];

void ClockSetup_Start(bool hemisphere) {ClockSetup_instance[hemisphere].BaseStart(hemisphere);}
void ClockSetup_Controller(bool hemisphere, bool forwarding) {ClockSetup_instance[hemisphere].BaseController(forwarding);}
void ClockSetup_View(bool hemisphere) {ClockSetup_instance[hemisphere].BaseView();}
void ClockSetup_OnButtonPress(bool hemisphere) {ClockSetup_instance[hemisphere].OnButtonPress();}
    2030:	4770      	bx	lr
    2032:	bf00      	nop
    2034:	1fffca50 	.word	0x1fffca50

00002038 <ClockSetup_ToggleHelpScreen(bool)>:
    2038:	4b04      	ldr	r3, [pc, #16]	; (204c <ClockSetup_ToggleHelpScreen(bool)+0x14>)
    203a:	2274      	movs	r2, #116	; 0x74
    203c:	fb02 3000 	mla	r0, r2, r0, r3
    2040:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2042:	f1c3 0301 	rsb	r3, r3, #1
    2046:	65c3      	str	r3, [r0, #92]	; 0x5c
void ClockSetup_OnEncoderMove(bool hemisphere, int direction) {ClockSetup_instance[hemisphere].OnEncoderMove(direction);}
void ClockSetup_ToggleHelpScreen(bool hemisphere) {ClockSetup_instance[hemisphere].HelpScreen();}
    2048:	4770      	bx	lr
    204a:	bf00      	nop
    204c:	1fffca50 	.word	0x1fffca50

00002050 <ClockSkip::applet_name()>:
class ClockSkip : public HemisphereApplet {
public:

    const char* applet_name() {
        return "ClockSkip";
    }
    2050:	4800      	ldr	r0, [pc, #0]	; (2054 <ClockSkip::applet_name()+0x4>)
    2052:	4770      	bx	lr
    2054:	000206d2 	.word	0x000206d2

00002058 <ClockSkip::Start()>:

    void Start() {
        ForEachChannel(ch)
        {
            p[ch] = 100 - (25 * ch);
    2058:	4b02      	ldr	r3, [pc, #8]	; (2064 <ClockSkip::Start()+0xc>)
    205a:	66c3      	str	r3, [r0, #108]	; 0x6c
            trigger_countdown[ch] = 0;
    205c:	2300      	movs	r3, #0
    205e:	6703      	str	r3, [r0, #112]	; 0x70
    2060:	6743      	str	r3, [r0, #116]	; 0x74
        }
    }
    2062:	4770      	bx	lr
    2064:	004b0064 	.word	0x004b0064

00002068 <ClockSkip::SetHelp()>:
        p[1] = Unpack(data, PackLocation {7,7});
    }

protected:
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "Clock Ch1, Ch2";
    2068:	4b03      	ldr	r3, [pc, #12]	; (2078 <ClockSkip::SetHelp()+0x10>)
        help[HEMISPHERE_HELP_CVS]      = "p Mod Ch1, Ch2";
    206a:	4a04      	ldr	r2, [pc, #16]	; (207c <ClockSkip::SetHelp()+0x14>)
        help[HEMISPHERE_HELP_DIGITALS] = "Clock Ch1, Ch2";
    206c:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_OUTS]     = "Clock Ch1, Ch2";
    206e:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Set p";
    2070:	4b03      	ldr	r3, [pc, #12]	; (2080 <ClockSkip::SetHelp()+0x18>)
        help[HEMISPHERE_HELP_CVS]      = "p Mod Ch1, Ch2";
    2072:	60c2      	str	r2, [r0, #12]
        help[HEMISPHERE_HELP_ENCODER]  = "Set p";
    2074:	6143      	str	r3, [r0, #20]
    }
    2076:	4770      	bx	lr
    2078:	000206dc 	.word	0x000206dc
    207c:	000206eb 	.word	0x000206eb
    2080:	000205a3 	.word	0x000205a3

00002084 <ClockSkip_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    2084:	4b05      	ldr	r3, [pc, #20]	; (209c <ClockSkip_OnButtonPress(bool)+0x18>)
    2086:	227c      	movs	r2, #124	; 0x7c
    2088:	fb02 3000 	mla	r0, r2, r0, r3
    208c:	f890 3078 	ldrb.w	r3, [r0, #120]	; 0x78
    2090:	f1c3 0301 	rsb	r3, r3, #1
    2094:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
    ClockSkip_instance[hemisphere].BaseView();
}

void ClockSkip_OnButtonPress(bool hemisphere) {
    ClockSkip_instance[hemisphere].OnButtonPress();
}
    2098:	4770      	bx	lr
    209a:	bf00      	nop
    209c:	1fffcac4 	.word	0x1fffcac4

000020a0 <ClockSkip_OnEncoderMove(bool, int)>:
        p[cursor] = constrain(p[cursor] += direction, 0, 100);
    20a0:	4b0e      	ldr	r3, [pc, #56]	; (20dc <ClockSkip_OnEncoderMove(bool, int)+0x3c>)
    20a2:	227c      	movs	r2, #124	; 0x7c
    20a4:	fb02 3200 	mla	r2, r2, r0, r3

void ClockSkip_OnEncoderMove(bool hemisphere, int direction) {
    20a8:	b530      	push	{r4, r5, lr}
        p[cursor] = constrain(p[cursor] += direction, 0, 100);
    20aa:	f892 2078 	ldrb.w	r2, [r2, #120]	; 0x78
    20ae:	253e      	movs	r5, #62	; 0x3e
    20b0:	fb05 2400 	mla	r4, r5, r0, r2
    20b4:	eb03 0444 	add.w	r4, r3, r4, lsl #1
    20b8:	f8b4 406c 	ldrh.w	r4, [r4, #108]	; 0x6c
    20bc:	4421      	add	r1, r4
    20be:	b209      	sxth	r1, r1
    20c0:	2900      	cmp	r1, #0
    20c2:	db09      	blt.n	20d8 <ClockSkip_OnEncoderMove(bool, int)+0x38>
    20c4:	2964      	cmp	r1, #100	; 0x64
    20c6:	bfa8      	it	ge
    20c8:	2164      	movge	r1, #100	; 0x64
    20ca:	fb05 2200 	mla	r2, r5, r0, r2
    20ce:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    20d2:	f8a3 106c 	strh.w	r1, [r3, #108]	; 0x6c
    ClockSkip_instance[hemisphere].OnEncoderMove(direction);
}
    20d6:	bd30      	pop	{r4, r5, pc}
        p[cursor] = constrain(p[cursor] += direction, 0, 100);
    20d8:	2100      	movs	r1, #0
    20da:	e7f6      	b.n	20ca <ClockSkip_OnEncoderMove(bool, int)+0x2a>
    20dc:	1fffcac4 	.word	0x1fffcac4

000020e0 <ClockSkip_ToggleHelpScreen(bool)>:
    20e0:	4b04      	ldr	r3, [pc, #16]	; (20f4 <ClockSkip_ToggleHelpScreen(bool)+0x14>)
    20e2:	227c      	movs	r2, #124	; 0x7c
    20e4:	fb02 3000 	mla	r0, r2, r0, r3
    20e8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    20ea:	f1c3 0301 	rsb	r3, r3, #1
    20ee:	65c3      	str	r3, [r0, #92]	; 0x5c

void ClockSkip_ToggleHelpScreen(bool hemisphere) {
    ClockSkip_instance[hemisphere].HelpScreen();
}
    20f0:	4770      	bx	lr
    20f2:	bf00      	nop
    20f4:	1fffcac4 	.word	0x1fffcac4

000020f8 <ClockSkip_OnDataRequest(bool)>:
        Pack(data, PackLocation {7,7}, p[1]);
    20f8:	4b05      	ldr	r3, [pc, #20]	; (2110 <ClockSkip_OnDataRequest(bool)+0x18>)
    20fa:	227c      	movs	r2, #124	; 0x7c
    20fc:	fb02 3300 	mla	r3, r2, r0, r3
    2100:	f9b3 006e 	ldrsh.w	r0, [r3, #110]	; 0x6e
        Pack(data, PackLocation {0,7}, p[0]);
    2104:	f9b3 306c 	ldrsh.w	r3, [r3, #108]	; 0x6c

uint32_t ClockSkip_OnDataRequest(bool hemisphere) {
    return ClockSkip_instance[hemisphere].OnDataRequest();
}
    2108:	ea43 10c0 	orr.w	r0, r3, r0, lsl #7
    210c:	4770      	bx	lr
    210e:	bf00      	nop
    2110:	1fffcac4 	.word	0x1fffcac4

00002114 <Compare::applet_name()>:
class Compare : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Compare";
    }
    2114:	4800      	ldr	r0, [pc, #0]	; (2118 <Compare::applet_name()+0x4>)
    2116:	4770      	bx	lr
    2118:	000206fa 	.word	0x000206fa

0000211c <Compare::Start()>:

    void Start() {
        level = 128;
    211c:	2380      	movs	r3, #128	; 0x80
    211e:	66c3      	str	r3, [r0, #108]	; 0x6c
        mod_cv = 0;
    2120:	2300      	movs	r3, #0
    2122:	6703      	str	r3, [r0, #112]	; 0x70
    }
    2124:	4770      	bx	lr
    2126:	Address 0x0000000000002126 is out of bounds.


00002128 <Compare::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    2128:	4b04      	ldr	r3, [pc, #16]	; (213c <Compare::SetHelp()+0x14>)
    212a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=CV1 2=Mod Level";
    212c:	4b04      	ldr	r3, [pc, #16]	; (2140 <Compare::SetHelp()+0x18>)
    212e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=CV1>Lv B=Lv>=CV1";
    2130:	4b04      	ldr	r3, [pc, #16]	; (2144 <Compare::SetHelp()+0x1c>)
    2132:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Set Level";
    2134:	4b04      	ldr	r3, [pc, #16]	; (2148 <Compare::SetHelp()+0x20>)
    2136:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2138:	4770      	bx	lr
    213a:	bf00      	nop
    213c:	000211c8 	.word	0x000211c8
    2140:	00020702 	.word	0x00020702
    2144:	00020714 	.word	0x00020714
    2148:	00020727 	.word	0x00020727

0000214c <Compare_OnEncoderMove(bool, int)>:
        level = constrain(level += direction, 0, HEM_COMPARE_MAX_VALUE);
    214c:	4b04      	ldr	r3, [pc, #16]	; (2160 <Compare_OnEncoderMove(bool, int)+0x14>)
    214e:	2278      	movs	r2, #120	; 0x78
    2150:	fb02 3000 	mla	r0, r2, r0, r3
    2154:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    2156:	440b      	add	r3, r1
    2158:	f383 0308 	usat	r3, #8, r3
    215c:	66c3      	str	r3, [r0, #108]	; 0x6c
    Compare_instance[hemisphere].OnButtonPress();
}

void Compare_OnEncoderMove(bool hemisphere, int direction) {
    Compare_instance[hemisphere].OnEncoderMove(direction);
}
    215e:	4770      	bx	lr
    2160:	1fffcbbc 	.word	0x1fffcbbc

00002164 <Compare_ToggleHelpScreen(bool)>:
    2164:	4b04      	ldr	r3, [pc, #16]	; (2178 <Compare_ToggleHelpScreen(bool)+0x14>)
    2166:	2278      	movs	r2, #120	; 0x78
    2168:	fb02 3000 	mla	r0, r2, r0, r3
    216c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    216e:	f1c3 0301 	rsb	r3, r3, #1
    2172:	65c3      	str	r3, [r0, #92]	; 0x5c

void Compare_ToggleHelpScreen(bool hemisphere) {
    Compare_instance[hemisphere].HelpScreen();
}
    2174:	4770      	bx	lr
    2176:	bf00      	nop
    2178:	1fffcbbc 	.word	0x1fffcbbc

0000217c <Compare_OnDataRequest(bool)>:
        Pack(data, PackLocation {0,8}, level);
    217c:	4b02      	ldr	r3, [pc, #8]	; (2188 <Compare_OnDataRequest(bool)+0xc>)
    217e:	2278      	movs	r2, #120	; 0x78
    2180:	fb02 3300 	mla	r3, r2, r0, r3

uint32_t Compare_OnDataRequest(bool hemisphere) {
    return Compare_instance[hemisphere].OnDataRequest();
}
    2184:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
    2186:	4770      	bx	lr
    2188:	1fffcbbc 	.word	0x1fffcbbc

0000218c <DrCrusher::applet_name()>:
class DrCrusher : public HemisphereApplet {
public:

    const char* applet_name() {
        return "DrCrusher";
    }
    218c:	4800      	ldr	r0, [pc, #0]	; (2190 <DrCrusher::applet_name()+0x4>)
    218e:	4770      	bx	lr
    2190:	00020731 	.word	0x00020731

00002194 <DrCrusher::Start()>:

    void Start() {
    }
    2194:	4770      	bx	lr
    2196:	Address 0x0000000000002196 is out of bounds.


00002198 <DrCrusher::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Defeat";
    2198:	4b04      	ldr	r3, [pc, #16]	; (21ac <DrCrusher::SetHelp()+0x14>)
    219a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Input";
    219c:	4b04      	ldr	r3, [pc, #16]	; (21b0 <DrCrusher::SetHelp()+0x18>)
    219e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Crush B=Thru";
    21a0:	4b04      	ldr	r3, [pc, #16]	; (21b4 <DrCrusher::SetHelp()+0x1c>)
    21a2:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Rate/Depth";
    21a4:	4b04      	ldr	r3, [pc, #16]	; (21b8 <DrCrusher::SetHelp()+0x20>)
    21a6:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    21a8:	4770      	bx	lr
    21aa:	bf00      	nop
    21ac:	0002073b 	.word	0x0002073b
    21b0:	00020744 	.word	0x00020744
    21b4:	0002074c 	.word	0x0002074c
    21b8:	0002075b 	.word	0x0002075b

000021bc <DrCrusher_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    21bc:	4b05      	ldr	r3, [pc, #20]	; (21d4 <DrCrusher_OnButtonPress(bool)+0x18>)
    21be:	227c      	movs	r2, #124	; 0x7c
    21c0:	fb02 3000 	mla	r0, r2, r0, r3
    21c4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    21c6:	f1c3 0301 	rsb	r3, r3, #1
    21ca:	66c3      	str	r3, [r0, #108]	; 0x6c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    21cc:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    21d0:	6483      	str	r3, [r0, #72]	; 0x48
DrCrusher DrCrusher_instance[2];

void DrCrusher_Start(bool hemisphere) {DrCrusher_instance[hemisphere].BaseStart(hemisphere);}
void DrCrusher_Controller(bool hemisphere, bool forwarding) {DrCrusher_instance[hemisphere].BaseController(forwarding);}
void DrCrusher_View(bool hemisphere) {DrCrusher_instance[hemisphere].BaseView();}
void DrCrusher_OnButtonPress(bool hemisphere) {DrCrusher_instance[hemisphere].OnButtonPress();}
    21d2:	4770      	bx	lr
    21d4:	1fffccac 	.word	0x1fffccac

000021d8 <DrCrusher_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    21d8:	4b04      	ldr	r3, [pc, #16]	; (21ec <DrCrusher_ToggleHelpScreen(bool)+0x14>)
    21da:	227c      	movs	r2, #124	; 0x7c
    21dc:	fb02 3000 	mla	r0, r2, r0, r3
    21e0:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    21e2:	f1c3 0301 	rsb	r3, r3, #1
    21e6:	65c3      	str	r3, [r0, #92]	; 0x5c
void DrCrusher_OnEncoderMove(bool hemisphere, int direction) {DrCrusher_instance[hemisphere].OnEncoderMove(direction);}
void DrCrusher_ToggleHelpScreen(bool hemisphere) {DrCrusher_instance[hemisphere].HelpScreen();}
    21e8:	4770      	bx	lr
    21ea:	bf00      	nop
    21ec:	1fffccac 	.word	0x1fffccac

000021f0 <DrCrusher_OnDataRequest(bool)>:
        Pack(data, PackLocation {3,4}, depth);
    21f0:	4b04      	ldr	r3, [pc, #16]	; (2204 <DrCrusher_OnDataRequest(bool)+0x14>)
    21f2:	227c      	movs	r2, #124	; 0x7c
    21f4:	fb02 3300 	mla	r3, r2, r0, r3
        data |= (value << p.location);
    21f8:	6f58      	ldr	r0, [r3, #116]	; 0x74
    21fa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
uint32_t DrCrusher_OnDataRequest(bool hemisphere) {return DrCrusher_instance[hemisphere].OnDataRequest();}
    21fc:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
    2200:	4770      	bx	lr
    2202:	bf00      	nop
    2204:	1fffccac 	.word	0x1fffccac

00002208 <DualQuant::applet_name()>:
class DualQuant : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "DualQuant";
    }
    2208:	4800      	ldr	r0, [pc, #0]	; (220c <DualQuant::applet_name()+0x4>)
    220a:	4770      	bx	lr
    220c:	00020766 	.word	0x00020766

00002210 <DualQuant::SetHelp()>:
    }

protected:
    /* Set help text. Each help section can have up to 18 characters. Be concise! */
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "Clock 1=Ch1 2=Ch2";
    2210:	4b04      	ldr	r3, [pc, #16]	; (2224 <DualQuant::SetHelp()+0x14>)
    2212:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "CV 1=Ch1 2=Ch2";
    2214:	4b04      	ldr	r3, [pc, #16]	; (2228 <DualQuant::SetHelp()+0x18>)
    2216:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "Pitch A=Ch1 B=Ch2";
    2218:	4b04      	ldr	r3, [pc, #16]	; (222c <DualQuant::SetHelp()+0x1c>)
    221a:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "Scale/Root";
    221c:	4b04      	ldr	r3, [pc, #16]	; (2230 <DualQuant::SetHelp()+0x20>)
    221e:	6143      	str	r3, [r0, #20]
    }
    2220:	4770      	bx	lr
    2222:	bf00      	nop
    2224:	00020770 	.word	0x00020770
    2228:	00020782 	.word	0x00020782
    222c:	00020791 	.word	0x00020791
    2230:	000207a3 	.word	0x000207a3

00002234 <DualQuant_OnButtonPress(bool)>:
void DualQuant_View(bool hemisphere) {
    DualQuant_instance[hemisphere].BaseView();
}

void DualQuant_OnButtonPress(bool hemisphere) {
    DualQuant_instance[hemisphere].OnButtonPress();
    2234:	4b08      	ldr	r3, [pc, #32]	; (2258 <DualQuant_OnButtonPress(bool)+0x24>)
    2236:	f44f 723e 	mov.w	r2, #760	; 0x2f8
    223a:	fb02 3000 	mla	r0, r2, r0, r3
        if (++cursor > 3) cursor = 0;
    223e:	f8d0 32e8 	ldr.w	r3, [r0, #744]	; 0x2e8
    2242:	3301      	adds	r3, #1
    2244:	2b04      	cmp	r3, #4
    2246:	bfa8      	it	ge
    2248:	2300      	movge	r3, #0
    224a:	f8c0 32e8 	str.w	r3, [r0, #744]	; 0x2e8
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    224e:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    2252:	6483      	str	r3, [r0, #72]	; 0x48
}
    2254:	4770      	bx	lr
    2256:	bf00      	nop
    2258:	1fffcda4 	.word	0x1fffcda4

0000225c <DualQuant_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    225c:	4b04      	ldr	r3, [pc, #16]	; (2270 <DualQuant_ToggleHelpScreen(bool)+0x14>)
    225e:	f44f 723e 	mov.w	r2, #760	; 0x2f8
    2262:	fb02 3000 	mla	r0, r2, r0, r3
    2266:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2268:	f1c3 0301 	rsb	r3, r3, #1
    226c:	65c3      	str	r3, [r0, #92]	; 0x5c
    DualQuant_instance[hemisphere].OnEncoderMove(direction);
}

void DualQuant_ToggleHelpScreen(bool hemisphere) {
    DualQuant_instance[hemisphere].HelpScreen();
}
    226e:	4770      	bx	lr
    2270:	1fffcda4 	.word	0x1fffcda4

00002274 <DualQuant_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, scale[1]);
    2274:	4b09      	ldr	r3, [pc, #36]	; (229c <DualQuant_OnDataRequest(bool)+0x28>)
    2276:	f44f 723e 	mov.w	r2, #760	; 0x2f8
    227a:	fb02 3000 	mla	r0, r2, r0, r3
        Pack(data, PackLocation {16,4}, root[0]);
    227e:	f890 32f4 	ldrb.w	r3, [r0, #756]	; 0x2f4
        data |= (value << p.location);
    2282:	f8d0 22f0 	ldr.w	r2, [r0, #752]	; 0x2f0
    2286:	041b      	lsls	r3, r3, #16
    2288:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    228c:	f8d0 22ec 	ldr.w	r2, [r0, #748]	; 0x2ec
        Pack(data, PackLocation {20,4}, root[1]);
    2290:	f890 02f5 	ldrb.w	r0, [r0, #757]	; 0x2f5
    2294:	4313      	orrs	r3, r2

uint32_t DualQuant_OnDataRequest(bool hemisphere) {
    return DualQuant_instance[hemisphere].OnDataRequest();
}
    2296:	ea43 5000 	orr.w	r0, r3, r0, lsl #20
    229a:	4770      	bx	lr
    229c:	1fffcda4 	.word	0x1fffcda4

000022a0 <EnigmaJr::applet_name()>:
class EnigmaJr : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Enigma Jr";
    }
    22a0:	4800      	ldr	r0, [pc, #0]	; (22a4 <EnigmaJr::applet_name()+0x4>)
    22a2:	4770      	bx	lr
    22a4:	000207ae 	.word	0x000207ae

000022a8 <EnigmaJr::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock";
    22a8:	4b04      	ldr	r3, [pc, #16]	; (22bc <EnigmaJr::SetHelp()+0x14>)
    22aa:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Shift 2=Organize";
    22ac:	4b04      	ldr	r3, [pc, #16]	; (22c0 <EnigmaJr::SetHelp()+0x18>)
    22ae:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Assignable";
    22b0:	4b04      	ldr	r3, [pc, #16]	; (22c4 <EnigmaJr::SetHelp()+0x1c>)
    22b2:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Reg/Prob/Assign";
    22b4:	4b04      	ldr	r3, [pc, #16]	; (22c8 <EnigmaJr::SetHelp()+0x20>)
    22b6:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    22b8:	4770      	bx	lr
    22ba:	bf00      	nop
    22bc:	000207b8 	.word	0x000207b8
    22c0:	000207c0 	.word	0x000207c0
    22c4:	00020ce4 	.word	0x00020ce4
    22c8:	000207d3 	.word	0x000207d3

000022cc <EnigmaJr_OnButtonPress(bool)>:
        if (++cursor > 3) cursor = 0;
    22cc:	4b05      	ldr	r3, [pc, #20]	; (22e4 <EnigmaJr_OnButtonPress(bool)+0x18>)
    22ce:	f44f 7243 	mov.w	r2, #780	; 0x30c
    22d2:	fb02 3000 	mla	r0, r2, r0, r3
    22d6:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    22d8:	3301      	adds	r3, #1
    22da:	2b04      	cmp	r3, #4
    22dc:	bfa8      	it	ge
    22de:	2300      	movge	r3, #0
    22e0:	66c3      	str	r3, [r0, #108]	; 0x6c
EnigmaJr EnigmaJr_instance[2];

void EnigmaJr_Start(bool hemisphere) {EnigmaJr_instance[hemisphere].BaseStart(hemisphere);}
void EnigmaJr_Controller(bool hemisphere, bool forwarding) {EnigmaJr_instance[hemisphere].BaseController(forwarding);}
void EnigmaJr_View(bool hemisphere) {EnigmaJr_instance[hemisphere].BaseView();}
void EnigmaJr_OnButtonPress(bool hemisphere) {EnigmaJr_instance[hemisphere].OnButtonPress();}
    22e2:	4770      	bx	lr
    22e4:	1fffd394 	.word	0x1fffd394

000022e8 <EnigmaJr_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    22e8:	4b04      	ldr	r3, [pc, #16]	; (22fc <EnigmaJr_ToggleHelpScreen(bool)+0x14>)
    22ea:	f44f 7243 	mov.w	r2, #780	; 0x30c
    22ee:	fb02 3000 	mla	r0, r2, r0, r3
    22f2:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    22f4:	f1c3 0301 	rsb	r3, r3, #1
    22f8:	65c3      	str	r3, [r0, #92]	; 0x5c
void EnigmaJr_OnEncoderMove(bool hemisphere, int direction) {EnigmaJr_instance[hemisphere].OnEncoderMove(direction);}
void EnigmaJr_ToggleHelpScreen(bool hemisphere) {EnigmaJr_instance[hemisphere].HelpScreen();}
    22fa:	4770      	bx	lr
    22fc:	1fffd394 	.word	0x1fffd394

00002300 <EnigmaJr_OnDataRequest(bool)>:
uint32_t EnigmaJr_OnDataRequest(bool hemisphere) {return EnigmaJr_instance[hemisphere].OnDataRequest();}
    2300:	4b09      	ldr	r3, [pc, #36]	; (2328 <EnigmaJr_OnDataRequest(bool)+0x28>)
    2302:	f44f 7243 	mov.w	r2, #780	; 0x30c
    2306:	fb02 3000 	mla	r0, r2, r0, r3
        Pack(data, PackLocation {11,4}, output[1].type());
    230a:	f890 3301 	ldrb.w	r3, [r0, #769]	; 0x301
        Pack(data, PackLocation {7,4}, output[0].type());
    230e:	f890 21b9 	ldrb.w	r2, [r0, #441]	; 0x1b9
        data |= (value << p.location);
    2312:	02db      	lsls	r3, r3, #11
    2314:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
        Pack(data, PackLocation {0,7}, p);
    2318:	f990 2071 	ldrsb.w	r2, [r0, #113]	; 0x71
        Pack(data, PackLocation {15,16}, tm_state.GetTMIndex());
    231c:	f890 0304 	ldrb.w	r0, [r0, #772]	; 0x304
    2320:	4313      	orrs	r3, r2
uint32_t EnigmaJr_OnDataRequest(bool hemisphere) {return EnigmaJr_instance[hemisphere].OnDataRequest();}
    2322:	ea43 30c0 	orr.w	r0, r3, r0, lsl #15
    2326:	4770      	bx	lr
    2328:	1fffd394 	.word	0x1fffd394

0000232c <EnvFollow::applet_name()>:
class EnvFollow : public HemisphereApplet {
public:

    const char* applet_name() {
        return "EnvFollow";
    }
    232c:	4800      	ldr	r0, [pc, #0]	; (2330 <EnvFollow::applet_name()+0x4>)
    232e:	4770      	bx	lr
    2330:	000207e3 	.word	0x000207e3

00002334 <EnvFollow::Start()>:

    void Start() {
        ForEachChannel(ch)
        {
            max[ch] = 0;
    2334:	2300      	movs	r3, #0
    2336:	6703      	str	r3, [r0, #112]	; 0x70
    2338:	6743      	str	r3, [r0, #116]	; 0x74
            gain[ch] = 10;
    233a:	4b03      	ldr	r3, [pc, #12]	; (2348 <EnvFollow::Start()+0x14>)
    233c:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
            duck[ch] = ch; // Default: one of each
        }
        countdown = HEM_ENV_FOLLOWER_SAMPLES;
    2340:	23a6      	movs	r3, #166	; 0xa6
    2342:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
    }
    2346:	4770      	bx	lr
    2348:	01000a0a 	.word	0x01000a0a

0000234c <EnvFollow::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    234c:	4b04      	ldr	r3, [pc, #16]	; (2360 <EnvFollow::SetHelp()+0x14>)
    234e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "Inputs 1,2";
    2350:	4b04      	ldr	r3, [pc, #16]	; (2364 <EnvFollow::SetHelp()+0x18>)
    2352:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Follow/Duck";
    2354:	4b04      	ldr	r3, [pc, #16]	; (2368 <EnvFollow::SetHelp()+0x1c>)
    2356:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Gain/Assign";
    2358:	4b04      	ldr	r3, [pc, #16]	; (236c <EnvFollow::SetHelp()+0x20>)
    235a:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    235c:	4770      	bx	lr
    235e:	bf00      	nop
    2360:	000211c8 	.word	0x000211c8
    2364:	000204d3 	.word	0x000204d3
    2368:	000207ed 	.word	0x000207ed
    236c:	000207f9 	.word	0x000207f9

00002370 <EnvFollow_OnButtonPress(bool)>:
EnvFollow EnvFollow_instance[2];

void EnvFollow_Start(bool hemisphere) {EnvFollow_instance[hemisphere].BaseStart(hemisphere);}
void EnvFollow_Controller(bool hemisphere, bool forwarding) {EnvFollow_instance[hemisphere].BaseController(forwarding);}
void EnvFollow_View(bool hemisphere) {EnvFollow_instance[hemisphere].BaseView();}
void EnvFollow_OnButtonPress(bool hemisphere) {EnvFollow_instance[hemisphere].OnButtonPress();}
    2370:	4b08      	ldr	r3, [pc, #32]	; (2394 <EnvFollow_OnButtonPress(bool)+0x24>)
    2372:	2290      	movs	r2, #144	; 0x90
    2374:	fb02 3000 	mla	r0, r2, r0, r3
        if (++cursor > 3) cursor = 0;
    2378:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
    237c:	3301      	adds	r3, #1
    237e:	b2db      	uxtb	r3, r3
    2380:	2b04      	cmp	r3, #4
    2382:	bf28      	it	cs
    2384:	2300      	movcs	r3, #0
    2386:	f880 306c 	strb.w	r3, [r0, #108]	; 0x6c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    238a:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    238e:	6483      	str	r3, [r0, #72]	; 0x48
void EnvFollow_OnButtonPress(bool hemisphere) {EnvFollow_instance[hemisphere].OnButtonPress();}
    2390:	4770      	bx	lr
    2392:	bf00      	nop
    2394:	1fffe940 	.word	0x1fffe940

00002398 <EnvFollow_OnEncoderMove(bool, int)>:
void EnvFollow_OnEncoderMove(bool hemisphere, int direction) {EnvFollow_instance[hemisphere].OnEncoderMove(direction);}
    2398:	4b10      	ldr	r3, [pc, #64]	; (23dc <EnvFollow_OnEncoderMove(bool, int)+0x44>)
    239a:	2290      	movs	r2, #144	; 0x90
    239c:	fb02 3000 	mla	r0, r2, r0, r3
        if (cursor < 2) { // Gain per channel
    23a0:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
    23a4:	2b01      	cmp	r3, #1
    23a6:	d80f      	bhi.n	23c8 <EnvFollow_OnEncoderMove(bool, int)+0x30>
            gain[cursor] = constrain(gain[cursor] + direction, 1, 31);
    23a8:	4403      	add	r3, r0
    23aa:	f893 208c 	ldrb.w	r2, [r3, #140]	; 0x8c
    23ae:	4411      	add	r1, r2
    23b0:	291f      	cmp	r1, #31
    23b2:	bfa8      	it	ge
    23b4:	211f      	movge	r1, #31
    23b6:	2901      	cmp	r1, #1
    23b8:	bfb8      	it	lt
    23ba:	2101      	movlt	r1, #1
    23bc:	f883 108c 	strb.w	r1, [r3, #140]	; 0x8c
    23c0:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    23c4:	6483      	str	r3, [r0, #72]	; 0x48
void EnvFollow_OnEncoderMove(bool hemisphere, int direction) {EnvFollow_instance[hemisphere].OnEncoderMove(direction);}
    23c6:	4770      	bx	lr
            duck[cursor - 2] = 1 - duck[cursor - 2];
    23c8:	3b02      	subs	r3, #2
    23ca:	4403      	add	r3, r0
    23cc:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
    23d0:	f082 0201 	eor.w	r2, r2, #1
    23d4:	f883 208e 	strb.w	r2, [r3, #142]	; 0x8e
    23d8:	e7f2      	b.n	23c0 <EnvFollow_OnEncoderMove(bool, int)+0x28>
    23da:	bf00      	nop
    23dc:	1fffe940 	.word	0x1fffe940

000023e0 <EnvFollow_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    23e0:	4b04      	ldr	r3, [pc, #16]	; (23f4 <EnvFollow_ToggleHelpScreen(bool)+0x14>)
    23e2:	2290      	movs	r2, #144	; 0x90
    23e4:	fb02 3000 	mla	r0, r2, r0, r3
    23e8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    23ea:	f1c3 0301 	rsb	r3, r3, #1
    23ee:	65c3      	str	r3, [r0, #92]	; 0x5c
void EnvFollow_ToggleHelpScreen(bool hemisphere) {EnvFollow_instance[hemisphere].HelpScreen();}
    23f0:	4770      	bx	lr
    23f2:	bf00      	nop
    23f4:	1fffe940 	.word	0x1fffe940

000023f8 <GateDelay::applet_name()>:
class GateDelay : public HemisphereApplet {
public:

    const char* applet_name() {
        return "GateDelay";
    }
    23f8:	4800      	ldr	r0, [pc, #0]	; (23fc <GateDelay::applet_name()+0x4>)
    23fa:	4770      	bx	lr
    23fc:	00020805 	.word	0x00020805

00002400 <GateDelay::Start()>:

    void Start() {
    2400:	b538      	push	{r3, r4, r5, lr}
        ForEachChannel(ch)
        {
            for (int i = 0; i < 64; i++) tape[ch][i] = 0x0000;
    2402:	f44f 7580 	mov.w	r5, #256	; 0x100
    void Start() {
    2406:	4604      	mov	r4, r0
            for (int i = 0; i < 64; i++) tape[ch][i] = 0x0000;
    2408:	462a      	mov	r2, r5
    240a:	2100      	movs	r1, #0
    240c:	306c      	adds	r0, #108	; 0x6c
    240e:	f017 fec3 	bl	1a198 <memset>
    2412:	462a      	mov	r2, r5
    2414:	2100      	movs	r1, #0
    2416:	f504 70b6 	add.w	r0, r4, #364	; 0x16c
    241a:	f017 febd 	bl	1a198 <memset>
            time[ch] = 1000;
    241e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    2422:	f8c4 326c 	str.w	r3, [r4, #620]	; 0x26c
    2426:	f8c4 3270 	str.w	r3, [r4, #624]	; 0x270
            location[ch] = 0;
    242a:	2300      	movs	r3, #0
    242c:	f8c4 3274 	str.w	r3, [r4, #628]	; 0x274
            last_gate[ch] = 0;
    2430:	f8c4 3278 	str.w	r3, [r4, #632]	; 0x278
    2434:	f8c4 327c 	str.w	r3, [r4, #636]	; 0x27c
        }
        cursor = 0;
    2438:	f884 3280 	strb.w	r3, [r4, #640]	; 0x280
        ms_countdown = 0;
    243c:	f8a4 3282 	strh.w	r3, [r4, #642]	; 0x282
    }
    2440:	bd38      	pop	{r3, r4, r5, pc}
    2442:	Address 0x0000000000002442 is out of bounds.


00002444 <GateDelay::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "Gate Ch1,2";
    2444:	4b04      	ldr	r3, [pc, #16]	; (2458 <GateDelay::SetHelp()+0x14>)
    2446:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "Time Mod Ch1,Ch2";
    2448:	4b04      	ldr	r3, [pc, #16]	; (245c <GateDelay::SetHelp()+0x18>)
    244a:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Delay Ch1,2";
    244c:	4b04      	ldr	r3, [pc, #16]	; (2460 <GateDelay::SetHelp()+0x1c>)
    244e:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Set time";
    2450:	4b04      	ldr	r3, [pc, #16]	; (2464 <GateDelay::SetHelp()+0x20>)
    2452:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2454:	4770      	bx	lr
    2456:	bf00      	nop
    2458:	0002080f 	.word	0x0002080f
    245c:	0002081a 	.word	0x0002081a
    2460:	0002082b 	.word	0x0002082b
    2464:	00020837 	.word	0x00020837

00002468 <GateDelay_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    2468:	4b05      	ldr	r3, [pc, #20]	; (2480 <GateDelay_OnButtonPress(bool)+0x18>)
    246a:	f44f 7221 	mov.w	r2, #644	; 0x284
    246e:	fb02 3000 	mla	r0, r2, r0, r3
    2472:	f890 3280 	ldrb.w	r3, [r0, #640]	; 0x280
    2476:	f1c3 0301 	rsb	r3, r3, #1
    247a:	f880 3280 	strb.w	r3, [r0, #640]	; 0x280
    GateDelay_instance[hemisphere].BaseView();
}

void GateDelay_OnButtonPress(bool hemisphere) {
    GateDelay_instance[hemisphere].OnButtonPress();
}
    247e:	4770      	bx	lr
    2480:	1fffea60 	.word	0x1fffea60

00002484 <GateDelay_OnEncoderMove(bool, int)>:
        if (time[cursor] > 100) direction *= 2;
    2484:	4a15      	ldr	r2, [pc, #84]	; (24dc <GateDelay_OnEncoderMove(bool, int)+0x58>)
    2486:	f44f 7321 	mov.w	r3, #644	; 0x284
    248a:	fb03 2300 	mla	r3, r3, r0, r2

void GateDelay_OnEncoderMove(bool hemisphere, int direction) {
    248e:	b530      	push	{r4, r5, lr}
        if (time[cursor] > 100) direction *= 2;
    2490:	f893 4280 	ldrb.w	r4, [r3, #640]	; 0x280
    2494:	23a1      	movs	r3, #161	; 0xa1
    2496:	fb03 4300 	mla	r3, r3, r0, r4
    249a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    249e:	f8d3 326c 	ldr.w	r3, [r3, #620]	; 0x26c
    24a2:	2b64      	cmp	r3, #100	; 0x64
    24a4:	dd03      	ble.n	24ae <GateDelay_OnEncoderMove(bool, int)+0x2a>
        if (time[cursor] > 500) direction *= 2;
    24a6:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
    24aa:	dc10      	bgt.n	24ce <GateDelay_OnEncoderMove(bool, int)+0x4a>
        if (time[cursor] > 100) direction *= 2;
    24ac:	0049      	lsls	r1, r1, #1
        time[cursor] = constrain(time[cursor] += direction, 0, 2000);
    24ae:	440b      	add	r3, r1
    24b0:	25a1      	movs	r5, #161	; 0xa1
    24b2:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
    24b6:	fb05 4400 	mla	r4, r5, r0, r4
    24ba:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    24be:	bfa8      	it	ge
    24c0:	f44f 63fa 	movge.w	r3, #2000	; 0x7d0
    24c4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    24c8:	f8c2 326c 	str.w	r3, [r2, #620]	; 0x26c
    GateDelay_instance[hemisphere].OnEncoderMove(direction);
}
    24cc:	bd30      	pop	{r4, r5, pc}
        if (time[cursor] > 1000) direction *= 2;
    24ce:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
        if (time[cursor] > 500) direction *= 2;
    24d2:	bfd4      	ite	le
    24d4:	0089      	lslle	r1, r1, #2
        if (time[cursor] > 1000) direction *= 2;
    24d6:	00c9      	lslgt	r1, r1, #3
    24d8:	e7e9      	b.n	24ae <GateDelay_OnEncoderMove(bool, int)+0x2a>
    24da:	bf00      	nop
    24dc:	1fffea60 	.word	0x1fffea60

000024e0 <GateDelay_ToggleHelpScreen(bool)>:
    24e0:	4b04      	ldr	r3, [pc, #16]	; (24f4 <GateDelay_ToggleHelpScreen(bool)+0x14>)
    24e2:	f44f 7221 	mov.w	r2, #644	; 0x284
    24e6:	fb02 3000 	mla	r0, r2, r0, r3
    24ea:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    24ec:	f1c3 0301 	rsb	r3, r3, #1
    24f0:	65c3      	str	r3, [r0, #92]	; 0x5c

void GateDelay_ToggleHelpScreen(bool hemisphere) {
    GateDelay_instance[hemisphere].HelpScreen();
}
    24f2:	4770      	bx	lr
    24f4:	1fffea60 	.word	0x1fffea60

000024f8 <GateDelay_OnDataRequest(bool)>:
        Pack(data, PackLocation {11,11}, time[1]);
    24f8:	4b05      	ldr	r3, [pc, #20]	; (2510 <GateDelay_OnDataRequest(bool)+0x18>)
    24fa:	f44f 7221 	mov.w	r2, #644	; 0x284
    24fe:	fb02 3300 	mla	r3, r2, r0, r3
        data |= (value << p.location);
    2502:	f8d3 0270 	ldr.w	r0, [r3, #624]	; 0x270
    2506:	f8d3 326c 	ldr.w	r3, [r3, #620]	; 0x26c

uint32_t GateDelay_OnDataRequest(bool hemisphere) {
    return GateDelay_instance[hemisphere].OnDataRequest();
}
    250a:	ea43 20c0 	orr.w	r0, r3, r0, lsl #11
    250e:	4770      	bx	lr
    2510:	1fffea60 	.word	0x1fffea60

00002514 <GatedVCA::applet_name()>:
class GatedVCA : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "Gated VCA";
    }
    2514:	4800      	ldr	r0, [pc, #0]	; (2518 <GatedVCA::applet_name()+0x4>)
    2516:	4770      	bx	lr
    2518:	00020840 	.word	0x00020840

0000251c <GatedVCA::Start()>:

    void Start() {
        amp_offset_pct = 0;
    251c:	2300      	movs	r3, #0
    251e:	66c3      	str	r3, [r0, #108]	; 0x6c
        amp_offset_cv = 0;
    2520:	6703      	str	r3, [r0, #112]	; 0x70
    }
    2522:	4770      	bx	lr

00002524 <GatedVCA::SetHelp()>:
    void OnDataReceive(uint32_t data) {
    }

protected:
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "1=A Gate 2=B Revrs";
    2524:	4b04      	ldr	r3, [pc, #16]	; (2538 <GatedVCA::SetHelp()+0x14>)
    2526:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "1=CV signal 2=Amp";
    2528:	4b04      	ldr	r3, [pc, #16]	; (253c <GatedVCA::SetHelp()+0x18>)
    252a:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "A=Norm off B=N. on";
    252c:	4b04      	ldr	r3, [pc, #16]	; (2540 <GatedVCA::SetHelp()+0x1c>)
    252e:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "T=Amp CV Offset";
    2530:	4b04      	ldr	r3, [pc, #16]	; (2544 <GatedVCA::SetHelp()+0x20>)
    2532:	6143      	str	r3, [r0, #20]
    }
    2534:	4770      	bx	lr
    2536:	bf00      	nop
    2538:	0002084a 	.word	0x0002084a
    253c:	0002085d 	.word	0x0002085d
    2540:	0002086f 	.word	0x0002086f
    2544:	00020882 	.word	0x00020882

00002548 <GatedVCA_OnEncoderMove(bool, int)>:
        amp_offset_pct = constrain(amp_offset_pct += direction, 0, 100);
    2548:	4b0a      	ldr	r3, [pc, #40]	; (2574 <GatedVCA_OnEncoderMove(bool, int)+0x2c>)
    254a:	2274      	movs	r2, #116	; 0x74
    254c:	fb02 3000 	mla	r0, r2, r0, r3
    2550:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    2552:	4419      	add	r1, r3
    2554:	2964      	cmp	r1, #100	; 0x64
    2556:	bfa8      	it	ge
    2558:	2164      	movge	r1, #100	; 0x64
    255a:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    255e:	2364      	movs	r3, #100	; 0x64
    2560:	66c1      	str	r1, [r0, #108]	; 0x6c
    2562:	0389      	lsls	r1, r1, #14
    2564:	fbb1 f1f3 	udiv	r1, r1, r3
        int scaled = simfloat2int(proportion * max_value);
    2568:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    256c:	4359      	muls	r1, r3
    256e:	1389      	asrs	r1, r1, #14
        amp_offset_cv = Proportion(amp_offset_pct, 100, HEMISPHERE_MAX_CV);
    2570:	6701      	str	r1, [r0, #112]	; 0x70
    GatedVCA_instance[hemisphere].OnButtonPress();
}

void GatedVCA_OnEncoderMove(bool hemisphere, int direction) {
    GatedVCA_instance[hemisphere].OnEncoderMove(direction);
}
    2572:	4770      	bx	lr
    2574:	1fffef68 	.word	0x1fffef68

00002578 <GatedVCA_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2578:	4b04      	ldr	r3, [pc, #16]	; (258c <GatedVCA_ToggleHelpScreen(bool)+0x14>)
    257a:	2274      	movs	r2, #116	; 0x74
    257c:	fb02 3000 	mla	r0, r2, r0, r3
    2580:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2582:	f1c3 0301 	rsb	r3, r3, #1
    2586:	65c3      	str	r3, [r0, #92]	; 0x5c

void GatedVCA_ToggleHelpScreen(bool hemisphere) {
    GatedVCA_instance[hemisphere].HelpScreen();
}
    2588:	4770      	bx	lr
    258a:	bf00      	nop
    258c:	1fffef68 	.word	0x1fffef68

00002590 <LoFiPCM::applet_name()>:
class LoFiPCM : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "LoFi Tape";
    }
    2590:	4800      	ldr	r0, [pc, #0]	; (2594 <LoFiPCM::applet_name()+0x4>)
    2592:	4770      	bx	lr
    2594:	00020892 	.word	0x00020892

00002598 <LoFiPCM::Start()>:

    void Start() {
        countdown = HEM_LOFI_PCM_SPEED;
    2598:	2308      	movs	r3, #8
    259a:	f8c0 3874 	str.w	r3, [r0, #2164]	; 0x874
        for (int i = 0; i < HEM_LOFI_PCM_BUFFER_SIZE; i++) pcm[i] = 127;
    259e:	f44f 6200 	mov.w	r2, #2048	; 0x800
    25a2:	217f      	movs	r1, #127	; 0x7f
    25a4:	306c      	adds	r0, #108	; 0x6c
    25a6:	f017 bdf7 	b.w	1a198 <memset>
    25aa:	Address 0x00000000000025aa is out of bounds.


000025ac <LoFiPCM::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "Gate 1=Pause 2=Rec";
    25ac:	4b04      	ldr	r3, [pc, #16]	; (25c0 <LoFiPCM::SetHelp()+0x14>)
    25ae:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Audio 2=SOS";
    25b0:	4b04      	ldr	r3, [pc, #16]	; (25c4 <LoFiPCM::SetHelp()+0x18>)
    25b2:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Audio B=EOC Trg";
    25b4:	4b04      	ldr	r3, [pc, #16]	; (25c8 <LoFiPCM::SetHelp()+0x1c>)
    25b6:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "T=End Pt P=Rec";
    25b8:	4b04      	ldr	r3, [pc, #16]	; (25cc <LoFiPCM::SetHelp()+0x20>)
    25ba:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    25bc:	4770      	bx	lr
    25be:	bf00      	nop
    25c0:	0002089c 	.word	0x0002089c
    25c4:	000208af 	.word	0x000208af
    25c8:	000208bd 	.word	0x000208bd
    25cc:	000208cf 	.word	0x000208cf

000025d0 <LoFiPCM_OnButtonPress(bool)>:
        record = 1 - record;
    25d0:	4b08      	ldr	r3, [pc, #32]	; (25f4 <LoFiPCM_OnButtonPress(bool)+0x24>)
    25d2:	f640 027c 	movw	r2, #2172	; 0x87c
    25d6:	fb02 3000 	mla	r0, r2, r0, r3
    25da:	f890 386c 	ldrb.w	r3, [r0, #2156]	; 0x86c
    25de:	f083 0301 	eor.w	r3, r3, #1
    25e2:	f880 386c 	strb.w	r3, [r0, #2156]	; 0x86c
        play = 0;
    25e6:	2300      	movs	r3, #0
    25e8:	f880 386e 	strb.w	r3, [r0, #2158]	; 0x86e
        head = 0;
    25ec:	f8c0 3870 	str.w	r3, [r0, #2160]	; 0x870
    LoFiPCM_instance[hemisphere].BaseView();
}

void LoFiPCM_OnButtonPress(bool hemisphere) {
    LoFiPCM_instance[hemisphere].OnButtonPress();
}
    25f0:	4770      	bx	lr
    25f2:	bf00      	nop
    25f4:	1ffff054 	.word	0x1ffff054

000025f8 <LoFiPCM_OnEncoderMove(bool, int)>:
        length = constrain(length += (direction * 32), 32, HEM_LOFI_PCM_BUFFER_SIZE);
    25f8:	4b09      	ldr	r3, [pc, #36]	; (2620 <LoFiPCM_OnEncoderMove(bool, int)+0x28>)
    25fa:	f640 027c 	movw	r2, #2172	; 0x87c
    25fe:	fb02 3000 	mla	r0, r2, r0, r3
    2602:	f8d0 3878 	ldr.w	r3, [r0, #2168]	; 0x878
    2606:	eb03 1341 	add.w	r3, r3, r1, lsl #5
    260a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    260e:	bfa8      	it	ge
    2610:	f44f 6300 	movge.w	r3, #2048	; 0x800
    2614:	2b20      	cmp	r3, #32
    2616:	bfb8      	it	lt
    2618:	2320      	movlt	r3, #32
    261a:	f8c0 3878 	str.w	r3, [r0, #2168]	; 0x878

void LoFiPCM_OnEncoderMove(bool hemisphere, int direction) {
    LoFiPCM_instance[hemisphere].OnEncoderMove(direction);
}
    261e:	4770      	bx	lr
    2620:	1ffff054 	.word	0x1ffff054

00002624 <LoFiPCM_ToggleHelpScreen(bool)>:
    2624:	4b04      	ldr	r3, [pc, #16]	; (2638 <LoFiPCM_ToggleHelpScreen(bool)+0x14>)
    2626:	f640 027c 	movw	r2, #2172	; 0x87c
    262a:	fb02 3000 	mla	r0, r2, r0, r3
    262e:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2630:	f1c3 0301 	rsb	r3, r3, #1
    2634:	65c3      	str	r3, [r0, #92]	; 0x5c

void LoFiPCM_ToggleHelpScreen(bool hemisphere) {
    LoFiPCM_instance[hemisphere].HelpScreen();
}
    2636:	4770      	bx	lr
    2638:	1ffff054 	.word	0x1ffff054

0000263c <hem_AND(bool, bool)>:
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Logical gate functions and typedef to function pointer
#define HEMISPHERE_NUMBER_OF_LOGIC 7
bool hem_AND(bool s1, bool s2) {return s1 & s2;}
    263c:	4008      	ands	r0, r1
    263e:	4770      	bx	lr

00002640 <hem_OR(bool, bool)>:
bool hem_OR(bool s1, bool s2) {return s1 | s2;}
    2640:	4308      	orrs	r0, r1
    2642:	4770      	bx	lr

00002644 <hem_XOR(bool, bool)>:
bool hem_XOR(bool s1, bool s2) {return s1 != s2;}
    2644:	4048      	eors	r0, r1
    2646:	4770      	bx	lr

00002648 <hem_NAND(bool, bool)>:
bool hem_NAND(bool s1, bool s2) {return !hem_AND(s1, s2);}
    2648:	4008      	ands	r0, r1
    264a:	f080 0001 	eor.w	r0, r0, #1
    264e:	4770      	bx	lr

00002650 <hem_NOR(bool, bool)>:
bool hem_OR(bool s1, bool s2) {return s1 | s2;}
    2650:	4308      	orrs	r0, r1
bool hem_NOR(bool s1, bool s2) {return !hem_OR(s1, s2);}
    2652:	f080 0001 	eor.w	r0, r0, #1
    2656:	4770      	bx	lr

00002658 <hem_XNOR(bool, bool)>:
bool hem_XOR(bool s1, bool s2) {return s1 != s2;}
    2658:	4048      	eors	r0, r1
bool hem_XNOR(bool s1, bool s2) {return !hem_XOR(s1, s2);}
    265a:	f080 0001 	eor.w	r0, r0, #1
    265e:	4770      	bx	lr

00002660 <hem_null(bool, bool)>:
bool hem_null(bool s1, bool s2) {return 0;} // Used when the section is under CV control
    2660:	2000      	movs	r0, #0
    2662:	4770      	bx	lr

00002664 <Logic::applet_name()>:
class Logic : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Logic";
    }
    2664:	4800      	ldr	r0, [pc, #0]	; (2668 <Logic::applet_name()+0x4>)
    2666:	4770      	bx	lr
    2668:	000208de 	.word	0x000208de

0000266c <Logic::Start()>:

    void Start() {
    266c:	b5f0      	push	{r4, r5, r6, r7, lr}
        selected = 0;
        operation[0] = 0;
        operation[1] = 2;
        const char * op_name_list[] = {"AND", "OR", "XOR", "NAND", "NOR", "XNOR", "-CV-"};
    266e:	4c16      	ldr	r4, [pc, #88]	; (26c8 <Logic::Start()+0x5c>)
        selected = 0;
    2670:	2300      	movs	r3, #0
    2672:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
        operation[0] = 0;
    2676:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
        const char * op_name_list[] = {"AND", "OR", "XOR", "NAND", "NOR", "XNOR", "-CV-"};
    267a:	f104 0638 	add.w	r6, r4, #56	; 0x38
        operation[1] = 2;
    267e:	2302      	movs	r3, #2
    void Start() {
    2680:	4607      	mov	r7, r0
        operation[1] = 2;
    2682:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
        const char * op_name_list[] = {"AND", "OR", "XOR", "NAND", "NOR", "XNOR", "-CV-"};
    2686:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    void Start() {
    2688:	b08f      	sub	sp, #60	; 0x3c
        const char * op_name_list[] = {"AND", "OR", "XOR", "NAND", "NOR", "XNOR", "-CV-"};
    268a:	466d      	mov	r5, sp
    268c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    268e:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
        LogicGateFunction logic_gate_list[] = {hem_AND, hem_OR, hem_XOR, hem_NAND, hem_NOR, hem_XNOR, hem_null};
    2692:	3454      	adds	r4, #84	; 0x54
        const char * op_name_list[] = {"AND", "OR", "XOR", "NAND", "NOR", "XNOR", "-CV-"};
    2694:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        LogicGateFunction logic_gate_list[] = {hem_AND, hem_OR, hem_XOR, hem_NAND, hem_NOR, hem_XNOR, hem_null};
    2698:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    269a:	ad07      	add	r5, sp, #28
    269c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    269e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
        for(int i = 0; i < HEMISPHERE_NUMBER_OF_LOGIC; i++) 
        {
            op_name[i] = op_name_list[i];
    26a2:	241c      	movs	r4, #28
        LogicGateFunction logic_gate_list[] = {hem_AND, hem_OR, hem_XOR, hem_NAND, hem_NOR, hem_XNOR, hem_null};
    26a4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            op_name[i] = op_name_list[i];
    26a8:	4622      	mov	r2, r4
    26aa:	4669      	mov	r1, sp
    26ac:	f107 006c 	add.w	r0, r7, #108	; 0x6c
    26b0:	f017 fc9e 	bl	19ff0 <memcpy>
            logic_gate[i] = logic_gate_list[i];    
    26b4:	4622      	mov	r2, r4
    26b6:	eb0d 0104 	add.w	r1, sp, r4
    26ba:	f107 0088 	add.w	r0, r7, #136	; 0x88
    26be:	f017 fc97 	bl	19ff0 <memcpy>
        }
    }
    26c2:	b00f      	add	sp, #60	; 0x3c
    26c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    26c6:	bf00      	nop
    26c8:	0002256c 	.word	0x0002256c

000026cc <Logic::SetHelp()>:
    }

protected:
    /* Set help text. Each help section can have up to 18 characters. Be concise! */
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "1=In1, 2=In2";
    26cc:	4b04      	ldr	r3, [pc, #16]	; (26e0 <Logic::SetHelp()+0x14>)
    26ce:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "-CV-:1=Op1, 2=Op2";
    26d0:	4b04      	ldr	r3, [pc, #16]	; (26e4 <Logic::SetHelp()+0x18>)
    26d2:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "A=Result1 B=Res2";
    26d4:	4b04      	ldr	r3, [pc, #16]	; (26e8 <Logic::SetHelp()+0x1c>)
    26d6:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "Operation";
    26d8:	4b04      	ldr	r3, [pc, #16]	; (26ec <Logic::SetHelp()+0x20>)
    26da:	6143      	str	r3, [r0, #20]
    }
    26dc:	4770      	bx	lr
    26de:	bf00      	nop
    26e0:	000208e4 	.word	0x000208e4
    26e4:	000208f1 	.word	0x000208f1
    26e8:	00020643 	.word	0x00020643
    26ec:	00020654 	.word	0x00020654

000026f0 <Logic_OnButtonPress(bool)>:
        selected = 1 - selected;
    26f0:	4b06      	ldr	r3, [pc, #24]	; (270c <Logic_OnButtonPress(bool)+0x1c>)
    26f2:	22bc      	movs	r2, #188	; 0xbc
    26f4:	fb02 3000 	mla	r0, r2, r0, r3
    26f8:	f8d0 30b8 	ldr.w	r3, [r0, #184]	; 0xb8
    26fc:	f1c3 0301 	rsb	r3, r3, #1
    2700:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    2704:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    2708:	6483      	str	r3, [r0, #72]	; 0x48
    Logic_instance[hemisphere].BaseView();
}

void Logic_OnButtonPress(bool hemisphere) {
    Logic_instance[hemisphere].OnButtonPress();
}
    270a:	4770      	bx	lr
    270c:	2000014c 	.word	0x2000014c

00002710 <Logic_OnEncoderMove(bool, int)>:
        operation[selected] += direction;
    2710:	4b0e      	ldr	r3, [pc, #56]	; (274c <Logic_OnEncoderMove(bool, int)+0x3c>)
    2712:	22bc      	movs	r2, #188	; 0xbc
    2714:	fb02 3200 	mla	r2, r2, r0, r3

void Logic_OnEncoderMove(bool hemisphere, int direction) {
    2718:	b530      	push	{r4, r5, lr}
        operation[selected] += direction;
    271a:	f8d2 20b8 	ldr.w	r2, [r2, #184]	; 0xb8
    271e:	252f      	movs	r5, #47	; 0x2f
    2720:	fb05 2400 	mla	r4, r5, r0, r2
    2724:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    2728:	f8d4 40a4 	ldr.w	r4, [r4, #164]	; 0xa4
    272c:	4421      	add	r1, r4
        if (operation[selected] == HEMISPHERE_NUMBER_OF_LOGIC) operation[selected] = 0;
    272e:	2907      	cmp	r1, #7
    2730:	d009      	beq.n	2746 <Logic_OnEncoderMove(bool, int)+0x36>
        if (operation[selected] < 0) operation[selected] = HEMISPHERE_NUMBER_OF_LOGIC - 1;
    2732:	2900      	cmp	r1, #0
    2734:	bfb8      	it	lt
    2736:	2106      	movlt	r1, #6
    2738:	fb05 2200 	mla	r2, r5, r0, r2
    273c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    2740:	f8c3 10a4 	str.w	r1, [r3, #164]	; 0xa4
    Logic_instance[hemisphere].OnEncoderMove(direction);
}
    2744:	bd30      	pop	{r4, r5, pc}
        if (operation[selected] == HEMISPHERE_NUMBER_OF_LOGIC) operation[selected] = 0;
    2746:	2100      	movs	r1, #0
    2748:	e7f6      	b.n	2738 <Logic_OnEncoderMove(bool, int)+0x28>
    274a:	bf00      	nop
    274c:	2000014c 	.word	0x2000014c

00002750 <Logic_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2750:	4b04      	ldr	r3, [pc, #16]	; (2764 <Logic_ToggleHelpScreen(bool)+0x14>)
    2752:	22bc      	movs	r2, #188	; 0xbc
    2754:	fb02 3000 	mla	r0, r2, r0, r3
    2758:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    275a:	f1c3 0301 	rsb	r3, r3, #1
    275e:	65c3      	str	r3, [r0, #92]	; 0x5c

void Logic_ToggleHelpScreen(bool hemisphere) {
    Logic_instance[hemisphere].HelpScreen();
}
    2760:	4770      	bx	lr
    2762:	bf00      	nop
    2764:	2000014c 	.word	0x2000014c

00002768 <Logic_OnDataRequest(bool)>:
        Pack(data, PackLocation {8, 8}, operation[1]);
    2768:	4b05      	ldr	r3, [pc, #20]	; (2780 <Logic_OnDataRequest(bool)+0x18>)
    276a:	22bc      	movs	r2, #188	; 0xbc
    276c:	fb02 3300 	mla	r3, r2, r0, r3
        data |= (value << p.location);
    2770:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
    2774:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4

uint32_t Logic_OnDataRequest(bool hemisphere) {
    return Logic_instance[hemisphere].OnDataRequest();
}
    2778:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    277c:	4770      	bx	lr
    277e:	bf00      	nop
    2780:	2000014c 	.word	0x2000014c

00002784 <LowerRenz::applet_name()>:
class LowerRenz : public HemisphereApplet {
public:

    const char* applet_name() {
        return "LowerRenz";
    }
    2784:	4800      	ldr	r0, [pc, #0]	; (2788 <LowerRenz::applet_name()+0x4>)
    2786:	4770      	bx	lr
    2788:	00020903 	.word	0x00020903

0000278c <LowerRenz::Start()>:

    void Start() {
        freq = 128;
    278c:	2380      	movs	r3, #128	; 0x80
    278e:	6703      	str	r3, [r0, #112]	; 0x70
        rho = 64;
    2790:	2340      	movs	r3, #64	; 0x40
    2792:	6743      	str	r3, [r0, #116]	; 0x74
    }
    2794:	4770      	bx	lr
    2796:	Address 0x0000000000002796 is out of bounds.


00002798 <LowerRenz::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Reset 2=Freeze";
    2798:	4b04      	ldr	r3, [pc, #16]	; (27ac <LowerRenz::SetHelp()+0x14>)
    279a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Freq 2=Rho";
    279c:	4b04      	ldr	r3, [pc, #16]	; (27b0 <LowerRenz::SetHelp()+0x18>)
    279e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=x B=y";
    27a0:	4b04      	ldr	r3, [pc, #16]	; (27b4 <LowerRenz::SetHelp()+0x1c>)
    27a2:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Freq/Rho";
    27a4:	4b04      	ldr	r3, [pc, #16]	; (27b8 <LowerRenz::SetHelp()+0x20>)
    27a6:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    27a8:	4770      	bx	lr
    27aa:	bf00      	nop
    27ac:	0002090d 	.word	0x0002090d
    27b0:	0002091e 	.word	0x0002091e
    27b4:	0002092b 	.word	0x0002092b
    27b8:	00020933 	.word	0x00020933

000027bc <LowerRenz_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    27bc:	4b04      	ldr	r3, [pc, #16]	; (27d0 <LowerRenz_OnButtonPress(bool)+0x14>)
    27be:	227c      	movs	r2, #124	; 0x7c
    27c0:	fb02 3000 	mla	r0, r2, r0, r3
    27c4:	6f83      	ldr	r3, [r0, #120]	; 0x78
    27c6:	f1c3 0301 	rsb	r3, r3, #1
    27ca:	6783      	str	r3, [r0, #120]	; 0x78
    LowerRenz_instance[hemisphere].BaseView();
}

void LowerRenz_OnButtonPress(bool hemisphere) {
    LowerRenz_instance[hemisphere].OnButtonPress();
}
    27cc:	4770      	bx	lr
    27ce:	bf00      	nop
    27d0:	200002c4 	.word	0x200002c4

000027d4 <LowerRenz_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    27d4:	4b04      	ldr	r3, [pc, #16]	; (27e8 <LowerRenz_ToggleHelpScreen(bool)+0x14>)
    27d6:	227c      	movs	r2, #124	; 0x7c
    27d8:	fb02 3000 	mla	r0, r2, r0, r3
    27dc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    27de:	f1c3 0301 	rsb	r3, r3, #1
    27e2:	65c3      	str	r3, [r0, #92]	; 0x5c
    LowerRenz_instance[hemisphere].OnEncoderMove(direction);
}

void LowerRenz_ToggleHelpScreen(bool hemisphere) {
    LowerRenz_instance[hemisphere].HelpScreen();
}
    27e4:	4770      	bx	lr
    27e6:	bf00      	nop
    27e8:	200002c4 	.word	0x200002c4

000027ec <LowerRenz_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, (uint8_t)rho);
    27ec:	4b05      	ldr	r3, [pc, #20]	; (2804 <LowerRenz_OnDataRequest(bool)+0x18>)
    27ee:	227c      	movs	r2, #124	; 0x7c
    27f0:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    27f4:	6f43      	ldr	r3, [r0, #116]	; 0x74
        Pack(data, PackLocation {0,8}, (uint8_t)freq);
    27f6:	f890 0070 	ldrb.w	r0, [r0, #112]	; 0x70
    27fa:	021b      	lsls	r3, r3, #8
    27fc:	b29b      	uxth	r3, r3

uint32_t LowerRenz_OnDataRequest(bool hemisphere) {
    return LowerRenz_instance[hemisphere].OnDataRequest();
}
    27fe:	4318      	orrs	r0, r3
    2800:	4770      	bx	lr
    2802:	bf00      	nop
    2804:	200002c4 	.word	0x200002c4

00002808 <Metronome::applet_name()>:
class Metronome : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Metronome";
    }
    2808:	4800      	ldr	r0, [pc, #0]	; (280c <Metronome::applet_name()+0x4>)
    280a:	4770      	bx	lr
    280c:	0002093c 	.word	0x0002093c

00002810 <Metronome::Start()>:

    void Start() { }
    2810:	4770      	bx	lr
    2812:	Address 0x0000000000002812 is out of bounds.


00002814 <Metronome::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    2814:	4b03      	ldr	r3, [pc, #12]	; (2824 <Metronome::SetHelp()+0x10>)
    2816:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "";
    2818:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Multiply B=Beat";
    281a:	4b03      	ldr	r3, [pc, #12]	; (2828 <Metronome::SetHelp()+0x14>)
    281c:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Tempo";
    281e:	4b03      	ldr	r3, [pc, #12]	; (282c <Metronome::SetHelp()+0x18>)
    2820:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2822:	4770      	bx	lr
    2824:	000211c8 	.word	0x000211c8
    2828:	00020946 	.word	0x00020946
    282c:	00020958 	.word	0x00020958

00002830 <Metronome_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2830:	4b04      	ldr	r3, [pc, #16]	; (2844 <Metronome_ToggleHelpScreen(bool)+0x14>)
    2832:	2274      	movs	r2, #116	; 0x74
    2834:	fb02 3000 	mla	r0, r2, r0, r3
    2838:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    283a:	f1c3 0301 	rsb	r3, r3, #1
    283e:	65c3      	str	r3, [r0, #92]	; 0x5c
void Metronome_Start(bool hemisphere) {Metronome_instance[hemisphere].BaseStart(hemisphere);}
void Metronome_Controller(bool hemisphere, bool forwarding) {Metronome_instance[hemisphere].BaseController(forwarding);}
void Metronome_View(bool hemisphere) {Metronome_instance[hemisphere].BaseView();}
void Metronome_OnButtonPress(bool hemisphere) {Metronome_instance[hemisphere].OnButtonPress();}
void Metronome_OnEncoderMove(bool hemisphere, int direction) {Metronome_instance[hemisphere].OnEncoderMove(direction);}
void Metronome_ToggleHelpScreen(bool hemisphere) {Metronome_instance[hemisphere].HelpScreen();}
    2840:	4770      	bx	lr
    2842:	bf00      	nop
    2844:	200003bc 	.word	0x200003bc

00002848 <MixerBal::applet_name()>:
class MixerBal : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Mixer:Bal";
    }
    2848:	4800      	ldr	r0, [pc, #0]	; (284c <MixerBal::applet_name()+0x4>)
    284a:	4770      	bx	lr
    284c:	0002095e 	.word	0x0002095e

00002850 <MixerBal::Start()>:

    void Start() {
        balance = 127;
    2850:	237f      	movs	r3, #127	; 0x7f
    2852:	6703      	str	r3, [r0, #112]	; 0x70
    }
    2854:	4770      	bx	lr
    2856:	Address 0x0000000000002856 is out of bounds.


00002858 <MixerBal::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    2858:	4b04      	ldr	r3, [pc, #16]	; (286c <MixerBal::SetHelp()+0x14>)
    285a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1,2 Signals";
    285c:	4b04      	ldr	r3, [pc, #16]	; (2870 <MixerBal::SetHelp()+0x18>)
    285e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Mix Out B=Comp";
    2860:	4b04      	ldr	r3, [pc, #16]	; (2874 <MixerBal::SetHelp()+0x1c>)
    2862:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Balance";
    2864:	4b04      	ldr	r3, [pc, #16]	; (2878 <MixerBal::SetHelp()+0x20>)
    2866:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2868:	4770      	bx	lr
    286a:	bf00      	nop
    286c:	000211c8 	.word	0x000211c8
    2870:	00020968 	.word	0x00020968
    2874:	00020974 	.word	0x00020974
    2878:	00020985 	.word	0x00020985

0000287c <MixerBal_OnEncoderMove(bool, int)>:
        balance = constrain(balance + direction, 0, 255);
    287c:	4b04      	ldr	r3, [pc, #16]	; (2890 <MixerBal_OnEncoderMove(bool, int)+0x14>)
    287e:	2274      	movs	r2, #116	; 0x74
    2880:	fb02 3000 	mla	r0, r2, r0, r3
    2884:	6f03      	ldr	r3, [r0, #112]	; 0x70
    2886:	440b      	add	r3, r1
    2888:	f383 0308 	usat	r3, #8, r3
    288c:	6703      	str	r3, [r0, #112]	; 0x70
    MixerBal_instance[hemisphere].OnButtonPress();
}

void MixerBal_OnEncoderMove(bool hemisphere, int direction) {
    MixerBal_instance[hemisphere].OnEncoderMove(direction);
}
    288e:	4770      	bx	lr
    2890:	200004a4 	.word	0x200004a4

00002894 <MixerBal_ToggleHelpScreen(bool)>:
    2894:	4b04      	ldr	r3, [pc, #16]	; (28a8 <MixerBal_ToggleHelpScreen(bool)+0x14>)
    2896:	2274      	movs	r2, #116	; 0x74
    2898:	fb02 3000 	mla	r0, r2, r0, r3
    289c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    289e:	f1c3 0301 	rsb	r3, r3, #1
    28a2:	65c3      	str	r3, [r0, #92]	; 0x5c

void MixerBal_ToggleHelpScreen(bool hemisphere) {
    MixerBal_instance[hemisphere].HelpScreen();
}
    28a4:	4770      	bx	lr
    28a6:	bf00      	nop
    28a8:	200004a4 	.word	0x200004a4

000028ac <MixerBal_OnDataRequest(bool)>:
        Pack(data, PackLocation {0,8}, balance);
    28ac:	4b02      	ldr	r3, [pc, #8]	; (28b8 <MixerBal_OnDataRequest(bool)+0xc>)
    28ae:	2274      	movs	r2, #116	; 0x74
    28b0:	fb02 3300 	mla	r3, r2, r0, r3

uint32_t MixerBal_OnDataRequest(bool hemisphere) {
    return MixerBal_instance[hemisphere].OnDataRequest();
}
    28b4:	6f18      	ldr	r0, [r3, #112]	; 0x70
    28b6:	4770      	bx	lr
    28b8:	200004a4 	.word	0x200004a4

000028bc <Palimpsest::applet_name()>:
class Palimpsest : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Palimpsest";
    }
    28bc:	4800      	ldr	r0, [pc, #0]	; (28c0 <Palimpsest::applet_name()+0x4>)
    28be:	4770      	bx	lr
    28c0:	0002098d 	.word	0x0002098d

000028c4 <Palimpsest::Start()>:

    void Start() {
        brush = 0;
    28c4:	2100      	movs	r1, #0
        length = 16;
    28c6:	2310      	movs	r3, #16
        brush = 0;
    28c8:	f880 10bc 	strb.w	r1, [r0, #188]	; 0xbc
        length = 16;
    28cc:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
        step = 0;
    28d0:	f8c0 10ac 	str.w	r1, [r0, #172]	; 0xac
        for (int s = 0; s < length; s++) accent[s] = 0;
    28d4:	2240      	movs	r2, #64	; 0x40
    28d6:	306c      	adds	r0, #108	; 0x6c
    28d8:	f017 bc5e 	b.w	1a198 <memset>

000028dc <Palimpsest::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Brush";
    28dc:	4b04      	ldr	r3, [pc, #16]	; (28f0 <Palimpsest::SetHelp()+0x14>)
    28de:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "Mod 1=Compose 2=De";
    28e0:	4b04      	ldr	r3, [pc, #16]	; (28f4 <Palimpsest::SetHelp()+0x18>)
    28e2:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Output B=Trigger";
    28e4:	4b04      	ldr	r3, [pc, #16]	; (28f8 <Palimpsest::SetHelp()+0x1c>)
    28e6:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Comp/Decomp/Length";
    28e8:	4b04      	ldr	r3, [pc, #16]	; (28fc <Palimpsest::SetHelp()+0x20>)
    28ea:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    28ec:	4770      	bx	lr
    28ee:	bf00      	nop
    28f0:	00020998 	.word	0x00020998
    28f4:	000209a8 	.word	0x000209a8
    28f8:	000209bb 	.word	0x000209bb
    28fc:	000209ce 	.word	0x000209ce

00002900 <Palimpsest_OnButtonPress(bool)>:
void Palimpsest_View(bool hemisphere) {
    Palimpsest_instance[hemisphere].BaseView();
}

void Palimpsest_OnButtonPress(bool hemisphere) {
    Palimpsest_instance[hemisphere].OnButtonPress();
    2900:	4b07      	ldr	r3, [pc, #28]	; (2920 <Palimpsest_OnButtonPress(bool)+0x20>)
    2902:	22cc      	movs	r2, #204	; 0xcc
    2904:	fb02 3000 	mla	r0, r2, r0, r3
        cursor++;
    2908:	f8d0 30b8 	ldr.w	r3, [r0, #184]	; 0xb8
    290c:	3301      	adds	r3, #1
        if (cursor > 2) cursor = 0;
    290e:	2b03      	cmp	r3, #3
    2910:	bfa8      	it	ge
    2912:	2300      	movge	r3, #0
    2914:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    2918:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    291c:	6483      	str	r3, [r0, #72]	; 0x48
}
    291e:	4770      	bx	lr
    2920:	20000d34 	.word	0x20000d34

00002924 <Palimpsest_OnEncoderMove(bool, int)>:

void Palimpsest_OnEncoderMove(bool hemisphere, int direction) {
    Palimpsest_instance[hemisphere].OnEncoderMove(direction);
    2924:	4b17      	ldr	r3, [pc, #92]	; (2984 <Palimpsest_OnEncoderMove(bool, int)+0x60>)
    2926:	22cc      	movs	r2, #204	; 0xcc
    2928:	fb02 3000 	mla	r0, r2, r0, r3
        if (cursor == 0) compose = constrain(compose += direction, 0, HEM_PALIMPSEST_MAX_VALUE);
    292c:	f8d0 30b8 	ldr.w	r3, [r0, #184]	; 0xb8
    2930:	b96b      	cbnz	r3, 294e <Palimpsest_OnEncoderMove(bool, int)+0x2a>
    2932:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
    2936:	440b      	add	r3, r1
    2938:	2b64      	cmp	r3, #100	; 0x64
    293a:	bfa8      	it	ge
    293c:	2364      	movge	r3, #100	; 0x64
    293e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    2942:	f8c0 30c4 	str.w	r3, [r0, #196]	; 0xc4
    2946:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    294a:	6483      	str	r3, [r0, #72]	; 0x48
}
    294c:	4770      	bx	lr
        if (cursor == 1) decompose = constrain(decompose -= direction, 0, HEM_PALIMPSEST_MAX_VALUE);
    294e:	2b01      	cmp	r3, #1
    2950:	d00d      	beq.n	296e <Palimpsest_OnEncoderMove(bool, int)+0x4a>
        if (cursor == 2) length = constrain(length += direction, 2, 16);
    2952:	2b02      	cmp	r3, #2
    2954:	d1f7      	bne.n	2946 <Palimpsest_OnEncoderMove(bool, int)+0x22>
    2956:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
    295a:	440b      	add	r3, r1
    295c:	2b10      	cmp	r3, #16
    295e:	bfa8      	it	ge
    2960:	2310      	movge	r3, #16
    2962:	2b02      	cmp	r3, #2
    2964:	bfb8      	it	lt
    2966:	2302      	movlt	r3, #2
    2968:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
    296c:	e7eb      	b.n	2946 <Palimpsest_OnEncoderMove(bool, int)+0x22>
        if (cursor == 1) decompose = constrain(decompose -= direction, 0, HEM_PALIMPSEST_MAX_VALUE);
    296e:	f8d0 30c8 	ldr.w	r3, [r0, #200]	; 0xc8
    2972:	1a5b      	subs	r3, r3, r1
    2974:	2b64      	cmp	r3, #100	; 0x64
    2976:	bfa8      	it	ge
    2978:	2364      	movge	r3, #100	; 0x64
    297a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    297e:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
        if (cursor == 2) length = constrain(length += direction, 2, 16);
    2982:	e7e0      	b.n	2946 <Palimpsest_OnEncoderMove(bool, int)+0x22>
    2984:	20000d34 	.word	0x20000d34

00002988 <Palimpsest_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2988:	4b04      	ldr	r3, [pc, #16]	; (299c <Palimpsest_ToggleHelpScreen(bool)+0x14>)
    298a:	22cc      	movs	r2, #204	; 0xcc
    298c:	fb02 3000 	mla	r0, r2, r0, r3
    2990:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2992:	f1c3 0301 	rsb	r3, r3, #1
    2996:	65c3      	str	r3, [r0, #92]	; 0x5c

void Palimpsest_ToggleHelpScreen(bool hemisphere) {
    Palimpsest_instance[hemisphere].HelpScreen();
}
    2998:	4770      	bx	lr
    299a:	bf00      	nop
    299c:	20000d34 	.word	0x20000d34

000029a0 <Palimpsest_OnDataRequest(bool)>:
        Pack(data, PackLocation {7,7}, decompose);
    29a0:	4b07      	ldr	r3, [pc, #28]	; (29c0 <Palimpsest_OnDataRequest(bool)+0x20>)
    29a2:	22cc      	movs	r2, #204	; 0xcc
    29a4:	fb02 3300 	mla	r3, r2, r0, r3
        data |= (value << p.location);
    29a8:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
    29ac:	f8d3 00c4 	ldr.w	r0, [r3, #196]	; 0xc4
        Pack(data, PackLocation {14,4}, length - 1);
    29b0:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    29b4:	ea40 10c2 	orr.w	r0, r0, r2, lsl #7
    29b8:	3b01      	subs	r3, #1

uint32_t Palimpsest_OnDataRequest(bool hemisphere) {
    return Palimpsest_instance[hemisphere].OnDataRequest();
}
    29ba:	ea40 3083 	orr.w	r0, r0, r3, lsl #14
    29be:	4770      	bx	lr
    29c0:	20000d34 	.word	0x20000d34

000029c4 <RunglBook::applet_name()>:
class RunglBook : public HemisphereApplet {
public:

    const char* applet_name() {
        return "RunglBook";
    }
    29c4:	4800      	ldr	r0, [pc, #0]	; (29c8 <RunglBook::applet_name()+0x4>)
    29c6:	4770      	bx	lr
    29c8:	000209e1 	.word	0x000209e1

000029cc <RunglBook::Start()>:

    void Start() {
        threshold = (12 << 7) * 2;
    29cc:	f44f 6340 	mov.w	r3, #3072	; 0xc00
    29d0:	f8a0 306e 	strh.w	r3, [r0, #110]	; 0x6e
    }
    29d4:	4770      	bx	lr
    29d6:	Address 0x00000000000029d6 is out of bounds.


000029d8 <RunglBook::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Freeze";
    29d8:	4b04      	ldr	r3, [pc, #16]	; (29ec <RunglBook::SetHelp()+0x14>)
    29da:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Signal";
    29dc:	4b04      	ldr	r3, [pc, #16]	; (29f0 <RunglBook::SetHelp()+0x18>)
    29de:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Rungle B=Alt";
    29e0:	4b04      	ldr	r3, [pc, #16]	; (29f4 <RunglBook::SetHelp()+0x1c>)
    29e2:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Threshold";
    29e4:	4b04      	ldr	r3, [pc, #16]	; (29f8 <RunglBook::SetHelp()+0x20>)
    29e6:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    29e8:	4770      	bx	lr
    29ea:	bf00      	nop
    29ec:	00020448 	.word	0x00020448
    29f0:	000209eb 	.word	0x000209eb
    29f4:	000209f4 	.word	0x000209f4
    29f8:	00020a03 	.word	0x00020a03

000029fc <RunglBook_OnEncoderMove(bool, int)>:
        threshold += (direction * 128);
    29fc:	4a0c      	ldr	r2, [pc, #48]	; (2a30 <RunglBook_OnEncoderMove(bool, int)+0x34>)

void RunglBook_Start(bool hemisphere) {RunglBook_instance[hemisphere].BaseStart(hemisphere);}
void RunglBook_Controller(bool hemisphere, bool forwarding) {RunglBook_instance[hemisphere].BaseController(forwarding);}
void RunglBook_View(bool hemisphere) {RunglBook_instance[hemisphere].BaseView();}
void RunglBook_OnButtonPress(bool hemisphere) {RunglBook_instance[hemisphere].OnButtonPress();}
void RunglBook_OnEncoderMove(bool hemisphere, int direction) {RunglBook_instance[hemisphere].OnEncoderMove(direction);}
    29fe:	b510      	push	{r4, lr}
        threshold += (direction * 128);
    2a00:	2470      	movs	r4, #112	; 0x70
    2a02:	fb04 2300 	mla	r3, r4, r0, r2
    2a06:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
    2a0a:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
    2a0e:	b289      	uxth	r1, r1
        threshold = constrain(threshold, (12 << 7), (12 << 7) * 5); // 1V - 5V
    2a10:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
    2a14:	d309      	bcc.n	2a2a <RunglBook_OnEncoderMove(bool, int)+0x2e>
    2a16:	f5b1 5ff0 	cmp.w	r1, #7680	; 0x1e00
    2a1a:	bfa8      	it	ge
    2a1c:	f44f 51f0 	movge.w	r1, #7680	; 0x1e00
    2a20:	fb04 2200 	mla	r2, r4, r0, r2
    2a24:	f8a2 106e 	strh.w	r1, [r2, #110]	; 0x6e
void RunglBook_OnEncoderMove(bool hemisphere, int direction) {RunglBook_instance[hemisphere].OnEncoderMove(direction);}
    2a28:	bd10      	pop	{r4, pc}
        threshold = constrain(threshold, (12 << 7), (12 << 7) * 5); // 1V - 5V
    2a2a:	f44f 61c0 	mov.w	r1, #1536	; 0x600
    2a2e:	e7f7      	b.n	2a20 <RunglBook_OnEncoderMove(bool, int)+0x24>
    2a30:	20000ecc 	.word	0x20000ecc

00002a34 <RunglBook_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2a34:	4b04      	ldr	r3, [pc, #16]	; (2a48 <RunglBook_ToggleHelpScreen(bool)+0x14>)
    2a36:	2270      	movs	r2, #112	; 0x70
    2a38:	fb02 3000 	mla	r0, r2, r0, r3
    2a3c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2a3e:	f1c3 0301 	rsb	r3, r3, #1
    2a42:	65c3      	str	r3, [r0, #92]	; 0x5c
void RunglBook_ToggleHelpScreen(bool hemisphere) {RunglBook_instance[hemisphere].HelpScreen();}
    2a44:	4770      	bx	lr
    2a46:	bf00      	nop
    2a48:	20000ecc 	.word	0x20000ecc

00002a4c <RunglBook_OnDataRequest(bool)>:
        Pack(data, PackLocation {0,16}, threshold);
    2a4c:	4b03      	ldr	r3, [pc, #12]	; (2a5c <RunglBook_OnDataRequest(bool)+0x10>)
    2a4e:	2270      	movs	r2, #112	; 0x70
    2a50:	fb02 3300 	mla	r3, r2, r0, r3
uint32_t RunglBook_OnDataRequest(bool hemisphere) {return RunglBook_instance[hemisphere].OnDataRequest();}
    2a54:	f8b3 006e 	ldrh.w	r0, [r3, #110]	; 0x6e
    2a58:	4770      	bx	lr
    2a5a:	bf00      	nop
    2a5c:	20000ecc 	.word	0x20000ecc

00002a60 <ScaleDuet::applet_name()>:
class ScaleDuet : public HemisphereApplet {
public:

    const char* applet_name() {
        return "ScaleDuet";
    }
    2a60:	4800      	ldr	r0, [pc, #0]	; (2a64 <ScaleDuet::applet_name()+0x4>)
    2a62:	4770      	bx	lr
    2a64:	00020a0d 	.word	0x00020a0d

00002a68 <ScaleDuet::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=ScaleSel";
    2a68:	4b04      	ldr	r3, [pc, #16]	; (2a7c <ScaleDuet::SetHelp()+0x14>)
    2a6a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=CV";
    2a6c:	4b04      	ldr	r3, [pc, #16]	; (2a80 <ScaleDuet::SetHelp()+0x18>)
    2a6e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Pitch";
    2a70:	4b04      	ldr	r3, [pc, #16]	; (2a84 <ScaleDuet::SetHelp()+0x1c>)
    2a72:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "T=Note P=Toggle";
    2a74:	4b04      	ldr	r3, [pc, #16]	; (2a88 <ScaleDuet::SetHelp()+0x20>)
    2a76:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2a78:	4770      	bx	lr
    2a7a:	bf00      	nop
    2a7c:	00020a17 	.word	0x00020a17
    2a80:	00020a2a 	.word	0x00020a2a
    2a84:	00020a2f 	.word	0x00020a2f
    2a88:	00020a37 	.word	0x00020a37

00002a8c <ScaleDuet_OnEncoderMove(bool, int)>:
void ScaleDuet_OnButtonPress(bool hemisphere) {
    ScaleDuet_instance[hemisphere].OnButtonPress();
}

void ScaleDuet_OnEncoderMove(bool hemisphere, int direction) {
    ScaleDuet_instance[hemisphere].OnEncoderMove(direction);
    2a8c:	4b0e      	ldr	r3, [pc, #56]	; (2ac8 <ScaleDuet_OnEncoderMove(bool, int)+0x3c>)
void ScaleDuet_OnEncoderMove(bool hemisphere, int direction) {
    2a8e:	b530      	push	{r4, r5, lr}
    ScaleDuet_instance[hemisphere].OnEncoderMove(direction);
    2a90:	f44f 74d8 	mov.w	r4, #432	; 0x1b0
    2a94:	fb04 3200 	mla	r2, r4, r0, r3
        if (cursor == 0 && direction == -1) cursor = 1;
    2a98:	f892 51a8 	ldrb.w	r5, [r2, #424]	; 0x1a8
    2a9c:	b925      	cbnz	r5, 2aa8 <ScaleDuet_OnEncoderMove(bool, int)+0x1c>
    2a9e:	1c4d      	adds	r5, r1, #1
    2aa0:	bf04      	itt	eq
    2aa2:	2501      	moveq	r5, #1
    2aa4:	f882 51a8 	strbeq.w	r5, [r2, #424]	; 0x1a8
        cursor = constrain(cursor += direction, 0, 23);
    2aa8:	fb04 3000 	mla	r0, r4, r0, r3
    2aac:	f890 31a8 	ldrb.w	r3, [r0, #424]	; 0x1a8
    2ab0:	4419      	add	r1, r3
    2ab2:	b2c9      	uxtb	r1, r1
    2ab4:	2917      	cmp	r1, #23
    2ab6:	bfa8      	it	ge
    2ab8:	2117      	movge	r1, #23
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    2aba:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    2abe:	f880 11a8 	strb.w	r1, [r0, #424]	; 0x1a8
    2ac2:	6493      	str	r3, [r2, #72]	; 0x48
}
    2ac4:	bd30      	pop	{r4, r5, pc}
    2ac6:	bf00      	nop
    2ac8:	20000fac 	.word	0x20000fac

00002acc <ScaleDuet_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2acc:	4b04      	ldr	r3, [pc, #16]	; (2ae0 <ScaleDuet_ToggleHelpScreen(bool)+0x14>)
    2ace:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
    2ad2:	fb02 3000 	mla	r0, r2, r0, r3
    2ad6:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2ad8:	f1c3 0301 	rsb	r3, r3, #1
    2adc:	65c3      	str	r3, [r0, #92]	; 0x5c

void ScaleDuet_ToggleHelpScreen(bool hemisphere) {
    ScaleDuet_instance[hemisphere].HelpScreen();
}
    2ade:	4770      	bx	lr
    2ae0:	20000fac 	.word	0x20000fac

00002ae4 <ScaleDuet_OnDataRequest(bool)>:
        Pack(data, PackLocation {12,12}, mask[1]);
    2ae4:	4b05      	ldr	r3, [pc, #20]	; (2afc <ScaleDuet_OnDataRequest(bool)+0x18>)
    2ae6:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
    2aea:	fb02 3300 	mla	r3, r2, r0, r3
    2aee:	f8b3 01a6 	ldrh.w	r0, [r3, #422]	; 0x1a6
        Pack(data, PackLocation {0,12}, mask[0]);
    2af2:	f8b3 31a4 	ldrh.w	r3, [r3, #420]	; 0x1a4

uint32_t ScaleDuet_OnDataRequest(bool hemisphere) {
    return ScaleDuet_instance[hemisphere].OnDataRequest();
}
    2af6:	ea43 3000 	orr.w	r0, r3, r0, lsl #12
    2afa:	4770      	bx	lr
    2afc:	20000fac 	.word	0x20000fac

00002b00 <Schmitt::applet_name()>:
class Schmitt : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "SchmittTr";
    }
    2b00:	4800      	ldr	r0, [pc, #0]	; (2b04 <Schmitt::applet_name()+0x4>)
    2b02:	4770      	bx	lr
    2b04:	00020a47 	.word	0x00020a47

00002b08 <Schmitt::Start()>:

    void Start() {
        low = 3200; // ~2.1V
        high = 3968; // ~2.6V
        cursor = 0;
    2b08:	2300      	movs	r3, #0
    2b0a:	66c3      	str	r3, [r0, #108]	; 0x6c
        gate_countdown = 0;
    2b0c:	6743      	str	r3, [r0, #116]	; 0x74
        low = 3200; // ~2.1V
    2b0e:	4b01      	ldr	r3, [pc, #4]	; (2b14 <Schmitt::Start()+0xc>)
    2b10:	6783      	str	r3, [r0, #120]	; 0x78
    }
    2b12:	4770      	bx	lr
    2b14:	0f800c80 	.word	0x0f800c80

00002b18 <Schmitt::SetHelp()>:

protected:
    /* Set help text. Each help section can have up to 18 characters. Be concise! */
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    2b18:	4b04      	ldr	r3, [pc, #16]	; (2b2c <Schmitt::SetHelp()+0x14>)
    2b1a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "CV Inputs 1,2";
    2b1c:	4b04      	ldr	r3, [pc, #16]	; (2b30 <Schmitt::SetHelp()+0x18>)
    2b1e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Gate Ouputs A,B";
    2b20:	4b04      	ldr	r3, [pc, #16]	; (2b34 <Schmitt::SetHelp()+0x1c>)
    2b22:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "High/Low Thresh";
    2b24:	4b04      	ldr	r3, [pc, #16]	; (2b38 <Schmitt::SetHelp()+0x20>)
    2b26:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2b28:	4770      	bx	lr
    2b2a:	bf00      	nop
    2b2c:	000211c8 	.word	0x000211c8
    2b30:	000204d0 	.word	0x000204d0
    2b34:	00020a51 	.word	0x00020a51
    2b38:	00020a61 	.word	0x00020a61

00002b3c <Schmitt_OnButtonPress(bool)>:
        if (++cursor == 3) cursor = 0;
    2b3c:	4b05      	ldr	r3, [pc, #20]	; (2b54 <Schmitt_OnButtonPress(bool)+0x18>)
    2b3e:	227c      	movs	r2, #124	; 0x7c
    2b40:	fb02 3000 	mla	r0, r2, r0, r3
    2b44:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
    2b46:	2a02      	cmp	r2, #2
    2b48:	f102 0301 	add.w	r3, r2, #1
    2b4c:	bf08      	it	eq
    2b4e:	2300      	moveq	r3, #0
    2b50:	66c3      	str	r3, [r0, #108]	; 0x6c
    Schmitt_instance[hemisphere].BaseView();
}

void Schmitt_OnButtonPress(bool hemisphere) {
    Schmitt_instance[hemisphere].OnButtonPress();
}
    2b52:	4770      	bx	lr
    2b54:	2000130c 	.word	0x2000130c

00002b58 <Schmitt_OnEncoderMove(bool, int)>:

void Schmitt_OnEncoderMove(bool hemisphere, int direction) {
    2b58:	b530      	push	{r4, r5, lr}
    Schmitt_instance[hemisphere].OnEncoderMove(direction);
    2b5a:	4c1b      	ldr	r4, [pc, #108]	; (2bc8 <Schmitt_OnEncoderMove(bool, int)+0x70>)
    2b5c:	237c      	movs	r3, #124	; 0x7c
    2b5e:	fb03 4300 	mla	r3, r3, r0, r4
        if (cursor == 1) {
    2b62:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    2b64:	2a01      	cmp	r2, #1
    2b66:	d117      	bne.n	2b98 <Schmitt_OnEncoderMove(bool, int)+0x40>
            low += (64 * direction);
    2b68:	f8b3 2078 	ldrh.w	r2, [r3, #120]	; 0x78
    2b6c:	eb02 1181 	add.w	r1, r2, r1, lsl #6
    2b70:	b289      	uxth	r1, r1
            low = constrain(low, 64, high - 64);
    2b72:	293f      	cmp	r1, #63	; 0x3f
    2b74:	f8b3 207a 	ldrh.w	r2, [r3, #122]	; 0x7a
    2b78:	d90c      	bls.n	2b94 <Schmitt_OnEncoderMove(bool, int)+0x3c>
    2b7a:	3a40      	subs	r2, #64	; 0x40
    2b7c:	428a      	cmp	r2, r1
    2b7e:	bfa8      	it	ge
    2b80:	460a      	movge	r2, r1
    2b82:	217c      	movs	r1, #124	; 0x7c
    2b84:	fb01 4100 	mla	r1, r1, r0, r4
    2b88:	f8a1 2078 	strh.w	r2, [r1, #120]	; 0x78
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    2b8c:	f642 62e0 	movw	r2, #12000	; 0x2ee0
    2b90:	649a      	str	r2, [r3, #72]	; 0x48
}
    2b92:	bd30      	pop	{r4, r5, pc}
            low = constrain(low, 64, high - 64);
    2b94:	2240      	movs	r2, #64	; 0x40
    2b96:	e7f4      	b.n	2b82 <Schmitt_OnEncoderMove(bool, int)+0x2a>
        if (cursor == 2) {
    2b98:	2a02      	cmp	r2, #2
    2b9a:	d1f7      	bne.n	2b8c <Schmitt_OnEncoderMove(bool, int)+0x34>
            high += (64 * direction);
    2b9c:	f8b3 207a 	ldrh.w	r2, [r3, #122]	; 0x7a
            high = constrain(high, low + 64, HEMISPHERE_MAX_CV);
    2ba0:	f8b3 5078 	ldrh.w	r5, [r3, #120]	; 0x78
            high += (64 * direction);
    2ba4:	eb02 1181 	add.w	r1, r2, r1, lsl #6
            high = constrain(high, low + 64, HEMISPHERE_MAX_CV);
    2ba8:	3540      	adds	r5, #64	; 0x40
    2baa:	b289      	uxth	r1, r1
    2bac:	428d      	cmp	r5, r1
    2bae:	dc05      	bgt.n	2bbc <Schmitt_OnEncoderMove(bool, int)+0x64>
    2bb0:	f5b1 5ff0 	cmp.w	r1, #7680	; 0x1e00
    2bb4:	bfa8      	it	ge
    2bb6:	f44f 51f0 	movge.w	r1, #7680	; 0x1e00
    2bba:	460d      	mov	r5, r1
    2bbc:	227c      	movs	r2, #124	; 0x7c
    2bbe:	fb02 4400 	mla	r4, r2, r0, r4
    2bc2:	f8a4 507a 	strh.w	r5, [r4, #122]	; 0x7a
    2bc6:	e7e1      	b.n	2b8c <Schmitt_OnEncoderMove(bool, int)+0x34>
    2bc8:	2000130c 	.word	0x2000130c

00002bcc <Schmitt_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2bcc:	4b04      	ldr	r3, [pc, #16]	; (2be0 <Schmitt_ToggleHelpScreen(bool)+0x14>)
    2bce:	227c      	movs	r2, #124	; 0x7c
    2bd0:	fb02 3000 	mla	r0, r2, r0, r3
    2bd4:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2bd6:	f1c3 0301 	rsb	r3, r3, #1
    2bda:	65c3      	str	r3, [r0, #92]	; 0x5c

void Schmitt_ToggleHelpScreen(bool hemisphere) {
    Schmitt_instance[hemisphere].HelpScreen();
}
    2bdc:	4770      	bx	lr
    2bde:	bf00      	nop
    2be0:	2000130c 	.word	0x2000130c

00002be4 <Schmitt_OnDataRequest(bool)>:
        data |= (value << p.location);
    2be4:	4b02      	ldr	r3, [pc, #8]	; (2bf0 <Schmitt_OnDataRequest(bool)+0xc>)
    2be6:	227c      	movs	r2, #124	; 0x7c
    2be8:	fb02 3300 	mla	r3, r2, r0, r3

uint32_t Schmitt_OnDataRequest(bool hemisphere) {
    return Schmitt_instance[hemisphere].OnDataRequest();
}
    2bec:	6f98      	ldr	r0, [r3, #120]	; 0x78
    2bee:	4770      	bx	lr
    2bf0:	2000130c 	.word	0x2000130c

00002bf4 <Scope::applet_name()>:
class Scope : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Scope";
    }
    2bf4:	4800      	ldr	r0, [pc, #0]	; (2bf8 <Scope::applet_name()+0x4>)
    2bf6:	4770      	bx	lr
    2bf8:	00020a71 	.word	0x00020a71

00002bfc <Scope::Start()>:

    void Start() {
        last_bpm_tick = OC::CORE::ticks;
    2bfc:	4b06      	ldr	r3, [pc, #24]	; (2c18 <Scope::Start()+0x1c>)
    2bfe:	681b      	ldr	r3, [r3, #0]
    2c00:	66c3      	str	r3, [r0, #108]	; 0x6c
        bpm = 0;
        sample_ticks = 320;
    2c02:	f44f 72a0 	mov.w	r2, #320	; 0x140
        bpm = 0;
    2c06:	2300      	movs	r3, #0
    2c08:	6703      	str	r3, [r0, #112]	; 0x70
        sample_ticks = 320;
    2c0a:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
        freeze = 0;
    2c0e:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
        last_scope_tick = 0;
    2c12:	f8c0 30cc 	str.w	r3, [r0, #204]	; 0xcc
    }
    2c16:	4770      	bx	lr
    2c18:	200046cc 	.word	0x200046cc

00002c1c <Scope::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "Clk 1=BPM 2=Cycle1";
    2c1c:	4b04      	ldr	r3, [pc, #16]	; (2c30 <Scope::SetHelp()+0x14>)
    2c1e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=CV1 2=CV2";
    2c20:	4b04      	ldr	r3, [pc, #16]	; (2c34 <Scope::SetHelp()+0x18>)
    2c22:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=CV1 B=CV2";
    2c24:	4b04      	ldr	r3, [pc, #16]	; (2c38 <Scope::SetHelp()+0x1c>)
    2c26:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "T=SmplRate P=Freez";
    2c28:	4b04      	ldr	r3, [pc, #16]	; (2c3c <Scope::SetHelp()+0x20>)
    2c2a:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2c2c:	4770      	bx	lr
    2c2e:	bf00      	nop
    2c30:	00020a77 	.word	0x00020a77
    2c34:	00020637 	.word	0x00020637
    2c38:	00020a8a 	.word	0x00020a8a
    2c3c:	00020a96 	.word	0x00020a96

00002c40 <Scope_OnButtonPress(bool)>:
        freeze = 1 - freeze;
    2c40:	4b05      	ldr	r3, [pc, #20]	; (2c58 <Scope_OnButtonPress(bool)+0x18>)
    2c42:	22d0      	movs	r2, #208	; 0xd0
    2c44:	fb02 3000 	mla	r0, r2, r0, r3
    2c48:	f890 3078 	ldrb.w	r3, [r0, #120]	; 0x78
    2c4c:	f083 0301 	eor.w	r3, r3, #1
    2c50:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
    Scope_instance[hemisphere].BaseView();
}

void Scope_OnButtonPress(bool hemisphere) {
    Scope_instance[hemisphere].OnButtonPress();
}
    2c54:	4770      	bx	lr
    2c56:	bf00      	nop
    2c58:	20001404 	.word	0x20001404

00002c5c <Scope_OnEncoderMove(bool, int)>:

void Scope_OnEncoderMove(bool hemisphere, int direction) {
    2c5c:	b510      	push	{r4, lr}
        if (sample_ticks < 32) sample_ticks += direction;
    2c5e:	4a0f      	ldr	r2, [pc, #60]	; (2c9c <Scope_OnEncoderMove(bool, int)+0x40>)
    2c60:	23d0      	movs	r3, #208	; 0xd0
    2c62:	fb03 2300 	mla	r3, r3, r0, r2
    2c66:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
    2c6a:	2b1f      	cmp	r3, #31
        else sample_ticks += direction * 10;
    2c6c:	bfca      	itet	gt
    2c6e:	240a      	movgt	r4, #10
        if (sample_ticks < 32) sample_ticks += direction;
    2c70:	185b      	addle	r3, r3, r1
        else sample_ticks += direction * 10;
    2c72:	fb04 3301 	mlagt	r3, r4, r1, r3
        sample_ticks = constrain(sample_ticks, 2, 64000);
    2c76:	f5b3 4f7a 	cmp.w	r3, #64000	; 0xfa00
    2c7a:	bfa8      	it	ge
    2c7c:	f44f 437a 	movge.w	r3, #64000	; 0xfa00
    2c80:	21d0      	movs	r1, #208	; 0xd0
    2c82:	fb01 2000 	mla	r0, r1, r0, r2
    2c86:	2b02      	cmp	r3, #2
    2c88:	bfb8      	it	lt
    2c8a:	2302      	movlt	r3, #2
    2c8c:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc
        last_encoder_move = OC::CORE::ticks;
    2c90:	4b03      	ldr	r3, [pc, #12]	; (2ca0 <Scope_OnEncoderMove(bool, int)+0x44>)
    2c92:	681b      	ldr	r3, [r3, #0]
    2c94:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
    Scope_instance[hemisphere].OnEncoderMove(direction);
}
    2c98:	bd10      	pop	{r4, pc}
    2c9a:	bf00      	nop
    2c9c:	20001404 	.word	0x20001404
    2ca0:	200046cc 	.word	0x200046cc

00002ca4 <Scope_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2ca4:	4b04      	ldr	r3, [pc, #16]	; (2cb8 <Scope_ToggleHelpScreen(bool)+0x14>)
    2ca6:	22d0      	movs	r2, #208	; 0xd0
    2ca8:	fb02 3000 	mla	r0, r2, r0, r3
    2cac:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2cae:	f1c3 0301 	rsb	r3, r3, #1
    2cb2:	65c3      	str	r3, [r0, #92]	; 0x5c

void Scope_ToggleHelpScreen(bool hemisphere) {
    Scope_instance[hemisphere].HelpScreen();
}
    2cb4:	4770      	bx	lr
    2cb6:	bf00      	nop
    2cb8:	20001404 	.word	0x20001404

00002cbc <Sequence5::applet_name()>:
class Sequence5 : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "Sequence5";
    }
    2cbc:	4800      	ldr	r0, [pc, #0]	; (2cc0 <Sequence5::applet_name()+0x4>)
    2cbe:	4770      	bx	lr
    2cc0:	00020aa9 	.word	0x00020aa9

00002cc4 <Sequence5::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Reset";
    2cc4:	4b04      	ldr	r3, [pc, #16]	; (2cd8 <Sequence5::SetHelp()+0x14>)
    2cc6:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Transpose";
    2cc8:	4b04      	ldr	r3, [pc, #16]	; (2cdc <Sequence5::SetHelp()+0x18>)
    2cca:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=CV B=Clk Step 1";
    2ccc:	4b04      	ldr	r3, [pc, #16]	; (2ce0 <Sequence5::SetHelp()+0x1c>)
    2cce:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Note";
    2cd0:	4b04      	ldr	r3, [pc, #16]	; (2ce4 <Sequence5::SetHelp()+0x20>)
    2cd2:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2cd4:	4770      	bx	lr
    2cd6:	bf00      	nop
    2cd8:	00020480 	.word	0x00020480
    2cdc:	00020ab3 	.word	0x00020ab3
    2ce0:	00020abf 	.word	0x00020abf
    2ce4:	00020ad1 	.word	0x00020ad1

00002ce8 <Sequence5_OnButtonPress(bool)>:
        if (++cursor == 5) cursor = 0;
    2ce8:	4b05      	ldr	r3, [pc, #20]	; (2d00 <Sequence5_OnButtonPress(bool)+0x18>)
    2cea:	2290      	movs	r2, #144	; 0x90
    2cec:	fb02 3000 	mla	r0, r2, r0, r3
    2cf0:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
    2cf2:	2a04      	cmp	r2, #4
    2cf4:	f102 0301 	add.w	r3, r2, #1
    2cf8:	bf08      	it	eq
    2cfa:	2300      	moveq	r3, #0
    2cfc:	66c3      	str	r3, [r0, #108]	; 0x6c
    Sequence5_instance[hemisphere].BaseView();
}

void Sequence5_OnButtonPress(bool hemisphere) {
    Sequence5_instance[hemisphere].OnButtonPress();
}
    2cfe:	4770      	bx	lr
    2d00:	200015a4 	.word	0x200015a4

00002d04 <Sequence5_OnEncoderMove(bool, int)>:
        if (note[cursor] + direction < 0 && cursor > 0) {
    2d04:	4b18      	ldr	r3, [pc, #96]	; (2d68 <Sequence5_OnEncoderMove(bool, int)+0x64>)

void Sequence5_OnEncoderMove(bool hemisphere, int direction) {
    2d06:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (note[cursor] + direction < 0 && cursor > 0) {
    2d08:	2590      	movs	r5, #144	; 0x90
    2d0a:	fb05 3500 	mla	r5, r5, r0, r3
    2d0e:	2624      	movs	r6, #36	; 0x24
    2d10:	6eea      	ldr	r2, [r5, #108]	; 0x6c
    2d12:	fb06 2400 	mla	r4, r6, r0, r2
    2d16:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    2d1a:	6f67      	ldr	r7, [r4, #116]	; 0x74
            muted |= (0x01 << cursor);
    2d1c:	2401      	movs	r4, #1
        if (note[cursor] + direction < 0 && cursor > 0) {
    2d1e:	19c9      	adds	r1, r1, r7
            muted |= (0x01 << cursor);
    2d20:	fa04 f402 	lsl.w	r4, r4, r2
        if (note[cursor] + direction < 0 && cursor > 0) {
    2d24:	d50e      	bpl.n	2d44 <Sequence5_OnEncoderMove(bool, int)+0x40>
    2d26:	2a00      	cmp	r2, #0
    2d28:	dd0c      	ble.n	2d44 <Sequence5_OnEncoderMove(bool, int)+0x40>
            muted |= (0x01 << cursor);
    2d2a:	f895 2070 	ldrb.w	r2, [r5, #112]	; 0x70
    2d2e:	4322      	orrs	r2, r4
    2d30:	b2d2      	uxtb	r2, r2
    2d32:	2190      	movs	r1, #144	; 0x90
    2d34:	fb01 3300 	mla	r3, r1, r0, r3
    2d38:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
        play = 1; // Replay the changed step in the controller, so it can be heard
    2d3c:	2201      	movs	r2, #1
    2d3e:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
    Sequence5_instance[hemisphere].OnEncoderMove(direction);
}
    2d42:	bdf0      	pop	{r4, r5, r6, r7, pc}
            note[cursor] = constrain(note[cursor] += direction, 0, 30);
    2d44:	291e      	cmp	r1, #30
    2d46:	fb06 2200 	mla	r2, r6, r0, r2
    2d4a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    2d4e:	bfa8      	it	ge
    2d50:	211e      	movge	r1, #30
    2d52:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
    2d56:	6751      	str	r1, [r2, #116]	; 0x74
            muted &= ~(0x01 << cursor);
    2d58:	2290      	movs	r2, #144	; 0x90
    2d5a:	fb02 3200 	mla	r2, r2, r0, r3
    2d5e:	f892 2070 	ldrb.w	r2, [r2, #112]	; 0x70
    2d62:	ea22 0204 	bic.w	r2, r2, r4
    2d66:	e7e4      	b.n	2d32 <Sequence5_OnEncoderMove(bool, int)+0x2e>
    2d68:	200015a4 	.word	0x200015a4

00002d6c <Sequence5_ToggleHelpScreen(bool)>:
    2d6c:	4b04      	ldr	r3, [pc, #16]	; (2d80 <Sequence5_ToggleHelpScreen(bool)+0x14>)
    2d6e:	2290      	movs	r2, #144	; 0x90
    2d70:	fb02 3000 	mla	r0, r2, r0, r3
    2d74:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2d76:	f1c3 0301 	rsb	r3, r3, #1
    2d7a:	65c3      	str	r3, [r0, #92]	; 0x5c

void Sequence5_ToggleHelpScreen(bool hemisphere) {
    Sequence5_instance[hemisphere].HelpScreen();
}
    2d7c:	4770      	bx	lr
    2d7e:	bf00      	nop
    2d80:	200015a4 	.word	0x200015a4

00002d84 <Sequence5_OnDataRequest(bool)>:
        for (int s = 0; s < 5; s++)
    2d84:	490b      	ldr	r1, [pc, #44]	; (2db4 <Sequence5_OnDataRequest(bool)+0x30>)
    2d86:	2390      	movs	r3, #144	; 0x90
    2d88:	fb03 1300 	mla	r3, r3, r0, r1

uint32_t Sequence5_OnDataRequest(bool hemisphere) {
    return Sequence5_instance[hemisphere].OnDataRequest();
    2d8c:	2200      	movs	r2, #0
uint32_t Sequence5_OnDataRequest(bool hemisphere) {
    2d8e:	b530      	push	{r4, r5, lr}
    2d90:	3370      	adds	r3, #112	; 0x70
        uint32_t data = 0;
    2d92:	4614      	mov	r4, r2
        data |= (value << p.location);
    2d94:	f853 5f04 	ldr.w	r5, [r3, #4]!
    2d98:	4095      	lsls	r5, r2
        for (int s = 0; s < 5; s++)
    2d9a:	3205      	adds	r2, #5
    2d9c:	2a19      	cmp	r2, #25
    2d9e:	ea44 0405 	orr.w	r4, r4, r5
    2da2:	d1f7      	bne.n	2d94 <Sequence5_OnDataRequest(bool)+0x10>
        Pack(data, PackLocation{25,5}, muted);
    2da4:	2390      	movs	r3, #144	; 0x90
    2da6:	fb03 1100 	mla	r1, r3, r0, r1
    2daa:	f891 0070 	ldrb.w	r0, [r1, #112]	; 0x70
}
    2dae:	ea44 6040 	orr.w	r0, r4, r0, lsl #25
    2db2:	bd30      	pop	{r4, r5, pc}
    2db4:	200015a4 	.word	0x200015a4

00002db8 <ShiftGate::applet_name()>:
class ShiftGate : public HemisphereApplet {
public:

    const char* applet_name() {
        return "ShiftGate";
    }
    2db8:	4800      	ldr	r0, [pc, #0]	; (2dbc <ShiftGate::applet_name()+0x4>)
    2dba:	4770      	bx	lr
    2dbc:	00020ad6 	.word	0x00020ad6

00002dc0 <ShiftGate::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Freeze";
    2dc0:	4b04      	ldr	r3, [pc, #16]	; (2dd4 <ShiftGate::SetHelp()+0x14>)
    2dc2:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1,2 Gate=Flip Bit0";
    2dc4:	4b04      	ldr	r3, [pc, #16]	; (2dd8 <ShiftGate::SetHelp()+0x18>)
    2dc6:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A,B Gate/Trigger";
    2dc8:	4b04      	ldr	r3, [pc, #16]	; (2ddc <ShiftGate::SetHelp()+0x1c>)
    2dca:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Length/Type";
    2dcc:	4b04      	ldr	r3, [pc, #16]	; (2de0 <ShiftGate::SetHelp()+0x20>)
    2dce:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2dd0:	4770      	bx	lr
    2dd2:	bf00      	nop
    2dd4:	00020448 	.word	0x00020448
    2dd8:	00020ae0 	.word	0x00020ae0
    2ddc:	00020af3 	.word	0x00020af3
    2de0:	00020b04 	.word	0x00020b04

00002de4 <ShiftGate_OnButtonPress(bool)>:
        if (++cursor > 3) cursor = 0;
    2de4:	4b05      	ldr	r3, [pc, #20]	; (2dfc <ShiftGate_OnButtonPress(bool)+0x18>)
    2de6:	2278      	movs	r2, #120	; 0x78
    2de8:	fb02 3000 	mla	r0, r2, r0, r3
    2dec:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    2dee:	3301      	adds	r3, #1
    2df0:	2b04      	cmp	r3, #4
    2df2:	bfa8      	it	ge
    2df4:	2300      	movge	r3, #0
    2df6:	66c3      	str	r3, [r0, #108]	; 0x6c
ShiftGate ShiftGate_instance[2];

void ShiftGate_Start(bool hemisphere) {ShiftGate_instance[hemisphere].BaseStart(hemisphere);}
void ShiftGate_Controller(bool hemisphere, bool forwarding) {ShiftGate_instance[hemisphere].BaseController(forwarding);}
void ShiftGate_View(bool hemisphere) {ShiftGate_instance[hemisphere].BaseView();}
void ShiftGate_OnButtonPress(bool hemisphere) {ShiftGate_instance[hemisphere].OnButtonPress();}
    2df8:	4770      	bx	lr
    2dfa:	bf00      	nop
    2dfc:	20001744 	.word	0x20001744

00002e00 <ShiftGate_OnEncoderMove(bool, int)>:
        byte ch = cursor > 1 ? 1 : 0;
    2e00:	4b15      	ldr	r3, [pc, #84]	; (2e58 <ShiftGate_OnEncoderMove(bool, int)+0x58>)
    2e02:	2278      	movs	r2, #120	; 0x78
    2e04:	fb02 3200 	mla	r2, r2, r0, r3
void ShiftGate_OnEncoderMove(bool hemisphere, int direction) {ShiftGate_instance[hemisphere].OnEncoderMove(direction);}
    2e08:	b510      	push	{r4, lr}
        byte ch = cursor > 1 ? 1 : 0;
    2e0a:	6ed4      	ldr	r4, [r2, #108]	; 0x6c
    2e0c:	2c01      	cmp	r4, #1
        byte c = cursor > 1 ? cursor - 2 : cursor;
    2e0e:	b2e2      	uxtb	r2, r4
        byte ch = cursor > 1 ? 1 : 0;
    2e10:	dc1e      	bgt.n	2e50 <ShiftGate_OnEncoderMove(bool, int)+0x50>
    2e12:	2400      	movs	r4, #0
        if (c == 0) length[ch] = constrain(length[ch] + direction, 1, 16);
    2e14:	b97a      	cbnz	r2, 2e36 <ShiftGate_OnEncoderMove(bool, int)+0x36>
    2e16:	2278      	movs	r2, #120	; 0x78
    2e18:	fb02 3300 	mla	r3, r2, r0, r3
    2e1c:	4423      	add	r3, r4
    2e1e:	f993 2074 	ldrsb.w	r2, [r3, #116]	; 0x74
    2e22:	4411      	add	r1, r2
    2e24:	2910      	cmp	r1, #16
    2e26:	bfa8      	it	ge
    2e28:	2110      	movge	r1, #16
    2e2a:	2901      	cmp	r1, #1
    2e2c:	bfb8      	it	lt
    2e2e:	2101      	movlt	r1, #1
    2e30:	f883 1074 	strb.w	r1, [r3, #116]	; 0x74
void ShiftGate_OnEncoderMove(bool hemisphere, int direction) {ShiftGate_instance[hemisphere].OnEncoderMove(direction);}
    2e34:	bd10      	pop	{r4, pc}
        if (c == 1) trigger[ch] = 1 - trigger[ch];
    2e36:	2a01      	cmp	r2, #1
    2e38:	d1fc      	bne.n	2e34 <ShiftGate_OnEncoderMove(bool, int)+0x34>
    2e3a:	2278      	movs	r2, #120	; 0x78
    2e3c:	fb02 3300 	mla	r3, r2, r0, r3
    2e40:	4423      	add	r3, r4
    2e42:	f893 2076 	ldrb.w	r2, [r3, #118]	; 0x76
    2e46:	f082 0201 	eor.w	r2, r2, #1
    2e4a:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
void ShiftGate_OnEncoderMove(bool hemisphere, int direction) {ShiftGate_instance[hemisphere].OnEncoderMove(direction);}
    2e4e:	e7f1      	b.n	2e34 <ShiftGate_OnEncoderMove(bool, int)+0x34>
        byte c = cursor > 1 ? cursor - 2 : cursor;
    2e50:	3a02      	subs	r2, #2
    2e52:	b2d2      	uxtb	r2, r2
        byte ch = cursor > 1 ? 1 : 0;
    2e54:	2401      	movs	r4, #1
    2e56:	e7dd      	b.n	2e14 <ShiftGate_OnEncoderMove(bool, int)+0x14>
    2e58:	20001744 	.word	0x20001744

00002e5c <ShiftGate_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2e5c:	4b04      	ldr	r3, [pc, #16]	; (2e70 <ShiftGate_ToggleHelpScreen(bool)+0x14>)
    2e5e:	2278      	movs	r2, #120	; 0x78
    2e60:	fb02 3000 	mla	r0, r2, r0, r3
    2e64:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2e66:	f1c3 0301 	rsb	r3, r3, #1
    2e6a:	65c3      	str	r3, [r0, #92]	; 0x5c
void ShiftGate_ToggleHelpScreen(bool hemisphere) {ShiftGate_instance[hemisphere].HelpScreen();}
    2e6c:	4770      	bx	lr
    2e6e:	bf00      	nop
    2e70:	20001744 	.word	0x20001744

00002e74 <ShiftGate_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,1}, trigger[0]);
    2e74:	4b0c      	ldr	r3, [pc, #48]	; (2ea8 <ShiftGate_OnDataRequest(bool)+0x34>)
    2e76:	2278      	movs	r2, #120	; 0x78
    2e78:	fb02 3000 	mla	r0, r2, r0, r3
        Pack(data, PackLocation {9,1}, trigger[1]);
    2e7c:	f890 3077 	ldrb.w	r3, [r0, #119]	; 0x77
        Pack(data, PackLocation {8,1}, trigger[0]);
    2e80:	f890 2076 	ldrb.w	r2, [r0, #118]	; 0x76
        data |= (value << p.location);
    2e84:	025b      	lsls	r3, r3, #9
    2e86:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        Pack(data, PackLocation {16,16}, reg[0]);
    2e8a:	f8b0 2070 	ldrh.w	r2, [r0, #112]	; 0x70
    2e8e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
        Pack(data, PackLocation {0,4}, length[0] - 1);
    2e92:	f990 2074 	ldrsb.w	r2, [r0, #116]	; 0x74
        Pack(data, PackLocation {4,4}, length[1] - 1);
    2e96:	f990 0075 	ldrsb.w	r0, [r0, #117]	; 0x75
        Pack(data, PackLocation {0,4}, length[0] - 1);
    2e9a:	3a01      	subs	r2, #1
    2e9c:	4313      	orrs	r3, r2
        Pack(data, PackLocation {4,4}, length[1] - 1);
    2e9e:	3801      	subs	r0, #1
uint32_t ShiftGate_OnDataRequest(bool hemisphere) {return ShiftGate_instance[hemisphere].OnDataRequest();}
    2ea0:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
    2ea4:	4770      	bx	lr
    2ea6:	bf00      	nop
    2ea8:	20001744 	.word	0x20001744

00002eac <Shuffle::applet_name()>:
class Shuffle : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Shuffle";
    }
    2eac:	4800      	ldr	r0, [pc, #0]	; (2eb0 <Shuffle::applet_name()+0x4>)
    2eae:	4770      	bx	lr
    2eb0:	00020b10 	.word	0x00020b10

00002eb4 <Shuffle::Start()>:

    void Start() {
        delay[0] = 0;
    2eb4:	2300      	movs	r3, #0
        delay[1] = 0;
        which = 0;
        cursor = 1;
    2eb6:	2201      	movs	r2, #1
        delay[0] = 0;
    2eb8:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
        which = 0;
    2ebc:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
        cursor = 1;
    2ec0:	66c2      	str	r2, [r0, #108]	; 0x6c
        last_tick = 0;
    2ec2:	6743      	str	r3, [r0, #116]	; 0x74
    }
    2ec4:	4770      	bx	lr
    2ec6:	Address 0x0000000000002ec6 is out of bounds.


00002ec8 <Shuffle::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Reset";
    2ec8:	4b04      	ldr	r3, [pc, #16]	; (2edc <Shuffle::SetHelp()+0x14>)
    2eca:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Odd Mod 2=Even";
    2ecc:	4b04      	ldr	r3, [pc, #16]	; (2ee0 <Shuffle::SetHelp()+0x18>)
    2ece:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Clock";
    2ed0:	4b04      	ldr	r3, [pc, #16]	; (2ee4 <Shuffle::SetHelp()+0x1c>)
    2ed2:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Odd/Even Delay";
    2ed4:	4b04      	ldr	r3, [pc, #16]	; (2ee8 <Shuffle::SetHelp()+0x20>)
    2ed6:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    2ed8:	4770      	bx	lr
    2eda:	bf00      	nop
    2edc:	00020480 	.word	0x00020480
    2ee0:	00020b18 	.word	0x00020b18
    2ee4:	00020b29 	.word	0x00020b29
    2ee8:	00020b31 	.word	0x00020b31

00002eec <Shuffle_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    2eec:	4b04      	ldr	r3, [pc, #16]	; (2f00 <Shuffle_OnButtonPress(bool)+0x14>)
    2eee:	2284      	movs	r2, #132	; 0x84
    2ef0:	fb02 3000 	mla	r0, r2, r0, r3
    2ef4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    2ef6:	f1c3 0301 	rsb	r3, r3, #1
    2efa:	66c3      	str	r3, [r0, #108]	; 0x6c
    Shuffle_instance[hemisphere].BaseView();
}

void Shuffle_OnButtonPress(bool hemisphere) {
    Shuffle_instance[hemisphere].OnButtonPress();
}
    2efc:	4770      	bx	lr
    2efe:	bf00      	nop
    2f00:	20001834 	.word	0x20001834

00002f04 <Shuffle_OnEncoderMove(bool, int)>:
        delay[cursor] += direction;
    2f04:	4a0d      	ldr	r2, [pc, #52]	; (2f3c <Shuffle_OnEncoderMove(bool, int)+0x38>)
    2f06:	2384      	movs	r3, #132	; 0x84
    2f08:	fb03 2300 	mla	r3, r3, r0, r2

void Shuffle_OnEncoderMove(bool hemisphere, int direction) {
    2f0c:	b530      	push	{r4, r5, lr}
        delay[cursor] += direction;
    2f0e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    2f10:	2542      	movs	r5, #66	; 0x42
    2f12:	fb05 3400 	mla	r4, r5, r0, r3
    2f16:	3440      	adds	r4, #64	; 0x40
    2f18:	f832 4014 	ldrh.w	r4, [r2, r4, lsl #1]
    2f1c:	4421      	add	r1, r4
    2f1e:	b209      	sxth	r1, r1
        delay[cursor] = constrain(delay[cursor], 0, 99);
    2f20:	2900      	cmp	r1, #0
    2f22:	db08      	blt.n	2f36 <Shuffle_OnEncoderMove(bool, int)+0x32>
    2f24:	2963      	cmp	r1, #99	; 0x63
    2f26:	bfa8      	it	ge
    2f28:	2163      	movge	r1, #99	; 0x63
    2f2a:	fb05 3300 	mla	r3, r5, r0, r3
    2f2e:	3340      	adds	r3, #64	; 0x40
    2f30:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    Shuffle_instance[hemisphere].OnEncoderMove(direction);
}
    2f34:	bd30      	pop	{r4, r5, pc}
        delay[cursor] = constrain(delay[cursor], 0, 99);
    2f36:	2100      	movs	r1, #0
    2f38:	e7f7      	b.n	2f2a <Shuffle_OnEncoderMove(bool, int)+0x26>
    2f3a:	bf00      	nop
    2f3c:	20001834 	.word	0x20001834

00002f40 <Shuffle_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    2f40:	4b04      	ldr	r3, [pc, #16]	; (2f54 <Shuffle_ToggleHelpScreen(bool)+0x14>)
    2f42:	2284      	movs	r2, #132	; 0x84
    2f44:	fb02 3000 	mla	r0, r2, r0, r3
    2f48:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2f4a:	f1c3 0301 	rsb	r3, r3, #1
    2f4e:	65c3      	str	r3, [r0, #92]	; 0x5c

void Shuffle_ToggleHelpScreen(bool hemisphere) {
    Shuffle_instance[hemisphere].HelpScreen();
}
    2f50:	4770      	bx	lr
    2f52:	bf00      	nop
    2f54:	20001834 	.word	0x20001834

00002f58 <Shuffle_OnDataRequest(bool)>:
        Pack(data, PackLocation {7,7}, delay[1]);
    2f58:	4b05      	ldr	r3, [pc, #20]	; (2f70 <Shuffle_OnDataRequest(bool)+0x18>)
    2f5a:	2284      	movs	r2, #132	; 0x84
    2f5c:	fb02 3300 	mla	r3, r2, r0, r3
    2f60:	f9b3 0082 	ldrsh.w	r0, [r3, #130]	; 0x82
        Pack(data, PackLocation {0,7}, delay[0]);
    2f64:	f9b3 3080 	ldrsh.w	r3, [r3, #128]	; 0x80

uint32_t Shuffle_OnDataRequest(bool hemisphere) {
    return Shuffle_instance[hemisphere].OnDataRequest();
}
    2f68:	ea43 10c0 	orr.w	r0, r3, r0, lsl #7
    2f6c:	4770      	bx	lr
    2f6e:	bf00      	nop
    2f70:	20001834 	.word	0x20001834

00002f74 <SkewedLFO::applet_name()>:
class SkewedLFO : public HemisphereApplet {
public:

    const char* applet_name() {
        return "SkewedLFO";
    }
    2f74:	4800      	ldr	r0, [pc, #0]	; (2f78 <SkewedLFO::applet_name()+0x4>)
    2f76:	4770      	bx	lr
    2f78:	00020b40 	.word	0x00020b40

00002f7c <SkewedLFO::Start()>:

    void Start() {
        rate = 61;
    2f7c:	233d      	movs	r3, #61	; 0x3d
    2f7e:	66c3      	str	r3, [r0, #108]	; 0x6c
        skew = 61;
    2f80:	6703      	str	r3, [r0, #112]	; 0x70
        cursor = 0;
    2f82:	2300      	movs	r3, #0
    2f84:	6743      	str	r3, [r0, #116]	; 0x74
        cycle_tick = 0;
    2f86:	6783      	str	r3, [r0, #120]	; 0x78
    }
    2f88:	4770      	bx	lr
    2f8a:	Address 0x0000000000002f8a is out of bounds.


00002f8c <SkewedLFO::SetHelp()>:
        rate = Unpack(data, PackLocation {8,8});
    }

protected:
    void SetHelp() {
        help[HEMISPHERE_HELP_DIGITALS] = "1=Reset";
    2f8c:	4b04      	ldr	r3, [pc, #16]	; (2fa0 <SkewedLFO::SetHelp()+0x14>)
    2f8e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "Mod 1=Rate 2=Skew";
    2f90:	4b04      	ldr	r3, [pc, #16]	; (2fa4 <SkewedLFO::SetHelp()+0x18>)
    2f92:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "A=CV B=Clock";
    2f94:	4b04      	ldr	r3, [pc, #16]	; (2fa8 <SkewedLFO::SetHelp()+0x1c>)
    2f96:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "Rate/Skew";
    2f98:	4b04      	ldr	r3, [pc, #16]	; (2fac <SkewedLFO::SetHelp()+0x20>)
    2f9a:	6143      	str	r3, [r0, #20]
    }
    2f9c:	4770      	bx	lr
    2f9e:	bf00      	nop
    2fa0:	00020b4a 	.word	0x00020b4a
    2fa4:	00020b52 	.word	0x00020b52
    2fa8:	00020b64 	.word	0x00020b64
    2fac:	00020b71 	.word	0x00020b71

00002fb0 <SkewedLFO_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    2fb0:	4b04      	ldr	r3, [pc, #16]	; (2fc4 <SkewedLFO_OnButtonPress(bool)+0x14>)
    2fb2:	2284      	movs	r2, #132	; 0x84
    2fb4:	fb02 3000 	mla	r0, r2, r0, r3
    2fb8:	6f43      	ldr	r3, [r0, #116]	; 0x74
    2fba:	f1c3 0301 	rsb	r3, r3, #1
    2fbe:	6743      	str	r3, [r0, #116]	; 0x74
    SkewedLFO_instance[hemisphere].BaseView();
}

void SkewedLFO_OnButtonPress(bool hemisphere) {
    SkewedLFO_instance[hemisphere].OnButtonPress();
}
    2fc0:	4770      	bx	lr
    2fc2:	bf00      	nop
    2fc4:	2000193c 	.word	0x2000193c

00002fc8 <SkewedLFO_ToggleHelpScreen(bool)>:
    2fc8:	4b04      	ldr	r3, [pc, #16]	; (2fdc <SkewedLFO_ToggleHelpScreen(bool)+0x14>)
    2fca:	2284      	movs	r2, #132	; 0x84
    2fcc:	fb02 3000 	mla	r0, r2, r0, r3
    2fd0:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    2fd2:	f1c3 0301 	rsb	r3, r3, #1
    2fd6:	65c3      	str	r3, [r0, #92]	; 0x5c
    SkewedLFO_instance[hemisphere].OnEncoderMove(direction);
}

void SkewedLFO_ToggleHelpScreen(bool hemisphere) {
    SkewedLFO_instance[hemisphere].HelpScreen();
}
    2fd8:	4770      	bx	lr
    2fda:	bf00      	nop
    2fdc:	2000193c 	.word	0x2000193c

00002fe0 <SkewedLFO_OnDataRequest(bool)>:
        Pack(data, PackLocation {8, 8}, rate);
    2fe0:	4b04      	ldr	r3, [pc, #16]	; (2ff4 <SkewedLFO_OnDataRequest(bool)+0x14>)
    2fe2:	2284      	movs	r2, #132	; 0x84
    2fe4:	fb02 3300 	mla	r3, r2, r0, r3
        data |= (value << p.location);
    2fe8:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
    2fea:	6f1b      	ldr	r3, [r3, #112]	; 0x70

uint32_t SkewedLFO_OnDataRequest(bool hemisphere) {
    return SkewedLFO_instance[hemisphere].OnDataRequest();
}
    2fec:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    2ff0:	4770      	bx	lr
    2ff2:	bf00      	nop
    2ff4:	2000193c 	.word	0x2000193c

00002ff8 <Slew::applet_name()>:
class Slew : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "Slew";
    }
    2ff8:	4800      	ldr	r0, [pc, #0]	; (2ffc <Slew::applet_name()+0x4>)
    2ffa:	4770      	bx	lr
    2ffc:	00020b7b 	.word	0x00020b7b

00003000 <Slew::Start()>:

    void Start() {
        ForEachChannel(ch) signal[ch] = 0;
    3000:	2300      	movs	r3, #0
    3002:	6743      	str	r3, [r0, #116]	; 0x74
    3004:	6783      	str	r3, [r0, #120]	; 0x78
        rise = 50;
    3006:	2332      	movs	r3, #50	; 0x32
    3008:	66c3      	str	r3, [r0, #108]	; 0x6c
        fall = 50;
    300a:	6703      	str	r3, [r0, #112]	; 0x70
    }
    300c:	4770      	bx	lr
    300e:	Address 0x000000000000300e is out of bounds.


00003010 <Slew::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "Defeat 1=Ch1 2=Ch2";
    3010:	4b04      	ldr	r3, [pc, #16]	; (3024 <Slew::SetHelp()+0x14>)
    3012:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "Input 1=Ch1 2=Ch2";
    3014:	4b04      	ldr	r3, [pc, #16]	; (3028 <Slew::SetHelp()+0x18>)
    3016:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Linear B=Exp";
    3018:	4b04      	ldr	r3, [pc, #16]	; (302c <Slew::SetHelp()+0x1c>)
    301a:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Rise/Fall";
    301c:	4b04      	ldr	r3, [pc, #16]	; (3030 <Slew::SetHelp()+0x20>)
    301e:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    3020:	4770      	bx	lr
    3022:	bf00      	nop
    3024:	00020b80 	.word	0x00020b80
    3028:	00020b93 	.word	0x00020b93
    302c:	00020ba5 	.word	0x00020ba5
    3030:	00020bb4 	.word	0x00020bb4

00003034 <Slew_OnButtonPress(bool)>:
        cursor = 1 - cursor;
    3034:	4b04      	ldr	r3, [pc, #16]	; (3048 <Slew_OnButtonPress(bool)+0x14>)
    3036:	2288      	movs	r2, #136	; 0x88
    3038:	fb02 3000 	mla	r0, r2, r0, r3
    303c:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
    303e:	f1c3 0301 	rsb	r3, r3, #1
    3042:	67c3      	str	r3, [r0, #124]	; 0x7c
    Slew_instance[hemisphere].BaseView();
}

void Slew_OnButtonPress(bool hemisphere) {
    Slew_instance[hemisphere].OnButtonPress();
}
    3044:	4770      	bx	lr
    3046:	bf00      	nop
    3048:	20001a44 	.word	0x20001a44

0000304c <Slew_OnEncoderMove(bool, int)>:
        if (cursor == 0) {
    304c:	4a16      	ldr	r2, [pc, #88]	; (30a8 <Slew_OnEncoderMove(bool, int)+0x5c>)
    304e:	2388      	movs	r3, #136	; 0x88
    3050:	fb03 2300 	mla	r3, r3, r0, r2

void Slew_OnEncoderMove(bool hemisphere, int direction) {
    3054:	b510      	push	{r4, lr}
        if (cursor == 0) {
    3056:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
    3058:	b9e4      	cbnz	r4, 3094 <Slew_OnEncoderMove(bool, int)+0x48>
            rise = constrain(rise += direction, 0, HEM_SLEW_MAX_VALUE);
    305a:	6edc      	ldr	r4, [r3, #108]	; 0x6c
    305c:	4421      	add	r1, r4
    305e:	29c8      	cmp	r1, #200	; 0xc8
    3060:	bfa8      	it	ge
    3062:	21c8      	movge	r1, #200	; 0xc8
    3064:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
    3068:	66d9      	str	r1, [r3, #108]	; 0x6c
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    306a:	038b      	lsls	r3, r1, #14
    306c:	21c8      	movs	r1, #200	; 0xc8
    306e:	fbb3 f3f1 	udiv	r3, r3, r1
        int scaled = simfloat2int(proportion * max_value);
    3072:	f44f 417a 	mov.w	r1, #64000	; 0xfa00
    3076:	434b      	muls	r3, r1
    3078:	139b      	asrs	r3, r3, #14
            last_ms_value = Proportion(fall, HEM_SLEW_MAX_VALUE, HEM_SLEW_MAX_TICKS) / 17;
    307a:	2111      	movs	r1, #17
    307c:	fbb3 f3f1 	udiv	r3, r3, r1
            last_ms_value = Proportion(rise, HEM_SLEW_MAX_VALUE, HEM_SLEW_MAX_TICKS) / 17;
    3080:	2188      	movs	r1, #136	; 0x88
    3082:	fb01 2200 	mla	r2, r1, r0, r2
    3086:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
        last_change_ticks = OC::CORE::ticks;
    308a:	4b08      	ldr	r3, [pc, #32]	; (30ac <Slew_OnEncoderMove(bool, int)+0x60>)
    308c:	681b      	ldr	r3, [r3, #0]
    308e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    Slew_instance[hemisphere].OnEncoderMove(direction);
}
    3092:	bd10      	pop	{r4, pc}
            fall = constrain(fall += direction, 0, HEM_SLEW_MAX_VALUE);
    3094:	6f1c      	ldr	r4, [r3, #112]	; 0x70
    3096:	4421      	add	r1, r4
    3098:	29c8      	cmp	r1, #200	; 0xc8
    309a:	bfa8      	it	ge
    309c:	21c8      	movge	r1, #200	; 0xc8
    309e:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
    30a2:	6719      	str	r1, [r3, #112]	; 0x70
    30a4:	e7e1      	b.n	306a <Slew_OnEncoderMove(bool, int)+0x1e>
    30a6:	bf00      	nop
    30a8:	20001a44 	.word	0x20001a44
    30ac:	200046cc 	.word	0x200046cc

000030b0 <Slew_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    30b0:	4b04      	ldr	r3, [pc, #16]	; (30c4 <Slew_ToggleHelpScreen(bool)+0x14>)
    30b2:	2288      	movs	r2, #136	; 0x88
    30b4:	fb02 3000 	mla	r0, r2, r0, r3
    30b8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    30ba:	f1c3 0301 	rsb	r3, r3, #1
    30be:	65c3      	str	r3, [r0, #92]	; 0x5c

void Slew_ToggleHelpScreen(bool hemisphere) {
    Slew_instance[hemisphere].HelpScreen();
}
    30c0:	4770      	bx	lr
    30c2:	bf00      	nop
    30c4:	20001a44 	.word	0x20001a44

000030c8 <Slew_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, fall);
    30c8:	4b04      	ldr	r3, [pc, #16]	; (30dc <Slew_OnDataRequest(bool)+0x14>)
    30ca:	2288      	movs	r2, #136	; 0x88
    30cc:	fb02 3300 	mla	r3, r2, r0, r3
        data |= (value << p.location);
    30d0:	6f18      	ldr	r0, [r3, #112]	; 0x70
    30d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c

uint32_t Slew_OnDataRequest(bool hemisphere) {
    return Slew_instance[hemisphere].OnDataRequest();
}
    30d4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    30d8:	4770      	bx	lr
    30da:	bf00      	nop
    30dc:	20001a44 	.word	0x20001a44

000030e0 <Squanch::applet_name()>:
class Squanch : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Squanch";
    }
    30e0:	4800      	ldr	r0, [pc, #0]	; (30e4 <Squanch::applet_name()+0x4>)
    30e2:	4770      	bx	lr
    30e4:	00020bbe 	.word	0x00020bbe

000030e8 <Squanch::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=+1 Oct A";
    30e8:	4b04      	ldr	r3, [pc, #16]	; (30fc <Squanch::SetHelp()+0x14>)
    30ea:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Signal 2=Shift B";
    30ec:	4b04      	ldr	r3, [pc, #16]	; (3100 <Squanch::SetHelp()+0x18>)
    30ee:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A,B=Quantized";
    30f0:	4b04      	ldr	r3, [pc, #16]	; (3104 <Squanch::SetHelp()+0x1c>)
    30f2:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Shift/Scale";
    30f4:	4b04      	ldr	r3, [pc, #16]	; (3108 <Squanch::SetHelp()+0x20>)
    30f6:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    30f8:	4770      	bx	lr
    30fa:	bf00      	nop
    30fc:	00020bc6 	.word	0x00020bc6
    3100:	00020bd9 	.word	0x00020bd9
    3104:	00020bec 	.word	0x00020bec
    3108:	00020bfa 	.word	0x00020bfa

0000310c <Squanch_OnButtonPress(bool)>:
        if (++cursor > 2) cursor = 0;
    310c:	4b05      	ldr	r3, [pc, #20]	; (3124 <Squanch_OnButtonPress(bool)+0x18>)
    310e:	f44f 72de 	mov.w	r2, #444	; 0x1bc
    3112:	fb02 3000 	mla	r0, r2, r0, r3
    3116:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3118:	3301      	adds	r3, #1
    311a:	2b03      	cmp	r3, #3
    311c:	bfa8      	it	ge
    311e:	2300      	movge	r3, #0
    3120:	66c3      	str	r3, [r0, #108]	; 0x6c
Squanch Squanch_instance[2];

void Squanch_Start(bool hemisphere) {Squanch_instance[hemisphere].BaseStart(hemisphere);}
void Squanch_Controller(bool hemisphere, bool forwarding) {Squanch_instance[hemisphere].BaseController(forwarding);}
void Squanch_View(bool hemisphere) {Squanch_instance[hemisphere].BaseView();}
void Squanch_OnButtonPress(bool hemisphere) {Squanch_instance[hemisphere].OnButtonPress();}
    3122:	4770      	bx	lr
    3124:	20001b54 	.word	0x20001b54

00003128 <Squanch_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3128:	4b04      	ldr	r3, [pc, #16]	; (313c <Squanch_ToggleHelpScreen(bool)+0x14>)
    312a:	f44f 72de 	mov.w	r2, #444	; 0x1bc
    312e:	fb02 3000 	mla	r0, r2, r0, r3
    3132:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    3134:	f1c3 0301 	rsb	r3, r3, #1
    3138:	65c3      	str	r3, [r0, #92]	; 0x5c
void Squanch_OnEncoderMove(bool hemisphere, int direction) {Squanch_instance[hemisphere].OnEncoderMove(direction);}
void Squanch_ToggleHelpScreen(bool hemisphere) {Squanch_instance[hemisphere].HelpScreen();}
    313a:	4770      	bx	lr
    313c:	20001b54 	.word	0x20001b54

00003140 <Squanch_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, shift[0] + 48);
    3140:	4b08      	ldr	r3, [pc, #32]	; (3164 <Squanch_OnDataRequest(bool)+0x24>)
    3142:	f44f 72de 	mov.w	r2, #444	; 0x1bc
    3146:	fb02 3000 	mla	r0, r2, r0, r3
        Pack(data, PackLocation {16,8}, shift[1] + 48);
    314a:	f9b0 31ba 	ldrsh.w	r3, [r0, #442]	; 0x1ba
        Pack(data, PackLocation {8,8}, shift[0] + 48);
    314e:	f9b0 21b8 	ldrsh.w	r2, [r0, #440]	; 0x1b8
        data |= (value << p.location);
    3152:	f8d0 01b4 	ldr.w	r0, [r0, #436]	; 0x1b4
        Pack(data, PackLocation {16,8}, shift[1] + 48);
    3156:	3330      	adds	r3, #48	; 0x30
        Pack(data, PackLocation {8,8}, shift[0] + 48);
    3158:	3230      	adds	r2, #48	; 0x30
    315a:	041b      	lsls	r3, r3, #16
    315c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
uint32_t Squanch_OnDataRequest(bool hemisphere) {return Squanch_instance[hemisphere].OnDataRequest();}
    3160:	4318      	orrs	r0, r3
    3162:	4770      	bx	lr
    3164:	20001b54 	.word	0x20001b54

00003168 <Switch::applet_name()>:
class Switch : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Switch";
    }
    3168:	4800      	ldr	r0, [pc, #0]	; (316c <Switch::applet_name()+0x4>)
    316a:	4770      	bx	lr
    316c:	00020c06 	.word	0x00020c06

00003170 <Switch::Start()>:

    void Start() {
        active[0] = 1;
    3170:	2301      	movs	r3, #1
    3172:	6703      	str	r3, [r0, #112]	; 0x70
        active[1] = 1;
    3174:	6743      	str	r3, [r0, #116]	; 0x74
    }
    3176:	4770      	bx	lr

00003178 <Switch::SetHelp()>:
    }

protected:
    void SetHelp() {
        // Each help section can have up to 18 characters. Be concise!
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Gate";
    3178:	4b04      	ldr	r3, [pc, #16]	; (318c <Switch::SetHelp()+0x14>)
    317a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS] = "1,2=CV";
    317c:	4b04      	ldr	r3, [pc, #16]	; (3190 <Switch::SetHelp()+0x18>)
    317e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS] = "A=Seq B=Gated Out";
    3180:	4b04      	ldr	r3, [pc, #16]	; (3194 <Switch::SetHelp()+0x1c>)
    3182:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER] = "";
    3184:	4b04      	ldr	r3, [pc, #16]	; (3198 <Switch::SetHelp()+0x20>)
    3186:	6143      	str	r3, [r0, #20]
    }
    3188:	4770      	bx	lr
    318a:	bf00      	nop
    318c:	00020c0d 	.word	0x00020c0d
    3190:	00020c1c 	.word	0x00020c1c
    3194:	00020c23 	.word	0x00020c23
    3198:	000211c8 	.word	0x000211c8

0000319c <Switch_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    319c:	4b04      	ldr	r3, [pc, #16]	; (31b0 <Switch_ToggleHelpScreen(bool)+0x14>)
    319e:	2278      	movs	r2, #120	; 0x78
    31a0:	fb02 3000 	mla	r0, r2, r0, r3
    31a4:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    31a6:	f1c3 0301 	rsb	r3, r3, #1
    31aa:	65c3      	str	r3, [r0, #92]	; 0x5c
    Switch_instance[hemisphere].OnEncoderMove(direction);
}

void Switch_ToggleHelpScreen(bool hemisphere) {
    Switch_instance[hemisphere].HelpScreen();
}
    31ac:	4770      	bx	lr
    31ae:	bf00      	nop
    31b0:	20001ecc 	.word	0x20001ecc

000031b4 <TLNeuron::applet_name()>:
class TLNeuron : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "TL Neuron";
    }
    31b4:	4800      	ldr	r0, [pc, #0]	; (31b8 <TLNeuron::applet_name()+0x4>)
    31b6:	4770      	bx	lr
    31b8:	00020c35 	.word	0x00020c35

000031bc <TLNeuron::Start()>:

    void Start() {
        selected = 0;
    31bc:	2300      	movs	r3, #0
    31be:	66c3      	str	r3, [r0, #108]	; 0x6c
    }
    31c0:	4770      	bx	lr
    31c2:	Address 0x00000000000031c2 is out of bounds.


000031c4 <TLNeuron::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1,2=Dendrites 1,2";
    31c4:	4b04      	ldr	r3, [pc, #16]	; (31d8 <TLNeuron::SetHelp()+0x14>)
    31c6:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "2=Dendrite3";
    31c8:	4b04      	ldr	r3, [pc, #16]	; (31dc <TLNeuron::SetHelp()+0x18>)
    31ca:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A,B=Axon Output";
    31cc:	4b04      	ldr	r3, [pc, #16]	; (31e0 <TLNeuron::SetHelp()+0x1c>)
    31ce:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "T=Set P=Select";
    31d0:	4b04      	ldr	r3, [pc, #16]	; (31e4 <TLNeuron::SetHelp()+0x20>)
    31d2:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    31d4:	4770      	bx	lr
    31d6:	bf00      	nop
    31d8:	00020c3f 	.word	0x00020c3f
    31dc:	00020c51 	.word	0x00020c51
    31e0:	00020c5d 	.word	0x00020c5d
    31e4:	00020c6d 	.word	0x00020c6d

000031e8 <TLNeuron_OnButtonPress(bool)>:
void TLNeuron_View(bool hemisphere) {
    TLNeuron_instance[hemisphere].BaseView();
}

void TLNeuron_OnButtonPress(bool hemisphere) {
    TLNeuron_instance[hemisphere].OnButtonPress();
    31e8:	4b06      	ldr	r3, [pc, #24]	; (3204 <TLNeuron_OnButtonPress(bool)+0x1c>)
    31ea:	228c      	movs	r2, #140	; 0x8c
    31ec:	fb02 3000 	mla	r0, r2, r0, r3
        if (++selected > 3) selected = 0;
    31f0:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    31f2:	3301      	adds	r3, #1
    31f4:	2b04      	cmp	r3, #4
    31f6:	bfa8      	it	ge
    31f8:	2300      	movge	r3, #0
    31fa:	66c3      	str	r3, [r0, #108]	; 0x6c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    31fc:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    3200:	6483      	str	r3, [r0, #72]	; 0x48
}
    3202:	4770      	bx	lr
    3204:	20001fbc 	.word	0x20001fbc

00003208 <TLNeuron_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3208:	4b04      	ldr	r3, [pc, #16]	; (321c <TLNeuron_ToggleHelpScreen(bool)+0x14>)
    320a:	228c      	movs	r2, #140	; 0x8c
    320c:	fb02 3000 	mla	r0, r2, r0, r3
    3210:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    3212:	f1c3 0301 	rsb	r3, r3, #1
    3216:	65c3      	str	r3, [r0, #92]	; 0x5c
    TLNeuron_instance[hemisphere].OnEncoderMove(direction);
}

void TLNeuron_ToggleHelpScreen(bool hemisphere) {
    TLNeuron_instance[hemisphere].HelpScreen();
}
    3218:	4770      	bx	lr
    321a:	bf00      	nop
    321c:	20001fbc 	.word	0x20001fbc

00003220 <TLNeuron_OnDataRequest(bool)>:
        Pack(data, PackLocation {5,5}, dendrite_weight[1] + 9);
    3220:	4b09      	ldr	r3, [pc, #36]	; (3248 <TLNeuron_OnDataRequest(bool)+0x28>)
    3222:	228c      	movs	r2, #140	; 0x8c
    3224:	fb02 3000 	mla	r0, r2, r0, r3
    3228:	6f43      	ldr	r3, [r0, #116]	; 0x74
    322a:	f103 0209 	add.w	r2, r3, #9
        Pack(data, PackLocation {10,5}, dendrite_weight[2] + 9);
    322e:	6f83      	ldr	r3, [r0, #120]	; 0x78
    3230:	3309      	adds	r3, #9
        data |= (value << p.location);
    3232:	029b      	lsls	r3, r3, #10
    3234:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
        Pack(data, PackLocation {0,5}, dendrite_weight[0] + 9);
    3238:	6f02      	ldr	r2, [r0, #112]	; 0x70
        Pack(data, PackLocation {15,6}, threshold + 27);
    323a:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
        Pack(data, PackLocation {0,5}, dendrite_weight[0] + 9);
    323c:	3209      	adds	r2, #9
    323e:	4313      	orrs	r3, r2
        Pack(data, PackLocation {15,6}, threshold + 27);
    3240:	301b      	adds	r0, #27

uint32_t TLNeuron_OnDataRequest(bool hemisphere) {
    return TLNeuron_instance[hemisphere].OnDataRequest();
}
    3242:	ea43 30c0 	orr.w	r0, r3, r0, lsl #15
    3246:	4770      	bx	lr
    3248:	20001fbc 	.word	0x20001fbc

0000324c <TM::applet_name()>:
class TM : public HemisphereApplet {
public:

    const char* applet_name() {
        return "ShiftReg";
    }
    324c:	4800      	ldr	r0, [pc, #0]	; (3250 <TM::applet_name()+0x4>)
    324e:	4770      	bx	lr
    3250:	00020c7c 	.word	0x00020c7c

00003254 <TM::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=p Gate";
    3254:	4b04      	ldr	r3, [pc, #16]	; (3268 <TM::SetHelp()+0x14>)
    3256:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Length 2=p Mod";
    3258:	4b04      	ldr	r3, [pc, #16]	; (326c <TM::SetHelp()+0x18>)
    325a:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A=Quant5-bit B=CV8";
    325c:	4b04      	ldr	r3, [pc, #16]	; (3270 <TM::SetHelp()+0x1c>)
    325e:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Length/Prob/Scale";
    3260:	4b04      	ldr	r3, [pc, #16]	; (3274 <TM::SetHelp()+0x20>)
    3262:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    3264:	4770      	bx	lr
    3266:	bf00      	nop
    3268:	00020c85 	.word	0x00020c85
    326c:	00020c96 	.word	0x00020c96
    3270:	00020ca7 	.word	0x00020ca7
    3274:	00020cba 	.word	0x00020cba

00003278 <TM_OnButtonPress(bool)>:
        if (++cursor > 2) cursor = 0;
    3278:	4b05      	ldr	r3, [pc, #20]	; (3290 <TM_OnButtonPress(bool)+0x18>)
    327a:	f44f 72dc 	mov.w	r2, #440	; 0x1b8
    327e:	fb02 3000 	mla	r0, r2, r0, r3
    3282:	6f03      	ldr	r3, [r0, #112]	; 0x70
    3284:	3301      	adds	r3, #1
    3286:	2b03      	cmp	r3, #3
    3288:	bfa8      	it	ge
    328a:	2300      	movge	r3, #0
    328c:	6703      	str	r3, [r0, #112]	; 0x70
    TM_instance[hemisphere].BaseView();
}

void TM_OnButtonPress(bool hemisphere) {
    TM_instance[hemisphere].OnButtonPress();
}
    328e:	4770      	bx	lr
    3290:	200020d4 	.word	0x200020d4

00003294 <TM_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3294:	4b04      	ldr	r3, [pc, #16]	; (32a8 <TM_ToggleHelpScreen(bool)+0x14>)
    3296:	f44f 72dc 	mov.w	r2, #440	; 0x1b8
    329a:	fb02 3000 	mla	r0, r2, r0, r3
    329e:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    32a0:	f1c3 0301 	rsb	r3, r3, #1
    32a4:	65c3      	str	r3, [r0, #92]	; 0x5c
    TM_instance[hemisphere].OnEncoderMove(direction);
}

void TM_ToggleHelpScreen(bool hemisphere) {
    TM_instance[hemisphere].HelpScreen();
}
    32a6:	4770      	bx	lr
    32a8:	200020d4 	.word	0x200020d4

000032ac <TM_OnDataRequest(bool)>:
        Pack(data, PackLocation {16,7}, p);
    32ac:	4b09      	ldr	r3, [pc, #36]	; (32d4 <TM_OnDataRequest(bool)+0x28>)
    32ae:	f44f 72dc 	mov.w	r2, #440	; 0x1b8
    32b2:	fb02 3000 	mla	r0, r2, r0, r3
        Pack(data, PackLocation {27,6}, scale);
    32b6:	f990 31b4 	ldrsb.w	r3, [r0, #436]	; 0x1b4
        data |= (value << p.location);
    32ba:	f8d0 21b0 	ldr.w	r2, [r0, #432]	; 0x1b0
    32be:	06db      	lsls	r3, r3, #27
    32c0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
        Pack(data, PackLocation {0,16}, reg);
    32c4:	f8b0 21ac 	ldrh.w	r2, [r0, #428]	; 0x1ac
        Pack(data, PackLocation {23,4}, length - 1);
    32c8:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
    32ca:	4313      	orrs	r3, r2
    32cc:	3801      	subs	r0, #1

uint32_t TM_OnDataRequest(bool hemisphere) {
    return TM_instance[hemisphere].OnDataRequest();
}
    32ce:	ea43 50c0 	orr.w	r0, r3, r0, lsl #23
    32d2:	4770      	bx	lr
    32d4:	200020d4 	.word	0x200020d4

000032d8 <Trending::applet_name()>:
class Trending : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Trending";
    }
    32d8:	4800      	ldr	r0, [pc, #0]	; (32dc <Trending::applet_name()+0x4>)
    32da:	4770      	bx	lr
    32dc:	00020ccc 	.word	0x00020ccc

000032e0 <Trending::Start()>:

    void Start() {
        ForEachChannel(ch)
        {
            assign[ch] = ch;
            result[ch] = 0;
    32e0:	2300      	movs	r3, #0
    32e2:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    32e6:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
            fire[ch] = 0;
    32ea:	f8a0 3096 	strh.w	r3, [r0, #150]	; 0x96
            assign[ch] = ch;
    32ee:	f44f 7280 	mov.w	r2, #256	; 0x100
        }
        sample_countdown = 0;
    32f2:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
        sensitivity = 40;
    32f6:	2328      	movs	r3, #40	; 0x28
            assign[ch] = ch;
    32f8:	f8a0 2098 	strh.w	r2, [r0, #152]	; 0x98
        sensitivity = 40;
    32fc:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    }
    3300:	4770      	bx	lr
    3302:	Address 0x0000000000003302 is out of bounds.


00003304 <Trending::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    3304:	4b04      	ldr	r3, [pc, #16]	; (3318 <Trending::SetHelp()+0x14>)
    3306:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1,2=Signal";
    3308:	4b04      	ldr	r3, [pc, #16]	; (331c <Trending::SetHelp()+0x18>)
    330a:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A,B=Assignable";
    330c:	4b04      	ldr	r3, [pc, #16]	; (3320 <Trending::SetHelp()+0x1c>)
    330e:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Assign/Sensitivity";
    3310:	4b04      	ldr	r3, [pc, #16]	; (3324 <Trending::SetHelp()+0x20>)
    3312:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    3314:	4770      	bx	lr
    3316:	bf00      	nop
    3318:	000211c8 	.word	0x000211c8
    331c:	00020cd5 	.word	0x00020cd5
    3320:	00020ce0 	.word	0x00020ce0
    3324:	00020cef 	.word	0x00020cef

00003328 <Trending_OnButtonPress(bool)>:
Trending Trending_instance[2];

void Trending_Start(bool hemisphere) {Trending_instance[hemisphere].BaseStart(hemisphere);}
void Trending_Controller(bool hemisphere, bool forwarding) {Trending_instance[hemisphere].BaseController(forwarding);}
void Trending_View(bool hemisphere) {Trending_instance[hemisphere].BaseView();}
void Trending_OnButtonPress(bool hemisphere) {Trending_instance[hemisphere].OnButtonPress();}
    3328:	4b06      	ldr	r3, [pc, #24]	; (3344 <Trending_OnButtonPress(bool)+0x1c>)
    332a:	22a0      	movs	r2, #160	; 0xa0
    332c:	fb02 3000 	mla	r0, r2, r0, r3
        if (++cursor > 2) cursor = 0;
    3330:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3332:	3301      	adds	r3, #1
    3334:	2b03      	cmp	r3, #3
    3336:	bfa8      	it	ge
    3338:	2300      	movge	r3, #0
    333a:	66c3      	str	r3, [r0, #108]	; 0x6c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    333c:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    3340:	6483      	str	r3, [r0, #72]	; 0x48
void Trending_OnButtonPress(bool hemisphere) {Trending_instance[hemisphere].OnButtonPress();}
    3342:	4770      	bx	lr
    3344:	20002654 	.word	0x20002654

00003348 <Trending_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3348:	4b04      	ldr	r3, [pc, #16]	; (335c <Trending_ToggleHelpScreen(bool)+0x14>)
    334a:	22a0      	movs	r2, #160	; 0xa0
    334c:	fb02 3000 	mla	r0, r2, r0, r3
    3350:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    3352:	f1c3 0301 	rsb	r3, r3, #1
    3356:	65c3      	str	r3, [r0, #92]	; 0x5c
void Trending_OnEncoderMove(bool hemisphere, int direction) {Trending_instance[hemisphere].OnEncoderMove(direction);}
void Trending_ToggleHelpScreen(bool hemisphere) {Trending_instance[hemisphere].HelpScreen();}
    3358:	4770      	bx	lr
    335a:	bf00      	nop
    335c:	20002654 	.word	0x20002654

00003360 <Trending_OnDataRequest(bool)>:
        Pack(data, PackLocation {4,4}, assign[1]);
    3360:	4b07      	ldr	r3, [pc, #28]	; (3380 <Trending_OnDataRequest(bool)+0x20>)
    3362:	22a0      	movs	r2, #160	; 0xa0
    3364:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    3368:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    336c:	f890 2099 	ldrb.w	r2, [r0, #153]	; 0x99
        Pack(data, PackLocation {0,4}, assign[0]);
    3370:	f890 0098 	ldrb.w	r0, [r0, #152]	; 0x98
    3374:	021b      	lsls	r3, r3, #8
    3376:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
uint32_t Trending_OnDataRequest(bool hemisphere) {return Trending_instance[hemisphere].OnDataRequest();}
    337a:	4318      	orrs	r0, r3
    337c:	4770      	bx	lr
    337e:	bf00      	nop
    3380:	20002654 	.word	0x20002654

00003384 <TrigSeq::applet_name()>:
class TrigSeq : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "TrigSeq";
    }
    3384:	4800      	ldr	r0, [pc, #0]	; (3388 <TrigSeq::applet_name()+0x4>)
    3386:	4770      	bx	lr
    3388:	00020d02 	.word	0x00020d02

0000338c <TrigSeq::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Reset";
    338c:	4b04      	ldr	r3, [pc, #16]	; (33a0 <TrigSeq::SetHelp()+0x14>)
    338e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Swap A&B @ 3V";
    3390:	4b04      	ldr	r3, [pc, #16]	; (33a4 <TrigSeq::SetHelp()+0x18>)
    3392:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Trg A=Ch1 B=Ch2";
    3394:	4b04      	ldr	r3, [pc, #16]	; (33a8 <TrigSeq::SetHelp()+0x1c>)
    3396:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "T=Set P=Select";
    3398:	4b04      	ldr	r3, [pc, #16]	; (33ac <TrigSeq::SetHelp()+0x20>)
    339a:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    339c:	4770      	bx	lr
    339e:	bf00      	nop
    33a0:	00020480 	.word	0x00020480
    33a4:	00020d0a 	.word	0x00020d0a
    33a8:	00020d1a 	.word	0x00020d1a
    33ac:	00020c6d 	.word	0x00020c6d

000033b0 <TrigSeq_OnButtonPress(bool)>:
void TrigSeq_View(bool hemisphere) {
    TrigSeq_instance[hemisphere].BaseView();
}

void TrigSeq_OnButtonPress(bool hemisphere) {
    TrigSeq_instance[hemisphere].OnButtonPress();
    33b0:	4b07      	ldr	r3, [pc, #28]	; (33d0 <TrigSeq_OnButtonPress(bool)+0x20>)
    33b2:	2284      	movs	r2, #132	; 0x84
    33b4:	fb02 3000 	mla	r0, r2, r0, r3
        cursor++;
    33b8:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    33bc:	3301      	adds	r3, #1
        if (cursor > 5) cursor = 0;
    33be:	2b06      	cmp	r3, #6
    33c0:	bfa8      	it	ge
    33c2:	2300      	movge	r3, #0
    33c4:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    33c8:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    33cc:	6483      	str	r3, [r0, #72]	; 0x48
}
    33ce:	4770      	bx	lr
    33d0:	2000288c 	.word	0x2000288c

000033d4 <TrigSeq_OnEncoderMove(bool, int)>:

void TrigSeq_OnEncoderMove(bool hemisphere, int direction) {
    33d4:	b570      	push	{r4, r5, r6, lr}
    33d6:	460d      	mov	r5, r1
        int ch = cursor > 2 ? 1 : 0;
    33d8:	4919      	ldr	r1, [pc, #100]	; (3440 <TrigSeq_OnEncoderMove(bool, int)+0x6c>)
    33da:	2284      	movs	r2, #132	; 0x84
    33dc:	fb02 1200 	mla	r2, r2, r0, r1
    33e0:	f8d2 6080 	ldr.w	r6, [r2, #128]	; 0x80
    33e4:	2e02      	cmp	r6, #2
        int this_cursor = cursor - (3 * ch);
    33e6:	bfcc      	ite	gt
    33e8:	f06f 0402 	mvngt.w	r4, #2
    33ec:	2400      	movle	r4, #0
    33ee:	4434      	add	r4, r6
        int ch = cursor > 2 ? 1 : 0;
    33f0:	bfcc      	ite	gt
    33f2:	2301      	movgt	r3, #1
    33f4:	2300      	movle	r3, #0
        if (this_cursor == 2) {
    33f6:	2c02      	cmp	r4, #2
    33f8:	d10b      	bne.n	3412 <TrigSeq_OnEncoderMove(bool, int)+0x3e>
            end_step[ch] = constrain(end_step[ch] += direction, 0, 7);
    33fa:	eb00 1040 	add.w	r0, r0, r0, lsl #5
    33fe:	4418      	add	r0, r3
    3400:	301e      	adds	r0, #30
    3402:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
    3406:	442b      	add	r3, r5
    3408:	f383 0303 	usat	r3, #3, r3
    340c:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
    TrigSeq_instance[hemisphere].OnEncoderMove(direction);
}
    3410:	bd70      	pop	{r4, r5, r6, pc}
            int curr_patt = pattern[ch];
    3412:	441a      	add	r2, r3
            uint8_t nybble = (curr_patt >> (this_cursor * 4)) & 0x0f;
    3414:	00a1      	lsls	r1, r4, #2
            int curr_patt = pattern[ch];
    3416:	f892 3074 	ldrb.w	r3, [r2, #116]	; 0x74
            uint8_t nybble = (curr_patt >> (this_cursor * 4)) & 0x0f;
    341a:	fa43 f101 	asr.w	r1, r3, r1
    341e:	4429      	add	r1, r5
    3420:	f001 010f 	and.w	r1, r1, #15
            if (this_cursor == 0) pattern[ch] = (curr_patt & 0xf0) + nybble;
    3424:	b92c      	cbnz	r4, 3432 <TrigSeq_OnEncoderMove(bool, int)+0x5e>
    3426:	f023 030f 	bic.w	r3, r3, #15
    342a:	4319      	orrs	r1, r3
    342c:	f882 1074 	strb.w	r1, [r2, #116]	; 0x74
    3430:	e7ee      	b.n	3410 <TrigSeq_OnEncoderMove(bool, int)+0x3c>
            else pattern[ch] = (curr_patt & 0x0f) + (nybble << 4);
    3432:	f003 030f 	and.w	r3, r3, #15
    3436:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    343a:	f882 3074 	strb.w	r3, [r2, #116]	; 0x74
}
    343e:	e7e7      	b.n	3410 <TrigSeq_OnEncoderMove(bool, int)+0x3c>
    3440:	2000288c 	.word	0x2000288c

00003444 <TrigSeq_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3444:	4b04      	ldr	r3, [pc, #16]	; (3458 <TrigSeq_ToggleHelpScreen(bool)+0x14>)
    3446:	2284      	movs	r2, #132	; 0x84
    3448:	fb02 3000 	mla	r0, r2, r0, r3
    344c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    344e:	f1c3 0301 	rsb	r3, r3, #1
    3452:	65c3      	str	r3, [r0, #92]	; 0x5c

void TrigSeq_ToggleHelpScreen(bool hemisphere) {
    TrigSeq_instance[hemisphere].HelpScreen();
}
    3454:	4770      	bx	lr
    3456:	bf00      	nop
    3458:	2000288c 	.word	0x2000288c

0000345c <TrigSeq_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, pattern[1]);
    345c:	4b08      	ldr	r3, [pc, #32]	; (3480 <TrigSeq_OnDataRequest(bool)+0x24>)
    345e:	2284      	movs	r2, #132	; 0x84
    3460:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    3464:	6f83      	ldr	r3, [r0, #120]	; 0x78
    3466:	f890 2075 	ldrb.w	r2, [r0, #117]	; 0x75
    346a:	041b      	lsls	r3, r3, #16
    346c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        Pack(data, PackLocation {0,8}, pattern[0]);
    3470:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
    3474:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
    3476:	4313      	orrs	r3, r2

uint32_t TrigSeq_OnDataRequest(bool hemisphere) {
    return TrigSeq_instance[hemisphere].OnDataRequest();
}
    3478:	ea43 40c0 	orr.w	r0, r3, r0, lsl #19
    347c:	4770      	bx	lr
    347e:	bf00      	nop
    3480:	2000288c 	.word	0x2000288c

00003484 <TrigSeq16::applet_name()>:
class TrigSeq16 : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "TrigSeq16";
    }
    3484:	4800      	ldr	r0, [pc, #0]	; (3488 <TrigSeq16::applet_name()+0x4>)
    3486:	4770      	bx	lr
    3488:	00020d2a 	.word	0x00020d2a

0000348c <TrigSeq16::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Clock 2=Reset";
    348c:	4b04      	ldr	r3, [pc, #16]	; (34a0 <TrigSeq16::SetHelp()+0x14>)
    348e:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Swap A&B @ 3V";
    3490:	4b04      	ldr	r3, [pc, #16]	; (34a4 <TrigSeq16::SetHelp()+0x18>)
    3492:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Trg A=Trg B=Cmp";
    3494:	4b04      	ldr	r3, [pc, #16]	; (34a8 <TrigSeq16::SetHelp()+0x1c>)
    3496:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "T=Set P=Select";
    3498:	4b04      	ldr	r3, [pc, #16]	; (34ac <TrigSeq16::SetHelp()+0x20>)
    349a:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    349c:	4770      	bx	lr
    349e:	bf00      	nop
    34a0:	00020480 	.word	0x00020480
    34a4:	00020d0a 	.word	0x00020d0a
    34a8:	00020d34 	.word	0x00020d34
    34ac:	00020c6d 	.word	0x00020c6d

000034b0 <TrigSeq16_OnButtonPress(bool)>:
void TrigSeq16_View(bool hemisphere) {
    TrigSeq16_instance[hemisphere].BaseView();
}

void TrigSeq16_OnButtonPress(bool hemisphere) {
    TrigSeq16_instance[hemisphere].OnButtonPress();
    34b0:	4b06      	ldr	r3, [pc, #24]	; (34cc <TrigSeq16_OnButtonPress(bool)+0x1c>)
    34b2:	227c      	movs	r2, #124	; 0x7c
    34b4:	fb02 3000 	mla	r0, r2, r0, r3
        cursor++;
    34b8:	6f83      	ldr	r3, [r0, #120]	; 0x78
    34ba:	3301      	adds	r3, #1
        if (cursor > 4) cursor = 0;
    34bc:	2b05      	cmp	r3, #5
    34be:	bfa8      	it	ge
    34c0:	2300      	movge	r3, #0
    34c2:	6783      	str	r3, [r0, #120]	; 0x78
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    34c4:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    34c8:	6483      	str	r3, [r0, #72]	; 0x48
}
    34ca:	4770      	bx	lr
    34cc:	20002794 	.word	0x20002794

000034d0 <TrigSeq16_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    34d0:	4b04      	ldr	r3, [pc, #16]	; (34e4 <TrigSeq16_ToggleHelpScreen(bool)+0x14>)
    34d2:	227c      	movs	r2, #124	; 0x7c
    34d4:	fb02 3000 	mla	r0, r2, r0, r3
    34d8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    34da:	f1c3 0301 	rsb	r3, r3, #1
    34de:	65c3      	str	r3, [r0, #92]	; 0x5c
    TrigSeq16_instance[hemisphere].OnEncoderMove(direction);
}

void TrigSeq16_ToggleHelpScreen(bool hemisphere) {
    TrigSeq16_instance[hemisphere].HelpScreen();
}
    34e0:	4770      	bx	lr
    34e2:	bf00      	nop
    34e4:	20002794 	.word	0x20002794

000034e8 <TrigSeq16_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,8}, pattern[1]);
    34e8:	4b06      	ldr	r3, [pc, #24]	; (3504 <TrigSeq16_OnDataRequest(bool)+0x1c>)
    34ea:	227c      	movs	r2, #124	; 0x7c
    34ec:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    34f0:	6f43      	ldr	r3, [r0, #116]	; 0x74
    34f2:	f890 2071 	ldrb.w	r2, [r0, #113]	; 0x71
        Pack(data, PackLocation {0,8}, pattern[0]);
    34f6:	f890 0070 	ldrb.w	r0, [r0, #112]	; 0x70
    34fa:	041b      	lsls	r3, r3, #16
    34fc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

uint32_t TrigSeq16_OnDataRequest(bool hemisphere) {
    return TrigSeq16_instance[hemisphere].OnDataRequest();
}
    3500:	4318      	orrs	r0, r3
    3502:	4770      	bx	lr
    3504:	20002794 	.word	0x20002794

00003508 <Tuner::applet_name()>:
class Tuner : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Tuner";
    }
    3508:	4800      	ldr	r0, [pc, #0]	; (350c <Tuner::applet_name()+0x4>)
    350a:	4770      	bx	lr
    350c:	00020d44 	.word	0x00020d44

00003510 <Tuner_OnButtonPress(bool)>:
void Tuner_View(bool hemisphere) {
    Tuner_instance[hemisphere].BaseView();
}

void Tuner_OnButtonPress(bool hemisphere) {
    Tuner_instance[hemisphere].OnButtonPress();
    3510:	2288      	movs	r2, #136	; 0x88
    3512:	4b03      	ldr	r3, [pc, #12]	; (3520 <Tuner_OnButtonPress(bool)+0x10>)
    3514:	4350      	muls	r0, r2
        Start();
    3516:	581a      	ldr	r2, [r3, r0]
    3518:	4418      	add	r0, r3
    351a:	6852      	ldr	r2, [r2, #4]
    351c:	4710      	bx	r2
    351e:	bf00      	nop
    3520:	20002998 	.word	0x20002998

00003524 <Tuner_OnEncoderMove(bool, int)>:
        A4_Hz = constrain(A4_Hz + direction, 400, 500);
    3524:	4b09      	ldr	r3, [pc, #36]	; (354c <Tuner_OnEncoderMove(bool, int)+0x28>)
    3526:	2288      	movs	r2, #136	; 0x88
    3528:	fb02 3000 	mla	r0, r2, r0, r3
    352c:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
    3530:	440b      	add	r3, r1
    3532:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
    3536:	bfa8      	it	ge
    3538:	f44f 73fa 	movge.w	r3, #500	; 0x1f4
    353c:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
    3540:	bfb8      	it	lt
    3542:	f44f 73c8 	movlt.w	r3, #400	; 0x190
    3546:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
}

void Tuner_OnEncoderMove(bool hemisphere, int direction) {
    Tuner_instance[hemisphere].OnEncoderMove(direction);
}
    354a:	4770      	bx	lr
    354c:	20002998 	.word	0x20002998

00003550 <Tuner_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3550:	4b04      	ldr	r3, [pc, #16]	; (3564 <Tuner_ToggleHelpScreen(bool)+0x14>)
    3552:	2288      	movs	r2, #136	; 0x88
    3554:	fb02 3000 	mla	r0, r2, r0, r3
    3558:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    355a:	f1c3 0301 	rsb	r3, r3, #1
    355e:	65c3      	str	r3, [r0, #92]	; 0x5c

void Tuner_ToggleHelpScreen(bool hemisphere) {
    Tuner_instance[hemisphere].HelpScreen();
}
    3560:	4770      	bx	lr
    3562:	bf00      	nop
    3564:	20002998 	.word	0x20002998

00003568 <Tuner_OnDataRequest(bool)>:
        Pack(data, PackLocation {0,16}, A4_Hz);
    3568:	4b03      	ldr	r3, [pc, #12]	; (3578 <Tuner_OnDataRequest(bool)+0x10>)
    356a:	2288      	movs	r2, #136	; 0x88
    356c:	fb02 3300 	mla	r3, r2, r0, r3

uint32_t Tuner_OnDataRequest(bool hemisphere) {
    return Tuner_instance[hemisphere].OnDataRequest();
}
    3570:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
    3574:	4770      	bx	lr
    3576:	bf00      	nop
    3578:	20002998 	.word	0x20002998

0000357c <VectorEG::applet_name()>:
class VectorEG : public HemisphereApplet {
public:

    const char* applet_name() {
        return "VectorEG";
    }
    357c:	4800      	ldr	r0, [pc, #0]	; (3580 <VectorEG::applet_name()+0x4>)
    357e:	4770      	bx	lr
    3580:	00020d4a 	.word	0x00020d4a

00003584 <VectorEG::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1,2=Gate";
    3584:	4b04      	ldr	r3, [pc, #16]	; (3598 <VectorEG::SetHelp()+0x14>)
    3586:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "";
    3588:	4b04      	ldr	r3, [pc, #16]	; (359c <VectorEG::SetHelp()+0x18>)
    358a:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A,B=Out";
    358c:	4b04      	ldr	r3, [pc, #16]	; (35a0 <VectorEG::SetHelp()+0x1c>)
    358e:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Freq./Waveform";
    3590:	4b04      	ldr	r3, [pc, #16]	; (35a4 <VectorEG::SetHelp()+0x20>)
    3592:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    3594:	4770      	bx	lr
    3596:	bf00      	nop
    3598:	00020d53 	.word	0x00020d53
    359c:	000211c8 	.word	0x000211c8
    35a0:	00020d5c 	.word	0x00020d5c
    35a4:	00020d64 	.word	0x00020d64

000035a8 <VectorEG_OnButtonPress(bool)>:
        if (++cursor > 3) cursor = 0;
    35a8:	4b05      	ldr	r3, [pc, #20]	; (35c0 <VectorEG_OnButtonPress(bool)+0x18>)
    35aa:	f44f 728a 	mov.w	r2, #276	; 0x114
    35ae:	fb02 3000 	mla	r0, r2, r0, r3
    35b2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    35b4:	3301      	adds	r3, #1
    35b6:	2b04      	cmp	r3, #4
    35b8:	bfa8      	it	ge
    35ba:	2300      	movge	r3, #0
    35bc:	66c3      	str	r3, [r0, #108]	; 0x6c
VectorEG VectorEG_instance[2];

void VectorEG_Start(bool hemisphere) {VectorEG_instance[hemisphere].BaseStart(hemisphere);}
void VectorEG_Controller(bool hemisphere, bool forwarding) {VectorEG_instance[hemisphere].BaseController(forwarding);}
void VectorEG_View(bool hemisphere) {VectorEG_instance[hemisphere].BaseView();}
void VectorEG_OnButtonPress(bool hemisphere) {VectorEG_instance[hemisphere].OnButtonPress();}
    35be:	4770      	bx	lr
    35c0:	20002ab0 	.word	0x20002ab0

000035c4 <VectorEG_ToggleHelpScreen(bool)>:
    35c4:	4b04      	ldr	r3, [pc, #16]	; (35d8 <VectorEG_ToggleHelpScreen(bool)+0x14>)
    35c6:	f44f 728a 	mov.w	r2, #276	; 0x114
    35ca:	fb02 3000 	mla	r0, r2, r0, r3
    35ce:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    35d0:	f1c3 0301 	rsb	r3, r3, #1
    35d4:	65c3      	str	r3, [r0, #92]	; 0x5c
void VectorEG_OnEncoderMove(bool hemisphere, int direction) {VectorEG_instance[hemisphere].OnEncoderMove(direction);}
void VectorEG_ToggleHelpScreen(bool hemisphere) {VectorEG_instance[hemisphere].HelpScreen();}
    35d6:	4770      	bx	lr
    35d8:	20002ab0 	.word	0x20002ab0

000035dc <VectorEG_OnDataRequest(bool)>:
        Pack(data, PackLocation {22,10}, freq[1] & 0x03ff);
    35dc:	4b0a      	ldr	r3, [pc, #40]	; (3608 <VectorEG_OnDataRequest(bool)+0x2c>)
    35de:	f44f 728a 	mov.w	r2, #276	; 0x114
    35e2:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    35e6:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
    35ea:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
    35ee:	019b      	lsls	r3, r3, #6
    35f0:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
    35f4:	f8d0 2104 	ldr.w	r2, [r0, #260]	; 0x104
    35f8:	4313      	orrs	r3, r2
    35fa:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
    35fe:	4803      	ldr	r0, [pc, #12]	; (360c <VectorEG_OnDataRequest(bool)+0x30>)
    3600:	ea00 3002 	and.w	r0, r0, r2, lsl #12
uint32_t VectorEG_OnDataRequest(bool hemisphere) {return VectorEG_instance[hemisphere].OnDataRequest();}
    3604:	4318      	orrs	r0, r3
    3606:	4770      	bx	lr
    3608:	20002ab0 	.word	0x20002ab0
    360c:	003ff000 	.word	0x003ff000

00003610 <VectorLFO::applet_name()>:
class VectorLFO : public HemisphereApplet {
public:

    const char* applet_name() {
        return "VectorLFO";
    }
    3610:	4800      	ldr	r0, [pc, #0]	; (3614 <VectorLFO::applet_name()+0x4>)
    3612:	4770      	bx	lr
    3614:	00020d73 	.word	0x00020d73

00003618 <VectorLFO::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1,2=Sync";
    3618:	4b04      	ldr	r3, [pc, #16]	; (362c <VectorLFO::SetHelp()+0x14>)
    361a:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Freq1 2=Atten1@B";
    361c:	4b04      	ldr	r3, [pc, #16]	; (3630 <VectorLFO::SetHelp()+0x18>)
    361e:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Out A=1, B=2+1";
    3620:	4b04      	ldr	r3, [pc, #16]	; (3634 <VectorLFO::SetHelp()+0x1c>)
    3622:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Freq./Waveform";
    3624:	4b04      	ldr	r3, [pc, #16]	; (3638 <VectorLFO::SetHelp()+0x20>)
    3626:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    3628:	4770      	bx	lr
    362a:	bf00      	nop
    362c:	00020d7d 	.word	0x00020d7d
    3630:	00020d86 	.word	0x00020d86
    3634:	00020d99 	.word	0x00020d99
    3638:	00020d64 	.word	0x00020d64

0000363c <VectorLFO_OnButtonPress(bool)>:
        if (++cursor > 3) cursor = 0;
    363c:	4b05      	ldr	r3, [pc, #20]	; (3654 <VectorLFO_OnButtonPress(bool)+0x18>)
    363e:	f44f 7288 	mov.w	r2, #272	; 0x110
    3642:	fb02 3000 	mla	r0, r2, r0, r3
    3646:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3648:	3301      	adds	r3, #1
    364a:	2b04      	cmp	r3, #4
    364c:	bfa8      	it	ge
    364e:	2300      	movge	r3, #0
    3650:	66c3      	str	r3, [r0, #108]	; 0x6c
VectorLFO VectorLFO_instance[2];

void VectorLFO_Start(bool hemisphere) {VectorLFO_instance[hemisphere].BaseStart(hemisphere);}
void VectorLFO_Controller(bool hemisphere, bool forwarding) {VectorLFO_instance[hemisphere].BaseController(forwarding);}
void VectorLFO_View(bool hemisphere) {VectorLFO_instance[hemisphere].BaseView();}
void VectorLFO_OnButtonPress(bool hemisphere) {VectorLFO_instance[hemisphere].OnButtonPress();}
    3652:	4770      	bx	lr
    3654:	20002cd8 	.word	0x20002cd8

00003658 <VectorLFO_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3658:	4b04      	ldr	r3, [pc, #16]	; (366c <VectorLFO_ToggleHelpScreen(bool)+0x14>)
    365a:	f44f 7288 	mov.w	r2, #272	; 0x110
    365e:	fb02 3000 	mla	r0, r2, r0, r3
    3662:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    3664:	f1c3 0301 	rsb	r3, r3, #1
    3668:	65c3      	str	r3, [r0, #92]	; 0x5c
void VectorLFO_OnEncoderMove(bool hemisphere, int direction) {VectorLFO_instance[hemisphere].OnEncoderMove(direction);}
void VectorLFO_ToggleHelpScreen(bool hemisphere) {VectorLFO_instance[hemisphere].HelpScreen();}
    366a:	4770      	bx	lr
    366c:	20002cd8 	.word	0x20002cd8

00003670 <VectorLFO_OnDataRequest(bool)>:
        Pack(data, PackLocation {22,10}, freq[1] & 0x03ff);
    3670:	4b0a      	ldr	r3, [pc, #40]	; (369c <VectorLFO_OnDataRequest(bool)+0x2c>)
    3672:	f44f 7288 	mov.w	r2, #272	; 0x110
    3676:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    367a:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
    367e:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
    3682:	019b      	lsls	r3, r3, #6
    3684:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
    3688:	f8d0 2100 	ldr.w	r2, [r0, #256]	; 0x100
    368c:	4313      	orrs	r3, r2
    368e:	f8d0 2108 	ldr.w	r2, [r0, #264]	; 0x108
    3692:	4803      	ldr	r0, [pc, #12]	; (36a0 <VectorLFO_OnDataRequest(bool)+0x30>)
    3694:	ea00 3002 	and.w	r0, r0, r2, lsl #12
uint32_t VectorLFO_OnDataRequest(bool hemisphere) {return VectorLFO_instance[hemisphere].OnDataRequest();}
    3698:	4318      	orrs	r0, r3
    369a:	4770      	bx	lr
    369c:	20002cd8 	.word	0x20002cd8
    36a0:	003ff000 	.word	0x003ff000

000036a4 <VectorMod::applet_name()>:
class VectorMod : public HemisphereApplet {
public:

    const char* applet_name() {
        return "VectorMod";
    }
    36a4:	4800      	ldr	r0, [pc, #0]	; (36a8 <VectorMod::applet_name()+0x4>)
    36a6:	4770      	bx	lr
    36a8:	00020da8 	.word	0x00020da8

000036ac <VectorMod::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1,2=Trigger";
    36ac:	4b04      	ldr	r3, [pc, #16]	; (36c0 <VectorMod::SetHelp()+0x14>)
    36ae:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1,2=Cycle";
    36b0:	4b04      	ldr	r3, [pc, #16]	; (36c4 <VectorMod::SetHelp()+0x18>)
    36b2:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A,B=Out";
    36b4:	4b04      	ldr	r3, [pc, #16]	; (36c8 <VectorMod::SetHelp()+0x1c>)
    36b6:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Freq./Waveform";
    36b8:	4b04      	ldr	r3, [pc, #16]	; (36cc <VectorMod::SetHelp()+0x20>)
    36ba:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    36bc:	4770      	bx	lr
    36be:	bf00      	nop
    36c0:	00020db2 	.word	0x00020db2
    36c4:	00020dbe 	.word	0x00020dbe
    36c8:	00020d5c 	.word	0x00020d5c
    36cc:	00020d64 	.word	0x00020d64

000036d0 <VectorMod_OnButtonPress(bool)>:
        if (++cursor > 3) cursor = 0;
    36d0:	4b05      	ldr	r3, [pc, #20]	; (36e8 <VectorMod_OnButtonPress(bool)+0x18>)
    36d2:	f44f 7288 	mov.w	r2, #272	; 0x110
    36d6:	fb02 3000 	mla	r0, r2, r0, r3
    36da:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    36dc:	3301      	adds	r3, #1
    36de:	2b04      	cmp	r3, #4
    36e0:	bfa8      	it	ge
    36e2:	2300      	movge	r3, #0
    36e4:	66c3      	str	r3, [r0, #108]	; 0x6c
VectorMod VectorMod_instance[2];

void VectorMod_Start(bool hemisphere) {VectorMod_instance[hemisphere].BaseStart(hemisphere);}
void VectorMod_Controller(bool hemisphere, bool forwarding) {VectorMod_instance[hemisphere].BaseController(forwarding);}
void VectorMod_View(bool hemisphere) {VectorMod_instance[hemisphere].BaseView();}
void VectorMod_OnButtonPress(bool hemisphere) {VectorMod_instance[hemisphere].OnButtonPress();}
    36e6:	4770      	bx	lr
    36e8:	20002ef8 	.word	0x20002ef8

000036ec <VectorMod_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    36ec:	4b04      	ldr	r3, [pc, #16]	; (3700 <VectorMod_ToggleHelpScreen(bool)+0x14>)
    36ee:	f44f 7288 	mov.w	r2, #272	; 0x110
    36f2:	fb02 3000 	mla	r0, r2, r0, r3
    36f6:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    36f8:	f1c3 0301 	rsb	r3, r3, #1
    36fc:	65c3      	str	r3, [r0, #92]	; 0x5c
void VectorMod_OnEncoderMove(bool hemisphere, int direction) {VectorMod_instance[hemisphere].OnEncoderMove(direction);}
void VectorMod_ToggleHelpScreen(bool hemisphere) {VectorMod_instance[hemisphere].HelpScreen();}
    36fe:	4770      	bx	lr
    3700:	20002ef8 	.word	0x20002ef8

00003704 <VectorMod_OnDataRequest(bool)>:
        Pack(data, PackLocation {22,10}, freq[1] & 0x03ff);
    3704:	4b0a      	ldr	r3, [pc, #40]	; (3730 <VectorMod_OnDataRequest(bool)+0x2c>)
    3706:	f44f 7288 	mov.w	r2, #272	; 0x110
    370a:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    370e:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
    3712:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
    3716:	019b      	lsls	r3, r3, #6
    3718:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
    371c:	f8d0 2100 	ldr.w	r2, [r0, #256]	; 0x100
    3720:	4313      	orrs	r3, r2
    3722:	f8d0 2108 	ldr.w	r2, [r0, #264]	; 0x108
    3726:	4803      	ldr	r0, [pc, #12]	; (3734 <VectorMod_OnDataRequest(bool)+0x30>)
    3728:	ea00 3002 	and.w	r0, r0, r2, lsl #12
uint32_t VectorMod_OnDataRequest(bool hemisphere) {return VectorMod_instance[hemisphere].OnDataRequest();}
    372c:	4318      	orrs	r0, r3
    372e:	4770      	bx	lr
    3730:	20002ef8 	.word	0x20002ef8
    3734:	003ff000 	.word	0x003ff000

00003738 <VectorMorph::applet_name()>:
class VectorMorph : public HemisphereApplet {
public:

    const char* applet_name() {
        return "VectMorph";
    }
    3738:	4800      	ldr	r0, [pc, #0]	; (373c <VectorMorph::applet_name()+0x4>)
    373a:	4770      	bx	lr
    373c:	00020dc8 	.word	0x00020dc8

00003740 <VectorMorph::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    3740:	4b04      	ldr	r3, [pc, #16]	; (3754 <VectorMorph::SetHelp()+0x14>)
    3742:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1,2=Phase";
    3744:	4b04      	ldr	r3, [pc, #16]	; (3758 <VectorMorph::SetHelp()+0x18>)
    3746:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "A,B=Out";
    3748:	4b04      	ldr	r3, [pc, #16]	; (375c <VectorMorph::SetHelp()+0x1c>)
    374a:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Phase/Waveform";
    374c:	4b04      	ldr	r3, [pc, #16]	; (3760 <VectorMorph::SetHelp()+0x20>)
    374e:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    3750:	4770      	bx	lr
    3752:	bf00      	nop
    3754:	000211c8 	.word	0x000211c8
    3758:	00020dd2 	.word	0x00020dd2
    375c:	00020d5c 	.word	0x00020d5c
    3760:	00020ddc 	.word	0x00020ddc

00003764 <VectorMorph_OnButtonPress(bool)>:
        if (++cursor > 3) cursor = 0;
    3764:	4b05      	ldr	r3, [pc, #20]	; (377c <VectorMorph_OnButtonPress(bool)+0x18>)
    3766:	f44f 728e 	mov.w	r2, #284	; 0x11c
    376a:	fb02 3000 	mla	r0, r2, r0, r3
    376e:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3770:	3301      	adds	r3, #1
    3772:	2b04      	cmp	r3, #4
    3774:	bfa8      	it	ge
    3776:	2300      	movge	r3, #0
    3778:	66c3      	str	r3, [r0, #108]	; 0x6c
VectorMorph VectorMorph_instance[2];

void VectorMorph_Start(bool hemisphere) {VectorMorph_instance[hemisphere].BaseStart(hemisphere);}
void VectorMorph_Controller(bool hemisphere, bool forwarding) {VectorMorph_instance[hemisphere].BaseController(forwarding);}
void VectorMorph_View(bool hemisphere) {VectorMorph_instance[hemisphere].BaseView();}
void VectorMorph_OnButtonPress(bool hemisphere) {VectorMorph_instance[hemisphere].OnButtonPress();}
    377a:	4770      	bx	lr
    377c:	20003118 	.word	0x20003118

00003780 <VectorMorph_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3780:	4b04      	ldr	r3, [pc, #16]	; (3794 <VectorMorph_ToggleHelpScreen(bool)+0x14>)
    3782:	f44f 728e 	mov.w	r2, #284	; 0x11c
    3786:	fb02 3000 	mla	r0, r2, r0, r3
    378a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    378c:	f1c3 0301 	rsb	r3, r3, #1
    3790:	65c3      	str	r3, [r0, #92]	; 0x5c
void VectorMorph_OnEncoderMove(bool hemisphere, int direction) {VectorMorph_instance[hemisphere].OnEncoderMove(direction);}
void VectorMorph_ToggleHelpScreen(bool hemisphere) {VectorMorph_instance[hemisphere].HelpScreen();}
    3792:	4770      	bx	lr
    3794:	20003118 	.word	0x20003118

00003798 <VectorMorph_OnDataRequest(bool)>:
        Pack(data, PackLocation {6,6}, waveform_number[1]);
    3798:	4b0b      	ldr	r3, [pc, #44]	; (37c8 <VectorMorph_OnDataRequest(bool)+0x30>)
    379a:	f44f 728e 	mov.w	r2, #284	; 0x11c
    379e:	fb02 3000 	mla	r0, r2, r0, r3
        data |= (value << p.location);
    37a2:	f8d0 3110 	ldr.w	r3, [r0, #272]	; 0x110
    37a6:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
    37aa:	031b      	lsls	r3, r3, #12
    37ac:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    37b0:	f8d0 2108 	ldr.w	r2, [r0, #264]	; 0x108
    37b4:	4313      	orrs	r3, r2
    37b6:	f8d0 2114 	ldr.w	r2, [r0, #276]	; 0x114
        Pack(data, PackLocation {30,1}, linked);
    37ba:	f890 0118 	ldrb.w	r0, [r0, #280]	; 0x118
    37be:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
uint32_t VectorMorph_OnDataRequest(bool hemisphere) {return VectorMorph_instance[hemisphere].OnDataRequest();}
    37c2:	ea43 7080 	orr.w	r0, r3, r0, lsl #30
    37c6:	4770      	bx	lr
    37c8:	20003118 	.word	0x20003118

000037cc <Voltage::applet_name()>:
class Voltage : public HemisphereApplet {
public:

    const char* applet_name() {
        return "Voltage";
    }
    37cc:	4800      	ldr	r0, [pc, #0]	; (37d0 <Voltage::applet_name()+0x4>)
    37ce:	4770      	bx	lr
    37d0:	00020deb 	.word	0x00020deb

000037d4 <Voltage::Start()>:

    void Start() {
        voltage[0] = (5 * (12 << 7)) / VOLTAGE_INCREMENTS; // 5V
    37d4:	233c      	movs	r3, #60	; 0x3c
    37d6:	6743      	str	r3, [r0, #116]	; 0x74
        voltage[1] = (-3 * (12 << 7)) / VOLTAGE_INCREMENTS; // -3V
    37d8:	f06f 0323 	mvn.w	r3, #35	; 0x23
    37dc:	6783      	str	r3, [r0, #120]	; 0x78
        gate[0] = 0;
    37de:	2300      	movs	r3, #0
    37e0:	f8a0 307c 	strh.w	r3, [r0, #124]	; 0x7c
        gate[1] = 0;
    }
    37e4:	4770      	bx	lr
    37e6:	Address 0x00000000000037e6 is out of bounds.


000037e8 <Voltage::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "Gate 1,2";
    37e8:	4b04      	ldr	r3, [pc, #16]	; (37fc <Voltage::SetHelp()+0x14>)
    37ea:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "";
    37ec:	4b04      	ldr	r3, [pc, #16]	; (3800 <Voltage::SetHelp()+0x18>)
    37ee:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Voltage A,B";
    37f0:	4b04      	ldr	r3, [pc, #16]	; (3804 <Voltage::SetHelp()+0x1c>)
    37f2:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Voltage/Gating";
    37f4:	4b04      	ldr	r3, [pc, #16]	; (3808 <Voltage::SetHelp()+0x20>)
    37f6:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    37f8:	4770      	bx	lr
    37fa:	bf00      	nop
    37fc:	00020df3 	.word	0x00020df3
    3800:	000211c8 	.word	0x000211c8
    3804:	00020dfc 	.word	0x00020dfc
    3808:	00020e08 	.word	0x00020e08

0000380c <Voltage_OnButtonPress(bool)>:
Voltage Voltage_instance[2];

void Voltage_Start(bool hemisphere) {Voltage_instance[hemisphere].BaseStart(hemisphere);}
void Voltage_Controller(bool hemisphere, bool forwarding) {Voltage_instance[hemisphere].BaseController(forwarding);}
void Voltage_View(bool hemisphere) {Voltage_instance[hemisphere].BaseView();}
void Voltage_OnButtonPress(bool hemisphere) {Voltage_instance[hemisphere].OnButtonPress();}
    380c:	4b06      	ldr	r3, [pc, #24]	; (3828 <Voltage_OnButtonPress(bool)+0x1c>)
    380e:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
        if (++cursor > 3) cursor = 0;
    3812:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3814:	3301      	adds	r3, #1
    3816:	2b04      	cmp	r3, #4
    3818:	bfa8      	it	ge
    381a:	2300      	movge	r3, #0
    381c:	66c3      	str	r3, [r0, #108]	; 0x6c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    381e:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    3822:	6483      	str	r3, [r0, #72]	; 0x48
void Voltage_OnButtonPress(bool hemisphere) {Voltage_instance[hemisphere].OnButtonPress();}
    3824:	4770      	bx	lr
    3826:	bf00      	nop
    3828:	20003350 	.word	0x20003350

0000382c <Voltage_OnEncoderMove(bool, int)>:
void Voltage_OnEncoderMove(bool hemisphere, int direction) {Voltage_instance[hemisphere].OnEncoderMove(direction);}
    382c:	b530      	push	{r4, r5, lr}
        uint8_t ch = cursor / 2;
    382e:	4c12      	ldr	r4, [pc, #72]	; (3878 <Voltage_OnEncoderMove(bool, int)+0x4c>)
    3830:	eb04 12c0 	add.w	r2, r4, r0, lsl #7
    3834:	6ed5      	ldr	r5, [r2, #108]	; 0x6c
    3836:	eb05 73d5 	add.w	r3, r5, r5, lsr #31
        if (cursor == 0 || cursor == 2) {
    383a:	f035 0502 	bics.w	r5, r5, #2
    383e:	f3c3 0347 	ubfx	r3, r3, #1, #8
    3842:	d110      	bne.n	3866 <Voltage_OnEncoderMove(bool, int)+0x3a>
            voltage[ch] = constrain(voltage[ch] + direction, min, max);
    3844:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    3848:	331c      	adds	r3, #28
    384a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    384e:	685a      	ldr	r2, [r3, #4]
    3850:	440a      	add	r2, r1
    3852:	2a3c      	cmp	r2, #60	; 0x3c
    3854:	bfa8      	it	ge
    3856:	223c      	movge	r2, #60	; 0x3c
    3858:	f06f 013b 	mvn.w	r1, #59	; 0x3b
    385c:	428a      	cmp	r2, r1
    385e:	bfac      	ite	ge
    3860:	605a      	strge	r2, [r3, #4]
    3862:	6059      	strlt	r1, [r3, #4]
void Voltage_OnEncoderMove(bool hemisphere, int direction) {Voltage_instance[hemisphere].OnEncoderMove(direction);}
    3864:	bd30      	pop	{r4, r5, pc}
            gate[ch] = 1 - gate[ch];
    3866:	4413      	add	r3, r2
    3868:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
    386c:	f082 0201 	eor.w	r2, r2, #1
    3870:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
void Voltage_OnEncoderMove(bool hemisphere, int direction) {Voltage_instance[hemisphere].OnEncoderMove(direction);}
    3874:	e7f6      	b.n	3864 <Voltage_OnEncoderMove(bool, int)+0x38>
    3876:	bf00      	nop
    3878:	20003350 	.word	0x20003350

0000387c <Voltage_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    387c:	4b03      	ldr	r3, [pc, #12]	; (388c <Voltage_ToggleHelpScreen(bool)+0x10>)
    387e:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    3882:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    3884:	f1c3 0301 	rsb	r3, r3, #1
    3888:	65c3      	str	r3, [r0, #92]	; 0x5c
void Voltage_ToggleHelpScreen(bool hemisphere) {Voltage_instance[hemisphere].HelpScreen();}
    388a:	4770      	bx	lr
    388c:	20003350 	.word	0x20003350

00003890 <Voltage_OnDataRequest(bool)>:
        Pack(data, PackLocation {0,9}, voltage[0] + 256);
    3890:	4b09      	ldr	r3, [pc, #36]	; (38b8 <Voltage_OnDataRequest(bool)+0x28>)
    3892:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    3896:	6f43      	ldr	r3, [r0, #116]	; 0x74
        Pack(data, PackLocation {19,1}, gate[0]);
    3898:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
        Pack(data, PackLocation {0,9}, voltage[0] + 256);
    389c:	f503 7380 	add.w	r3, r3, #256	; 0x100
        data |= (value << p.location);
    38a0:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
        Pack(data, PackLocation {20,1}, gate[1]);
    38a4:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
        Pack(data, PackLocation {10,9}, voltage[1] + 256);
    38a8:	6f80      	ldr	r0, [r0, #120]	; 0x78
    38aa:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    38ae:	f500 7080 	add.w	r0, r0, #256	; 0x100
uint32_t Voltage_OnDataRequest(bool hemisphere) {return Voltage_instance[hemisphere].OnDataRequest();}
    38b2:	ea43 2080 	orr.w	r0, r3, r0, lsl #10
    38b6:	4770      	bx	lr
    38b8:	20003350 	.word	0x20003350

000038bc <hMIDIIn::applet_name()>:
class hMIDIIn : public HemisphereApplet {
public:

    const char* applet_name() {
        return "MIDIIn";
    }
    38bc:	4800      	ldr	r0, [pc, #0]	; (38c0 <hMIDIIn::applet_name()+0x4>)
    38be:	4770      	bx	lr
    38c0:	00020e17 	.word	0x00020e17

000038c4 <hMIDIIn::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "";
    38c4:	4b03      	ldr	r3, [pc, #12]	; (38d4 <hMIDIIn::SetHelp()+0x10>)
    38c6:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "";
    38c8:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "Assignable";
    38ca:	4b03      	ldr	r3, [pc, #12]	; (38d8 <hMIDIIn::SetHelp()+0x14>)
    38cc:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "MIDI Ch/Assign/Log";
    38ce:	4b03      	ldr	r3, [pc, #12]	; (38dc <hMIDIIn::SetHelp()+0x18>)
    38d0:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    38d2:	4770      	bx	lr
    38d4:	000211c8 	.word	0x000211c8
    38d8:	00020ce4 	.word	0x00020ce4
    38dc:	00020e1e 	.word	0x00020e1e

000038e0 <hMIDIIn_OnButtonPress(bool)>:
void hMIDIIn_View(bool hemisphere) {
    hMIDIIn_instance[hemisphere].BaseView();
}

void hMIDIIn_OnButtonPress(bool hemisphere) {
    hMIDIIn_instance[hemisphere].OnButtonPress();
    38e0:	4b06      	ldr	r3, [pc, #24]	; (38fc <hMIDIIn_OnButtonPress(bool)+0x1c>)
    38e2:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        if (++cursor > 3) cursor = 0;
    38e6:	6f83      	ldr	r3, [r0, #120]	; 0x78
    38e8:	3301      	adds	r3, #1
    38ea:	2b04      	cmp	r3, #4
    38ec:	bfa8      	it	ge
    38ee:	2300      	movge	r3, #0
    38f0:	6783      	str	r3, [r0, #120]	; 0x78
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    38f2:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    38f6:	6483      	str	r3, [r0, #72]	; 0x48
}
    38f8:	4770      	bx	lr
    38fa:	bf00      	nop
    38fc:	20004db8 	.word	0x20004db8

00003900 <hMIDIIn_OnEncoderMove(bool, int)>:

void hMIDIIn_OnEncoderMove(bool hemisphere, int direction) {
    3900:	b510      	push	{r4, lr}
    hMIDIIn_instance[hemisphere].OnEncoderMove(direction);
    3902:	4c0f      	ldr	r4, [pc, #60]	; (3940 <hMIDIIn_OnEncoderMove(bool, int)+0x40>)
    3904:	eb04 2200 	add.w	r2, r4, r0, lsl #8
        if (cursor == 3) return;
    3908:	6f93      	ldr	r3, [r2, #120]	; 0x78
    390a:	2b03      	cmp	r3, #3
    390c:	d008      	beq.n	3920 <hMIDIIn_OnEncoderMove(bool, int)+0x20>
        if (cursor == 0) channel = constrain(channel += direction, 0, 15);
    390e:	b943      	cbnz	r3, 3922 <hMIDIIn_OnEncoderMove(bool, int)+0x22>
    3910:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
    3912:	440b      	add	r3, r1
    3914:	f383 0304 	usat	r3, #4, r3
    3918:	66d3      	str	r3, [r2, #108]	; 0x6c
    391a:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    391e:	6493      	str	r3, [r2, #72]	; 0x48
}
    3920:	bd10      	pop	{r4, pc}
            function[ch] = constrain(function[ch] += direction, 0, 7);
    3922:	eb03 1380 	add.w	r3, r3, r0, lsl #6
    3926:	331b      	adds	r3, #27
    3928:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
    392c:	4408      	add	r0, r1
    392e:	f380 0003 	usat	r0, #3, r0
    3932:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
            clock_count = 0;
    3936:	2300      	movs	r3, #0
    3938:	f882 30a4 	strb.w	r3, [r2, #164]	; 0xa4
    393c:	e7ed      	b.n	391a <hMIDIIn_OnEncoderMove(bool, int)+0x1a>
    393e:	bf00      	nop
    3940:	20004db8 	.word	0x20004db8

00003944 <hMIDIIn_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3944:	4b03      	ldr	r3, [pc, #12]	; (3954 <hMIDIIn_ToggleHelpScreen(bool)+0x10>)
    3946:	eb03 2000 	add.w	r0, r3, r0, lsl #8
    394a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    394c:	f1c3 0301 	rsb	r3, r3, #1
    3950:	65c3      	str	r3, [r0, #92]	; 0x5c

void hMIDIIn_ToggleHelpScreen(bool hemisphere) {
    hMIDIIn_instance[hemisphere].HelpScreen();
}
    3952:	4770      	bx	lr
    3954:	20004db8 	.word	0x20004db8

00003958 <hMIDIIn_OnDataRequest(bool)>:
        Pack(data, PackLocation {8,3}, function[0]);
    3958:	4b05      	ldr	r3, [pc, #20]	; (3970 <hMIDIIn_OnDataRequest(bool)+0x18>)
    395a:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        data |= (value << p.location);
    395e:	6f43      	ldr	r3, [r0, #116]	; 0x74
    3960:	6f02      	ldr	r2, [r0, #112]	; 0x70
    3962:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
    3964:	02db      	lsls	r3, r3, #11
    3966:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

uint32_t hMIDIIn_OnDataRequest(bool hemisphere) {
    return hMIDIIn_instance[hemisphere].OnDataRequest();
}
    396a:	4318      	orrs	r0, r3
    396c:	4770      	bx	lr
    396e:	bf00      	nop
    3970:	20004db8 	.word	0x20004db8

00003974 <hMIDIOut::applet_name()>:
class hMIDIOut : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "MIDIOut";
    }
    3974:	4800      	ldr	r0, [pc, #0]	; (3978 <hMIDIOut::applet_name()+0x4>)
    3976:	4770      	bx	lr
    3978:	00020e31 	.word	0x00020e31

0000397c <hMIDIOut::Start()>:

    void Start() {
        channel = 0; // Default channel 1
    397c:	2300      	movs	r3, #0
    397e:	66c3      	str	r3, [r0, #108]	; 0x6c
        last_channel = 0;
    3980:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
        function = 0;
    3984:	6703      	str	r3, [r0, #112]	; 0x70
        gated = 0;
    3986:	f880 308c 	strb.w	r3, [r0, #140]	; 0x8c
        transpose = 0;
    398a:	6743      	str	r3, [r0, #116]	; 0x74
        legato = 1;
        log_index = 0;
    398c:	f8c0 30fc 	str.w	r3, [r0, #252]	; 0xfc

        const char * fn_name_list[] = {"Mod", "Aft", "Bend", "Veloc"};
        for (int i = 0; i < 4; i++) fn_name[i] = fn_name_list[i];
    3990:	4b07      	ldr	r3, [pc, #28]	; (39b0 <hMIDIOut::Start()+0x34>)
    3992:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
    3996:	4b07      	ldr	r3, [pc, #28]	; (39b4 <hMIDIOut::Start()+0x38>)
    3998:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    399c:	4b06      	ldr	r3, [pc, #24]	; (39b8 <hMIDIOut::Start()+0x3c>)
    399e:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
        legato = 1;
    39a2:	2201      	movs	r2, #1
        for (int i = 0; i < 4; i++) fn_name[i] = fn_name_list[i];
    39a4:	4b05      	ldr	r3, [pc, #20]	; (39bc <hMIDIOut::Start()+0x40>)
        legato = 1;
    39a6:	6782      	str	r2, [r0, #120]	; 0x78
        for (int i = 0; i < 4; i++) fn_name[i] = fn_name_list[i];
    39a8:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    }
    39ac:	4770      	bx	lr
    39ae:	bf00      	nop
    39b0:	00020590 	.word	0x00020590
    39b4:	00020e39 	.word	0x00020e39
    39b8:	00020e3d 	.word	0x00020e3d
    39bc:	00020e42 	.word	0x00020e42

000039c0 <hMIDIOut::SetHelp()>:
    }

protected:
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "1=Gate";
    39c0:	4b04      	ldr	r3, [pc, #16]	; (39d4 <hMIDIOut::SetHelp()+0x14>)
    39c2:	6083      	str	r3, [r0, #8]
        help[HEMISPHERE_HELP_CVS]      = "1=Pitch 2=Assign";
    39c4:	4b04      	ldr	r3, [pc, #16]	; (39d8 <hMIDIOut::SetHelp()+0x18>)
    39c6:	60c3      	str	r3, [r0, #12]
        help[HEMISPHERE_HELP_OUTS]     = "";
    39c8:	4b04      	ldr	r3, [pc, #16]	; (39dc <hMIDIOut::SetHelp()+0x1c>)
    39ca:	6103      	str	r3, [r0, #16]
        help[HEMISPHERE_HELP_ENCODER]  = "Ch/Trp/Assign/Log";
    39cc:	4b04      	ldr	r3, [pc, #16]	; (39e0 <hMIDIOut::SetHelp()+0x20>)
    39ce:	6143      	str	r3, [r0, #20]
        //                               "------------------" <-- Size Guide
    }
    39d0:	4770      	bx	lr
    39d2:	bf00      	nop
    39d4:	00020e48 	.word	0x00020e48
    39d8:	00020e4f 	.word	0x00020e4f
    39dc:	000211c8 	.word	0x000211c8
    39e0:	00020e60 	.word	0x00020e60

000039e4 <hMIDIOut_OnButtonPress(bool)>:
void hMIDIOut_View(bool hemisphere) {
    hMIDIOut_instance[hemisphere].BaseView();
}

void hMIDIOut_OnButtonPress(bool hemisphere) {
    hMIDIOut_instance[hemisphere].OnButtonPress();
    39e4:	4b06      	ldr	r3, [pc, #24]	; (3a00 <hMIDIOut_OnButtonPress(bool)+0x1c>)
    39e6:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        if (++cursor > 4) cursor = 0;
    39ea:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
    39ec:	3301      	adds	r3, #1
    39ee:	2b05      	cmp	r3, #5
    39f0:	bfa8      	it	ge
    39f2:	2300      	movge	r3, #0
    39f4:	67c3      	str	r3, [r0, #124]	; 0x7c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    39f6:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    39fa:	6483      	str	r3, [r0, #72]	; 0x48
}
    39fc:	4770      	bx	lr
    39fe:	bf00      	nop
    3a00:	20004fb8 	.word	0x20004fb8

00003a04 <hMIDIOut_OnEncoderMove(bool, int)>:

void hMIDIOut_OnEncoderMove(bool hemisphere, int direction) {
    hMIDIOut_instance[hemisphere].OnEncoderMove(direction);
    3a04:	4b15      	ldr	r3, [pc, #84]	; (3a5c <hMIDIOut_OnEncoderMove(bool, int)+0x58>)
    3a06:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        if (cursor == 0) channel = constrain(channel += direction, 0, 15);
    3a0a:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
    3a0c:	b943      	cbnz	r3, 3a20 <hMIDIOut_OnEncoderMove(bool, int)+0x1c>
    3a0e:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3a10:	440b      	add	r3, r1
    3a12:	f383 0304 	usat	r3, #4, r3
    3a16:	66c3      	str	r3, [r0, #108]	; 0x6c
    3a18:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    3a1c:	6483      	str	r3, [r0, #72]	; 0x48
}
    3a1e:	4770      	bx	lr
        if (cursor == 1) transpose = constrain(transpose += direction, -24, 24);
    3a20:	2b01      	cmp	r3, #1
    3a22:	d009      	beq.n	3a38 <hMIDIOut_OnEncoderMove(bool, int)+0x34>
        if (cursor == 2) function = constrain(function += direction, 0, 3);
    3a24:	2b02      	cmp	r3, #2
    3a26:	d013      	beq.n	3a50 <hMIDIOut_OnEncoderMove(bool, int)+0x4c>
        if (cursor == 3) legato = direction > 0 ? 1 : 0;
    3a28:	2b03      	cmp	r3, #3
    3a2a:	d1f5      	bne.n	3a18 <hMIDIOut_OnEncoderMove(bool, int)+0x14>
    3a2c:	2900      	cmp	r1, #0
    3a2e:	bfd4      	ite	le
    3a30:	2100      	movle	r1, #0
    3a32:	2101      	movgt	r1, #1
    3a34:	6781      	str	r1, [r0, #120]	; 0x78
    3a36:	e7ef      	b.n	3a18 <hMIDIOut_OnEncoderMove(bool, int)+0x14>
        if (cursor == 1) transpose = constrain(transpose += direction, -24, 24);
    3a38:	6f43      	ldr	r3, [r0, #116]	; 0x74
    3a3a:	440b      	add	r3, r1
    3a3c:	2b18      	cmp	r3, #24
    3a3e:	bfa8      	it	ge
    3a40:	2318      	movge	r3, #24
    3a42:	f06f 0217 	mvn.w	r2, #23
    3a46:	4293      	cmp	r3, r2
    3a48:	bfac      	ite	ge
    3a4a:	6743      	strge	r3, [r0, #116]	; 0x74
    3a4c:	6742      	strlt	r2, [r0, #116]	; 0x74
        if (cursor == 3) legato = direction > 0 ? 1 : 0;
    3a4e:	e7e3      	b.n	3a18 <hMIDIOut_OnEncoderMove(bool, int)+0x14>
        if (cursor == 2) function = constrain(function += direction, 0, 3);
    3a50:	6f03      	ldr	r3, [r0, #112]	; 0x70
    3a52:	440b      	add	r3, r1
    3a54:	f383 0302 	usat	r3, #2, r3
    3a58:	6703      	str	r3, [r0, #112]	; 0x70
        if (cursor == 3) legato = direction > 0 ? 1 : 0;
    3a5a:	e7dd      	b.n	3a18 <hMIDIOut_OnEncoderMove(bool, int)+0x14>
    3a5c:	20004fb8 	.word	0x20004fb8

00003a60 <hMIDIOut_ToggleHelpScreen(bool)>:
        help_active = 1 - help_active;
    3a60:	4b03      	ldr	r3, [pc, #12]	; (3a70 <hMIDIOut_ToggleHelpScreen(bool)+0x10>)
    3a62:	eb03 2000 	add.w	r0, r3, r0, lsl #8
    3a66:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    3a68:	f1c3 0301 	rsb	r3, r3, #1
    3a6c:	65c3      	str	r3, [r0, #92]	; 0x5c

void hMIDIOut_ToggleHelpScreen(bool hemisphere) {
    hMIDIOut_instance[hemisphere].HelpScreen();
}
    3a6e:	4770      	bx	lr
    3a70:	20004fb8 	.word	0x20004fb8

00003a74 <hMIDIOut_OnDataRequest(bool)>:
        Pack(data, PackLocation {4,3}, function);
    3a74:	4b05      	ldr	r3, [pc, #20]	; (3a8c <hMIDIOut_OnDataRequest(bool)+0x18>)
    3a76:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        data |= (value << p.location);
    3a7a:	6f83      	ldr	r3, [r0, #120]	; 0x78
    3a7c:	6f02      	ldr	r2, [r0, #112]	; 0x70
    3a7e:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
    3a80:	01db      	lsls	r3, r3, #7
    3a82:	ea43 1302 	orr.w	r3, r3, r2, lsl #4

uint32_t hMIDIOut_OnDataRequest(bool hemisphere) {
    return hMIDIOut_instance[hemisphere].OnDataRequest();
}
    3a86:	4318      	orrs	r0, r3
    3a88:	4770      	bx	lr
    3a8a:	bf00      	nop
    3a8c:	20004fb8 	.word	0x20004fb8

00003a90 <EnigmaTMWS::~EnigmaTMWS()>:
class EnigmaTMWS : public HSApplication, public SystemExclusiveHandler,
    3a90:	4770      	bx	lr

00003a92 <CaptainMIDI::~CaptainMIDI()>:
class CaptainMIDI : public SystemExclusiveHandler, public HSApplication,
    3a92:	4770      	bx	lr

00003a94 <ScaleEditor::~ScaleEditor()>:
class ScaleEditor : public HSApplication, public SystemExclusiveHandler {
    3a94:	4770      	bx	lr

00003a96 <TheDarkestTimeline::~TheDarkestTimeline()>:
class TheDarkestTimeline : public HSApplication, public SystemExclusiveHandler,
    3a96:	4770      	bx	lr

00003a98 <TrigSeq16::Start()>:
    void Start() {
    3a98:	b510      	push	{r4, lr}
            pattern[ch] = random(1, 255);
    3a9a:	21ff      	movs	r1, #255	; 0xff
    void Start() {
    3a9c:	4604      	mov	r4, r0
            pattern[ch] = random(1, 255);
    3a9e:	2001      	movs	r0, #1
    3aa0:	f016 fa25 	bl	19eee <random(long, long)>
    3aa4:	21ff      	movs	r1, #255	; 0xff
    3aa6:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
    3aaa:	2001      	movs	r0, #1
    3aac:	f016 fa1f 	bl	19eee <random(long, long)>
        step = 0;
    3ab0:	2300      	movs	r3, #0
        end_step = 15;
    3ab2:	220f      	movs	r2, #15
            pattern[ch] = random(1, 255);
    3ab4:	f884 0071 	strb.w	r0, [r4, #113]	; 0x71
        step = 0;
    3ab8:	66e3      	str	r3, [r4, #108]	; 0x6c
        end_step = 15;
    3aba:	6762      	str	r2, [r4, #116]	; 0x74
        cursor = 0;
    3abc:	67a3      	str	r3, [r4, #120]	; 0x78
    }
    3abe:	bd10      	pop	{r4, pc}

00003ac0 <TrigSeq::Start()>:
    void Start() {
    3ac0:	b570      	push	{r4, r5, r6, lr}
            pattern[ch] = random(1, 255);
    3ac2:	21ff      	movs	r1, #255	; 0xff
    void Start() {
    3ac4:	4604      	mov	r4, r0
            pattern[ch] = random(1, 255);
    3ac6:	2001      	movs	r0, #1
    3ac8:	f016 fa11 	bl	19eee <random(long, long)>
            step[ch] = 0;
    3acc:	2500      	movs	r5, #0
            end_step[ch] = 7;
    3ace:	2607      	movs	r6, #7
            pattern[ch] = random(1, 255);
    3ad0:	f884 0074 	strb.w	r0, [r4, #116]	; 0x74
            end_step[ch] = 7;
    3ad4:	67a6      	str	r6, [r4, #120]	; 0x78
            step[ch] = 0;
    3ad6:	66e5      	str	r5, [r4, #108]	; 0x6c
            pattern[ch] = random(1, 255);
    3ad8:	21ff      	movs	r1, #255	; 0xff
    3ada:	2001      	movs	r0, #1
    3adc:	f016 fa07 	bl	19eee <random(long, long)>
            end_step[ch] = 7;
    3ae0:	67e6      	str	r6, [r4, #124]	; 0x7c
            pattern[ch] = random(1, 255);
    3ae2:	f884 0075 	strb.w	r0, [r4, #117]	; 0x75
            step[ch] = 0;
    3ae6:	6725      	str	r5, [r4, #112]	; 0x70
        cursor = 0;
    3ae8:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    }
    3aec:	bd70      	pop	{r4, r5, r6, pc}

00003aee <ShiftGate::Start()>:
    void Start() {
    3aee:	b570      	push	{r4, r5, r6, lr}
            trigger[ch] = ch;
    3af0:	2500      	movs	r5, #0
            length[ch] = 4;
    3af2:	2604      	movs	r6, #4
    void Start() {
    3af4:	4604      	mov	r4, r0
            length[ch] = 4;
    3af6:	f880 6074 	strb.w	r6, [r0, #116]	; 0x74
            trigger[ch] = ch;
    3afa:	f880 5076 	strb.w	r5, [r0, #118]	; 0x76
            reg[ch] = random(0, 0xffff);
    3afe:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3b02:	4628      	mov	r0, r5
    3b04:	f016 f9f3 	bl	19eee <random(long, long)>
            trigger[ch] = ch;
    3b08:	2301      	movs	r3, #1
            reg[ch] = random(0, 0xffff);
    3b0a:	f8a4 0070 	strh.w	r0, [r4, #112]	; 0x70
            length[ch] = 4;
    3b0e:	f884 6075 	strb.w	r6, [r4, #117]	; 0x75
            trigger[ch] = ch;
    3b12:	f884 3077 	strb.w	r3, [r4, #119]	; 0x77
            reg[ch] = random(0, 0xffff);
    3b16:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3b1a:	4628      	mov	r0, r5
    3b1c:	f016 f9e7 	bl	19eee <random(long, long)>
    3b20:	f8a4 0072 	strh.w	r0, [r4, #114]	; 0x72
    }
    3b24:	bd70      	pop	{r4, r5, r6, pc}

00003b26 <Sequence5::Start()>:
    void Start() {
    3b26:	b570      	push	{r4, r5, r6, lr}
    3b28:	4604      	mov	r4, r0
    3b2a:	f100 0570 	add.w	r5, r0, #112	; 0x70
    3b2e:	f100 0684 	add.w	r6, r0, #132	; 0x84
        for (int s = 0; s < 5; s++) note[s] = random(0, 30);
    3b32:	211e      	movs	r1, #30
    3b34:	2000      	movs	r0, #0
    3b36:	f016 f9da 	bl	19eee <random(long, long)>
    3b3a:	f845 0f04 	str.w	r0, [r5, #4]!
    3b3e:	42b5      	cmp	r5, r6
    3b40:	d1f7      	bne.n	3b32 <Sequence5::Start()+0xc>
        play = 1;
    3b42:	2301      	movs	r3, #1
    3b44:	f884 308c 	strb.w	r3, [r4, #140]	; 0x8c
    }
    3b48:	bd70      	pop	{r4, r5, r6, pc}

00003b4a <Tuner::Start()>:
        A4_Hz = 440;
    3b4a:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
    3b4e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
        if (hemisphere == 0) {
    3b52:	7903      	ldrb	r3, [r0, #4]
    void Start() {
    3b54:	b510      	push	{r4, lr}
    3b56:	4604      	mov	r4, r0
        if (hemisphere == 0) {
    3b58:	b90b      	cbnz	r3, 3b5e <Tuner::Start()+0x14>
            FreqMeasure.begin();
    3b5a:	f015 f933 	bl	18dc4 <FreqMeasureClass::begin()>
        applet_started = 0;
    3b5e:	2300      	movs	r3, #0
    3b60:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
    }
    3b64:	bd10      	pop	{r4, pc}

00003b66 <IntervalTimer::~IntervalTimer()>:
public:
	IntervalTimer() {
		channel = NULL;
		nvic_priority = 128;
	}
	~IntervalTimer() {
    3b66:	b510      	push	{r4, lr}
    3b68:	4604      	mov	r4, r0
		end();
    3b6a:	f016 f93f 	bl	19dec <IntervalTimer::end()>
	}
    3b6e:	4620      	mov	r0, r4
    3b70:	bd10      	pop	{r4, pc}
    3b72:	Address 0x0000000000003b72 is out of bounds.


00003b74 <Tuner::SetHelp()>:
        if (hemisphere == 1) {
    3b74:	7903      	ldrb	r3, [r0, #4]
    void SetHelp() {
    3b76:	b510      	push	{r4, lr}
        if (hemisphere == 1) {
    3b78:	b143      	cbz	r3, 3b8c <Tuner::SetHelp()+0x18>
    3b7a:	4b07      	ldr	r3, [pc, #28]	; (3b98 <Tuner::SetHelp()+0x24>)
    3b7c:	4c07      	ldr	r4, [pc, #28]	; (3b9c <Tuner::SetHelp()+0x28>)
    3b7e:	4a08      	ldr	r2, [pc, #32]	; (3ba0 <Tuner::SetHelp()+0x2c>)
    3b80:	4619      	mov	r1, r3
            help[HEMISPHERE_HELP_CVS]      = "";
    3b82:	e9c0 4302 	strd	r4, r3, [r0, #8]
            help[HEMISPHERE_HELP_ENCODER]  = "A4 Hz P=Reset";
    3b86:	e9c0 1204 	strd	r1, r2, [r0, #16]
    }
    3b8a:	bd10      	pop	{r4, pc}
    3b8c:	4c05      	ldr	r4, [pc, #20]	; (3ba4 <Tuner::SetHelp()+0x30>)
    3b8e:	4b06      	ldr	r3, [pc, #24]	; (3ba8 <Tuner::SetHelp()+0x34>)
    3b90:	4906      	ldr	r1, [pc, #24]	; (3bac <Tuner::SetHelp()+0x38>)
    3b92:	4a07      	ldr	r2, [pc, #28]	; (3bb0 <Tuner::SetHelp()+0x3c>)
    3b94:	e7f5      	b.n	3b82 <Tuner::SetHelp()+0xe>
    3b96:	bf00      	nop
    3b98:	000211c8 	.word	0x000211c8
    3b9c:	00020744 	.word	0x00020744
    3ba0:	00020e72 	.word	0x00020e72
    3ba4:	00020e80 	.word	0x00020e80
    3ba8:	00020e90 	.word	0x00020e90
    3bac:	00020ea1 	.word	0x00020ea1
    3bb0:	00020eb3 	.word	0x00020eb3

00003bb4 <Backup_handleEncoderEvent(UI::Event const&)>:
        if (!receiving) {
    3bb4:	4b04      	ldr	r3, [pc, #16]	; (3bc8 <Backup_handleEncoderEvent(UI::Event const&)+0x14>)
    3bb6:	7999      	ldrb	r1, [r3, #6]
    3bb8:	b921      	cbnz	r1, 3bc4 <Backup_handleEncoderEvent(UI::Event const&)+0x10>
            calibration = 1 - calibration;
    3bba:	795a      	ldrb	r2, [r3, #5]
            packet = 0;
    3bbc:	71d9      	strb	r1, [r3, #7]
            calibration = 1 - calibration;
    3bbe:	f082 0201 	eor.w	r2, r2, #1
    3bc2:	715a      	strb	r2, [r3, #5]
void Backup_loop() {} // Deprecated
void Backup_screensaver() {Backup_instance.View();}
void Backup_handleEncoderEvent(const UI::Event &event) {
    Backup_instance.ToggleCalibration();
}
    3bc4:	4770      	bx	lr
    3bc6:	bf00      	nop
    3bc8:	1fffb1c0 	.word	0x1fffb1c0

00003bcc <Burst_OnButtonPress(bool)>:
        cursor += 1;
    3bcc:	4b08      	ldr	r3, [pc, #32]	; (3bf0 <Burst_OnButtonPress(bool)+0x24>)
    3bce:	2290      	movs	r2, #144	; 0x90
    3bd0:	fb02 3000 	mla	r0, r2, r0, r3
    3bd4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3bd6:	3301      	adds	r3, #1
        if (cursor > 2) cursor = 0;
    3bd8:	2b02      	cmp	r3, #2
    3bda:	dd02      	ble.n	3be2 <Burst_OnButtonPress(bool)+0x16>
    3bdc:	2300      	movs	r3, #0
        if (cursor > 1 && !clocked) cursor = 0;
    3bde:	66c3      	str	r3, [r0, #108]	; 0x6c
}
    3be0:	e005      	b.n	3bee <Burst_OnButtonPress(bool)+0x22>
    3be2:	66c3      	str	r3, [r0, #108]	; 0x6c
        if (cursor > 1 && !clocked) cursor = 0;
    3be4:	d103      	bne.n	3bee <Burst_OnButtonPress(bool)+0x22>
    3be6:	f890 3078 	ldrb.w	r3, [r0, #120]	; 0x78
    3bea:	2b00      	cmp	r3, #0
    3bec:	d0f7      	beq.n	3bde <Burst_OnButtonPress(bool)+0x12>
}
    3bee:	4770      	bx	lr
    3bf0:	1fffb750 	.word	0x1fffb750

00003bf4 <Burst_OnEncoderMove(bool, int)>:
void Burst_OnEncoderMove(bool hemisphere, int direction) {
    3bf4:	b510      	push	{r4, lr}
        if (cursor == 0) number = constrain(number += direction, 1, HEM_BURST_NUMBER_MAX);
    3bf6:	4c26      	ldr	r4, [pc, #152]	; (3c90 <Burst_OnEncoderMove(bool, int)+0x9c>)
    3bf8:	2390      	movs	r3, #144	; 0x90
    3bfa:	fb03 4300 	mla	r3, r3, r0, r4
    3bfe:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    3c00:	b95a      	cbnz	r2, 3c1a <Burst_OnEncoderMove(bool, int)+0x26>
    3c02:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
    3c06:	440a      	add	r2, r1
    3c08:	2a0c      	cmp	r2, #12
    3c0a:	bfa8      	it	ge
    3c0c:	220c      	movge	r2, #12
    3c0e:	2a01      	cmp	r2, #1
    3c10:	bfb8      	it	lt
    3c12:	2201      	movlt	r2, #1
    3c14:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    3c18:	bd10      	pop	{r4, pc}
        if (cursor == 1) {
    3c1a:	2a01      	cmp	r2, #1
    3c1c:	d01c      	beq.n	3c58 <Burst_OnEncoderMove(bool, int)+0x64>
        if (cursor == 2) {
    3c1e:	2a02      	cmp	r2, #2
    3c20:	d1fa      	bne.n	3c18 <Burst_OnEncoderMove(bool, int)+0x24>
            div += direction;
    3c22:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    3c26:	440a      	add	r2, r1
            if (div > HEM_BURST_CLOCKDIV_MAX) div = HEM_BURST_CLOCKDIV_MAX;
    3c28:	2a08      	cmp	r2, #8
    3c2a:	dc26      	bgt.n	3c7a <Burst_OnEncoderMove(bool, int)+0x86>
            if (div < -HEM_BURST_CLOCKDIV_MAX) div = -HEM_BURST_CLOCKDIV_MAX;
    3c2c:	f112 0f08 	cmn.w	r2, #8
    3c30:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    3c34:	db23      	blt.n	3c7e <Burst_OnEncoderMove(bool, int)+0x8a>
            if (div == 0) div = direction > 0 ? 1 : -2; // No such thing as 1/1 Multiple
    3c36:	b32a      	cbz	r2, 3c84 <Burst_OnEncoderMove(bool, int)+0x90>
    3c38:	2390      	movs	r3, #144	; 0x90
    3c3a:	fb03 4300 	mla	r3, r3, r0, r4
    3c3e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            if (div == -1) div = 1; // Must be moving up to hit -1 (see previous line)
    3c42:	2390      	movs	r3, #144	; 0x90
    3c44:	fb03 4400 	mla	r4, r3, r0, r4
    3c48:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    3c4c:	3301      	adds	r3, #1
    3c4e:	bf04      	itt	eq
    3c50:	2301      	moveq	r3, #1
    3c52:	f8c4 308c 	streq.w	r3, [r4, #140]	; 0x8c
}
    3c56:	e7df      	b.n	3c18 <Burst_OnEncoderMove(bool, int)+0x24>
            spacing = constrain(spacing += direction, HEM_BURST_SPACING_MIN, HEM_BURST_SPACING_MAX);
    3c58:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    3c5c:	440a      	add	r2, r1
    3c5e:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
    3c62:	bfa8      	it	ge
    3c64:	f44f 72fa 	movge.w	r2, #500	; 0x1f4
    3c68:	2a08      	cmp	r2, #8
    3c6a:	bfb8      	it	lt
    3c6c:	2208      	movlt	r2, #8
    3c6e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            clocked = 0;
    3c72:	2200      	movs	r2, #0
    3c74:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
        if (cursor == 2) {
    3c78:	e7ce      	b.n	3c18 <Burst_OnEncoderMove(bool, int)+0x24>
            if (div > HEM_BURST_CLOCKDIV_MAX) div = HEM_BURST_CLOCKDIV_MAX;
    3c7a:	2208      	movs	r2, #8
    3c7c:	e7dc      	b.n	3c38 <Burst_OnEncoderMove(bool, int)+0x44>
            if (div < -HEM_BURST_CLOCKDIV_MAX) div = -HEM_BURST_CLOCKDIV_MAX;
    3c7e:	f06f 0207 	mvn.w	r2, #7
    3c82:	e7d9      	b.n	3c38 <Burst_OnEncoderMove(bool, int)+0x44>
            if (div == 0) div = direction > 0 ? 1 : -2; // No such thing as 1/1 Multiple
    3c84:	2900      	cmp	r1, #0
    3c86:	bfcc      	ite	gt
    3c88:	2201      	movgt	r2, #1
    3c8a:	f06f 0201 	mvnle.w	r2, #1
    3c8e:	e7d6      	b.n	3c3e <Burst_OnEncoderMove(bool, int)+0x4a>
    3c90:	1fffb750 	.word	0x1fffb750

00003c94 <LowerRenz_OnEncoderMove(bool, int)>:
        if (cursor == 0) freq = constrain(freq += direction, 0, 255);
    3c94:	4b0b      	ldr	r3, [pc, #44]	; (3cc4 <LowerRenz_OnEncoderMove(bool, int)+0x30>)
    3c96:	227c      	movs	r2, #124	; 0x7c
    3c98:	fb02 3000 	mla	r0, r2, r0, r3
    3c9c:	6f83      	ldr	r3, [r0, #120]	; 0x78
    3c9e:	b92b      	cbnz	r3, 3cac <LowerRenz_OnEncoderMove(bool, int)+0x18>
    3ca0:	6f03      	ldr	r3, [r0, #112]	; 0x70
    3ca2:	440b      	add	r3, r1
    3ca4:	f383 0308 	usat	r3, #8, r3
    3ca8:	6703      	str	r3, [r0, #112]	; 0x70
        if (cursor == 1) rho = constrain(rho += direction, 4, 127);
    3caa:	4770      	bx	lr
    3cac:	2b01      	cmp	r3, #1
    3cae:	d108      	bne.n	3cc2 <LowerRenz_OnEncoderMove(bool, int)+0x2e>
    3cb0:	6f43      	ldr	r3, [r0, #116]	; 0x74
    3cb2:	440b      	add	r3, r1
    3cb4:	2b7f      	cmp	r3, #127	; 0x7f
    3cb6:	bfa8      	it	ge
    3cb8:	237f      	movge	r3, #127	; 0x7f
    3cba:	2b04      	cmp	r3, #4
    3cbc:	bfb8      	it	lt
    3cbe:	2304      	movlt	r3, #4
    3cc0:	6743      	str	r3, [r0, #116]	; 0x74
}
    3cc2:	4770      	bx	lr
    3cc4:	200002c4 	.word	0x200002c4

00003cc8 <SkewedLFO_OnEncoderMove(bool, int)>:
        if (cursor == 0) {
    3cc8:	4b0b      	ldr	r3, [pc, #44]	; (3cf8 <SkewedLFO_OnEncoderMove(bool, int)+0x30>)
    3cca:	2284      	movs	r2, #132	; 0x84
    3ccc:	fb02 3000 	mla	r0, r2, r0, r3
    3cd0:	6f43      	ldr	r3, [r0, #116]	; 0x74
    3cd2:	b943      	cbnz	r3, 3ce6 <SkewedLFO_OnEncoderMove(bool, int)+0x1e>
            rate = constrain(rate += direction, 0, HEM_LFO_MAX_VALUE);
    3cd4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3cd6:	440b      	add	r3, r1
    3cd8:	2b78      	cmp	r3, #120	; 0x78
    3cda:	bfa8      	it	ge
    3cdc:	2378      	movge	r3, #120	; 0x78
    3cde:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    3ce2:	66c3      	str	r3, [r0, #108]	; 0x6c
    }
    3ce4:	4770      	bx	lr
            skew = constrain(skew += direction, 0, HEM_LFO_MAX_VALUE);
    3ce6:	6f03      	ldr	r3, [r0, #112]	; 0x70
    3ce8:	440b      	add	r3, r1
    3cea:	2b78      	cmp	r3, #120	; 0x78
    3cec:	bfa8      	it	ge
    3cee:	2378      	movge	r3, #120	; 0x78
    3cf0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    3cf4:	6703      	str	r3, [r0, #112]	; 0x70
}
    3cf6:	4770      	bx	lr
    3cf8:	2000193c 	.word	0x2000193c

00003cfc <TLNeuron_OnEncoderMove(bool, int)>:
void TLNeuron_OnEncoderMove(bool hemisphere, int direction) {
    3cfc:	b510      	push	{r4, lr}
        if (selected < 3) {
    3cfe:	4c13      	ldr	r4, [pc, #76]	; (3d4c <TLNeuron_OnEncoderMove(bool, int)+0x50>)
    3d00:	228c      	movs	r2, #140	; 0x8c
    3d02:	fb02 4200 	mla	r2, r2, r0, r4
    3d06:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
    3d08:	2b02      	cmp	r3, #2
    3d0a:	dc12      	bgt.n	3d32 <TLNeuron_OnEncoderMove(bool, int)+0x36>
            dendrite_weight[selected] = constrain(dendrite_weight[selected] + direction, -9, 9);
    3d0c:	2223      	movs	r2, #35	; 0x23
    3d0e:	fb02 3000 	mla	r0, r2, r0, r3
    3d12:	301c      	adds	r0, #28
    3d14:	f06f 0208 	mvn.w	r2, #8
    3d18:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
    3d1c:	440b      	add	r3, r1
    3d1e:	2b09      	cmp	r3, #9
    3d20:	bfa8      	it	ge
    3d22:	2309      	movge	r3, #9
    3d24:	4293      	cmp	r3, r2
    3d26:	bfac      	ite	ge
    3d28:	f844 3020 	strge.w	r3, [r4, r0, lsl #2]
    3d2c:	f844 2020 	strlt.w	r2, [r4, r0, lsl #2]
}
    3d30:	bd10      	pop	{r4, pc}
            threshold = constrain(threshold + direction, -27, 27);
    3d32:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    3d34:	440b      	add	r3, r1
    3d36:	2b1b      	cmp	r3, #27
    3d38:	bfa8      	it	ge
    3d3a:	231b      	movge	r3, #27
    3d3c:	f06f 011a 	mvn.w	r1, #26
    3d40:	428b      	cmp	r3, r1
    3d42:	bfac      	ite	ge
    3d44:	67d3      	strge	r3, [r2, #124]	; 0x7c
    3d46:	67d1      	strlt	r1, [r2, #124]	; 0x7c
}
    3d48:	e7f2      	b.n	3d30 <TLNeuron_OnEncoderMove(bool, int)+0x34>
    3d4a:	bf00      	nop
    3d4c:	20001fbc 	.word	0x20001fbc

00003d50 <Trending_OnEncoderMove(bool, int)>:
        if (cursor < 2) {
    3d50:	4b10      	ldr	r3, [pc, #64]	; (3d94 <Trending_OnEncoderMove(bool, int)+0x44>)
    3d52:	22a0      	movs	r2, #160	; 0xa0
    3d54:	fb02 3000 	mla	r0, r2, r0, r3
    3d58:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    3d5a:	2b01      	cmp	r3, #1
    3d5c:	dc0e      	bgt.n	3d7c <Trending_OnEncoderMove(bool, int)+0x2c>
            assign[cursor] = constrain(assign[cursor] + direction, 0, 5);
    3d5e:	4418      	add	r0, r3
    3d60:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
    3d64:	4419      	add	r1, r3
    3d66:	2905      	cmp	r1, #5
    3d68:	bfa8      	it	ge
    3d6a:	2105      	movge	r1, #5
    3d6c:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
            reset[cursor] = 1;
    3d70:	2301      	movs	r3, #1
            assign[cursor] = constrain(assign[cursor] + direction, 0, 5);
    3d72:	f880 1098 	strb.w	r1, [r0, #152]	; 0x98
            reset[cursor] = 1;
    3d76:	f880 3094 	strb.w	r3, [r0, #148]	; 0x94
    3d7a:	4770      	bx	lr
        else sensitivity = constrain(sensitivity + direction, 4, TRENDING_MAX_SENS);
    3d7c:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    3d80:	440b      	add	r3, r1
    3d82:	2b7c      	cmp	r3, #124	; 0x7c
    3d84:	bfa8      	it	ge
    3d86:	237c      	movge	r3, #124	; 0x7c
    3d88:	2b04      	cmp	r3, #4
    3d8a:	bfb8      	it	lt
    3d8c:	2304      	movlt	r3, #4
    3d8e:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
void Trending_OnEncoderMove(bool hemisphere, int direction) {Trending_instance[hemisphere].OnEncoderMove(direction);}
    3d92:	4770      	bx	lr
    3d94:	20002654 	.word	0x20002654

00003d98 <TrigSeq16_OnEncoderMove(bool, int)>:
void TrigSeq16_OnEncoderMove(bool hemisphere, int direction) {
    3d98:	b510      	push	{r4, lr}
        if (cursor == 4) {
    3d9a:	4b16      	ldr	r3, [pc, #88]	; (3df4 <TrigSeq16_OnEncoderMove(bool, int)+0x5c>)
    3d9c:	227c      	movs	r2, #124	; 0x7c
    3d9e:	fb02 3000 	mla	r0, r2, r0, r3
    3da2:	6f83      	ldr	r3, [r0, #120]	; 0x78
    3da4:	2b04      	cmp	r3, #4
    3da6:	d105      	bne.n	3db4 <TrigSeq16_OnEncoderMove(bool, int)+0x1c>
            end_step = constrain(end_step += direction, 0, 15);
    3da8:	6f43      	ldr	r3, [r0, #116]	; 0x74
    3daa:	440b      	add	r3, r1
    3dac:	f383 0304 	usat	r3, #4, r3
    3db0:	6743      	str	r3, [r0, #116]	; 0x74
}
    3db2:	bd10      	pop	{r4, pc}
            int ch = cursor > 1 ? 1 : 0;
    3db4:	2b01      	cmp	r3, #1
    3db6:	bfcc      	ite	gt
    3db8:	2201      	movgt	r2, #1
    3dba:	2200      	movle	r2, #0
            int curr_patt = pattern[ch];
    3dbc:	4410      	add	r0, r2
            int this_cursor = cursor - (ch * 2);
    3dbe:	bfcc      	ite	gt
    3dc0:	2402      	movgt	r4, #2
    3dc2:	2400      	movle	r4, #0
            int curr_patt = pattern[ch];
    3dc4:	f890 2070 	ldrb.w	r2, [r0, #112]	; 0x70
            int this_cursor = cursor - (ch * 2);
    3dc8:	1b1c      	subs	r4, r3, r4
            uint8_t nybble = (curr_patt >> (this_cursor * 4)) & 0x0f;
    3dca:	00a3      	lsls	r3, r4, #2
    3dcc:	fa42 f303 	asr.w	r3, r2, r3
    3dd0:	4419      	add	r1, r3
    3dd2:	f001 010f 	and.w	r1, r1, #15
            if (this_cursor == 0) pattern[ch] = (curr_patt & 0xf0) + nybble;
    3dd6:	b92c      	cbnz	r4, 3de4 <TrigSeq16_OnEncoderMove(bool, int)+0x4c>
    3dd8:	f022 020f 	bic.w	r2, r2, #15
    3ddc:	4311      	orrs	r1, r2
    3dde:	f880 1070 	strb.w	r1, [r0, #112]	; 0x70
    3de2:	e7e6      	b.n	3db2 <TrigSeq16_OnEncoderMove(bool, int)+0x1a>
            else pattern[ch] = (curr_patt & 0x0f) + (nybble << 4);
    3de4:	f002 020f 	and.w	r2, r2, #15
    3de8:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    3dec:	f880 2070 	strb.w	r2, [r0, #112]	; 0x70
}
    3df0:	e7df      	b.n	3db2 <TrigSeq16_OnEncoderMove(bool, int)+0x1a>
    3df2:	bf00      	nop
    3df4:	20002794 	.word	0x20002794

00003df8 <Switch_OnDataReceive(bool, unsigned long)>:
    3df8:	4770      	bx	lr

00003dfa <Switch_OnDataRequest(bool)>:
    3dfa:	2000      	movs	r0, #0
    3dfc:	4770      	bx	lr

00003dfe <Switch_OnButtonPress(bool)>:
    3dfe:	4770      	bx	lr

00003e00 <TheDarkestTimeline::Resume()>:
        setup_screen = 0;
    3e00:	2300      	movs	r3, #0
    3e02:	f880 31e8 	strb.w	r3, [r0, #488]	; 0x1e8
        last_midi_note[0] = -1;
    3e06:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3e0a:	f8a0 31fc 	strh.w	r3, [r0, #508]	; 0x1fc
        if (!length()) {
    3e0e:	f890 3088 	ldrb.w	r3, [r0, #136]	; 0x88
    3e12:	b95b      	cbnz	r3, 3e2c <TheDarkestTimeline::Resume()+0x2c>
            values_[DT_LENGTH] = 16;
    3e14:	2310      	movs	r3, #16
    3e16:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
            values_[DT_SCALE] = 5;
    3e1a:	2305      	movs	r3, #5
    3e1c:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
            values_[DT_MIDI_CHANNEL] = 11;
    3e20:	230b      	movs	r3, #11
    3e22:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
            values_[DT_MIDI_CHANNEL_ALT] = 12;
    3e26:	230c      	movs	r3, #12
    3e28:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
	}
    3e2c:	4770      	bx	lr

00003e2e <__tcf_5>:
    3e2e:	4770      	bx	lr

00003e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>:
    }

    /* Retrieve value from a 32-bit storage unit at the specified location and of the specified bit size */
    int Unpack(uint32_t data, PackLocation p) {
    3e30:	b537      	push	{r0, r1, r2, r4, r5, lr}
    3e32:	ab02      	add	r3, sp, #8
    3e34:	e903 0006 	stmdb	r3, {r1, r2}
        uint32_t mask = 1;
        for (int i = 1; i < p.size; i++) mask |= (0x01 << i);
    3e38:	2301      	movs	r3, #1
    3e3a:	4611      	mov	r1, r2
    3e3c:	461c      	mov	r4, r3
        uint32_t mask = 1;
    3e3e:	461a      	mov	r2, r3
        for (int i = 1; i < p.size; i++) mask |= (0x01 << i);
    3e40:	428b      	cmp	r3, r1
    3e42:	db04      	blt.n	3e4e <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]+0x1e>
        return (data >> p.location) & mask;
    3e44:	9b00      	ldr	r3, [sp, #0]
    3e46:	40d8      	lsrs	r0, r3
    }
    3e48:	4010      	ands	r0, r2
    3e4a:	b003      	add	sp, #12
    3e4c:	bd30      	pop	{r4, r5, pc}
        for (int i = 1; i < p.size; i++) mask |= (0x01 << i);
    3e4e:	fa04 f503 	lsl.w	r5, r4, r3
    3e52:	432a      	orrs	r2, r5
    3e54:	3301      	adds	r3, #1
    3e56:	e7f3      	b.n	3e40 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]+0x10>

00003e58 <hMIDIOut_OnDataReceive(bool, unsigned long)>:

void hMIDIOut_OnDataReceive(bool hemisphere, uint32_t data) {
    3e58:	b5f0      	push	{r4, r5, r6, r7, lr}
        channel = Unpack(data, PackLocation {0,4});
    3e5a:	2300      	movs	r3, #0
void hMIDIOut_OnDataReceive(bool hemisphere, uint32_t data) {
    3e5c:	b087      	sub	sp, #28
        channel = Unpack(data, PackLocation {0,4});
    3e5e:	2704      	movs	r7, #4
    3e60:	e9cd 3704 	strd	r3, r7, [sp, #16]
void hMIDIOut_OnDataReceive(bool hemisphere, uint32_t data) {
    3e64:	460d      	mov	r5, r1
        channel = Unpack(data, PackLocation {0,4});
    3e66:	ab06      	add	r3, sp, #24
    3e68:	e913 0006 	ldmdb	r3, {r1, r2}
void hMIDIOut_OnDataReceive(bool hemisphere, uint32_t data) {
    3e6c:	4606      	mov	r6, r0
        channel = Unpack(data, PackLocation {0,4});
    3e6e:	4c0e      	ldr	r4, [pc, #56]	; (3ea8 <hMIDIOut_OnDataReceive(bool, unsigned long)+0x50>)
    3e70:	4628      	mov	r0, r5
    3e72:	f7ff ffdd 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3e76:	eb04 2406 	add.w	r4, r4, r6, lsl #8
        function = Unpack(data, PackLocation {4,3});
    3e7a:	2303      	movs	r3, #3
        channel = Unpack(data, PackLocation {0,4});
    3e7c:	66e0      	str	r0, [r4, #108]	; 0x6c
        function = Unpack(data, PackLocation {4,3});
    3e7e:	461a      	mov	r2, r3
    3e80:	4639      	mov	r1, r7
    3e82:	4628      	mov	r0, r5
    3e84:	9303      	str	r3, [sp, #12]
    3e86:	9702      	str	r7, [sp, #8]
    3e88:	f7ff ffd2 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        legato = Unpack(data, PackLocation {7,1});
    3e8c:	2301      	movs	r3, #1
    3e8e:	2207      	movs	r2, #7
    3e90:	e9cd 2300 	strd	r2, r3, [sp]
        function = Unpack(data, PackLocation {4,3});
    3e94:	6720      	str	r0, [r4, #112]	; 0x70
        legato = Unpack(data, PackLocation {7,1});
    3e96:	461a      	mov	r2, r3
    3e98:	2107      	movs	r1, #7
    3e9a:	4628      	mov	r0, r5
    3e9c:	f7ff ffc8 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3ea0:	67a0      	str	r0, [r4, #120]	; 0x78
    hMIDIOut_instance[hemisphere].OnDataReceive(data);
}
    3ea2:	b007      	add	sp, #28
    3ea4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3ea6:	bf00      	nop
    3ea8:	20004fb8 	.word	0x20004fb8

00003eac <hMIDIIn_OnDataReceive(bool, unsigned long)>:

void hMIDIIn_OnDataReceive(bool hemisphere, uint32_t data) {
    3eac:	b5f0      	push	{r4, r5, r6, r7, lr}
        channel = Unpack(data, PackLocation {0,8});
    3eae:	2300      	movs	r3, #0
void hMIDIIn_OnDataReceive(bool hemisphere, uint32_t data) {
    3eb0:	b087      	sub	sp, #28
        channel = Unpack(data, PackLocation {0,8});
    3eb2:	2708      	movs	r7, #8
    3eb4:	e9cd 3704 	strd	r3, r7, [sp, #16]
void hMIDIIn_OnDataReceive(bool hemisphere, uint32_t data) {
    3eb8:	460d      	mov	r5, r1
        channel = Unpack(data, PackLocation {0,8});
    3eba:	ab06      	add	r3, sp, #24
    3ebc:	e913 0006 	ldmdb	r3, {r1, r2}
void hMIDIIn_OnDataReceive(bool hemisphere, uint32_t data) {
    3ec0:	4606      	mov	r6, r0
        channel = Unpack(data, PackLocation {0,8});
    3ec2:	4c0d      	ldr	r4, [pc, #52]	; (3ef8 <hMIDIIn_OnDataReceive(bool, unsigned long)+0x4c>)
    3ec4:	4628      	mov	r0, r5
    3ec6:	f7ff ffb3 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3eca:	eb04 2406 	add.w	r4, r4, r6, lsl #8
        function[0] = Unpack(data, PackLocation {8,3});
    3ece:	2603      	movs	r6, #3
        channel = Unpack(data, PackLocation {0,8});
    3ed0:	66e0      	str	r0, [r4, #108]	; 0x6c
        function[0] = Unpack(data, PackLocation {8,3});
    3ed2:	4632      	mov	r2, r6
    3ed4:	4639      	mov	r1, r7
    3ed6:	4628      	mov	r0, r5
    3ed8:	9702      	str	r7, [sp, #8]
    3eda:	9603      	str	r6, [sp, #12]
    3edc:	f7ff ffa8 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        function[1] = Unpack(data, PackLocation {11,3});
    3ee0:	230b      	movs	r3, #11
        function[0] = Unpack(data, PackLocation {8,3});
    3ee2:	6720      	str	r0, [r4, #112]	; 0x70
        function[1] = Unpack(data, PackLocation {11,3});
    3ee4:	4632      	mov	r2, r6
    3ee6:	4619      	mov	r1, r3
    3ee8:	4628      	mov	r0, r5
    3eea:	e9cd 3600 	strd	r3, r6, [sp]
    3eee:	f7ff ff9f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3ef2:	6760      	str	r0, [r4, #116]	; 0x74
    hMIDIIn_instance[hemisphere].OnDataReceive(data);
}
    3ef4:	b007      	add	sp, #28
    3ef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3ef8:	20004db8 	.word	0x20004db8

00003efc <Tuner_OnDataReceive(bool, unsigned long)>:

void Tuner_OnDataReceive(bool hemisphere, uint32_t data) {
    3efc:	b513      	push	{r0, r1, r4, lr}
        A4_Hz = Unpack(data, PackLocation {0,16});
    3efe:	2200      	movs	r2, #0
    3f00:	2310      	movs	r3, #16
    3f02:	e9cd 2300 	strd	r2, r3, [sp]
    3f06:	ab02      	add	r3, sp, #8
void Tuner_OnDataReceive(bool hemisphere, uint32_t data) {
    3f08:	4604      	mov	r4, r0
    3f0a:	4608      	mov	r0, r1
        A4_Hz = Unpack(data, PackLocation {0,16});
    3f0c:	e913 0006 	ldmdb	r3, {r1, r2}
    3f10:	f7ff ff8e 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3f14:	4b03      	ldr	r3, [pc, #12]	; (3f24 <Tuner_OnDataReceive(bool, unsigned long)+0x28>)
    3f16:	2288      	movs	r2, #136	; 0x88
    3f18:	fb02 3304 	mla	r3, r2, r4, r3
    3f1c:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
    Tuner_instance[hemisphere].OnDataReceive(data);
}
    3f20:	b002      	add	sp, #8
    3f22:	bd10      	pop	{r4, pc}
    3f24:	20002998 	.word	0x20002998

00003f28 <TrigSeq16_OnDataReceive(bool, unsigned long)>:

void TrigSeq16_OnDataReceive(bool hemisphere, uint32_t data) {
    3f28:	b5f0      	push	{r4, r5, r6, r7, lr}
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f2a:	2300      	movs	r3, #0
void TrigSeq16_OnDataReceive(bool hemisphere, uint32_t data) {
    3f2c:	b087      	sub	sp, #28
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f2e:	2608      	movs	r6, #8
    3f30:	e9cd 3604 	strd	r3, r6, [sp, #16]
void TrigSeq16_OnDataReceive(bool hemisphere, uint32_t data) {
    3f34:	460d      	mov	r5, r1
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f36:	ab06      	add	r3, sp, #24
    3f38:	e913 0006 	ldmdb	r3, {r1, r2}
void TrigSeq16_OnDataReceive(bool hemisphere, uint32_t data) {
    3f3c:	4607      	mov	r7, r0
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f3e:	4c0f      	ldr	r4, [pc, #60]	; (3f7c <TrigSeq16_OnDataReceive(bool, unsigned long)+0x54>)
    3f40:	4628      	mov	r0, r5
    3f42:	f7ff ff75 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3f46:	237c      	movs	r3, #124	; 0x7c
    3f48:	fb03 4407 	mla	r4, r3, r7, r4
        pattern[1] = Unpack(data, PackLocation {8,8});
    3f4c:	4632      	mov	r2, r6
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f4e:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
        pattern[1] = Unpack(data, PackLocation {8,8});
    3f52:	4631      	mov	r1, r6
    3f54:	4628      	mov	r0, r5
    3f56:	e9cd 6602 	strd	r6, r6, [sp, #8]
    3f5a:	f7ff ff69 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        end_step = Unpack(data, PackLocation {16,4});
    3f5e:	2304      	movs	r3, #4
    3f60:	2210      	movs	r2, #16
    3f62:	e9cd 2300 	strd	r2, r3, [sp]
        pattern[1] = Unpack(data, PackLocation {8,8});
    3f66:	f884 0071 	strb.w	r0, [r4, #113]	; 0x71
        end_step = Unpack(data, PackLocation {16,4});
    3f6a:	461a      	mov	r2, r3
    3f6c:	2110      	movs	r1, #16
    3f6e:	4628      	mov	r0, r5
    3f70:	f7ff ff5e 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3f74:	6760      	str	r0, [r4, #116]	; 0x74
    TrigSeq16_instance[hemisphere].OnDataReceive(data);
}
    3f76:	b007      	add	sp, #28
    3f78:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3f7a:	bf00      	nop
    3f7c:	20002794 	.word	0x20002794

00003f80 <TrigSeq_OnDataReceive(bool, unsigned long)>:

void TrigSeq_OnDataReceive(bool hemisphere, uint32_t data) {
    3f80:	b5f0      	push	{r4, r5, r6, r7, lr}
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f82:	2300      	movs	r3, #0
void TrigSeq_OnDataReceive(bool hemisphere, uint32_t data) {
    3f84:	b089      	sub	sp, #36	; 0x24
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f86:	2608      	movs	r6, #8
    3f88:	e9cd 3606 	strd	r3, r6, [sp, #24]
void TrigSeq_OnDataReceive(bool hemisphere, uint32_t data) {
    3f8c:	460d      	mov	r5, r1
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f8e:	ab08      	add	r3, sp, #32
    3f90:	e913 0006 	ldmdb	r3, {r1, r2}
void TrigSeq_OnDataReceive(bool hemisphere, uint32_t data) {
    3f94:	4607      	mov	r7, r0
        pattern[0] = Unpack(data, PackLocation {0,8});
    3f96:	4c13      	ldr	r4, [pc, #76]	; (3fe4 <TrigSeq_OnDataReceive(bool, unsigned long)+0x64>)
    3f98:	4628      	mov	r0, r5
    3f9a:	f7ff ff49 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3f9e:	2384      	movs	r3, #132	; 0x84
    3fa0:	fb03 4407 	mla	r4, r3, r7, r4
        pattern[1] = Unpack(data, PackLocation {8,8});
    3fa4:	4632      	mov	r2, r6
        pattern[0] = Unpack(data, PackLocation {0,8});
    3fa6:	f884 0074 	strb.w	r0, [r4, #116]	; 0x74
        pattern[1] = Unpack(data, PackLocation {8,8});
    3faa:	4631      	mov	r1, r6
    3fac:	4628      	mov	r0, r5
    3fae:	e9cd 6604 	strd	r6, r6, [sp, #16]
    3fb2:	f7ff ff3d 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        end_step[0] = Unpack(data, PackLocation {16,3});
    3fb6:	2603      	movs	r6, #3
    3fb8:	2310      	movs	r3, #16
        pattern[1] = Unpack(data, PackLocation {8,8});
    3fba:	f884 0075 	strb.w	r0, [r4, #117]	; 0x75
        end_step[0] = Unpack(data, PackLocation {16,3});
    3fbe:	4632      	mov	r2, r6
    3fc0:	4619      	mov	r1, r3
    3fc2:	4628      	mov	r0, r5
    3fc4:	e9cd 3602 	strd	r3, r6, [sp, #8]
    3fc8:	f7ff ff32 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        end_step[1] = Unpack(data, PackLocation {19,3});
    3fcc:	2313      	movs	r3, #19
        end_step[0] = Unpack(data, PackLocation {16,3});
    3fce:	67a0      	str	r0, [r4, #120]	; 0x78
        end_step[1] = Unpack(data, PackLocation {19,3});
    3fd0:	4632      	mov	r2, r6
    3fd2:	4619      	mov	r1, r3
    3fd4:	4628      	mov	r0, r5
    3fd6:	e9cd 3600 	strd	r3, r6, [sp]
    3fda:	f7ff ff29 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    3fde:	67e0      	str	r0, [r4, #124]	; 0x7c
    TrigSeq_instance[hemisphere].OnDataReceive(data);
}
    3fe0:	b009      	add	sp, #36	; 0x24
    3fe2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3fe4:	2000288c 	.word	0x2000288c

00003fe8 <Trending_OnDataReceive(bool, unsigned long)>:
void Trending_OnDataReceive(bool hemisphere, uint32_t data) {Trending_instance[hemisphere].OnDataReceive(data);}
    3fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
        assign[0] = Unpack(data, PackLocation {0,4});
    3fea:	2300      	movs	r3, #0
void Trending_OnDataReceive(bool hemisphere, uint32_t data) {Trending_instance[hemisphere].OnDataReceive(data);}
    3fec:	b087      	sub	sp, #28
        assign[0] = Unpack(data, PackLocation {0,4});
    3fee:	2604      	movs	r6, #4
    3ff0:	e9cd 3604 	strd	r3, r6, [sp, #16]
void Trending_OnDataReceive(bool hemisphere, uint32_t data) {Trending_instance[hemisphere].OnDataReceive(data);}
    3ff4:	460d      	mov	r5, r1
        assign[0] = Unpack(data, PackLocation {0,4});
    3ff6:	ab06      	add	r3, sp, #24
    3ff8:	e913 0006 	ldmdb	r3, {r1, r2}
void Trending_OnDataReceive(bool hemisphere, uint32_t data) {Trending_instance[hemisphere].OnDataReceive(data);}
    3ffc:	4607      	mov	r7, r0
        assign[0] = Unpack(data, PackLocation {0,4});
    3ffe:	4c0f      	ldr	r4, [pc, #60]	; (403c <Trending_OnDataReceive(bool, unsigned long)+0x54>)
    4000:	4628      	mov	r0, r5
    4002:	f7ff ff15 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4006:	23a0      	movs	r3, #160	; 0xa0
    4008:	fb03 4407 	mla	r4, r3, r7, r4
        assign[1] = Unpack(data, PackLocation {4,4});
    400c:	4632      	mov	r2, r6
        assign[0] = Unpack(data, PackLocation {0,4});
    400e:	f884 0098 	strb.w	r0, [r4, #152]	; 0x98
        assign[1] = Unpack(data, PackLocation {4,4});
    4012:	4631      	mov	r1, r6
    4014:	4628      	mov	r0, r5
    4016:	e9cd 6602 	strd	r6, r6, [sp, #8]
    401a:	f7ff ff09 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        sensitivity = Unpack(data, PackLocation {8,8});
    401e:	2308      	movs	r3, #8
        assign[1] = Unpack(data, PackLocation {4,4});
    4020:	f884 0099 	strb.w	r0, [r4, #153]	; 0x99
        sensitivity = Unpack(data, PackLocation {8,8});
    4024:	461a      	mov	r2, r3
    4026:	4619      	mov	r1, r3
    4028:	4628      	mov	r0, r5
    402a:	e9cd 3300 	strd	r3, r3, [sp]
    402e:	f7ff feff 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4032:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
void Trending_OnDataReceive(bool hemisphere, uint32_t data) {Trending_instance[hemisphere].OnDataReceive(data);}
    4036:	b007      	add	sp, #28
    4038:	bdf0      	pop	{r4, r5, r6, r7, pc}
    403a:	bf00      	nop
    403c:	20002654 	.word	0x20002654

00004040 <Slew_OnDataReceive(bool, unsigned long)>:

void Slew_OnDataReceive(bool hemisphere, uint32_t data) {
    4040:	b5f0      	push	{r4, r5, r6, r7, lr}
        rise = Unpack(data, PackLocation {0,8});
    4042:	2300      	movs	r3, #0
void Slew_OnDataReceive(bool hemisphere, uint32_t data) {
    4044:	b085      	sub	sp, #20
        rise = Unpack(data, PackLocation {0,8});
    4046:	2608      	movs	r6, #8
    4048:	e9cd 3602 	strd	r3, r6, [sp, #8]
void Slew_OnDataReceive(bool hemisphere, uint32_t data) {
    404c:	460d      	mov	r5, r1
        rise = Unpack(data, PackLocation {0,8});
    404e:	ab04      	add	r3, sp, #16
    4050:	e913 0006 	ldmdb	r3, {r1, r2}
void Slew_OnDataReceive(bool hemisphere, uint32_t data) {
    4054:	4607      	mov	r7, r0
        rise = Unpack(data, PackLocation {0,8});
    4056:	4c09      	ldr	r4, [pc, #36]	; (407c <Slew_OnDataReceive(bool, unsigned long)+0x3c>)
    4058:	4628      	mov	r0, r5
    405a:	f7ff fee9 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    405e:	2388      	movs	r3, #136	; 0x88
    4060:	fb03 4407 	mla	r4, r3, r7, r4
        fall = Unpack(data, PackLocation {8,8});
    4064:	4632      	mov	r2, r6
        rise = Unpack(data, PackLocation {0,8});
    4066:	66e0      	str	r0, [r4, #108]	; 0x6c
        fall = Unpack(data, PackLocation {8,8});
    4068:	4631      	mov	r1, r6
    406a:	4628      	mov	r0, r5
    406c:	e9cd 6600 	strd	r6, r6, [sp]
    4070:	f7ff fede 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4074:	6720      	str	r0, [r4, #112]	; 0x70
    Slew_instance[hemisphere].OnDataReceive(data);
}
    4076:	b005      	add	sp, #20
    4078:	bdf0      	pop	{r4, r5, r6, r7, pc}
    407a:	bf00      	nop
    407c:	20001a44 	.word	0x20001a44

00004080 <SkewedLFO_OnDataReceive(bool, unsigned long)>:

void SkewedLFO_OnDataReceive(bool hemisphere, uint32_t data) {
    4080:	b5f0      	push	{r4, r5, r6, r7, lr}
        skew = Unpack(data, PackLocation {0,8});
    4082:	2300      	movs	r3, #0
void SkewedLFO_OnDataReceive(bool hemisphere, uint32_t data) {
    4084:	b085      	sub	sp, #20
        skew = Unpack(data, PackLocation {0,8});
    4086:	2608      	movs	r6, #8
    4088:	e9cd 3602 	strd	r3, r6, [sp, #8]
void SkewedLFO_OnDataReceive(bool hemisphere, uint32_t data) {
    408c:	460d      	mov	r5, r1
        skew = Unpack(data, PackLocation {0,8});
    408e:	ab04      	add	r3, sp, #16
    4090:	e913 0006 	ldmdb	r3, {r1, r2}
void SkewedLFO_OnDataReceive(bool hemisphere, uint32_t data) {
    4094:	4607      	mov	r7, r0
        skew = Unpack(data, PackLocation {0,8});
    4096:	4c09      	ldr	r4, [pc, #36]	; (40bc <SkewedLFO_OnDataReceive(bool, unsigned long)+0x3c>)
    4098:	4628      	mov	r0, r5
    409a:	f7ff fec9 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    409e:	2384      	movs	r3, #132	; 0x84
    40a0:	fb03 4407 	mla	r4, r3, r7, r4
        rate = Unpack(data, PackLocation {8,8});
    40a4:	4632      	mov	r2, r6
        skew = Unpack(data, PackLocation {0,8});
    40a6:	6720      	str	r0, [r4, #112]	; 0x70
        rate = Unpack(data, PackLocation {8,8});
    40a8:	4631      	mov	r1, r6
    40aa:	4628      	mov	r0, r5
    40ac:	e9cd 6600 	strd	r6, r6, [sp]
    40b0:	f7ff febe 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    40b4:	66e0      	str	r0, [r4, #108]	; 0x6c
    SkewedLFO_instance[hemisphere].OnDataReceive(data);
}
    40b6:	b005      	add	sp, #20
    40b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    40ba:	bf00      	nop
    40bc:	2000193c 	.word	0x2000193c

000040c0 <Shuffle_OnDataReceive(bool, unsigned long)>:

void Shuffle_OnDataReceive(bool hemisphere, uint32_t data) {
    40c0:	b5f0      	push	{r4, r5, r6, r7, lr}
        delay[0] = Unpack(data, PackLocation {0,7});
    40c2:	2300      	movs	r3, #0
void Shuffle_OnDataReceive(bool hemisphere, uint32_t data) {
    40c4:	b085      	sub	sp, #20
        delay[0] = Unpack(data, PackLocation {0,7});
    40c6:	2607      	movs	r6, #7
    40c8:	e9cd 3602 	strd	r3, r6, [sp, #8]
void Shuffle_OnDataReceive(bool hemisphere, uint32_t data) {
    40cc:	460d      	mov	r5, r1
        delay[0] = Unpack(data, PackLocation {0,7});
    40ce:	ab04      	add	r3, sp, #16
    40d0:	e913 0006 	ldmdb	r3, {r1, r2}
void Shuffle_OnDataReceive(bool hemisphere, uint32_t data) {
    40d4:	4607      	mov	r7, r0
        delay[0] = Unpack(data, PackLocation {0,7});
    40d6:	4c0a      	ldr	r4, [pc, #40]	; (4100 <Shuffle_OnDataReceive(bool, unsigned long)+0x40>)
    40d8:	4628      	mov	r0, r5
    40da:	f7ff fea9 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    40de:	2384      	movs	r3, #132	; 0x84
    40e0:	fb03 4407 	mla	r4, r3, r7, r4
        delay[1] = Unpack(data, PackLocation {7,7});
    40e4:	4632      	mov	r2, r6
        delay[0] = Unpack(data, PackLocation {0,7});
    40e6:	f8a4 0080 	strh.w	r0, [r4, #128]	; 0x80
        delay[1] = Unpack(data, PackLocation {7,7});
    40ea:	4631      	mov	r1, r6
    40ec:	4628      	mov	r0, r5
    40ee:	e9cd 6600 	strd	r6, r6, [sp]
    40f2:	f7ff fe9d 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    40f6:	f8a4 0082 	strh.w	r0, [r4, #130]	; 0x82
    Shuffle_instance[hemisphere].OnDataReceive(data);
}
    40fa:	b005      	add	sp, #20
    40fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    40fe:	bf00      	nop
    4100:	20001834 	.word	0x20001834

00004104 <Sequence5_OnDataReceive(bool, unsigned long)>:

void Sequence5_OnDataReceive(bool hemisphere, uint32_t data) {
    4104:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    4108:	4e13      	ldr	r6, [pc, #76]	; (4158 <Sequence5_OnDataReceive(bool, unsigned long)+0x54>)
    410a:	2490      	movs	r4, #144	; 0x90
    410c:	fb04 6400 	mla	r4, r4, r0, r6
    4110:	4607      	mov	r7, r0
    4112:	4688      	mov	r8, r1
        for (int s = 0; s < 5; s++)
    4114:	3470      	adds	r4, #112	; 0x70
    Sequence5_instance[hemisphere].OnDataReceive(data);
    4116:	2500      	movs	r5, #0
            note[s] = Unpack(data, PackLocation {s * 5,5});
    4118:	f04f 0905 	mov.w	r9, #5
    411c:	f10d 0a08 	add.w	sl, sp, #8
    4120:	e9cd 5902 	strd	r5, r9, [sp, #8]
    4124:	4640      	mov	r0, r8
    4126:	e89a 0006 	ldmia.w	sl, {r1, r2}
    412a:	f7ff fe81 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        for (int s = 0; s < 5; s++)
    412e:	3505      	adds	r5, #5
    4130:	2d19      	cmp	r5, #25
            note[s] = Unpack(data, PackLocation {s * 5,5});
    4132:	f844 0f04 	str.w	r0, [r4, #4]!
        for (int s = 0; s < 5; s++)
    4136:	d1f3      	bne.n	4120 <Sequence5_OnDataReceive(bool, unsigned long)+0x1c>
        muted = Unpack(data, PackLocation {25,5});
    4138:	464a      	mov	r2, r9
    413a:	4629      	mov	r1, r5
    413c:	4640      	mov	r0, r8
    413e:	e9cd 5900 	strd	r5, r9, [sp]
    4142:	f7ff fe75 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4146:	2390      	movs	r3, #144	; 0x90
    4148:	fb03 6607 	mla	r6, r3, r7, r6
    414c:	f886 0070 	strb.w	r0, [r6, #112]	; 0x70
}
    4150:	b004      	add	sp, #16
    4152:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4156:	bf00      	nop
    4158:	200015a4 	.word	0x200015a4

0000415c <Schmitt_OnDataReceive(bool, unsigned long)>:

void Schmitt_OnDataReceive(bool hemisphere, uint32_t data) {
    415c:	b5f0      	push	{r4, r5, r6, r7, lr}
        low = Unpack(data, PackLocation {0,16});
    415e:	2300      	movs	r3, #0
void Schmitt_OnDataReceive(bool hemisphere, uint32_t data) {
    4160:	b085      	sub	sp, #20
        low = Unpack(data, PackLocation {0,16});
    4162:	2610      	movs	r6, #16
    4164:	e9cd 3602 	strd	r3, r6, [sp, #8]
void Schmitt_OnDataReceive(bool hemisphere, uint32_t data) {
    4168:	460d      	mov	r5, r1
        low = Unpack(data, PackLocation {0,16});
    416a:	eb0d 0306 	add.w	r3, sp, r6
    416e:	e913 0006 	ldmdb	r3, {r1, r2}
void Schmitt_OnDataReceive(bool hemisphere, uint32_t data) {
    4172:	4607      	mov	r7, r0
        low = Unpack(data, PackLocation {0,16});
    4174:	4c09      	ldr	r4, [pc, #36]	; (419c <Schmitt_OnDataReceive(bool, unsigned long)+0x40>)
    4176:	4628      	mov	r0, r5
    4178:	f7ff fe5a 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    417c:	237c      	movs	r3, #124	; 0x7c
    417e:	fb03 4407 	mla	r4, r3, r7, r4
        high = Unpack(data, PackLocation {16,16});
    4182:	4632      	mov	r2, r6
        low = Unpack(data, PackLocation {0,16});
    4184:	f8a4 0078 	strh.w	r0, [r4, #120]	; 0x78
        high = Unpack(data, PackLocation {16,16});
    4188:	4631      	mov	r1, r6
    418a:	4628      	mov	r0, r5
    418c:	e9cd 6600 	strd	r6, r6, [sp]
    4190:	f7ff fe4e 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4194:	f8a4 007a 	strh.w	r0, [r4, #122]	; 0x7a
    Schmitt_instance[hemisphere].OnDataReceive(data);
}
    4198:	b005      	add	sp, #20
    419a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    419c:	2000130c 	.word	0x2000130c

000041a0 <RunglBook_OnDataReceive(bool, unsigned long)>:
void RunglBook_OnDataReceive(bool hemisphere, uint32_t data) {RunglBook_instance[hemisphere].OnDataReceive(data);}
    41a0:	b513      	push	{r0, r1, r4, lr}
        threshold = Unpack(data, PackLocation {0,16});
    41a2:	2200      	movs	r2, #0
    41a4:	2310      	movs	r3, #16
    41a6:	e9cd 2300 	strd	r2, r3, [sp]
    41aa:	ab02      	add	r3, sp, #8
void RunglBook_OnDataReceive(bool hemisphere, uint32_t data) {RunglBook_instance[hemisphere].OnDataReceive(data);}
    41ac:	4604      	mov	r4, r0
    41ae:	4608      	mov	r0, r1
        threshold = Unpack(data, PackLocation {0,16});
    41b0:	e913 0006 	ldmdb	r3, {r1, r2}
    41b4:	f7ff fe3c 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    41b8:	4b03      	ldr	r3, [pc, #12]	; (41c8 <RunglBook_OnDataReceive(bool, unsigned long)+0x28>)
    41ba:	2270      	movs	r2, #112	; 0x70
    41bc:	fb02 3304 	mla	r3, r2, r4, r3
    41c0:	f8a3 006e 	strh.w	r0, [r3, #110]	; 0x6e
void RunglBook_OnDataReceive(bool hemisphere, uint32_t data) {RunglBook_instance[hemisphere].OnDataReceive(data);}
    41c4:	b002      	add	sp, #8
    41c6:	bd10      	pop	{r4, pc}
    41c8:	20000ecc 	.word	0x20000ecc

000041cc <Palimpsest_OnDataReceive(bool, unsigned long)>:

void Palimpsest_OnDataReceive(bool hemisphere, uint32_t data) {
    41cc:	b5f0      	push	{r4, r5, r6, r7, lr}
        compose = Unpack(data, PackLocation {0,7});
    41ce:	2300      	movs	r3, #0
void Palimpsest_OnDataReceive(bool hemisphere, uint32_t data) {
    41d0:	b087      	sub	sp, #28
        compose = Unpack(data, PackLocation {0,7});
    41d2:	2607      	movs	r6, #7
    41d4:	e9cd 3604 	strd	r3, r6, [sp, #16]
void Palimpsest_OnDataReceive(bool hemisphere, uint32_t data) {
    41d8:	460d      	mov	r5, r1
        compose = Unpack(data, PackLocation {0,7});
    41da:	ab06      	add	r3, sp, #24
    41dc:	e913 0006 	ldmdb	r3, {r1, r2}
void Palimpsest_OnDataReceive(bool hemisphere, uint32_t data) {
    41e0:	4607      	mov	r7, r0
        compose = Unpack(data, PackLocation {0,7});
    41e2:	4c10      	ldr	r4, [pc, #64]	; (4224 <Palimpsest_OnDataReceive(bool, unsigned long)+0x58>)
    41e4:	4628      	mov	r0, r5
    41e6:	f7ff fe23 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    41ea:	23cc      	movs	r3, #204	; 0xcc
    41ec:	fb03 4407 	mla	r4, r3, r7, r4
        decompose = Unpack(data, PackLocation {7,7});
    41f0:	4632      	mov	r2, r6
        compose = Unpack(data, PackLocation {0,7});
    41f2:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4
        decompose = Unpack(data, PackLocation {7,7});
    41f6:	4631      	mov	r1, r6
    41f8:	4628      	mov	r0, r5
    41fa:	e9cd 6602 	strd	r6, r6, [sp, #8]
    41fe:	f7ff fe17 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        length = Unpack(data, PackLocation {14,4}) + 1;
    4202:	2304      	movs	r3, #4
    4204:	220e      	movs	r2, #14
    4206:	e9cd 2300 	strd	r2, r3, [sp]
        decompose = Unpack(data, PackLocation {7,7});
    420a:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
        length = Unpack(data, PackLocation {14,4}) + 1;
    420e:	461a      	mov	r2, r3
    4210:	210e      	movs	r1, #14
    4212:	4628      	mov	r0, r5
    4214:	f7ff fe0c 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4218:	3001      	adds	r0, #1
    421a:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
    Palimpsest_instance[hemisphere].OnDataReceive(data);
}
    421e:	b007      	add	sp, #28
    4220:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4222:	bf00      	nop
    4224:	20000d34 	.word	0x20000d34

00004228 <MixerBal_OnDataReceive(bool, unsigned long)>:

void MixerBal_OnDataReceive(bool hemisphere, uint32_t data) {
    4228:	b513      	push	{r0, r1, r4, lr}
        balance = Unpack(data, PackLocation {0,8});
    422a:	2200      	movs	r2, #0
    422c:	2308      	movs	r3, #8
    422e:	e9cd 2300 	strd	r2, r3, [sp]
    4232:	446b      	add	r3, sp
void MixerBal_OnDataReceive(bool hemisphere, uint32_t data) {
    4234:	4604      	mov	r4, r0
    4236:	4608      	mov	r0, r1
        balance = Unpack(data, PackLocation {0,8});
    4238:	e913 0006 	ldmdb	r3, {r1, r2}
    423c:	f7ff fdf8 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4240:	4b03      	ldr	r3, [pc, #12]	; (4250 <MixerBal_OnDataReceive(bool, unsigned long)+0x28>)
    4242:	2274      	movs	r2, #116	; 0x74
    4244:	fb02 3304 	mla	r3, r2, r4, r3
    4248:	6718      	str	r0, [r3, #112]	; 0x70
    MixerBal_instance[hemisphere].OnDataReceive(data);
}
    424a:	b002      	add	sp, #8
    424c:	bd10      	pop	{r4, pc}
    424e:	bf00      	nop
    4250:	200004a4 	.word	0x200004a4

00004254 <LowerRenz_OnDataReceive(bool, unsigned long)>:

void LowerRenz_OnDataReceive(bool hemisphere, uint32_t data) {
    4254:	b5f0      	push	{r4, r5, r6, r7, lr}
        freq = Unpack(data, PackLocation {0,8});
    4256:	2300      	movs	r3, #0
void LowerRenz_OnDataReceive(bool hemisphere, uint32_t data) {
    4258:	b085      	sub	sp, #20
        freq = Unpack(data, PackLocation {0,8});
    425a:	2608      	movs	r6, #8
    425c:	e9cd 3602 	strd	r3, r6, [sp, #8]
void LowerRenz_OnDataReceive(bool hemisphere, uint32_t data) {
    4260:	460d      	mov	r5, r1
        freq = Unpack(data, PackLocation {0,8});
    4262:	ab04      	add	r3, sp, #16
    4264:	e913 0006 	ldmdb	r3, {r1, r2}
void LowerRenz_OnDataReceive(bool hemisphere, uint32_t data) {
    4268:	4607      	mov	r7, r0
        freq = Unpack(data, PackLocation {0,8});
    426a:	4c09      	ldr	r4, [pc, #36]	; (4290 <LowerRenz_OnDataReceive(bool, unsigned long)+0x3c>)
    426c:	4628      	mov	r0, r5
    426e:	f7ff fddf 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4272:	237c      	movs	r3, #124	; 0x7c
    4274:	fb03 4407 	mla	r4, r3, r7, r4
        rho = Unpack(data, PackLocation {8,8});
    4278:	4632      	mov	r2, r6
        freq = Unpack(data, PackLocation {0,8});
    427a:	6720      	str	r0, [r4, #112]	; 0x70
        rho = Unpack(data, PackLocation {8,8});
    427c:	4631      	mov	r1, r6
    427e:	4628      	mov	r0, r5
    4280:	e9cd 6600 	strd	r6, r6, [sp]
    4284:	f7ff fdd4 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4288:	6760      	str	r0, [r4, #116]	; 0x74
    LowerRenz_instance[hemisphere].OnDataReceive(data);
}
    428a:	b005      	add	sp, #20
    428c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    428e:	bf00      	nop
    4290:	200002c4 	.word	0x200002c4

00004294 <Logic_OnDataReceive(bool, unsigned long)>:

void Logic_OnDataReceive(bool hemisphere, uint32_t data) {
    4294:	b5f0      	push	{r4, r5, r6, r7, lr}
        operation[0] = Unpack(data, PackLocation {0, 8});
    4296:	2300      	movs	r3, #0
void Logic_OnDataReceive(bool hemisphere, uint32_t data) {
    4298:	b085      	sub	sp, #20
        operation[0] = Unpack(data, PackLocation {0, 8});
    429a:	2608      	movs	r6, #8
    429c:	e9cd 3602 	strd	r3, r6, [sp, #8]
void Logic_OnDataReceive(bool hemisphere, uint32_t data) {
    42a0:	460d      	mov	r5, r1
        operation[0] = Unpack(data, PackLocation {0, 8});
    42a2:	ab04      	add	r3, sp, #16
    42a4:	e913 0006 	ldmdb	r3, {r1, r2}
void Logic_OnDataReceive(bool hemisphere, uint32_t data) {
    42a8:	4607      	mov	r7, r0
        operation[0] = Unpack(data, PackLocation {0, 8});
    42aa:	4c0a      	ldr	r4, [pc, #40]	; (42d4 <Logic_OnDataReceive(bool, unsigned long)+0x40>)
    42ac:	4628      	mov	r0, r5
    42ae:	f7ff fdbf 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    42b2:	23bc      	movs	r3, #188	; 0xbc
    42b4:	fb03 4407 	mla	r4, r3, r7, r4
        operation[1] = Unpack(data, PackLocation {8, 8});
    42b8:	4632      	mov	r2, r6
        operation[0] = Unpack(data, PackLocation {0, 8});
    42ba:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
        operation[1] = Unpack(data, PackLocation {8, 8});
    42be:	4631      	mov	r1, r6
    42c0:	4628      	mov	r0, r5
    42c2:	e9cd 6600 	strd	r6, r6, [sp]
    42c6:	f7ff fdb3 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    42ca:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
    Logic_instance[hemisphere].OnDataReceive(data);
}
    42ce:	b005      	add	sp, #20
    42d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    42d2:	bf00      	nop
    42d4:	2000014c 	.word	0x2000014c

000042d8 <GateDelay_OnDataReceive(bool, unsigned long)>:

void GateDelay_OnDataReceive(bool hemisphere, uint32_t data) {
    42d8:	b5f0      	push	{r4, r5, r6, r7, lr}
        time[0] = Unpack(data, PackLocation {0,11});
    42da:	2300      	movs	r3, #0
void GateDelay_OnDataReceive(bool hemisphere, uint32_t data) {
    42dc:	b085      	sub	sp, #20
        time[0] = Unpack(data, PackLocation {0,11});
    42de:	260b      	movs	r6, #11
    42e0:	e9cd 3602 	strd	r3, r6, [sp, #8]
void GateDelay_OnDataReceive(bool hemisphere, uint32_t data) {
    42e4:	460d      	mov	r5, r1
        time[0] = Unpack(data, PackLocation {0,11});
    42e6:	ab04      	add	r3, sp, #16
    42e8:	e913 0006 	ldmdb	r3, {r1, r2}
void GateDelay_OnDataReceive(bool hemisphere, uint32_t data) {
    42ec:	4607      	mov	r7, r0
        time[0] = Unpack(data, PackLocation {0,11});
    42ee:	4c0a      	ldr	r4, [pc, #40]	; (4318 <GateDelay_OnDataReceive(bool, unsigned long)+0x40>)
    42f0:	4628      	mov	r0, r5
    42f2:	f7ff fd9d 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    42f6:	f44f 7321 	mov.w	r3, #644	; 0x284
    42fa:	fb03 4407 	mla	r4, r3, r7, r4
        time[1] = Unpack(data, PackLocation {11,11});
    42fe:	4632      	mov	r2, r6
        time[0] = Unpack(data, PackLocation {0,11});
    4300:	f8c4 026c 	str.w	r0, [r4, #620]	; 0x26c
        time[1] = Unpack(data, PackLocation {11,11});
    4304:	4631      	mov	r1, r6
    4306:	4628      	mov	r0, r5
    4308:	e9cd 6600 	strd	r6, r6, [sp]
    430c:	f7ff fd90 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4310:	f8c4 0270 	str.w	r0, [r4, #624]	; 0x270
    GateDelay_instance[hemisphere].OnDataReceive(data);
}
    4314:	b005      	add	sp, #20
    4316:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4318:	1fffea60 	.word	0x1fffea60

0000431c <EnvFollow_OnDataReceive(bool, unsigned long)>:
uint32_t EnvFollow_OnDataRequest(bool hemisphere) {return EnvFollow_instance[hemisphere].OnDataRequest();}
void EnvFollow_OnDataReceive(bool hemisphere, uint32_t data) {EnvFollow_instance[hemisphere].OnDataReceive(data);}
    431c:	b5f0      	push	{r4, r5, r6, r7, lr}
        gain[0] = Unpack(data, PackLocation {0,5});
    431e:	2300      	movs	r3, #0
void EnvFollow_OnDataReceive(bool hemisphere, uint32_t data) {EnvFollow_instance[hemisphere].OnDataReceive(data);}
    4320:	b089      	sub	sp, #36	; 0x24
        gain[0] = Unpack(data, PackLocation {0,5});
    4322:	2605      	movs	r6, #5
    4324:	e9cd 3606 	strd	r3, r6, [sp, #24]
void EnvFollow_OnDataReceive(bool hemisphere, uint32_t data) {EnvFollow_instance[hemisphere].OnDataReceive(data);}
    4328:	460d      	mov	r5, r1
        gain[0] = Unpack(data, PackLocation {0,5});
    432a:	ab08      	add	r3, sp, #32
    432c:	e913 0006 	ldmdb	r3, {r1, r2}
void EnvFollow_OnDataReceive(bool hemisphere, uint32_t data) {EnvFollow_instance[hemisphere].OnDataReceive(data);}
    4330:	4607      	mov	r7, r0
        gain[0] = Unpack(data, PackLocation {0,5});
    4332:	4c17      	ldr	r4, [pc, #92]	; (4390 <EnvFollow_OnDataReceive(bool, unsigned long)+0x74>)
    4334:	4628      	mov	r0, r5
    4336:	f7ff fd7b 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    433a:	2390      	movs	r3, #144	; 0x90
    433c:	fb03 4407 	mla	r4, r3, r7, r4
        gain[1] = Unpack(data, PackLocation {5,5});
    4340:	4632      	mov	r2, r6
        gain[0] = Unpack(data, PackLocation {0,5});
    4342:	f884 008c 	strb.w	r0, [r4, #140]	; 0x8c
        gain[1] = Unpack(data, PackLocation {5,5});
    4346:	4631      	mov	r1, r6
    4348:	4628      	mov	r0, r5
    434a:	e9cd 6604 	strd	r6, r6, [sp, #16]
    434e:	f7ff fd6f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        duck[0] = Unpack(data, PackLocation {10,1});
    4352:	2601      	movs	r6, #1
    4354:	230a      	movs	r3, #10
        gain[1] = Unpack(data, PackLocation {5,5});
    4356:	f884 008d 	strb.w	r0, [r4, #141]	; 0x8d
        duck[0] = Unpack(data, PackLocation {10,1});
    435a:	4632      	mov	r2, r6
    435c:	4619      	mov	r1, r3
    435e:	4628      	mov	r0, r5
    4360:	e9cd 3602 	strd	r3, r6, [sp, #8]
    4364:	f7ff fd64 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4368:	3800      	subs	r0, #0
    436a:	bf18      	it	ne
    436c:	2001      	movne	r0, #1
        duck[1] = Unpack(data, PackLocation {11,1});
    436e:	230b      	movs	r3, #11
        duck[0] = Unpack(data, PackLocation {10,1});
    4370:	f884 008e 	strb.w	r0, [r4, #142]	; 0x8e
        duck[1] = Unpack(data, PackLocation {11,1});
    4374:	4632      	mov	r2, r6
    4376:	4619      	mov	r1, r3
    4378:	4628      	mov	r0, r5
    437a:	e9cd 3600 	strd	r3, r6, [sp]
    437e:	f7ff fd57 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4382:	3800      	subs	r0, #0
    4384:	bf18      	it	ne
    4386:	2001      	movne	r0, #1
    4388:	f884 008f 	strb.w	r0, [r4, #143]	; 0x8f
void EnvFollow_OnDataReceive(bool hemisphere, uint32_t data) {EnvFollow_instance[hemisphere].OnDataReceive(data);}
    438c:	b009      	add	sp, #36	; 0x24
    438e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4390:	1fffe940 	.word	0x1fffe940

00004394 <Compare_OnDataReceive(bool, unsigned long)>:

void Compare_OnDataReceive(bool hemisphere, uint32_t data) {
    4394:	b513      	push	{r0, r1, r4, lr}
        level = Unpack(data, PackLocation {0,8});
    4396:	2200      	movs	r2, #0
    4398:	2308      	movs	r3, #8
    439a:	e9cd 2300 	strd	r2, r3, [sp]
    439e:	446b      	add	r3, sp
void Compare_OnDataReceive(bool hemisphere, uint32_t data) {
    43a0:	4604      	mov	r4, r0
    43a2:	4608      	mov	r0, r1
        level = Unpack(data, PackLocation {0,8});
    43a4:	e913 0006 	ldmdb	r3, {r1, r2}
    43a8:	f7ff fd42 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    43ac:	4b03      	ldr	r3, [pc, #12]	; (43bc <Compare_OnDataReceive(bool, unsigned long)+0x28>)
    43ae:	2278      	movs	r2, #120	; 0x78
    43b0:	fb02 3304 	mla	r3, r2, r4, r3
    43b4:	66d8      	str	r0, [r3, #108]	; 0x6c
    Compare_instance[hemisphere].OnDataReceive(data);
}
    43b6:	b002      	add	sp, #8
    43b8:	bd10      	pop	{r4, pc}
    43ba:	bf00      	nop
    43bc:	1fffcbbc 	.word	0x1fffcbbc

000043c0 <ClockSkip_OnDataReceive(bool, unsigned long)>:

void ClockSkip_OnDataReceive(bool hemisphere, uint32_t data) {
    43c0:	b5f0      	push	{r4, r5, r6, r7, lr}
        p[0] = Unpack(data, PackLocation {0,7});
    43c2:	2300      	movs	r3, #0
void ClockSkip_OnDataReceive(bool hemisphere, uint32_t data) {
    43c4:	b085      	sub	sp, #20
        p[0] = Unpack(data, PackLocation {0,7});
    43c6:	2607      	movs	r6, #7
    43c8:	e9cd 3602 	strd	r3, r6, [sp, #8]
void ClockSkip_OnDataReceive(bool hemisphere, uint32_t data) {
    43cc:	460d      	mov	r5, r1
        p[0] = Unpack(data, PackLocation {0,7});
    43ce:	ab04      	add	r3, sp, #16
    43d0:	e913 0006 	ldmdb	r3, {r1, r2}
void ClockSkip_OnDataReceive(bool hemisphere, uint32_t data) {
    43d4:	4607      	mov	r7, r0
        p[0] = Unpack(data, PackLocation {0,7});
    43d6:	4c0a      	ldr	r4, [pc, #40]	; (4400 <ClockSkip_OnDataReceive(bool, unsigned long)+0x40>)
    43d8:	4628      	mov	r0, r5
    43da:	f7ff fd29 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    43de:	237c      	movs	r3, #124	; 0x7c
    43e0:	fb03 4407 	mla	r4, r3, r7, r4
        p[1] = Unpack(data, PackLocation {7,7});
    43e4:	4632      	mov	r2, r6
        p[0] = Unpack(data, PackLocation {0,7});
    43e6:	f8a4 006c 	strh.w	r0, [r4, #108]	; 0x6c
        p[1] = Unpack(data, PackLocation {7,7});
    43ea:	4631      	mov	r1, r6
    43ec:	4628      	mov	r0, r5
    43ee:	e9cd 6600 	strd	r6, r6, [sp]
    43f2:	f7ff fd1d 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    43f6:	f8a4 006e 	strh.w	r0, [r4, #110]	; 0x6e
    ClockSkip_instance[hemisphere].OnDataReceive(data);
}
    43fa:	b005      	add	sp, #20
    43fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    43fe:	bf00      	nop
    4400:	1fffcac4 	.word	0x1fffcac4

00004404 <ClockDivider_OnDataReceive(bool, unsigned long)>:

void ClockDivider_OnDataReceive(bool hemisphere, uint32_t data) {
    4404:	b5f0      	push	{r4, r5, r6, r7, lr}
        div[0] = Unpack(data, PackLocation {0,8}) - 32;
    4406:	2300      	movs	r3, #0
void ClockDivider_OnDataReceive(bool hemisphere, uint32_t data) {
    4408:	b085      	sub	sp, #20
        div[0] = Unpack(data, PackLocation {0,8}) - 32;
    440a:	2608      	movs	r6, #8
    440c:	e9cd 3602 	strd	r3, r6, [sp, #8]
void ClockDivider_OnDataReceive(bool hemisphere, uint32_t data) {
    4410:	460d      	mov	r5, r1
        div[0] = Unpack(data, PackLocation {0,8}) - 32;
    4412:	ab04      	add	r3, sp, #16
    4414:	e913 0006 	ldmdb	r3, {r1, r2}
void ClockDivider_OnDataReceive(bool hemisphere, uint32_t data) {
    4418:	4607      	mov	r7, r0
        div[0] = Unpack(data, PackLocation {0,8}) - 32;
    441a:	4628      	mov	r0, r5
    441c:	f7ff fd08 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4420:	4c08      	ldr	r4, [pc, #32]	; (4444 <ClockDivider_OnDataReceive(bool, unsigned long)+0x40>)
    4422:	238c      	movs	r3, #140	; 0x8c
    4424:	fb03 4407 	mla	r4, r3, r7, r4
    4428:	3820      	subs	r0, #32
    442a:	66e0      	str	r0, [r4, #108]	; 0x6c
        div[1] = Unpack(data, PackLocation {8,8}) - 32;
    442c:	4632      	mov	r2, r6
    442e:	4631      	mov	r1, r6
    4430:	4628      	mov	r0, r5
    4432:	e9cd 6600 	strd	r6, r6, [sp]
    4436:	f7ff fcfb 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    443a:	3820      	subs	r0, #32
    443c:	6720      	str	r0, [r4, #112]	; 0x70
    ClockDivider_instance[hemisphere].OnDataReceive(data);
}
    443e:	b005      	add	sp, #20
    4440:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4442:	bf00      	nop
    4444:	1fffc938 	.word	0x1fffc938

00004448 <Calculate_OnDataReceive(bool, unsigned long)>:

void Calculate_OnDataReceive(bool hemisphere, uint32_t data) {
    4448:	b5f0      	push	{r4, r5, r6, r7, lr}
        operation[0] = Unpack(data, PackLocation {0, 8});
    444a:	2300      	movs	r3, #0
void Calculate_OnDataReceive(bool hemisphere, uint32_t data) {
    444c:	b085      	sub	sp, #20
        operation[0] = Unpack(data, PackLocation {0, 8});
    444e:	2608      	movs	r6, #8
    4450:	e9cd 3602 	strd	r3, r6, [sp, #8]
void Calculate_OnDataReceive(bool hemisphere, uint32_t data) {
    4454:	460d      	mov	r5, r1
        operation[0] = Unpack(data, PackLocation {0, 8});
    4456:	ab04      	add	r3, sp, #16
    4458:	e913 0006 	ldmdb	r3, {r1, r2}
void Calculate_OnDataReceive(bool hemisphere, uint32_t data) {
    445c:	4607      	mov	r7, r0
        operation[0] = Unpack(data, PackLocation {0, 8});
    445e:	4c0a      	ldr	r4, [pc, #40]	; (4488 <Calculate_OnDataReceive(bool, unsigned long)+0x40>)
    4460:	4628      	mov	r0, r5
    4462:	f7ff fce5 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4466:	23bc      	movs	r3, #188	; 0xbc
    4468:	fb03 4407 	mla	r4, r3, r7, r4
        operation[1] = Unpack(data, PackLocation {8, 8});
    446c:	4632      	mov	r2, r6
        operation[0] = Unpack(data, PackLocation {0, 8});
    446e:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
        operation[1] = Unpack(data, PackLocation {8, 8});
    4472:	4631      	mov	r1, r6
    4474:	4628      	mov	r0, r5
    4476:	e9cd 6600 	strd	r6, r6, [sp]
    447a:	f7ff fcd9 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    447e:	f8c4 00b0 	str.w	r0, [r4, #176]	; 0xb0
    Calculate_instance[hemisphere].OnDataReceive(data);
}
    4482:	b005      	add	sp, #20
    4484:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4486:	bf00      	nop
    4488:	1fffc670 	.word	0x1fffc670

0000448c <CVRecV2_OnDataReceive(bool, unsigned long)>:
void CVRecV2_OnDataReceive(bool hemisphere, uint32_t data) {CVRecV2_instance[hemisphere].OnDataReceive(data);}
    448c:	b5f0      	push	{r4, r5, r6, r7, lr}
        start = Unpack(data, PackLocation {0,9});
    448e:	2300      	movs	r3, #0
void CVRecV2_OnDataReceive(bool hemisphere, uint32_t data) {CVRecV2_instance[hemisphere].OnDataReceive(data);}
    4490:	b087      	sub	sp, #28
        start = Unpack(data, PackLocation {0,9});
    4492:	2609      	movs	r6, #9
    4494:	e9cd 3604 	strd	r3, r6, [sp, #16]
void CVRecV2_OnDataReceive(bool hemisphere, uint32_t data) {CVRecV2_instance[hemisphere].OnDataReceive(data);}
    4498:	460d      	mov	r5, r1
        start = Unpack(data, PackLocation {0,9});
    449a:	ab06      	add	r3, sp, #24
    449c:	e913 0006 	ldmdb	r3, {r1, r2}
void CVRecV2_OnDataReceive(bool hemisphere, uint32_t data) {CVRecV2_instance[hemisphere].OnDataReceive(data);}
    44a0:	4607      	mov	r7, r0
        start = Unpack(data, PackLocation {0,9});
    44a2:	4c11      	ldr	r4, [pc, #68]	; (44e8 <CVRecV2_OnDataReceive(bool, unsigned long)+0x5c>)
    44a4:	4628      	mov	r0, r5
    44a6:	f7ff fcc3 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    44aa:	f240 63fc 	movw	r3, #1788	; 0x6fc
    44ae:	fb03 4407 	mla	r4, r3, r7, r4
        end = Unpack(data, PackLocation {9,9});
    44b2:	4632      	mov	r2, r6
        start = Unpack(data, PackLocation {0,9});
    44b4:	f8a4 06f4 	strh.w	r0, [r4, #1780]	; 0x6f4
        end = Unpack(data, PackLocation {9,9});
    44b8:	4631      	mov	r1, r6
    44ba:	4628      	mov	r0, r5
    44bc:	e9cd 6602 	strd	r6, r6, [sp, #8]
    44c0:	f7ff fcb6 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        smooth = Unpack(data, PackLocation {18,1});
    44c4:	2301      	movs	r3, #1
    44c6:	2212      	movs	r2, #18
    44c8:	e9cd 2300 	strd	r2, r3, [sp]
        end = Unpack(data, PackLocation {9,9});
    44cc:	f8a4 06f6 	strh.w	r0, [r4, #1782]	; 0x6f6
        smooth = Unpack(data, PackLocation {18,1});
    44d0:	461a      	mov	r2, r3
    44d2:	2112      	movs	r1, #18
    44d4:	4628      	mov	r0, r5
    44d6:	f7ff fcab 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    44da:	3800      	subs	r0, #0
    44dc:	bf18      	it	ne
    44de:	2001      	movne	r0, #1
    44e0:	f884 06ec 	strb.w	r0, [r4, #1772]	; 0x6ec
void CVRecV2_OnDataReceive(bool hemisphere, uint32_t data) {CVRecV2_instance[hemisphere].OnDataReceive(data);}
    44e4:	b007      	add	sp, #28
    44e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    44e8:	1fffb878 	.word	0x1fffb878

000044ec <Burst_OnDataReceive(bool, unsigned long)>:

void Burst_OnDataReceive(bool hemisphere, uint32_t data) {
    44ec:	b5f0      	push	{r4, r5, r6, r7, lr}
        number = Unpack(data, PackLocation {0,8});
    44ee:	2300      	movs	r3, #0
void Burst_OnDataReceive(bool hemisphere, uint32_t data) {
    44f0:	b087      	sub	sp, #28
        number = Unpack(data, PackLocation {0,8});
    44f2:	2608      	movs	r6, #8
    44f4:	e9cd 3604 	strd	r3, r6, [sp, #16]
void Burst_OnDataReceive(bool hemisphere, uint32_t data) {
    44f8:	460d      	mov	r5, r1
        number = Unpack(data, PackLocation {0,8});
    44fa:	ab06      	add	r3, sp, #24
    44fc:	e913 0006 	ldmdb	r3, {r1, r2}
void Burst_OnDataReceive(bool hemisphere, uint32_t data) {
    4500:	4607      	mov	r7, r0
        number = Unpack(data, PackLocation {0,8});
    4502:	4c0f      	ldr	r4, [pc, #60]	; (4540 <Burst_OnDataReceive(bool, unsigned long)+0x54>)
    4504:	4628      	mov	r0, r5
    4506:	f7ff fc93 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    450a:	2390      	movs	r3, #144	; 0x90
    450c:	fb03 4407 	mla	r4, r3, r7, r4
        spacing = Unpack(data, PackLocation {8,8});
    4510:	4632      	mov	r2, r6
        number = Unpack(data, PackLocation {0,8});
    4512:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
        spacing = Unpack(data, PackLocation {8,8});
    4516:	4631      	mov	r1, r6
    4518:	4628      	mov	r0, r5
    451a:	e9cd 6602 	strd	r6, r6, [sp, #8]
    451e:	f7ff fc87 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        div = Unpack(data, PackLocation {16,8}) - 8;
    4522:	2310      	movs	r3, #16
        spacing = Unpack(data, PackLocation {8,8});
    4524:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
        div = Unpack(data, PackLocation {16,8}) - 8;
    4528:	4632      	mov	r2, r6
    452a:	4619      	mov	r1, r3
    452c:	4628      	mov	r0, r5
    452e:	e9cd 3600 	strd	r3, r6, [sp]
    4532:	f7ff fc7d 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4536:	3808      	subs	r0, #8
    4538:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    Burst_instance[hemisphere].OnDataReceive(data);
}
    453c:	b007      	add	sp, #28
    453e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4540:	1fffb750 	.word	0x1fffb750

00004544 <Brancher_OnDataReceive(bool, unsigned long)>:

void Brancher_OnDataReceive(bool hemisphere, uint32_t data) {
    4544:	b513      	push	{r0, r1, r4, lr}
        p = Unpack(data, PackLocation {0,7});
    4546:	2200      	movs	r2, #0
    4548:	2307      	movs	r3, #7
    454a:	e9cd 2300 	strd	r2, r3, [sp]
    454e:	ab02      	add	r3, sp, #8
void Brancher_OnDataReceive(bool hemisphere, uint32_t data) {
    4550:	4604      	mov	r4, r0
    4552:	4608      	mov	r0, r1
        p = Unpack(data, PackLocation {0,7});
    4554:	e913 0006 	ldmdb	r3, {r1, r2}
    4558:	f7ff fc6a 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    455c:	4b03      	ldr	r3, [pc, #12]	; (456c <Brancher_OnDataReceive(bool, unsigned long)+0x28>)
    455e:	2274      	movs	r2, #116	; 0x74
    4560:	fb02 3304 	mla	r3, r2, r4, r3
    4564:	66d8      	str	r0, [r3, #108]	; 0x6c
    Brancher_instance[hemisphere].OnDataReceive(data);
}
    4566:	b002      	add	sp, #8
    4568:	bd10      	pop	{r4, pc}
    456a:	bf00      	nop
    456c:	1fffb668 	.word	0x1fffb668

00004570 <AttenuateOffset_OnDataReceive(bool, unsigned long)>:
void AttenuateOffset_OnDataReceive(bool hemisphere, uint32_t data) {AttenuateOffset_instance[hemisphere].OnDataReceive(data);}
    4570:	b5f0      	push	{r4, r5, r6, r7, lr}
        offset[0] = Unpack(data, PackLocation {0,9}) - 256;
    4572:	2300      	movs	r3, #0
void AttenuateOffset_OnDataReceive(bool hemisphere, uint32_t data) {AttenuateOffset_instance[hemisphere].OnDataReceive(data);}
    4574:	b089      	sub	sp, #36	; 0x24
        offset[0] = Unpack(data, PackLocation {0,9}) - 256;
    4576:	2709      	movs	r7, #9
    4578:	e9cd 3706 	strd	r3, r7, [sp, #24]
void AttenuateOffset_OnDataReceive(bool hemisphere, uint32_t data) {AttenuateOffset_instance[hemisphere].OnDataReceive(data);}
    457c:	460d      	mov	r5, r1
        offset[0] = Unpack(data, PackLocation {0,9}) - 256;
    457e:	ab08      	add	r3, sp, #32
    4580:	e913 0006 	ldmdb	r3, {r1, r2}
void AttenuateOffset_OnDataReceive(bool hemisphere, uint32_t data) {AttenuateOffset_instance[hemisphere].OnDataReceive(data);}
    4584:	4606      	mov	r6, r0
        offset[0] = Unpack(data, PackLocation {0,9}) - 256;
    4586:	4628      	mov	r0, r5
    4588:	f7ff fc52 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    458c:	4c12      	ldr	r4, [pc, #72]	; (45d8 <AttenuateOffset_OnDataReceive(bool, unsigned long)+0x68>)
    458e:	eb04 14c6 	add.w	r4, r4, r6, lsl #7
        offset[1] = Unpack(data, PackLocation {10,9}) - 256;
    4592:	230a      	movs	r3, #10
        offset[0] = Unpack(data, PackLocation {0,9}) - 256;
    4594:	f5a0 7080 	sub.w	r0, r0, #256	; 0x100
    4598:	67a0      	str	r0, [r4, #120]	; 0x78
        offset[1] = Unpack(data, PackLocation {10,9}) - 256;
    459a:	463a      	mov	r2, r7
    459c:	4619      	mov	r1, r3
    459e:	4628      	mov	r0, r5
    45a0:	e9cd 3704 	strd	r3, r7, [sp, #16]
    45a4:	f7ff fc44 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        level[0] = Unpack(data, PackLocation {19,6});
    45a8:	2606      	movs	r6, #6
    45aa:	2313      	movs	r3, #19
        offset[1] = Unpack(data, PackLocation {10,9}) - 256;
    45ac:	f5a0 7080 	sub.w	r0, r0, #256	; 0x100
    45b0:	67e0      	str	r0, [r4, #124]	; 0x7c
        level[0] = Unpack(data, PackLocation {19,6});
    45b2:	4632      	mov	r2, r6
    45b4:	4619      	mov	r1, r3
    45b6:	4628      	mov	r0, r5
    45b8:	e9cd 3602 	strd	r3, r6, [sp, #8]
    45bc:	f7ff fc38 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        level[1] = Unpack(data, PackLocation {25,6});
    45c0:	2319      	movs	r3, #25
        level[0] = Unpack(data, PackLocation {19,6});
    45c2:	6720      	str	r0, [r4, #112]	; 0x70
        level[1] = Unpack(data, PackLocation {25,6});
    45c4:	4632      	mov	r2, r6
    45c6:	4619      	mov	r1, r3
    45c8:	4628      	mov	r0, r5
    45ca:	e9cd 3600 	strd	r3, r6, [sp]
    45ce:	f7ff fc2f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    45d2:	6760      	str	r0, [r4, #116]	; 0x74
void AttenuateOffset_OnDataReceive(bool hemisphere, uint32_t data) {AttenuateOffset_instance[hemisphere].OnDataReceive(data);}
    45d4:	b009      	add	sp, #36	; 0x24
    45d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    45d8:	1fffb0c0 	.word	0x1fffb0c0

000045dc <ASR_OnDataReceive(bool, unsigned long)>:
void ASR_OnDataReceive(bool hemisphere, uint32_t data) {ASR_instance[hemisphere].OnDataReceive(data);}
    45dc:	b5f0      	push	{r4, r5, r6, r7, lr}
        buffer_m->SetIndex(Unpack(data, PackLocation {0,8}));
    45de:	4c0f      	ldr	r4, [pc, #60]	; (461c <ASR_OnDataReceive(bool, unsigned long)+0x40>)
    45e0:	f44f 73da 	mov.w	r3, #436	; 0x1b4
void ASR_OnDataReceive(bool hemisphere, uint32_t data) {ASR_instance[hemisphere].OnDataReceive(data);}
    45e4:	b085      	sub	sp, #20
        buffer_m->SetIndex(Unpack(data, PackLocation {0,8}));
    45e6:	fb03 4400 	mla	r4, r3, r0, r4
    45ea:	2608      	movs	r6, #8
    45ec:	2300      	movs	r3, #0
    45ee:	e9cd 3602 	strd	r3, r6, [sp, #8]
void ASR_OnDataReceive(bool hemisphere, uint32_t data) {ASR_instance[hemisphere].OnDataReceive(data);}
    45f2:	460d      	mov	r5, r1
        buffer_m->SetIndex(Unpack(data, PackLocation {0,8}));
    45f4:	ab04      	add	r3, sp, #16
    45f6:	e913 0006 	ldmdb	r3, {r1, r2}
    45fa:	4628      	mov	r0, r5
    45fc:	f7ff fc18 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4600:	6f27      	ldr	r7, [r4, #112]	; 0x70
        scale = Unpack(data, PackLocation {8,8});
    4602:	4632      	mov	r2, r6
        buffer_m->SetIndex(Unpack(data, PackLocation {0,8}));
    4604:	f887 0401 	strb.w	r0, [r7, #1025]	; 0x401
        scale = Unpack(data, PackLocation {8,8});
    4608:	4631      	mov	r1, r6
    460a:	4628      	mov	r0, r5
    460c:	e9cd 6600 	strd	r6, r6, [sp]
    4610:	f7ff fc0e 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4614:	f8c4 01ac 	str.w	r0, [r4, #428]	; 0x1ac
void ASR_OnDataReceive(bool hemisphere, uint32_t data) {ASR_instance[hemisphere].OnDataReceive(data);}
    4618:	b005      	add	sp, #20
    461a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    461c:	1fffab30 	.word	0x1fffab30

00004620 <ADEG_OnDataReceive(bool, unsigned long)>:
void ADEG_OnDataReceive(bool hemisphere, uint32_t data) {ADEG_instance[hemisphere].OnDataReceive(data);}
    4620:	b5f0      	push	{r4, r5, r6, r7, lr}
        attack = Unpack(data, PackLocation {0,8});
    4622:	2300      	movs	r3, #0
void ADEG_OnDataReceive(bool hemisphere, uint32_t data) {ADEG_instance[hemisphere].OnDataReceive(data);}
    4624:	b085      	sub	sp, #20
        attack = Unpack(data, PackLocation {0,8});
    4626:	2608      	movs	r6, #8
    4628:	e9cd 3602 	strd	r3, r6, [sp, #8]
void ADEG_OnDataReceive(bool hemisphere, uint32_t data) {ADEG_instance[hemisphere].OnDataReceive(data);}
    462c:	460d      	mov	r5, r1
        attack = Unpack(data, PackLocation {0,8});
    462e:	ab04      	add	r3, sp, #16
    4630:	e913 0006 	ldmdb	r3, {r1, r2}
void ADEG_OnDataReceive(bool hemisphere, uint32_t data) {ADEG_instance[hemisphere].OnDataReceive(data);}
    4634:	4607      	mov	r7, r0
        attack = Unpack(data, PackLocation {0,8});
    4636:	4c0a      	ldr	r4, [pc, #40]	; (4660 <ADEG_OnDataReceive(bool, unsigned long)+0x40>)
    4638:	4628      	mov	r0, r5
    463a:	f7ff fbf9 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    463e:	2390      	movs	r3, #144	; 0x90
    4640:	fb03 4407 	mla	r4, r3, r7, r4
        decay = Unpack(data, PackLocation {8,8});
    4644:	4632      	mov	r2, r6
        attack = Unpack(data, PackLocation {0,8});
    4646:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
        decay = Unpack(data, PackLocation {8,8});
    464a:	4631      	mov	r1, r6
    464c:	4628      	mov	r0, r5
    464e:	e9cd 6600 	strd	r6, r6, [sp]
    4652:	f7ff fbed 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4656:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
void ADEG_OnDataReceive(bool hemisphere, uint32_t data) {ADEG_instance[hemisphere].OnDataReceive(data);}
    465a:	b005      	add	sp, #20
    465c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    465e:	bf00      	nop
    4660:	1fffa8c8 	.word	0x1fffa8c8

00004664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>:
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    4664:	0383      	lsls	r3, r0, #14
    4666:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
    466a:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    466e:	434b      	muls	r3, r1
        int prop = constrain(Proportion(cv_value, HEMISPHERE_MAX_CV, max_pixels), 0, max_pixels);
    4670:	139b      	asrs	r3, r3, #14
    4672:	d404      	bmi.n	467e <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]+0x1a>
    4674:	4299      	cmp	r1, r3
    4676:	bfa8      	it	ge
    4678:	4619      	movge	r1, r3
    467a:	4608      	mov	r0, r1
    467c:	4770      	bx	lr
    467e:	2000      	movs	r0, #0
    }
    4680:	4770      	bx	lr

00004682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>:
            if (abs(number) < range) padding += 6;
    4682:	2900      	cmp	r1, #0
    uint8_t pad(int range, int number) {
    4684:	4603      	mov	r3, r0
            if (abs(number) < range) padding += 6;
    4686:	bfb8      	it	lt
    4688:	4249      	neglt	r1, r1
        uint8_t padding = 0;
    468a:	2000      	movs	r0, #0
            range = range / 10;
    468c:	220a      	movs	r2, #10
        while (range > 1)
    468e:	2b01      	cmp	r3, #1
    4690:	dc00      	bgt.n	4694 <HemisphereApplet::pad(int, int) [clone .constprop.0]+0x12>
    }
    4692:	4770      	bx	lr
            if (abs(number) < range) padding += 6;
    4694:	4299      	cmp	r1, r3
    4696:	bfbc      	itt	lt
    4698:	3006      	addlt	r0, #6
    469a:	b2c0      	uxtblt	r0, r0
            range = range / 10;
    469c:	fb93 f3f2 	sdiv	r3, r3, r2
    46a0:	e7f5      	b.n	468e <HemisphereApplet::pad(int, int) [clone .constprop.0]+0xc>
    46a2:	Address 0x00000000000046a2 is out of bounds.


000046a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>:
    void gfxBitmap(int x, int y, int w, const uint8_t *data) {
        graphics.drawBitmap8(x, y, w, data);
    }

    // Like gfxBitmap, but always 8x8
    void gfxIcon(int x, int y, const uint8_t *data) {
    46a4:	b507      	push	{r0, r1, r2, lr}
        graphics.drawBitmap8(x, y, w, data);
    46a6:	2308      	movs	r3, #8
    46a8:	9200      	str	r2, [sp, #0]
    46aa:	460a      	mov	r2, r1
    46ac:	4601      	mov	r1, r0
    46ae:	4803      	ldr	r0, [pc, #12]	; (46bc <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]+0x18>)
    46b0:	f014 ffc8 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
        gfxBitmap(x, y, 8, data);
    }
    46b4:	b003      	add	sp, #12
    46b6:	f85d fb04 	ldr.w	pc, [sp], #4
    46ba:	bf00      	nop
    46bc:	200065e0 	.word	0x200065e0

000046c0 <Backup_restore(void const*)>:
    46c0:	2000      	movs	r0, #0
    46c2:	4770      	bx	lr

000046c4 <NeuralNetwork_handleEncoderEvent(UI::Event const&)>:
    }
}

void NeuralNetwork_handleEncoderEvent(const UI::Event &event) {
    // Left encoder turned
    if (event.control == OC::CONTROL_ENCODER_L) NeuralNetwork_instance.OnLeftEncoderMove(event.value);
    46c4:	8843      	ldrh	r3, [r0, #2]
    46c6:	2b20      	cmp	r3, #32
void NeuralNetwork_handleEncoderEvent(const UI::Event &event) {
    46c8:	b530      	push	{r4, r5, lr}
    if (event.control == OC::CONTROL_ENCODER_L) NeuralNetwork_instance.OnLeftEncoderMove(event.value);
    46ca:	d113      	bne.n	46f4 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x30>
        selected = constrain(selected + direction, 0, 6);
    46cc:	4a5c      	ldr	r2, [pc, #368]	; (4840 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x17c>)
    if (event.control == OC::CONTROL_ENCODER_L) NeuralNetwork_instance.OnLeftEncoderMove(event.value);
    46ce:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
        selected = constrain(selected + direction, 0, 6);
    46d2:	f8d2 13ec 	ldr.w	r1, [r2, #1004]	; 0x3ec
    46d6:	440b      	add	r3, r1
    46d8:	2b06      	cmp	r3, #6
    46da:	bfa8      	it	ge
    46dc:	2306      	movge	r3, #6
    46de:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    46e2:	f8c2 33ec 	str.w	r3, [r2, #1004]	; 0x3ec
        cursor = 0;
    46e6:	2300      	movs	r3, #0
    46e8:	f882 33ea 	strb.w	r3, [r2, #1002]	; 0x3ea
    bool CursorBlink() {
        return (cursor_countdown > 0);
    }

    void ResetCursor() {
        cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    46ec:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    46f0:	6253      	str	r3, [r2, #36]	; 0x24

    // Right encoder turned
    if (event.control == OC::CONTROL_ENCODER_R) NeuralNetwork_instance.OnRightEncoderMove(event.value);
}
    46f2:	bd30      	pop	{r4, r5, pc}
    if (event.control == OC::CONTROL_ENCODER_R) NeuralNetwork_instance.OnRightEncoderMove(event.value);
    46f4:	2b40      	cmp	r3, #64	; 0x40
    46f6:	d1fc      	bne.n	46f2 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x2e>
        if (selected < 6) {
    46f8:	4b51      	ldr	r3, [pc, #324]	; (4840 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x17c>)
    if (event.control == OC::CONTROL_ENCODER_R) NeuralNetwork_instance.OnRightEncoderMove(event.value);
    46fa:	f9b0 1004 	ldrsh.w	r1, [r0, #4]
        if (selected < 6) {
    46fe:	f8d3 53ec 	ldr.w	r5, [r3, #1004]	; 0x3ec
            byte ix = (setup * 6) + selected;
    4702:	f893 03f0 	ldrb.w	r0, [r3, #1008]	; 0x3f0
            neuron[ix].UpdateValue(cursor, direction);
    4706:	f893 23ea 	ldrb.w	r2, [r3, #1002]	; 0x3ea
        if (selected < 6) {
    470a:	2d05      	cmp	r5, #5
    470c:	f300 8088 	bgt.w	4820 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x15c>
            byte ix = (setup * 6) + selected;
    4710:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    4714:	eb05 0540 	add.w	r5, r5, r0, lsl #1
            neuron[ix].UpdateValue(cursor, direction);
    4718:	b2ed      	uxtb	r5, r5
        return max;
    }

    void UpdateValue(byte cursor, int direction) {
        if (cursor == 0) {
            type = constrain(type + direction, LogicGateType::NONE, LogicGateType::TL_NEURON);
    471a:	2024      	movs	r0, #36	; 0x24
    471c:	fb00 3005 	mla	r0, r0, r5, r3
    4720:	f8d0 4400 	ldr.w	r4, [r0, #1024]	; 0x400
        if (cursor == 0) {
    4724:	b9d2      	cbnz	r2, 475c <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x98>
            type = constrain(type + direction, LogicGateType::NONE, LogicGateType::TL_NEURON);
    4726:	440c      	add	r4, r1
    4728:	2c0b      	cmp	r4, #11
    472a:	bfa8      	it	ge
    472c:	240b      	movge	r4, #11
    472e:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
    4732:	f8c0 4400 	str.w	r4, [r0, #1024]	; 0x400
            state = 0; // Reset when changing type
    4736:	f880 23fc 	strb.w	r2, [r0, #1020]	; 0x3fc
            source1 = constrain(source1 + direction, 0, LG_MAX_SOURCE);
        }
        if (cursor == 2 && type >= LogicGateType::AND) {
            source2 = constrain(source2 + direction, 0, LG_MAX_SOURCE);
        }
        if (cursor == 3 && type >= LogicGateType::AND) {
    473a:	2024      	movs	r0, #36	; 0x24
    473c:	fb00 3005 	mla	r0, r0, r5, r3
    4740:	2a03      	cmp	r2, #3
    4742:	f8d0 4400 	ldr.w	r4, [r0, #1024]	; 0x400
    4746:	d120      	bne.n	478a <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0xc6>
    4748:	2c01      	cmp	r4, #1
            source3 = constrain(source3 + direction, 0, LG_MAX_SOURCE);
    474a:	bfc1      	itttt	gt
    474c:	f8d0 440c 	ldrgt.w	r4, [r0, #1036]	; 0x40c
    4750:	1864      	addgt	r4, r4, r1
    4752:	f384 0404 	usatgt	r4, #4, r4
    4756:	f8c0 440c 	strgt.w	r4, [r0, #1036]	; 0x40c
    475a:	e016      	b.n	478a <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0xc6>
        if (cursor == 1 && type > LogicGateType::NONE) {
    475c:	2a01      	cmp	r2, #1
    475e:	d00b      	beq.n	4778 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0xb4>
        if (cursor == 2 && type >= LogicGateType::AND) {
    4760:	2a02      	cmp	r2, #2
    4762:	d1ea      	bne.n	473a <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x76>
    4764:	2c01      	cmp	r4, #1
    4766:	dd10      	ble.n	478a <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0xc6>
            source2 = constrain(source2 + direction, 0, LG_MAX_SOURCE);
    4768:	f8d0 4408 	ldr.w	r4, [r0, #1032]	; 0x408
    476c:	440c      	add	r4, r1
    476e:	f384 0404 	usat	r4, #4, r4
    4772:	f8c0 4408 	str.w	r4, [r0, #1032]	; 0x408
    4776:	e008      	b.n	478a <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0xc6>
        if (cursor == 1 && type > LogicGateType::NONE) {
    4778:	2c00      	cmp	r4, #0
    477a:	dd06      	ble.n	478a <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0xc6>
            source1 = constrain(source1 + direction, 0, LG_MAX_SOURCE);
    477c:	f8d0 4404 	ldr.w	r4, [r0, #1028]	; 0x404
    4780:	440c      	add	r4, r1
    4782:	f384 0404 	usat	r4, #4, r4
    4786:	f8c0 4404 	str.w	r4, [r0, #1028]	; 0x404
        }
        if (type == LogicGateType::TL_NEURON) {
    478a:	2024      	movs	r0, #36	; 0x24
    478c:	fb00 3305 	mla	r3, r0, r5, r3
    4790:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
    4794:	280b      	cmp	r0, #11
    4796:	d1ac      	bne.n	46f2 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x2e>
            if (cursor == 4) weight1 = constrain(weight1 + direction, -9, 9);
    4798:	2a04      	cmp	r2, #4
    479a:	d10e      	bne.n	47ba <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0xf6>
    479c:	f8d3 2410 	ldr.w	r2, [r3, #1040]	; 0x410
    47a0:	440a      	add	r2, r1
    47a2:	2a09      	cmp	r2, #9
    47a4:	bfa8      	it	ge
    47a6:	2209      	movge	r2, #9
    47a8:	f06f 0108 	mvn.w	r1, #8
    47ac:	428a      	cmp	r2, r1
    47ae:	bfac      	ite	ge
    47b0:	f8c3 2410 	strge.w	r2, [r3, #1040]	; 0x410
    47b4:	f8c3 1410 	strlt.w	r1, [r3, #1040]	; 0x410
    47b8:	e79b      	b.n	46f2 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x2e>
            if (cursor == 5) weight2 = constrain(weight2 + direction, -9, 9);
    47ba:	2a05      	cmp	r2, #5
    47bc:	d012      	beq.n	47e4 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x120>
            if (cursor == 6) weight3 = constrain(weight3 + direction, -9, 9);
    47be:	2a06      	cmp	r2, #6
    47c0:	d01f      	beq.n	4802 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x13e>
            if (cursor == 7) threshold = constrain(threshold + direction, -27, 27);
    47c2:	2a07      	cmp	r2, #7
    47c4:	d195      	bne.n	46f2 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x2e>
    47c6:	f8d3 241c 	ldr.w	r2, [r3, #1052]	; 0x41c
    47ca:	440a      	add	r2, r1
    47cc:	2a1b      	cmp	r2, #27
    47ce:	bfa8      	it	ge
    47d0:	221b      	movge	r2, #27
    47d2:	f06f 011a 	mvn.w	r1, #26
    47d6:	428a      	cmp	r2, r1
    47d8:	bfac      	ite	ge
    47da:	f8c3 241c 	strge.w	r2, [r3, #1052]	; 0x41c
    47de:	f8c3 141c 	strlt.w	r1, [r3, #1052]	; 0x41c
        }
    }
    47e2:	e786      	b.n	46f2 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x2e>
            if (cursor == 5) weight2 = constrain(weight2 + direction, -9, 9);
    47e4:	f8d3 2414 	ldr.w	r2, [r3, #1044]	; 0x414
    47e8:	440a      	add	r2, r1
    47ea:	2a09      	cmp	r2, #9
    47ec:	bfa8      	it	ge
    47ee:	2209      	movge	r2, #9
    47f0:	f06f 0108 	mvn.w	r1, #8
    47f4:	428a      	cmp	r2, r1
    47f6:	bfac      	ite	ge
    47f8:	f8c3 2414 	strge.w	r2, [r3, #1044]	; 0x414
    47fc:	f8c3 1414 	strlt.w	r1, [r3, #1044]	; 0x414
    4800:	e777      	b.n	46f2 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x2e>
            if (cursor == 6) weight3 = constrain(weight3 + direction, -9, 9);
    4802:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
    4806:	440a      	add	r2, r1
    4808:	2a09      	cmp	r2, #9
    480a:	bfa8      	it	ge
    480c:	2209      	movge	r2, #9
    480e:	f06f 0108 	mvn.w	r1, #8
    4812:	428a      	cmp	r2, r1
    4814:	bfac      	ite	ge
    4816:	f8c3 2418 	strge.w	r2, [r3, #1048]	; 0x418
    481a:	f8c3 1418 	strlt.w	r1, [r3, #1048]	; 0x418
    481e:	e768      	b.n	46f2 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x2e>
            byte ix = (setup * 4) + cursor;
    4820:	eb02 0280 	add.w	r2, r2, r0, lsl #2
            output_neuron[ix] = constrain(output_neuron[ix] + direction, 0, 5);
    4824:	b2d2      	uxtb	r2, r2
    4826:	f502 72eb 	add.w	r2, r2, #470	; 0x1d6
    482a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    482e:	685a      	ldr	r2, [r3, #4]
    4830:	440a      	add	r2, r1
    4832:	2a05      	cmp	r2, #5
    4834:	bfa8      	it	ge
    4836:	2205      	movge	r2, #5
    4838:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    483c:	605a      	str	r2, [r3, #4]
}
    483e:	e758      	b.n	46f2 <NeuralNetwork_handleEncoderEvent(UI::Event const&)+0x2e>
    4840:	2000058c 	.word	0x2000058c

00004844 <Metronome_OnDataRequest(bool)>:
uint32_t Metronome_OnDataRequest(bool hemisphere) {return Metronome_instance[hemisphere].OnDataRequest();}
    4844:	4b05      	ldr	r3, [pc, #20]	; (485c <Metronome_OnDataRequest(bool)+0x18>)
    4846:	2274      	movs	r2, #116	; 0x74
    4848:	fb02 3300 	mla	r3, r2, r0, r3
    484c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        Pack(data, PackLocation {16,5}, clock_m->GetMultiply() - 1);
    484e:	f992 3012 	ldrsb.w	r3, [r2, #18]
        Pack(data, PackLocation {0,16}, clock_m->GetTempo());
    4852:	89d0      	ldrh	r0, [r2, #14]
        Pack(data, PackLocation {16,5}, clock_m->GetMultiply() - 1);
    4854:	3b01      	subs	r3, #1
uint32_t Metronome_OnDataRequest(bool hemisphere) {return Metronome_instance[hemisphere].OnDataRequest();}
    4856:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
    485a:	4770      	bx	lr
    485c:	200003bc 	.word	0x200003bc

00004860 <EnvFollow_OnDataRequest(bool)>:
uint32_t EnvFollow_OnDataRequest(bool hemisphere) {return EnvFollow_instance[hemisphere].OnDataRequest();}
    4860:	4b09      	ldr	r3, [pc, #36]	; (4888 <EnvFollow_OnDataRequest(bool)+0x28>)
    4862:	2290      	movs	r2, #144	; 0x90
    4864:	fb02 3000 	mla	r0, r2, r0, r3
        Pack(data, PackLocation {10,1}, duck[0]);
    4868:	f890 308e 	ldrb.w	r3, [r0, #142]	; 0x8e
        Pack(data, PackLocation {5,5}, gain[1]);
    486c:	f890 208d 	ldrb.w	r2, [r0, #141]	; 0x8d
        data |= (value << p.location);
    4870:	029b      	lsls	r3, r3, #10
    4872:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
        Pack(data, PackLocation {0,5}, gain[0]);
    4876:	f890 208c 	ldrb.w	r2, [r0, #140]	; 0x8c
        Pack(data, PackLocation {11,1}, duck[1]);
    487a:	f890 008f 	ldrb.w	r0, [r0, #143]	; 0x8f
    487e:	4313      	orrs	r3, r2
uint32_t EnvFollow_OnDataRequest(bool hemisphere) {return EnvFollow_instance[hemisphere].OnDataRequest();}
    4880:	ea43 20c0 	orr.w	r0, r3, r0, lsl #11
    4884:	4770      	bx	lr
    4886:	bf00      	nop
    4888:	1fffe940 	.word	0x1fffe940

0000488c <DrCrusher_OnDataReceive(bool, unsigned long)>:
void DrCrusher_OnDataReceive(bool hemisphere, uint32_t data) {DrCrusher_instance[hemisphere].OnDataReceive(data);}
    488c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        rate = Unpack(data, PackLocation {0,3});
    4890:	2600      	movs	r6, #0
void DrCrusher_OnDataReceive(bool hemisphere, uint32_t data) {DrCrusher_instance[hemisphere].OnDataReceive(data);}
    4892:	b085      	sub	sp, #20
        rate = Unpack(data, PackLocation {0,3});
    4894:	f04f 0903 	mov.w	r9, #3
    4898:	e9cd 6902 	strd	r6, r9, [sp, #8]
void DrCrusher_OnDataReceive(bool hemisphere, uint32_t data) {DrCrusher_instance[hemisphere].OnDataReceive(data);}
    489c:	4688      	mov	r8, r1
        rate = Unpack(data, PackLocation {0,3});
    489e:	ab04      	add	r3, sp, #16
    48a0:	e913 0006 	ldmdb	r3, {r1, r2}
void DrCrusher_OnDataReceive(bool hemisphere, uint32_t data) {DrCrusher_instance[hemisphere].OnDataReceive(data);}
    48a4:	4604      	mov	r4, r0
        rate = Unpack(data, PackLocation {0,3});
    48a6:	4d16      	ldr	r5, [pc, #88]	; (4900 <DrCrusher_OnDataReceive(bool, unsigned long)+0x74>)
    48a8:	4640      	mov	r0, r8
    48aa:	f7ff fac1 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    48ae:	277c      	movs	r7, #124	; 0x7c
    48b0:	fb07 5704 	mla	r7, r7, r4, r5
        depth = Unpack(data, PackLocation {3,4});
    48b4:	2304      	movs	r3, #4
    48b6:	461a      	mov	r2, r3
        rate = Unpack(data, PackLocation {0,3});
    48b8:	6738      	str	r0, [r7, #112]	; 0x70
        depth = Unpack(data, PackLocation {3,4});
    48ba:	4649      	mov	r1, r9
    48bc:	4640      	mov	r0, r8
    48be:	9301      	str	r3, [sp, #4]
    48c0:	f8cd 9000 	str.w	r9, [sp]
    48c4:	f7ff fab4 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    48c8:	4632      	mov	r2, r6
    48ca:	6778      	str	r0, [r7, #116]	; 0x74
        uint16_t mask = 0x0000;
    48cc:	4633      	mov	r3, r6
        for (byte b = 0; b <= depth; b++)
    48ce:	b2d1      	uxtb	r1, r2
    48d0:	4288      	cmp	r0, r1
    48d2:	f102 0201 	add.w	r2, r2, #1
    48d6:	da0e      	bge.n	48f6 <DrCrusher_OnDataReceive(bool, unsigned long)+0x6a>
        mask = mask << (13 - depth);
    48d8:	f1c0 020d 	rsb	r2, r0, #13
    48dc:	4093      	lsls	r3, r2
        mask = get_mask();
    48de:	227c      	movs	r2, #124	; 0x7c
    48e0:	fb02 5504 	mla	r5, r2, r4, r5
        mask |= 0xc000; // Turn on the high two bits
    48e4:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    48e8:	ea6f 4393 	mvn.w	r3, r3, lsr #18
        mask = get_mask();
    48ec:	f8a5 307a 	strh.w	r3, [r5, #122]	; 0x7a
void DrCrusher_OnDataReceive(bool hemisphere, uint32_t data) {DrCrusher_instance[hemisphere].OnDataReceive(data);}
    48f0:	b005      	add	sp, #20
    48f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            mask = mask << 1;
    48f6:	005b      	lsls	r3, r3, #1
    48f8:	b29b      	uxth	r3, r3
            mask |= 0x01;
    48fa:	f043 0301 	orr.w	r3, r3, #1
        for (byte b = 0; b <= depth; b++)
    48fe:	e7e6      	b.n	48ce <DrCrusher_OnDataReceive(bool, unsigned long)+0x42>
    4900:	1fffccac 	.word	0x1fffccac

00004904 <VectorOscillator::scale_level(unsigned char) [clone .isra.0]>:
    /*
     * Provide a signal value based on a segment level. The segment level is internally
     * 0-255, and this is converted to a bipolar value by subtracting 128.
     */
    vosignal_t scale_level(byte level) {
        int b_level = constrain(level, 0, 255) - 128;
    4904:	3980      	subs	r1, #128	; 0x80
        vosignal_t proportion = int2signal((int32_t)numerator) / (int32_t)denominator;
    4906:	237f      	movs	r3, #127	; 0x7f
    4908:	0289      	lsls	r1, r1, #10
    490a:	fb91 f1f3 	sdiv	r1, r1, r3
        int32_t scaled = signal2int(proportion * max_value);
    490e:	4348      	muls	r0, r1
        int scaled = Proportion(b_level, 127, scale);
        vosignal_t scaled_level = int2signal(scaled);
        return scaled_level;
    }
    4910:	f420 707f 	bic.w	r0, r0, #1020	; 0x3fc
    4914:	f020 0003 	bic.w	r0, r0, #3
    4918:	4770      	bx	lr

0000491a <HS::VOSegment::IsTOC() [clone .isra.0]>:
    bool IsTOC() {return (time == 0xff && level > 0);}
    491a:	29ff      	cmp	r1, #255	; 0xff
    491c:	d103      	bne.n	4926 <HS::VOSegment::IsTOC() [clone .isra.0]+0xc>
    491e:	3800      	subs	r0, #0
    4920:	bf18      	it	ne
    4922:	2001      	movne	r0, #1
    4924:	4770      	bx	lr
    4926:	2000      	movs	r0, #0
    4928:	4770      	bx	lr
    492a:	Address 0x000000000000492a is out of bounds.


0000492c <LogicGate::draw_line_from(unsigned char, unsigned char) [clone .isra.0]>:
    bool tl_neuron_fn(bool d1, bool d2, bool d3) {
        int v = (d1 * weight1) + (d2 * weight2) + (d3 * weight3);
        return (v > threshold);
    }

    void draw_line_from(byte source, byte n) {
    492c:	b513      	push	{r0, r1, r4, lr}
        byte fx;
        byte fy;
        byte tx = ((n / 2) * 32) + 28;
    492e:	084b      	lsrs	r3, r1, #1
        byte ty = ((n % 2) * 24) + 29;
    4930:	f001 0101 	and.w	r1, r1, #1
        byte tx = ((n / 2) * 32) + 28;
    4934:	015b      	lsls	r3, r3, #5
        byte ty = ((n % 2) * 24) + 29;
    4936:	eb01 0141 	add.w	r1, r1, r1, lsl #1
        byte tx = ((n / 2) * 32) + 28;
    493a:	331c      	adds	r3, #28
        byte ty = ((n % 2) * 24) + 29;
    493c:	00c9      	lsls	r1, r1, #3
        if (source < 8) {
    493e:	2807      	cmp	r0, #7
        byte tx = ((n / 2) * 32) + 28;
    4940:	b2db      	uxtb	r3, r3
        byte ty = ((n % 2) * 24) + 29;
    4942:	f101 041d 	add.w	r4, r1, #29
        if (source < 8) {
    4946:	d812      	bhi.n	496e <LogicGate::draw_line_from(unsigned char, unsigned char) [clone .isra.0]+0x42>
            // Physical input sources
            fx = ((source / 4) * 6) + 4;
            fy = ((source % 4) * 10) + 27;
    4948:	f000 0203 	and.w	r2, r0, #3
            fx = ((source / 4) * 6) + 4;
    494c:	0880      	lsrs	r0, r0, #2
    494e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
            fy = ((source % 4) * 10) + 27;
    4952:	eb02 0282 	add.w	r2, r2, r2, lsl #2
            fx = ((source / 4) * 6) + 4;
    4956:	0040      	lsls	r0, r0, #1
            fy = ((source % 4) * 10) + 27;
    4958:	0052      	lsls	r2, r2, #1
            fx = ((source / 4) * 6) + 4;
    495a:	3004      	adds	r0, #4
            graphics.drawLine(fx, fy, tx, ty);
    495c:	9400      	str	r4, [sp, #0]
    495e:	321b      	adds	r2, #27
    4960:	f000 01fe 	and.w	r1, r0, #254	; 0xfe
        } else if (source < 14) {
            // Logical output sources
            source -= 8;
            fx = ((source / 2) * 32) + 45;
            fy = ((source % 2) * 24) + 29;
            graphics.drawLine(fx, fy, tx, ty);
    4964:	480a      	ldr	r0, [pc, #40]	; (4990 <LogicGate::draw_line_from(unsigned char, unsigned char) [clone .isra.0]+0x64>)
    4966:	f014 ff43 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        } else {
        		// 14 and 15 are TRUE and FALSE and are not drawn
        }
    }
    496a:	b002      	add	sp, #8
    496c:	bd10      	pop	{r4, pc}
        } else if (source < 14) {
    496e:	280d      	cmp	r0, #13
    4970:	d8fb      	bhi.n	496a <LogicGate::draw_line_from(unsigned char, unsigned char) [clone .isra.0]+0x3e>
            source -= 8;
    4972:	f1a0 0108 	sub.w	r1, r0, #8
            fx = ((source / 2) * 32) + 45;
    4976:	f3c1 0146 	ubfx	r1, r1, #1, #7
            fy = ((source % 2) * 24) + 29;
    497a:	f000 0001 	and.w	r0, r0, #1
    497e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
            fx = ((source / 2) * 32) + 45;
    4982:	0149      	lsls	r1, r1, #5
            fy = ((source % 2) * 24) + 29;
    4984:	00c2      	lsls	r2, r0, #3
            fx = ((source / 2) * 32) + 45;
    4986:	312d      	adds	r1, #45	; 0x2d
            graphics.drawLine(fx, fy, tx, ty);
    4988:	9400      	str	r4, [sp, #0]
    498a:	321d      	adds	r2, #29
    498c:	b2c9      	uxtb	r1, r1
    498e:	e7e9      	b.n	4964 <LogicGate::draw_line_from(unsigned char, unsigned char) [clone .isra.0]+0x38>
    4990:	200065e0 	.word	0x200065e0

00004994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>:
        graphics.drawBitmap8(x + gfx_offset, y, w, data);
    4994:	4401      	add	r1, r0
    4996:	4801      	ldr	r0, [pc, #4]	; (499c <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]+0x8>)
    4998:	f014 be54 	b.w	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
    499c:	200065e0 	.word	0x200065e0

000049a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>:
    void gfxIcon(int x, int y, const uint8_t *data) {
    49a0:	b507      	push	{r0, r1, r2, lr}
        gfxBitmap(x, y, 8, data);
    49a2:	9300      	str	r3, [sp, #0]
    49a4:	2308      	movs	r3, #8
    49a6:	f7ff fff5 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
    }
    49aa:	b003      	add	sp, #12
    49ac:	f85d fb04 	ldr.w	pc, [sp], #4

000049b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>:
        graphics.drawCircle(x + gfx_offset, y, r);
    49b0:	4401      	add	r1, r0
    49b2:	4801      	ldr	r0, [pc, #4]	; (49b8 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]+0x8>)
    49b4:	f014 bf25 	b.w	19802 <weegfx::Graphics::drawCircle(int, int, int)>
    49b8:	200065e0 	.word	0x200065e0

000049bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>:
    void gfxDottedLine(int x, int y, int x2, int y2, uint8_t p = 2) {
    49bc:	b410      	push	{r4}
    49be:	f89d 4008 	ldrb.w	r4, [sp, #8]
        graphics.drawLine(x + gfx_offset, y, x2 + gfx_offset, y2, p);
    49c2:	9402      	str	r4, [sp, #8]
    49c4:	4403      	add	r3, r0
    49c6:	4401      	add	r1, r0
    }
    49c8:	bc10      	pop	{r4}
        graphics.drawLine(x + gfx_offset, y, x2 + gfx_offset, y2, p);
    49ca:	4801      	ldr	r0, [pc, #4]	; (49d0 <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]+0x14>)
    49cc:	f014 be86 	b.w	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
    49d0:	200065e0 	.word	0x200065e0

000049d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>:
    void gfxLine(int x, int y, int x2, int y2, bool dotted) {
    49d4:	b410      	push	{r4}
    49d6:	f89d 4008 	ldrb.w	r4, [sp, #8]
        graphics.drawLine(x + gfx_offset, y, x2 + gfx_offset, y2, dotted ? 2 : 1);
    49da:	3401      	adds	r4, #1
    49dc:	b2e4      	uxtb	r4, r4
    49de:	9402      	str	r4, [sp, #8]
    49e0:	4403      	add	r3, r0
    49e2:	4401      	add	r1, r0
    }
    49e4:	bc10      	pop	{r4}
        graphics.drawLine(x + gfx_offset, y, x2 + gfx_offset, y2, dotted ? 2 : 1);
    49e6:	4801      	ldr	r0, [pc, #4]	; (49ec <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]+0x18>)
    49e8:	f014 be78 	b.w	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
    49ec:	200065e0 	.word	0x200065e0

000049f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>:
        graphics.drawLine(x + gfx_offset, y, x2 + gfx_offset, y2);
    49f0:	4403      	add	r3, r0
    49f2:	4401      	add	r1, r0
    49f4:	4801      	ldr	r0, [pc, #4]	; (49fc <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]+0xc>)
    49f6:	f014 befb 	b.w	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    49fa:	bf00      	nop
    49fc:	200065e0 	.word	0x200065e0

00004a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>:
        graphics.drawRect(x + gfx_offset, y, w, h);
    4a00:	4401      	add	r1, r0
    4a02:	4801      	ldr	r0, [pc, #4]	; (4a08 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]+0x8>)
    4a04:	f014 bc46 	b.w	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
    4a08:	200065e0 	.word	0x200065e0

00004a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>:
        graphics.drawFrame(x + gfx_offset, y, w, h);
    4a0c:	4401      	add	r1, r0
    4a0e:	4801      	ldr	r0, [pc, #4]	; (4a14 <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]+0x8>)
    4a10:	f014 bdf3 	b.w	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
    4a14:	200065e0 	.word	0x200065e0

00004a18 <HemisphereApplet::gfxPixel(int, int) [clone .isra.0]>:
  return frame_ + ((y >>3) << 7) + x;
    4a18:	10d3      	asrs	r3, r2, #3
        graphics.setPixel(x + gfx_offset, y);
    4a1a:	4401      	add	r1, r0
    4a1c:	eb01 11c3 	add.w	r1, r1, r3, lsl #7
    4a20:	4b04      	ldr	r3, [pc, #16]	; (4a34 <HemisphereApplet::gfxPixel(int, int) [clone .isra.0]+0x1c>)
    4a22:	6818      	ldr	r0, [r3, #0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    4a24:	f002 0207 	and.w	r2, r2, #7
    4a28:	2301      	movs	r3, #1
    4a2a:	4093      	lsls	r3, r2
    4a2c:	5c42      	ldrb	r2, [r0, r1]
    4a2e:	4313      	orrs	r3, r2
    4a30:	5443      	strb	r3, [r0, r1]
    }
    4a32:	4770      	bx	lr
    4a34:	200065e0 	.word	0x200065e0

00004a38 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]>:
    void gfxPrint(int x_adv, int num) { // Print number with character padding
    4a38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        graphics.print(str);
    4a3c:	4f0a      	ldr	r7, [pc, #40]	; (4a68 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]+0x30>)
    4a3e:	f8df 802c 	ldr.w	r8, [pc, #44]	; 4a6c <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]+0x34>
    void gfxPrint(int x_adv, int num) { // Print number with character padding
    4a42:	460c      	mov	r4, r1
        for (int c = 0; c < (x_adv / 6); c++) gfxPrint(" ");
    4a44:	2600      	movs	r6, #0
    4a46:	2306      	movs	r3, #6
    4a48:	fb90 f5f3 	sdiv	r5, r0, r3
    4a4c:	42ae      	cmp	r6, r5
    4a4e:	db05      	blt.n	4a5c <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]+0x24>
        graphics.print(num);
    4a50:	4621      	mov	r1, r4
    4a52:	4806      	ldr	r0, [pc, #24]	; (4a6c <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]+0x34>)
    }
    4a54:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        graphics.print(num);
    4a58:	f015 b8b1 	b.w	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    4a5c:	4639      	mov	r1, r7
    4a5e:	4640      	mov	r0, r8
    4a60:	f015 f839 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        for (int c = 0; c < (x_adv / 6); c++) gfxPrint(" ");
    4a64:	3601      	adds	r6, #1
    4a66:	e7f1      	b.n	4a4c <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]+0x14>
    4a68:	000211c7 	.word	0x000211c7
    4a6c:	200065e0 	.word	0x200065e0

00004a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>:
    void gfxPrint(int x, int y, int num) {
    4a70:	b410      	push	{r4}
  text_x_ = x;
    4a72:	4c04      	ldr	r4, [pc, #16]	; (4a84 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]+0x14>)
        graphics.setPrintPos(x + gfx_offset, y);
    4a74:	4408      	add	r0, r1
    4a76:	6060      	str	r0, [r4, #4]
  text_y_ = y;
    4a78:	60a2      	str	r2, [r4, #8]
        graphics.print(num);
    4a7a:	4620      	mov	r0, r4
    4a7c:	4619      	mov	r1, r3
    }
    4a7e:	bc10      	pop	{r4}
        graphics.print(num);
    4a80:	f015 b89d 	b.w	19bbe <weegfx::Graphics::print(int)>
    4a84:	200065e0 	.word	0x200065e0

00004a88 <EnigmaTMWS::DrawSelectorBox(char const*) [clone .isra.0]>:
    void DrawSelectorBox(const char* object) {
    4a88:	b537      	push	{r0, r1, r2, r4, r5, lr}
  text_x_ = x;
    4a8a:	4c18      	ldr	r4, [pc, #96]	; (4aec <EnigmaTMWS::DrawSelectorBox(char const*) [clone .isra.0]+0x64>)
    4a8c:	2500      	movs	r5, #0
    4a8e:	4601      	mov	r1, r0
  text_y_ = y;
    4a90:	230f      	movs	r3, #15
        graphics.print(str);
    4a92:	4620      	mov	r0, r4
    4a94:	60a3      	str	r3, [r4, #8]
  text_x_ = x;
    4a96:	6065      	str	r5, [r4, #4]
    4a98:	f015 f81d 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.drawFrame(x, y, w, h);
    4a9c:	2328      	movs	r3, #40	; 0x28
    4a9e:	9300      	str	r3, [sp, #0]
    4aa0:	4629      	mov	r1, r5
    4aa2:	4620      	mov	r0, r4
    4aa4:	2330      	movs	r3, #48	; 0x30
    4aa6:	2217      	movs	r2, #23
    4aa8:	f014 fda7 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
        graphics.drawLine(x, y, x2, y2);
    4aac:	2220      	movs	r2, #32
    4aae:	9200      	str	r2, [sp, #0]
    4ab0:	4629      	mov	r1, r5
    4ab2:	4620      	mov	r0, r4
    4ab4:	232f      	movs	r3, #47	; 0x2f
    4ab6:	f014 fe9b 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    4aba:	222a      	movs	r2, #42	; 0x2a
    4abc:	9200      	str	r2, [sp, #0]
    4abe:	4629      	mov	r1, r5
    4ac0:	4620      	mov	r0, r4
    4ac2:	232f      	movs	r3, #47	; 0x2f
    4ac4:	f014 fe94 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    4ac8:	2234      	movs	r2, #52	; 0x34
    4aca:	9200      	str	r2, [sp, #0]
    4acc:	4629      	mov	r1, r5
    4ace:	4620      	mov	r0, r4
    4ad0:	232f      	movs	r3, #47	; 0x2f
    4ad2:	f014 fe8d 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        graphics.invertRect(x, y, w, h);
    4ad6:	2309      	movs	r3, #9
    4ad8:	9300      	str	r3, [sp, #0]
    4ada:	2218      	movs	r2, #24
    4adc:	232e      	movs	r3, #46	; 0x2e
    4ade:	2101      	movs	r1, #1
    4ae0:	4620      	mov	r0, r4
    4ae2:	f014 fc9c 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
    }
    4ae6:	b003      	add	sp, #12
    4ae8:	bd30      	pop	{r4, r5, pc}
    4aea:	bf00      	nop
    4aec:	200065e0 	.word	0x200065e0

00004af0 <EnigmaTMWS::DrawSongHelp() [clone .isra.0]>:
    void DrawSongHelp() {
    4af0:	b538      	push	{r3, r4, r5, lr}
    4af2:	4c0e      	ldr	r4, [pc, #56]	; (4b2c <EnigmaTMWS::DrawSongHelp() [clone .isra.0]+0x3c>)
        gfxIcon(56, 15, UP_BTN_ICON);
    4af4:	4a0e      	ldr	r2, [pc, #56]	; (4b30 <EnigmaTMWS::DrawSongHelp() [clone .isra.0]+0x40>)
    4af6:	210f      	movs	r1, #15
    4af8:	2038      	movs	r0, #56	; 0x38
    4afa:	f7ff fdd3 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
    4afe:	2542      	movs	r5, #66	; 0x42
  text_y_ = y;
    4b00:	230f      	movs	r3, #15
        graphics.print(str);
    4b02:	4620      	mov	r0, r4
    4b04:	490b      	ldr	r1, [pc, #44]	; (4b34 <EnigmaTMWS::DrawSongHelp() [clone .isra.0]+0x44>)
    4b06:	60a3      	str	r3, [r4, #8]
  text_x_ = x;
    4b08:	6065      	str	r5, [r4, #4]
    4b0a:	f014 ffe4 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxIcon(56, 25, DOWN_BTN_ICON);
    4b0e:	2119      	movs	r1, #25
    4b10:	2038      	movs	r0, #56	; 0x38
    4b12:	4a09      	ldr	r2, [pc, #36]	; (4b38 <EnigmaTMWS::DrawSongHelp() [clone .isra.0]+0x48>)
    4b14:	f7ff fdc6 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
  text_y_ = y;
    4b18:	2319      	movs	r3, #25
  text_x_ = x;
    4b1a:	6065      	str	r5, [r4, #4]
  text_y_ = y;
    4b1c:	60a3      	str	r3, [r4, #8]
    4b1e:	4620      	mov	r0, r4
    4b20:	4906      	ldr	r1, [pc, #24]	; (4b3c <EnigmaTMWS::DrawSongHelp() [clone .isra.0]+0x4c>)
    }
    4b22:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    4b26:	f014 bfd6 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    4b2a:	bf00      	nop
    4b2c:	200065e0 	.word	0x200065e0
    4b30:	00023ca0 	.word	0x00023ca0
    4b34:	00020ec3 	.word	0x00020ec3
    4b38:	00023d50 	.word	0x00023d50
    4b3c:	00020ecc 	.word	0x00020ecc

00004b40 <HSApplication::pad(int, int) [clone .isra.0]>:
    uint8_t pad(int range, int number) {
    4b40:	b530      	push	{r4, r5, lr}
            if (abs(number) < range) padding += 6;
    4b42:	ea81 74e1 	eor.w	r4, r1, r1, asr #31
    uint8_t pad(int range, int number) {
    4b46:	4602      	mov	r2, r0
            if (abs(number) < range) padding += 6;
    4b48:	eba4 74e1 	sub.w	r4, r4, r1, asr #31
        uint8_t padding = 0;
    4b4c:	2000      	movs	r0, #0
            range = range / 10;
    4b4e:	250a      	movs	r5, #10
        while (range > 1)
    4b50:	2a01      	cmp	r2, #1
    4b52:	dc05      	bgt.n	4b60 <HSApplication::pad(int, int) [clone .isra.0]+0x20>
        if (number < 0 && padding > 0) padding -= 6; // Compensate for minus sign
    4b54:	2900      	cmp	r1, #0
    4b56:	da02      	bge.n	4b5e <HSApplication::pad(int, int) [clone .isra.0]+0x1e>
    4b58:	b108      	cbz	r0, 4b5e <HSApplication::pad(int, int) [clone .isra.0]+0x1e>
    4b5a:	3806      	subs	r0, #6
    4b5c:	b2c0      	uxtb	r0, r0
    }
    4b5e:	bd30      	pop	{r4, r5, pc}
            if (abs(number) < range) padding += 6;
    4b60:	4294      	cmp	r4, r2
    4b62:	bfbc      	itt	lt
    4b64:	1d83      	addlt	r3, r0, #6
    4b66:	b2d8      	uxtblt	r0, r3
            range = range / 10;
    4b68:	fb92 f2f5 	sdiv	r2, r2, r5
    4b6c:	e7f0      	b.n	4b50 <HSApplication::pad(int, int) [clone .isra.0]+0x10>
    4b6e:	Address 0x0000000000004b6e is out of bounds.


00004b70 <HSApplication::gfxPrint(int, int) [clone .isra.0]>:
    void gfxPrint(int x_adv, int num) { // Print number with character padding
    4b70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        graphics.print(str);
    4b74:	4f0a      	ldr	r7, [pc, #40]	; (4ba0 <HSApplication::gfxPrint(int, int) [clone .isra.0]+0x30>)
    4b76:	f8df 802c 	ldr.w	r8, [pc, #44]	; 4ba4 <HSApplication::gfxPrint(int, int) [clone .isra.0]+0x34>
    void gfxPrint(int x_adv, int num) { // Print number with character padding
    4b7a:	460c      	mov	r4, r1
        for (int c = 0; c < (x_adv / 6); c++) gfxPrint(" ");
    4b7c:	2600      	movs	r6, #0
    4b7e:	2306      	movs	r3, #6
    4b80:	fb90 f5f3 	sdiv	r5, r0, r3
    4b84:	42ae      	cmp	r6, r5
    4b86:	db05      	blt.n	4b94 <HSApplication::gfxPrint(int, int) [clone .isra.0]+0x24>
        graphics.print(num);
    4b88:	4621      	mov	r1, r4
    4b8a:	4806      	ldr	r0, [pc, #24]	; (4ba4 <HSApplication::gfxPrint(int, int) [clone .isra.0]+0x34>)
    }
    4b8c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        graphics.print(num);
    4b90:	f015 b815 	b.w	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    4b94:	4639      	mov	r1, r7
    4b96:	4640      	mov	r0, r8
    4b98:	f014 ff9d 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        for (int c = 0; c < (x_adv / 6); c++) gfxPrint(" ");
    4b9c:	3601      	adds	r6, #1
    4b9e:	e7f1      	b.n	4b84 <HSApplication::gfxPrint(int, int) [clone .isra.0]+0x14>
    4ba0:	000211c7 	.word	0x000211c7
    4ba4:	200065e0 	.word	0x200065e0

00004ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>:
        if (CursorBlink()) gfxLine(x, y, x + w - 1, y);
    4ba8:	2800      	cmp	r0, #0
    void gfxCursor(int x, int y, int w) {
    4baa:	b537      	push	{r0, r1, r2, r4, r5, lr}
        if (CursorBlink()) gfxLine(x, y, x + w - 1, y);
    4bac:	dd05      	ble.n	4bba <HSApplication::gfxCursor(int, int, int) [clone .isra.0]+0x12>
    4bae:	440b      	add	r3, r1
        graphics.drawLine(x, y, x2, y2);
    4bb0:	4803      	ldr	r0, [pc, #12]	; (4bc0 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]+0x18>)
    4bb2:	9200      	str	r2, [sp, #0]
    4bb4:	3b01      	subs	r3, #1
    4bb6:	f014 fe1b 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    }
    4bba:	b003      	add	sp, #12
    4bbc:	bd30      	pop	{r4, r5, pc}
    4bbe:	bf00      	nop
    4bc0:	200065e0 	.word	0x200065e0

00004bc4 <OC::Ui::IgnoreEvent(UI::Event const&) [clone .isra.0]>:
    if (button_ignore_mask_ & event.control) {
    4bc4:	f8b0 2046 	ldrh.w	r2, [r0, #70]	; 0x46
  bool IgnoreEvent(const UI::Event &event) {
    4bc8:	4603      	mov	r3, r0
    if (button_ignore_mask_ & event.control) {
    4bca:	ea12 0001 	ands.w	r0, r2, r1
      button_ignore_mask_ &= ~event.control;
    4bce:	bf1c      	itt	ne
    4bd0:	438a      	bicne	r2, r1
    4bd2:	f8a3 2046 	strhne.w	r2, [r3, #70]	; 0x46
    if (screensaver_) {
    4bd6:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
      ignore = true;
    4bda:	bf18      	it	ne
    4bdc:	2001      	movne	r0, #1
    if (screensaver_) {
    4bde:	b11a      	cbz	r2, 4be8 <OC::Ui::IgnoreEvent(UI::Event const&) [clone .isra.0]+0x24>
      screensaver_ = false;
    4be0:	2100      	movs	r1, #0
    4be2:	f883 1048 	strb.w	r1, [r3, #72]	; 0x48
      ignore = true;
    4be6:	4610      	mov	r0, r2
  }
    4be8:	4770      	bx	lr

00004bea <PONGGAME_save(void*)>:
    4bea:	2000      	movs	r0, #0
    4bec:	4770      	bx	lr

00004bee <PONGGAME_restore(void const*)>:
    4bee:	2000      	movs	r0, #0
    4bf0:	4770      	bx	lr

00004bf2 <SCALEEDITOR_save(void*)>:
    4bf2:	2000      	movs	r0, #0
    4bf4:	4770      	bx	lr

00004bf6 <SCALEEDITOR_restore(void const*)>:
    4bf6:	2000      	movs	r0, #0
    4bf8:	4770      	bx	lr

00004bfa <Settings_save(void*)>:
    4bfa:	2000      	movs	r0, #0
    4bfc:	4770      	bx	lr

00004bfe <Settings_restore(void const*)>:
    4bfe:	2000      	movs	r0, #0
    4c00:	4770      	bx	lr

00004c02 <WaveformEditor_save(void*)>:
    4c02:	2000      	movs	r0, #0
    4c04:	4770      	bx	lr

00004c06 <WaveformEditor_restore(void const*)>:
    4c06:	2000      	movs	r0, #0
    4c08:	4770      	bx	lr

00004c0a <ClockSetup_OnDataRequest(bool)>:
    4c0a:	2000      	movs	r0, #0
    4c0c:	4770      	bx	lr

00004c0e <ClockSetup_OnDataReceive(bool, unsigned long)>:
    4c0e:	4770      	bx	lr

00004c10 <GatedVCA_OnDataRequest(bool)>:
    4c10:	2000      	movs	r0, #0
    4c12:	4770      	bx	lr

00004c14 <GatedVCA_OnDataReceive(bool, unsigned long)>:
    4c14:	4770      	bx	lr

00004c16 <LoFiPCM_OnDataRequest(bool)>:
    4c16:	2000      	movs	r0, #0
    4c18:	4770      	bx	lr

00004c1a <LoFiPCM_OnDataReceive(bool, unsigned long)>:
    4c1a:	4770      	bx	lr

00004c1c <Scope_OnDataRequest(bool)>:
    4c1c:	2000      	movs	r0, #0
    4c1e:	4770      	bx	lr

00004c20 <Scope_OnDataReceive(bool, unsigned long)>:
    4c20:	4770      	bx	lr

00004c22 <Switch_OnEncoderMove(bool, int)>:
    4c22:	4770      	bx	lr

00004c24 <RunglBook_OnButtonPress(bool)>:
    4c24:	4770      	bx	lr

00004c26 <Metronome_OnButtonPress(bool)>:
    4c26:	4770      	bx	lr

00004c28 <MixerBal_OnButtonPress(bool)>:
    4c28:	4770      	bx	lr

00004c2a <GatedVCA_OnButtonPress(bool)>:
    4c2a:	4770      	bx	lr

00004c2c <WaveformEditor_storageSize()>:
    4c2c:	2000      	movs	r0, #0
    4c2e:	4770      	bx	lr

00004c30 <Compare_OnButtonPress(bool)>:
    4c30:	4770      	bx	lr

00004c32 <__tcf_0>:
    4c32:	4770      	bx	lr

00004c34 <__tcf_1>:
    4c34:	4770      	bx	lr

00004c36 <__tcf_2>:
    4c36:	4770      	bx	lr

00004c38 <__tcf_3>:
    4c38:	4770      	bx	lr

00004c3a <__tcf_4>:
    4c3a:	4770      	bx	lr

00004c3c <PONGGAME_storageSize()>:
    4c3c:	2000      	movs	r0, #0
    4c3e:	4770      	bx	lr

00004c40 <SCALEEDITOR_storageSize()>:
    4c40:	2000      	movs	r0, #0
    4c42:	4770      	bx	lr

00004c44 <Settings_storageSize()>:
    4c44:	2000      	movs	r0, #0
    4c46:	4770      	bx	lr

00004c48 <Settings_handleAppEvent(OC::AppEvent)>:
    4c48:	4770      	bx	lr

00004c4a <Settings_loop()>:
    4c4a:	4770      	bx	lr

00004c4c <WaveformEditor_loop()>:
    4c4c:	4770      	bx	lr

00004c4e <WaveformEditor_screensaver()>:
    4c4e:	4770      	bx	lr

00004c50 <Settings_screensaver()>:
    4c50:	4770      	bx	lr

00004c52 <TheDarkestTimeline_loop()>:
    4c52:	4770      	bx	lr

00004c54 <TheDarkestTimeline_screensaver()>:
    4c54:	4770      	bx	lr

00004c56 <SCALEEDITOR_loop()>:
    4c56:	4770      	bx	lr

00004c58 <SCALEEDITOR_screensaver()>:
    4c58:	4770      	bx	lr

00004c5a <PONGGAME_screensaver()>:
    4c5a:	4770      	bx	lr

00004c5c <NeuralNetwork_loop()>:
    4c5c:	4770      	bx	lr

00004c5e <NeuralNetwork_screensaver()>:
    4c5e:	4770      	bx	lr

00004c60 <MIDI_loop()>:
    4c60:	4770      	bx	lr

00004c62 <MIDI_screensaver()>:
    4c62:	4770      	bx	lr

00004c64 <EnigmaTMWS_loop()>:
    4c64:	4770      	bx	lr

00004c66 <EnigmaTMWS_screensaver()>:
    4c66:	4770      	bx	lr

00004c68 <HEMISPHERE_loop()>:
    4c68:	4770      	bx	lr

00004c6a <HEMISPHERE_screensaver()>:
    4c6a:	4770      	bx	lr

00004c6c <Backup_loop()>:
    4c6c:	4770      	bx	lr
    4c6e:	Address 0x0000000000004c6e is out of bounds.


00004c70 <DrCrusher_OnEncoderMove(bool, int)>:
void DrCrusher_OnEncoderMove(bool hemisphere, int direction) {DrCrusher_instance[hemisphere].OnEncoderMove(direction);}
    4c70:	b530      	push	{r4, r5, lr}
        if (cursor == 0) {
    4c72:	4c17      	ldr	r4, [pc, #92]	; (4cd0 <DrCrusher_OnEncoderMove(bool, int)+0x60>)
    4c74:	237c      	movs	r3, #124	; 0x7c
    4c76:	fb03 4300 	mla	r3, r3, r0, r4
    4c7a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    4c7c:	b92a      	cbnz	r2, 4c8a <DrCrusher_OnEncoderMove(bool, int)+0x1a>
            rate = constrain(rate - direction, 0, 7);
    4c7e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4c80:	1a52      	subs	r2, r2, r1
    4c82:	f382 0203 	usat	r2, #3, r2
    4c86:	671a      	str	r2, [r3, #112]	; 0x70
void DrCrusher_OnEncoderMove(bool hemisphere, int direction) {DrCrusher_instance[hemisphere].OnEncoderMove(direction);}
    4c88:	bd30      	pop	{r4, r5, pc}
            depth = constrain(depth + direction, 1, 13);
    4c8a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
    4c8c:	440a      	add	r2, r1
    4c8e:	2a0d      	cmp	r2, #13
    4c90:	bfa8      	it	ge
    4c92:	220d      	movge	r2, #13
    4c94:	2a01      	cmp	r2, #1
    4c96:	bfb8      	it	lt
    4c98:	2201      	movlt	r2, #1
void DrCrusher_OnEncoderMove(bool hemisphere, int direction) {DrCrusher_instance[hemisphere].OnEncoderMove(direction);}
    4c9a:	2100      	movs	r1, #0
            depth = constrain(depth + direction, 1, 13);
    4c9c:	675a      	str	r2, [r3, #116]	; 0x74
        uint16_t mask = 0x0000;
    4c9e:	460b      	mov	r3, r1
        for (byte b = 0; b <= depth; b++)
    4ca0:	b2cd      	uxtb	r5, r1
    4ca2:	42aa      	cmp	r2, r5
    4ca4:	f101 0101 	add.w	r1, r1, #1
    4ca8:	da0c      	bge.n	4cc4 <DrCrusher_OnEncoderMove(bool, int)+0x54>
        mask = mask << (13 - depth);
    4caa:	f1c2 020d 	rsb	r2, r2, #13
    4cae:	4093      	lsls	r3, r2
            mask = get_mask();
    4cb0:	227c      	movs	r2, #124	; 0x7c
    4cb2:	fb02 4400 	mla	r4, r2, r0, r4
        mask |= 0xc000; // Turn on the high two bits
    4cb6:	ea6f 4383 	mvn.w	r3, r3, lsl #18
    4cba:	ea6f 4393 	mvn.w	r3, r3, lsr #18
            mask = get_mask();
    4cbe:	f8a4 307a 	strh.w	r3, [r4, #122]	; 0x7a
void DrCrusher_OnEncoderMove(bool hemisphere, int direction) {DrCrusher_instance[hemisphere].OnEncoderMove(direction);}
    4cc2:	e7e1      	b.n	4c88 <DrCrusher_OnEncoderMove(bool, int)+0x18>
            mask = mask << 1;
    4cc4:	005b      	lsls	r3, r3, #1
    4cc6:	b29b      	uxth	r3, r3
            mask |= 0x01;
    4cc8:	f043 0301 	orr.w	r3, r3, #1
        for (byte b = 0; b <= depth; b++)
    4ccc:	e7e8      	b.n	4ca0 <DrCrusher_OnEncoderMove(bool, int)+0x30>
    4cce:	bf00      	nop
    4cd0:	1fffccac 	.word	0x1fffccac

00004cd4 <Metronome_OnEncoderMove(bool, int)>:
void Metronome_OnEncoderMove(bool hemisphere, int direction) {Metronome_instance[hemisphere].OnEncoderMove(direction);}
    4cd4:	4b0a      	ldr	r3, [pc, #40]	; (4d00 <Metronome_OnEncoderMove(bool, int)+0x2c>)
    4cd6:	2274      	movs	r2, #116	; 0x74
    4cd8:	fb02 3300 	mla	r3, r2, r0, r3
    4cdc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
        bpm += direction;
    4cde:	89da      	ldrh	r2, [r3, #14]
    4ce0:	4411      	add	r1, r2
    4ce2:	b289      	uxth	r1, r1
    4ce4:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
    4ce8:	bf28      	it	cs
    4cea:	f44f 7196 	movcs.w	r1, #300	; 0x12c
    4cee:	290a      	cmp	r1, #10
    4cf0:	bf38      	it	cc
    4cf2:	210a      	movcc	r1, #10
     * This is approximate, because the arithmetical value is likely to be fractional, and we
     * need to live with a certain amount of imprecision here. So I'm not even rounding up.
     */
    void SetTempoBPM(uint16_t bpm) {
        bpm = constrain(bpm, CLOCK_TEMPO_MIN, CLOCK_TEMPO_MAX);
        ticks_per_tock = 1000000 / bpm;
    4cf4:	4a03      	ldr	r2, [pc, #12]	; (4d04 <Metronome_OnEncoderMove(bool, int)+0x30>)
        tempo = bpm;
    4cf6:	81d9      	strh	r1, [r3, #14]
        ticks_per_tock = 1000000 / bpm;
    4cf8:	fbb2 f2f1 	udiv	r2, r2, r1
    4cfc:	601a      	str	r2, [r3, #0]
void Metronome_OnEncoderMove(bool hemisphere, int direction) {Metronome_instance[hemisphere].OnEncoderMove(direction);}
    4cfe:	4770      	bx	lr
    4d00:	200003bc 	.word	0x200003bc
    4d04:	000f4240 	.word	0x000f4240

00004d08 <Metronome_OnDataReceive(bool, unsigned long)>:
void Metronome_OnDataReceive(bool hemisphere, uint32_t data) {Metronome_instance[hemisphere].OnDataReceive(data);}
    4d08:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
        clock_m->SetTempoBPM(Unpack(data, PackLocation {0,16}));
    4d0a:	4b19      	ldr	r3, [pc, #100]	; (4d70 <Metronome_OnDataReceive(bool, unsigned long)+0x68>)
    4d0c:	2274      	movs	r2, #116	; 0x74
    4d0e:	fb02 3300 	mla	r3, r2, r0, r3
    4d12:	2610      	movs	r6, #16
    4d14:	6f1c      	ldr	r4, [r3, #112]	; 0x70
    4d16:	2300      	movs	r3, #0
    4d18:	e9cd 3602 	strd	r3, r6, [sp, #8]
void Metronome_OnDataReceive(bool hemisphere, uint32_t data) {Metronome_instance[hemisphere].OnDataReceive(data);}
    4d1c:	460d      	mov	r5, r1
        clock_m->SetTempoBPM(Unpack(data, PackLocation {0,16}));
    4d1e:	eb0d 0306 	add.w	r3, sp, r6
    4d22:	e913 0006 	ldmdb	r3, {r1, r2}
    4d26:	4628      	mov	r0, r5
    4d28:	f7ff f882 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        bpm = constrain(bpm, CLOCK_TEMPO_MIN, CLOCK_TEMPO_MAX);
    4d2c:	b283      	uxth	r3, r0
    4d2e:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    4d32:	bf28      	it	cs
    4d34:	f44f 7396 	movcs.w	r3, #300	; 0x12c
    4d38:	2b0a      	cmp	r3, #10
    4d3a:	bf38      	it	cc
    4d3c:	230a      	movcc	r3, #10
        tempo = bpm;
    4d3e:	81e3      	strh	r3, [r4, #14]
        ticks_per_tock = 1000000 / bpm;
    4d40:	4a0c      	ldr	r2, [pc, #48]	; (4d74 <Metronome_OnDataReceive(bool, unsigned long)+0x6c>)
    4d42:	fbb2 f2f3 	udiv	r2, r2, r3
        clock_m->SetMultiply(Unpack(data, PackLocation {16,5}) + 1);
    4d46:	2305      	movs	r3, #5
    4d48:	6022      	str	r2, [r4, #0]
    4d4a:	4631      	mov	r1, r6
    4d4c:	461a      	mov	r2, r3
    4d4e:	4628      	mov	r0, r5
    4d50:	9600      	str	r6, [sp, #0]
    4d52:	9301      	str	r3, [sp, #4]
    4d54:	f7ff f86c 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    4d58:	3001      	adds	r0, #1
    4d5a:	b240      	sxtb	r0, r0
        multiply = constrain(multiply, 1, 24);
    4d5c:	2800      	cmp	r0, #0
    4d5e:	dd05      	ble.n	4d6c <Metronome_OnDataReceive(bool, unsigned long)+0x64>
    4d60:	2818      	cmp	r0, #24
    4d62:	bfa8      	it	ge
    4d64:	2018      	movge	r0, #24
    4d66:	74a0      	strb	r0, [r4, #18]
void Metronome_OnDataReceive(bool hemisphere, uint32_t data) {Metronome_instance[hemisphere].OnDataReceive(data);}
    4d68:	b004      	add	sp, #16
    4d6a:	bd70      	pop	{r4, r5, r6, pc}
    4d6c:	2001      	movs	r0, #1
    4d6e:	e7fa      	b.n	4d66 <Metronome_OnDataReceive(bool, unsigned long)+0x5e>
    4d70:	200003bc 	.word	0x200003bc
    4d74:	000f4240 	.word	0x000f4240

00004d78 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]>:
  static int clamp_value(size_t index, int value) {
    return value_attr_[index].clamp(value);
  }

  bool apply_value(size_t index, int value) {
    if (index < num_settings) {
    4d78:	2905      	cmp	r1, #5
  bool apply_value(size_t index, int value) {
    4d7a:	b510      	push	{r4, lr}
    if (index < num_settings) {
    4d7c:	d810      	bhi.n	4da0 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]+0x28>
    if (value < min_) return min_;
    4d7e:	4c09      	ldr	r4, [pc, #36]	; (4da4 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]+0x2c>)
    4d80:	2318      	movs	r3, #24
    4d82:	fb03 4401 	mla	r4, r3, r1, r4
    4d86:	6863      	ldr	r3, [r4, #4]
    4d88:	429a      	cmp	r2, r3
    4d8a:	db03      	blt.n	4d94 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]+0x1c>
    else if (value > max_) return max_;
    4d8c:	68a3      	ldr	r3, [r4, #8]
    4d8e:	4293      	cmp	r3, r2
    4d90:	bfa8      	it	ge
    4d92:	4613      	movge	r3, r2
      const int clamped = value_attr_[index].clamp(value);
      if (values_[index] != clamped) {
    4d94:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
    4d98:	429a      	cmp	r2, r3
        values_[index] = clamped;
    4d9a:	bf18      	it	ne
    4d9c:	f840 3021 	strne.w	r3, [r0, r1, lsl #2]
        return true;
      }
    }
    return false;
  }
    4da0:	bd10      	pop	{r4, pc}
    4da2:	bf00      	nop
    4da4:	000273d8 	.word	0x000273d8

00004da8 <settings::SettingsBase<EnigmaTMWS, 150u>::apply_value(unsigned int, int) [clone .isra.0]>:
    if (index < num_settings) {
    4da8:	2995      	cmp	r1, #149	; 0x95
  bool apply_value(size_t index, int value) {
    4daa:	b510      	push	{r4, lr}
    if (index < num_settings) {
    4dac:	d810      	bhi.n	4dd0 <settings::SettingsBase<EnigmaTMWS, 150u>::apply_value(unsigned int, int) [clone .isra.0]+0x28>
    if (value < min_) return min_;
    4dae:	4c09      	ldr	r4, [pc, #36]	; (4dd4 <settings::SettingsBase<EnigmaTMWS, 150u>::apply_value(unsigned int, int) [clone .isra.0]+0x2c>)
    4db0:	2318      	movs	r3, #24
    4db2:	fb03 4401 	mla	r4, r3, r1, r4
    4db6:	6863      	ldr	r3, [r4, #4]
    4db8:	429a      	cmp	r2, r3
    4dba:	db03      	blt.n	4dc4 <settings::SettingsBase<EnigmaTMWS, 150u>::apply_value(unsigned int, int) [clone .isra.0]+0x1c>
    else if (value > max_) return max_;
    4dbc:	68a3      	ldr	r3, [r4, #8]
    4dbe:	4293      	cmp	r3, r2
    4dc0:	bfa8      	it	ge
    4dc2:	4613      	movge	r3, r2
      if (values_[index] != clamped) {
    4dc4:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
    4dc8:	429a      	cmp	r2, r3
        values_[index] = clamped;
    4dca:	bf18      	it	ne
    4dcc:	f840 3021 	strne.w	r3, [r0, r1, lsl #2]
  }
    4dd0:	bd10      	pop	{r4, pc}
    4dd2:	bf00      	nop
    4dd4:	00024270 	.word	0x00024270

00004dd8 <settings::SettingsBase<NeuralNetwork, 216u>::apply_value(unsigned int, int) [clone .isra.0]>:
    if (index < num_settings) {
    4dd8:	29d7      	cmp	r1, #215	; 0xd7
  bool apply_value(size_t index, int value) {
    4dda:	b510      	push	{r4, lr}
    if (index < num_settings) {
    4ddc:	d810      	bhi.n	4e00 <settings::SettingsBase<NeuralNetwork, 216u>::apply_value(unsigned int, int) [clone .isra.0]+0x28>
    if (value < min_) return min_;
    4dde:	4c09      	ldr	r4, [pc, #36]	; (4e04 <settings::SettingsBase<NeuralNetwork, 216u>::apply_value(unsigned int, int) [clone .isra.0]+0x2c>)
    4de0:	2318      	movs	r3, #24
    4de2:	fb03 4401 	mla	r4, r3, r1, r4
    4de6:	6863      	ldr	r3, [r4, #4]
    4de8:	429a      	cmp	r2, r3
    4dea:	db03      	blt.n	4df4 <settings::SettingsBase<NeuralNetwork, 216u>::apply_value(unsigned int, int) [clone .isra.0]+0x1c>
    else if (value > max_) return max_;
    4dec:	68a3      	ldr	r3, [r4, #8]
    4dee:	4293      	cmp	r3, r2
    4df0:	bfa8      	it	ge
    4df2:	4613      	movge	r3, r2
      if (values_[index] != clamped) {
    4df4:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
    4df8:	429a      	cmp	r2, r3
        values_[index] = clamped;
    4dfa:	bf18      	it	ne
    4dfc:	f840 3021 	strne.w	r3, [r0, r1, lsl #2]
  }
    4e00:	bd10      	pop	{r4, pc}
    4e02:	bf00      	nop
    4e04:	00025f98 	.word	0x00025f98

00004e08 <Tuner::Controller()>:
    void Controller() {
    4e08:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
        if (hemisphere == 0 && FreqMeasure.available())
    4e0c:	f890 8004 	ldrb.w	r8, [r0, #4]
    4e10:	4d25      	ldr	r5, [pc, #148]	; (4ea8 <Tuner::Controller()+0xa0>)
    void Controller() {
    4e12:	4604      	mov	r4, r0
        if (hemisphere == 0 && FreqMeasure.available())
    4e14:	f1b8 0f00 	cmp.w	r8, #0
    4e18:	d137      	bne.n	4e8a <Tuner::Controller()+0x82>
    4e1a:	f014 f811 	bl	18e40 <FreqMeasureClass::available()>
    4e1e:	2800      	cmp	r0, #0
    4e20:	d033      	beq.n	4e8a <Tuner::Controller()+0x82>
            freq_sum_ = freq_sum_ + FreqMeasure.read();
    4e22:	e9d4 671c 	ldrd	r6, r7, [r4, #112]	; 0x70
    4e26:	f014 f81b 	bl	18e60 <FreqMeasureClass::read()>
    4e2a:	f017 fd8f 	bl	1c94c <__aeabi_ui2d>
    4e2e:	4632      	mov	r2, r6
    4e30:	463b      	mov	r3, r7
    4e32:	f017 fc4f 	bl	1c6d4 <__adddf3>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4e36:	682b      	ldr	r3, [r5, #0]
    4e38:	9301      	str	r3, [sp, #4]
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
    4e3a:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
	return ret;
    4e3e:	9b01      	ldr	r3, [sp, #4]
    4e40:	4606      	mov	r6, r0
            freq_count_ = freq_count_ + 1;
    4e42:	6fa0      	ldr	r0, [r4, #120]	; 0x78
    4e44:	1a9b      	subs	r3, r3, r2
            if (milliseconds_since_last_freq_ > 750) {
    4e46:	f240 22ee 	movw	r2, #750	; 0x2ee
            freq_sum_ = freq_sum_ + FreqMeasure.read();
    4e4a:	460f      	mov	r7, r1
            freq_count_ = freq_count_ + 1;
    4e4c:	3001      	adds	r0, #1
            if (milliseconds_since_last_freq_ > 750) {
    4e4e:	4293      	cmp	r3, r2
            freq_sum_ = freq_sum_ + FreqMeasure.read();
    4e50:	e9c4 671c 	strd	r6, r7, [r4, #112]	; 0x70
            freq_count_ = freq_count_ + 1;
    4e54:	67a0      	str	r0, [r4, #120]	; 0x78
            if (milliseconds_since_last_freq_ > 750) {
    4e56:	d921      	bls.n	4e9c <Tuner::Controller()+0x94>
                frequency_ = FreqMeasure.countToFrequency(freq_sum_ / freq_count_);
    4e58:	f017 fd78 	bl	1c94c <__aeabi_ui2d>
    4e5c:	4602      	mov	r2, r0
    4e5e:	460b      	mov	r3, r1
    4e60:	4630      	mov	r0, r6
    4e62:	4639      	mov	r1, r7
    4e64:	f017 ff16 	bl	1cc94 <__aeabi_ddiv>
    4e68:	f017 fffc 	bl	1ce64 <__aeabi_d2uiz>
    4e6c:	f014 f812 	bl	18e94 <FreqMeasureClass::countToFrequency(unsigned long)>
                freq_sum_ = 0;
    4e70:	2300      	movs	r3, #0
    4e72:	2200      	movs	r2, #0
    4e74:	e9c4 231c 	strd	r2, r3, [r4, #112]	; 0x70
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4e78:	682b      	ldr	r3, [r5, #0]
    4e7a:	9303      	str	r3, [sp, #12]
	return ret;
    4e7c:	9b03      	ldr	r3, [sp, #12]
                frequency_ = FreqMeasure.countToFrequency(freq_sum_ / freq_count_);
    4e7e:	67e0      	str	r0, [r4, #124]	; 0x7c
                freq_count_ = 0;
    4e80:	f8c4 8078 	str.w	r8, [r4, #120]	; 0x78
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    4e84:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    4e88:	e008      	b.n	4e9c <Tuner::Controller()+0x94>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4e8a:	682b      	ldr	r3, [r5, #0]
    4e8c:	9302      	str	r3, [sp, #8]
	operator unsigned long () const { return millis() - ms; }
    4e8e:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
	return ret;
    4e92:	9b02      	ldr	r3, [sp, #8]
    4e94:	1a9b      	subs	r3, r3, r2
        } else if (milliseconds_since_last_freq_ > 100000) {
    4e96:	4a05      	ldr	r2, [pc, #20]	; (4eac <Tuner::Controller()+0xa4>)
    4e98:	4293      	cmp	r3, r2
    4e9a:	d802      	bhi.n	4ea2 <Tuner::Controller()+0x9a>
    }
    4e9c:	b004      	add	sp, #16
    4e9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            frequency_ = 0.0f;
    4ea2:	2300      	movs	r3, #0
    4ea4:	67e3      	str	r3, [r4, #124]	; 0x7c
    }
    4ea6:	e7f9      	b.n	4e9c <Tuner::Controller()+0x94>
    4ea8:	20006600 	.word	0x20006600
    4eac:	000186a0 	.word	0x000186a0

00004eb0 <OC::DAC::set_pitch(DAC_CHANNEL, long, long)>:
    pitch += (kOctaveZero + octave_offset) * 12 << 7;
    4eb0:	230c      	movs	r3, #12
    4eb2:	3205      	adds	r2, #5
    4eb4:	435a      	muls	r2, r3
    int32_t sample = calibration_data_->calibrated_octaves[channel][octave];
    4eb6:	4b15      	ldr	r3, [pc, #84]	; (4f0c <OC::DAC::set_pitch(DAC_CHANNEL, long, long)+0x5c>)
    pitch += (kOctaveZero + octave_offset) * 12 << 7;
    4eb8:	eb01 11c2 	add.w	r1, r1, r2, lsl #7
  static void set_pitch(DAC_CHANNEL channel, int32_t pitch, int32_t octave_offset) {
    4ebc:	b5f0      	push	{r4, r5, r6, r7, lr}
    4ebe:	f5b1 5f70 	cmp.w	r1, #15360	; 0x3c00
    int32_t sample = calibration_data_->calibrated_octaves[channel][octave];
    4ec2:	681e      	ldr	r6, [r3, #0]
    4ec4:	f04f 030b 	mov.w	r3, #11
    4ec8:	bfa8      	it	ge
    4eca:	f44f 5170 	movge.w	r1, #15360	; 0x3c00
    4ece:	4343      	muls	r3, r0
    4ed0:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
    const int32_t octave = pitch / (12 << 7);
    4ed4:	f44f 65c0 	mov.w	r5, #1536	; 0x600
    4ed8:	fbb1 f4f5 	udiv	r4, r1, r5
    const int32_t fractional = pitch - octave * (12 << 7);
    4edc:	eba4 0784 	sub.w	r7, r4, r4, lsl #2
    int32_t sample = calibration_data_->calibrated_octaves[channel][octave];
    4ee0:	191a      	adds	r2, r3, r4
    if (fractional) {
    4ee2:	eb11 2147 	adds.w	r1, r1, r7, lsl #9
    int32_t sample = calibration_data_->calibrated_octaves[channel][octave];
    4ee6:	f836 2012 	ldrh.w	r2, [r6, r2, lsl #1]
    if (fractional) {
    4eea:	d008      	beq.n	4efe <OC::DAC::set_pitch(DAC_CHANNEL, long, long)+0x4e>
      int32_t span = calibration_data_->calibrated_octaves[channel][octave + 1] - sample;
    4eec:	3401      	adds	r4, #1
    4eee:	4423      	add	r3, r4
    4ef0:	f836 3013 	ldrh.w	r3, [r6, r3, lsl #1]
    4ef4:	1a9b      	subs	r3, r3, r2
      sample += (fractional * span) / (12 << 7);
    4ef6:	434b      	muls	r3, r1
    4ef8:	fb93 f3f5 	sdiv	r3, r3, r5
    4efc:	441a      	add	r2, r3
    values_[channel] = USAT16(value);
    4efe:	4b04      	ldr	r3, [pc, #16]	; (4f10 <OC::DAC::set_pitch(DAC_CHANNEL, long, long)+0x60>)
    4f00:	f382 0210 	usat	r2, #16, r2
    4f04:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
  }
    4f08:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4f0a:	bf00      	nop
    4f0c:	1fffa4d4 	.word	0x1fffa4d4
    4f10:	1fffa4d8 	.word	0x1fffa4d8

00004f14 <OC::DAC::set_octave(DAC_CHANNEL, int)>:
    set(channel, calibration_data_->calibrated_octaves[channel][kOctaveZero + v]);
    4f14:	4b06      	ldr	r3, [pc, #24]	; (4f30 <OC::DAC::set_octave(DAC_CHANNEL, int)+0x1c>)
    4f16:	220b      	movs	r2, #11
    4f18:	3105      	adds	r1, #5
    4f1a:	fb02 1100 	mla	r1, r2, r0, r1
    4f1e:	681b      	ldr	r3, [r3, #0]
    values_[channel] = USAT16(value);
    4f20:	4a04      	ldr	r2, [pc, #16]	; (4f34 <OC::DAC::set_octave(DAC_CHANNEL, int)+0x20>)
    set(channel, calibration_data_->calibrated_octaves[channel][kOctaveZero + v]);
    4f22:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    4f26:	f383 0310 	usat	r3, #16, r3
    values_[channel] = USAT16(value);
    4f2a:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  }
    4f2e:	4770      	bx	lr
    4f30:	1fffa4d4 	.word	0x1fffa4d4
    4f34:	1fffa4d8 	.word	0x1fffa4d8

00004f38 <OC::DAC::set_all_octave(int)>:
  static void set_all_octave(int v) {
    4f38:	b510      	push	{r4, lr}
    set_octave(DAC_CHANNEL_A, v);
    4f3a:	4601      	mov	r1, r0
  static void set_all_octave(int v) {
    4f3c:	4604      	mov	r4, r0
    set_octave(DAC_CHANNEL_A, v);
    4f3e:	2000      	movs	r0, #0
    4f40:	f7ff ffe8 	bl	4f14 <OC::DAC::set_octave(DAC_CHANNEL, int)>
    set_octave(DAC_CHANNEL_B, v);
    4f44:	4621      	mov	r1, r4
    4f46:	2001      	movs	r0, #1
    4f48:	f7ff ffe4 	bl	4f14 <OC::DAC::set_octave(DAC_CHANNEL, int)>
    set_octave(DAC_CHANNEL_C, v);
    4f4c:	4621      	mov	r1, r4
    4f4e:	2002      	movs	r0, #2
    4f50:	f7ff ffe0 	bl	4f14 <OC::DAC::set_octave(DAC_CHANNEL, int)>
    set_octave(DAC_CHANNEL_D, v);
    4f54:	4621      	mov	r1, r4
    4f56:	2003      	movs	r0, #3
    4f58:	f7ff ffdc 	bl	4f14 <OC::DAC::set_octave(DAC_CHANNEL, int)>
  }
    4f5c:	bd10      	pop	{r4, pc}
    4f5e:	Address 0x0000000000004f5e is out of bounds.


00004f60 <debug::ScopedCycleMeasurement::~ScopedCycleMeasurement()>:
    return ARM_DWT_CYCCNT - start_;
    4f60:	4b09      	ldr	r3, [pc, #36]	; (4f88 <debug::ScopedCycleMeasurement::~ScopedCycleMeasurement()+0x28>)
  ScopedCycleMeasurement(AveragedCycles &dest)
  : dest_(dest)
  , cycles_() { }

  ~ScopedCycleMeasurement() {
    dest_.push(cycles_.read());
    4f62:	6801      	ldr	r1, [r0, #0]
    return ARM_DWT_CYCCNT - start_;
    4f64:	685a      	ldr	r2, [r3, #4]
    4f66:	6843      	ldr	r3, [r0, #4]
    4f68:	1ad2      	subs	r2, r2, r3
    if (value < min_) min_ = value;
    4f6a:	684b      	ldr	r3, [r1, #4]
    4f6c:	429a      	cmp	r2, r3
    if (value > max_) max_ = value;
    4f6e:	688b      	ldr	r3, [r1, #8]
    if (value < min_) min_ = value;
    4f70:	bf38      	it	cc
    4f72:	604a      	strcc	r2, [r1, #4]
    if (value > max_) max_ = value;
    4f74:	429a      	cmp	r2, r3
    value_ = (value_ * (kSmoothing - 1) + value) / kSmoothing;
    4f76:	680b      	ldr	r3, [r1, #0]
    if (value > max_) max_ = value;
    4f78:	bf88      	it	hi
    4f7a:	608a      	strhi	r2, [r1, #8]
    value_ = (value_ * (kSmoothing - 1) + value) / kSmoothing;
    4f7c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    4f80:	4413      	add	r3, r2
    4f82:	08db      	lsrs	r3, r3, #3
    4f84:	600b      	str	r3, [r1, #0]
  }
    4f86:	4770      	bx	lr
    4f88:	e0001000 	.word	0xe0001000

00004f8c <OC::ADC::value(ADC_CHANNEL)>:
    return calibration_data_->offset[channel] - (smoothed_[channel] >> kAdcValueShift);
    4f8c:	4b04      	ldr	r3, [pc, #16]	; (4fa0 <OC::ADC::value(ADC_CHANNEL)+0x14>)
    4f8e:	681b      	ldr	r3, [r3, #0]
    4f90:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
    4f94:	4b03      	ldr	r3, [pc, #12]	; (4fa4 <OC::ADC::value(ADC_CHANNEL)+0x18>)
    4f96:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
  }
    4f9a:	eba2 2010 	sub.w	r0, r2, r0, lsr #8
    4f9e:	4770      	bx	lr
    4fa0:	1fffa344 	.word	0x1fffa344
    4fa4:	1fffa4bc 	.word	0x1fffa4bc

00004fa8 <OC::ADC::raw_pitch_value(ADC_CHANNEL)>:
  static int32_t pitch_value(ADC_CHANNEL channel) {
    return (value(channel) * calibration_data_->pitch_cv_scale) >> 12;
  }

  static int32_t raw_pitch_value(ADC_CHANNEL channel) {
    int32_t value = calibration_data_->offset[channel] - raw_value(channel);
    4fa8:	4b06      	ldr	r3, [pc, #24]	; (4fc4 <OC::ADC::raw_pitch_value(ADC_CHANNEL)+0x1c>)
    return raw_[channel] >> kAdcValueShift;
    4faa:	4907      	ldr	r1, [pc, #28]	; (4fc8 <OC::ADC::raw_pitch_value(ADC_CHANNEL)+0x20>)
    int32_t value = calibration_data_->offset[channel] - raw_value(channel);
    4fac:	681a      	ldr	r2, [r3, #0]
    4fae:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
    return raw_[channel] >> kAdcValueShift;
    4fb2:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    int32_t value = calibration_data_->offset[channel] - raw_value(channel);
    4fb6:	eba3 2010 	sub.w	r0, r3, r0, lsr #8
    return (value * calibration_data_->pitch_cv_scale) >> 12;
    4fba:	8913      	ldrh	r3, [r2, #8]
    4fbc:	4358      	muls	r0, r3
  }
    4fbe:	1300      	asrs	r0, r0, #12
    4fc0:	4770      	bx	lr
    4fc2:	bf00      	nop
    4fc4:	1fffa344 	.word	0x1fffa344
    4fc8:	1fffa4ac 	.word	0x1fffa4ac

00004fcc <EEPROMStorage::update(unsigned int, void const*, unsigned int)>:

/* Define a storage implemenation using teensy EEPROM */
struct EEPROMStorage {
  static const size_t LENGTH = 2048;

  static void update(size_t addr, const void *data, size_t length) {
    4fcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4fce:	4605      	mov	r5, r0
    4fd0:	460c      	mov	r4, r1
    EEPtr e = addr;
    const uint8_t *src = (const uint8_t *)data;
    while (length--)
    4fd2:	188e      	adds	r6, r1, r2
    4fd4:	42b4      	cmp	r4, r6
    4fd6:	d100      	bne.n	4fda <EEPROMStorage::update(unsigned int, void const*, unsigned int)+0xe>
      (*e++).update(*src++);
  }
    4fd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4fda:	4628      	mov	r0, r5
    4fdc:	f014 ffce 	bl	19f7c <eeprom_read_byte>
      (*e++).update(*src++);
    4fe0:	f814 7b01 	ldrb.w	r7, [r4], #1
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4fe4:	4287      	cmp	r7, r0
    4fe6:	d003      	beq.n	4ff0 <EEPROMStorage::update(unsigned int, void const*, unsigned int)+0x24>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4fe8:	4639      	mov	r1, r7
    4fea:	4628      	mov	r0, r5
    4fec:	f014 ffda 	bl	19fa4 <eeprom_write_byte>
    4ff0:	3501      	adds	r5, #1
    4ff2:	e7ef      	b.n	4fd4 <EEPROMStorage::update(unsigned int, void const*, unsigned int)+0x8>

00004ff4 <EEPROMStorage::read(unsigned int, void*, unsigned int)>:
    const uint8_t *src = (const uint8_t*)data;
    while (length--)
      (*e++) = (*src++);
  }

  static void read(size_t addr, void *data, size_t length) {
    4ff4:	b570      	push	{r4, r5, r6, lr}
    4ff6:	460c      	mov	r4, r1
    EEPtr e = addr;
    uint8_t *dst = (uint8_t*)data;
    while (length--)
    4ff8:	188d      	adds	r5, r1, r2
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4ffa:	1a46      	subs	r6, r0, r1
    4ffc:	42ac      	cmp	r4, r5
    4ffe:	d100      	bne.n	5002 <EEPROMStorage::read(unsigned int, void*, unsigned int)+0xe>
      *dst++ = *e++;
  }
    5000:	bd70      	pop	{r4, r5, r6, pc}
    5002:	1930      	adds	r0, r6, r4
    5004:	f014 ffba 	bl	19f7c <eeprom_read_byte>
      *dst++ = *e++;
    5008:	f804 0b01 	strb.w	r0, [r4], #1
    500c:	e7f6      	b.n	4ffc <EEPROMStorage::read(unsigned int, void*, unsigned int)+0x8>
    500e:	Address 0x000000000000500e is out of bounds.


00005010 <OC::DigitalInputDisplay::Update(unsigned long, bool)>:

  void Init() {
    phase_ = 0;
  }

  void Update(uint32_t ticks, bool clocked) {
    5010:	b510      	push	{r4, lr}
    uint32_t phase_inc = ticks * kPhaseInc;
    if (clocked) {
    5012:	b11a      	cbz	r2, 501c <OC::DigitalInputDisplay::Update(unsigned long, bool)+0xc>
      phase_ = 0xffffffff;
    5014:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
      uint32_t phase = phase_;
      if (phase) {
        if (phase < phase_inc)
          phase_ = 0;
        else
          phase_ = phase - phase_inc;
    5018:	6003      	str	r3, [r0, #0]
      }
    }
  }
    501a:	e006      	b.n	502a <OC::DigitalInputDisplay::Update(unsigned long, bool)+0x1a>
      uint32_t phase = phase_;
    501c:	6803      	ldr	r3, [r0, #0]
      if (phase) {
    501e:	b123      	cbz	r3, 502a <OC::DigitalInputDisplay::Update(unsigned long, bool)+0x1a>
    uint32_t phase_inc = ticks * kPhaseInc;
    5020:	4c03      	ldr	r4, [pc, #12]	; (5030 <OC::DigitalInputDisplay::Update(unsigned long, bool)+0x20>)
    5022:	4361      	muls	r1, r4
        if (phase < phase_inc)
    5024:	4299      	cmp	r1, r3
    5026:	d901      	bls.n	502c <OC::DigitalInputDisplay::Update(unsigned long, bool)+0x1c>
          phase_ = 0;
    5028:	6002      	str	r2, [r0, #0]
  }
    502a:	bd10      	pop	{r4, pc}
          phase_ = phase - phase_inc;
    502c:	1a5b      	subs	r3, r3, r1
    502e:	e7f3      	b.n	5018 <OC::DigitalInputDisplay::Update(unsigned long, bool)+0x8>
    5030:	001d7ef4 	.word	0x001d7ef4

00005034 <OC::menu::SettingsListItem::DrawCustom() const>:
    if (selected)
      graphics.invertRect(x, y, kDisplayWidth - x, kMenuLineH - 1);
  }

  inline void DrawCustom() const {
    if (selected)
    5034:	7803      	ldrb	r3, [r0, #0]
  inline void DrawCustom() const {
    5036:	b507      	push	{r0, r1, r2, lr}
    if (selected)
    5038:	b143      	cbz	r3, 504c <OC::menu::SettingsListItem::DrawCustom() const+0x18>
      graphics.invertRect(x, y, kDisplayWidth - x, kMenuLineH - 1);
    503a:	6841      	ldr	r1, [r0, #4]
    503c:	230b      	movs	r3, #11
    503e:	9300      	str	r3, [sp, #0]
    5040:	6882      	ldr	r2, [r0, #8]
    5042:	4804      	ldr	r0, [pc, #16]	; (5054 <OC::menu::SettingsListItem::DrawCustom() const+0x20>)
    5044:	f1c1 0380 	rsb	r3, r1, #128	; 0x80
    5048:	f014 f9e9 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
      graphics.invertRect(x, y, kDisplayWidth - x, kMenuLineH - 1);
  }
    504c:	b003      	add	sp, #12
    504e:	f85d fb04 	ldr.w	pc, [sp], #4
    5052:	bf00      	nop
    5054:	200065e0 	.word	0x200065e0

00005058 <OC::Ui::encoders_enable_acceleration(bool)>:
    if (b != acceleration_enabled_) {
    5058:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
    505c:	428b      	cmp	r3, r1
      acceleration_ = 0;
    505e:	bf1c      	itt	ne
    5060:	2300      	movne	r3, #0
    5062:	6643      	strne	r3, [r0, #100]	; 0x64
    if (b != acceleration_enabled_) {
    5064:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
      acceleration_enabled_ = b;
    5068:	bf18      	it	ne
    506a:	f880 105c 	strbne.w	r1, [r0, #92]	; 0x5c
    if (b != acceleration_enabled_) {
    506e:	428b      	cmp	r3, r1
      acceleration_ = 0;
    5070:	bf1e      	ittt	ne
    5072:	2300      	movne	r3, #0
      acceleration_enabled_ = b;
    5074:	f880 104c 	strbne.w	r1, [r0, #76]	; 0x4c
      acceleration_ = 0;
    5078:	6543      	strne	r3, [r0, #84]	; 0x54
  }
    507a:	4770      	bx	lr

0000507c <VBiasManager::get()>:
    static VBiasManager *get() {
    507c:	b538      	push	{r3, r4, r5, lr}
        if (!instance) instance = new VBiasManager;
    507e:	4c05      	ldr	r4, [pc, #20]	; (5094 <VBiasManager::get()+0x18>)
    5080:	6825      	ldr	r5, [r4, #0]
    5082:	b92d      	cbnz	r5, 5090 <VBiasManager::get()+0x14>
    5084:	2008      	movs	r0, #8
    5086:	f015 f8e5 	bl	1a254 <operator new(unsigned int)>
        bias_state = 0;
    508a:	6005      	str	r5, [r0, #0]
        last_advance_tick = 0;
    508c:	6045      	str	r5, [r0, #4]
        if (!instance) instance = new VBiasManager;
    508e:	6020      	str	r0, [r4, #0]
    }
    5090:	6820      	ldr	r0, [r4, #0]
    5092:	bd38      	pop	{r3, r4, r5, pc}
    5094:	1fffa7c8 	.word	0x1fffa7c8

00005098 <VBiasManager::DrawPopupPerhaps()>:

    /*
     * If the last state advance (with the button) was less than a second ago, draw the popup indicator
     */
    void DrawPopupPerhaps() {
        if (OC::CORE::ticks - last_advance_tick < BIAS_EDITOR_TIMEOUT) {
    5098:	4b24      	ldr	r3, [pc, #144]	; (512c <VBiasManager::DrawPopupPerhaps()+0x94>)
    509a:	6842      	ldr	r2, [r0, #4]
    509c:	681b      	ldr	r3, [r3, #0]
    509e:	1a9b      	subs	r3, r3, r2
    50a0:	f244 1219 	movw	r2, #16665	; 0x4119
    50a4:	4293      	cmp	r3, r2
    void DrawPopupPerhaps() {
    50a6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    50aa:	4605      	mov	r5, r0
        if (OC::CORE::ticks - last_advance_tick < BIAS_EDITOR_TIMEOUT) {
    50ac:	d83b      	bhi.n	5126 <VBiasManager::DrawPopupPerhaps()+0x8e>
            graphics.clearRect(17, 7, 82, 43);
    50ae:	4c20      	ldr	r4, [pc, #128]	; (5130 <VBiasManager::DrawPopupPerhaps()+0x98>)
    50b0:	232b      	movs	r3, #43	; 0x2b
    50b2:	9300      	str	r3, [sp, #0]
    50b4:	4620      	mov	r0, r4
    50b6:	2352      	movs	r3, #82	; 0x52
    50b8:	2207      	movs	r2, #7
    50ba:	2111      	movs	r1, #17
    50bc:	f014 f94c 	bl	19358 <weegfx::Graphics::clearRect(int, int, int, int)>
            graphics.drawFrame(18, 8, 80, 42);
    50c0:	232a      	movs	r3, #42	; 0x2a
    50c2:	2208      	movs	r2, #8
    50c4:	9300      	str	r3, [sp, #0]
    50c6:	4620      	mov	r0, r4
    50c8:	2350      	movs	r3, #80	; 0x50
    50ca:	2112      	movs	r1, #18
    50cc:	f014 fa95 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
  text_x_ = x;
    50d0:	2714      	movs	r7, #20
  text_y_ = y;
    50d2:	f04f 080a 	mov.w	r8, #10

            graphics.setPrintPos(20, 10);
            graphics.print("Range:");
    50d6:	4620      	mov	r0, r4
    50d8:	4916      	ldr	r1, [pc, #88]	; (5134 <VBiasManager::DrawPopupPerhaps()+0x9c>)
  text_x_ = x;
    50da:	6067      	str	r7, [r4, #4]
    50dc:	261e      	movs	r6, #30
  text_y_ = y;
    50de:	f8c4 8008 	str.w	r8, [r4, #8]
    50e2:	f014 fcf8 	bl	19ad6 <weegfx::Graphics::print(char const*)>

            // Bipolar state
            graphics.setPrintPos(30, 20);
            graphics.print("-5V -> 5V");
    50e6:	4620      	mov	r0, r4
    50e8:	4913      	ldr	r1, [pc, #76]	; (5138 <VBiasManager::DrawPopupPerhaps()+0xa0>)
  text_x_ = x;
    50ea:	6066      	str	r6, [r4, #4]
  text_y_ = y;
    50ec:	60a7      	str	r7, [r4, #8]
    50ee:	f014 fcf2 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            // Asym State
            graphics.setPrintPos(30, 30);
            graphics.print("-3V -> 7V");
    50f2:	4620      	mov	r0, r4
    50f4:	4911      	ldr	r1, [pc, #68]	; (513c <VBiasManager::DrawPopupPerhaps()+0xa4>)
  text_x_ = x;
    50f6:	6066      	str	r6, [r4, #4]
  text_y_ = y;
    50f8:	60a6      	str	r6, [r4, #8]
    50fa:	f014 fcec 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    50fe:	2328      	movs	r3, #40	; 0x28
            // Unipolar state
            graphics.setPrintPos(30, 40);
            graphics.print(" 0V -> 10V");
    5100:	4620      	mov	r0, r4
    5102:	490f      	ldr	r1, [pc, #60]	; (5140 <VBiasManager::DrawPopupPerhaps()+0xa8>)
    5104:	60a3      	str	r3, [r4, #8]
  text_x_ = x;
    5106:	6066      	str	r6, [r4, #4]
    5108:	f014 fce5 	bl	19ad6 <weegfx::Graphics::print(char const*)>

            graphics.setPrintPos(20, 20 + (bias_state * 10));
    510c:	682b      	ldr	r3, [r5, #0]
            graphics.print("> ");
    510e:	490d      	ldr	r1, [pc, #52]	; (5144 <VBiasManager::DrawPopupPerhaps()+0xac>)
    5110:	6067      	str	r7, [r4, #4]
            graphics.setPrintPos(20, 20 + (bias_state * 10));
    5112:	fb08 f303 	mul.w	r3, r8, r3
    5116:	443b      	add	r3, r7
            graphics.print("> ");
    5118:	4620      	mov	r0, r4
  text_y_ = y;
    511a:	60a3      	str	r3, [r4, #8]
        }
    }
    511c:	b002      	add	sp, #8
    511e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            graphics.print("> ");
    5122:	f014 bcd8 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    }
    5126:	b002      	add	sp, #8
    5128:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    512c:	200046cc 	.word	0x200046cc
    5130:	200065e0 	.word	0x200065e0
    5134:	00020ed5 	.word	0x00020ed5
    5138:	00020edc 	.word	0x00020edc
    513c:	00020ee6 	.word	0x00020ee6
    5140:	00020ef0 	.word	0x00020ef0
    5144:	00020efb 	.word	0x00020efb

00005148 <_SysExData::set_data(int, unsigned char*)>:
 */
typedef struct _SysExData {
    int size;
    uint8_t data[SYSEX_DATA_MAX_SIZE];

    void set_data(int size_, uint8_t data_[])
    5148:	b510      	push	{r4, lr}
    {
        size = size_;
    514a:	f840 1b03 	str.w	r1, [r0], #3
        for (int i = 0; i < size; i++) data[i] = data_[i];
    514e:	2300      	movs	r3, #0
    5150:	428b      	cmp	r3, r1
    5152:	db00      	blt.n	5156 <_SysExData::set_data(int, unsigned char*)+0xe>
    }
    5154:	bd10      	pop	{r4, pc}
        for (int i = 0; i < size; i++) data[i] = data_[i];
    5156:	5cd4      	ldrb	r4, [r2, r3]
    5158:	f800 4f01 	strb.w	r4, [r0, #1]!
    515c:	3301      	adds	r3, #1
    515e:	e7f7      	b.n	5150 <_SysExData::set_data(int, unsigned char*)+0x8>

00005160 <_SysExData::pack()>:
     *   (Let's continue the example from unpack_data() above, by opening the filter all the way. As you
     *     may recall, mopho_voice_data is an UnpackedData)
     *   mopho_voice.data[20] = 164;
     *   PackedData mopho_sysex = pack_data(mopho_voice);
     */
    _SysExData pack()
    5160:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5164:	4605      	mov	r5, r0
        uint8_t packbyte = 0;  /* Composite of high bits of next 7 bytes */
        uint8_t pos = 0;       /* Current position of 7 */
        uint8_t psize = 0;     /* Packed voice size */
        uint8_t packet[7];     /* Current packet */
        uint8_t c;             /* Current source byte */
        for (int ixu = 0; ixu < size; ixu++)
    5166:	4608      	mov	r0, r1
    5168:	f1c1 21ff 	rsb	r1, r1, #4278255360	; 0xff00ff00
        uint8_t psize = 0;     /* Packed voice size */
    516c:	2300      	movs	r3, #0
        for (int ixu = 0; ixu < size; ixu++)
    516e:	f501 017f 	add.w	r1, r1, #16711680	; 0xff0000
    5172:	f850 cb03 	ldr.w	ip, [r0], #3
    _SysExData pack()
    5176:	b093      	sub	sp, #76	; 0x4c
        uint8_t pos = 0;       /* Current position of 7 */
    5178:	461a      	mov	r2, r3
        uint8_t packbyte = 0;  /* Composite of high bits of next 7 bytes */
    517a:	461c      	mov	r4, r3
        for (int ixu = 0; ixu < size; ixu++)
    517c:	31fd      	adds	r1, #253	; 0xfd
                for (int i = 0; i < pos; i++) pdata[psize++] = packet[i];
                packbyte = 0;
                pos = 0;
            }
            if (c & 0x80) {
                packbyte += (1 << pos);
    517e:	f04f 0e01 	mov.w	lr, #1
        for (int ixu = 0; ixu < size; ixu++)
    5182:	180e      	adds	r6, r1, r0
    5184:	45b4      	cmp	ip, r6
    5186:	dd2c      	ble.n	51e2 <_SysExData::pack()+0x82>
            if (pos == 7) {
    5188:	2a07      	cmp	r2, #7
            c = data[ixu];
    518a:	f810 6f01 	ldrb.w	r6, [r0, #1]!
            if (pos == 7) {
    518e:	d116      	bne.n	51be <_SysExData::pack()+0x5e>
                pdata[psize++] = packbyte;
    5190:	f103 0248 	add.w	r2, r3, #72	; 0x48
    5194:	446a      	add	r2, sp
    5196:	af01      	add	r7, sp, #4
    5198:	f802 4c3c 	strb.w	r4, [r2, #-60]
    519c:	2201      	movs	r2, #1
                for (int i = 0; i < pos; i++) pdata[psize++] = packet[i];
    519e:	189c      	adds	r4, r3, r2
    51a0:	f10d 0948 	add.w	r9, sp, #72	; 0x48
    51a4:	fa59 f484 	uxtab	r4, r9, r4
    51a8:	3201      	adds	r2, #1
    51aa:	f817 8b01 	ldrb.w	r8, [r7], #1
    51ae:	f804 8c3c 	strb.w	r8, [r4, #-60]
    51b2:	2a08      	cmp	r2, #8
    51b4:	d1f3      	bne.n	519e <_SysExData::pack()+0x3e>
    51b6:	3308      	adds	r3, #8
                pos = 0;
    51b8:	2200      	movs	r2, #0
                for (int i = 0; i < pos; i++) pdata[psize++] = packet[i];
    51ba:	b2db      	uxtb	r3, r3
                packbyte = 0;
    51bc:	4614      	mov	r4, r2
            if (c & 0x80) {
    51be:	0637      	lsls	r7, r6, #24
                packbyte += (1 << pos);
    51c0:	bf44      	itt	mi
    51c2:	fa0e f702 	lslmi.w	r7, lr, r2
    51c6:	19e4      	addmi	r4, r4, r7
                c &= 0x7f;
            }
            packet[pos] = c;
    51c8:	f102 0748 	add.w	r7, r2, #72	; 0x48
    51cc:	446f      	add	r7, sp
                c &= 0x7f;
    51ce:	bf44      	itt	mi
    51d0:	f006 067f 	andmi.w	r6, r6, #127	; 0x7f
                packbyte += (1 << pos);
    51d4:	b2e4      	uxtbmi	r4, r4
            pos++;
    51d6:	3201      	adds	r2, #1
            if ((psize + 8) > SYSEX_DATA_MAX_SIZE) break;
    51d8:	2b34      	cmp	r3, #52	; 0x34
            packet[pos] = c;
    51da:	f807 6c44 	strb.w	r6, [r7, #-68]
            pos++;
    51de:	b2d2      	uxtb	r2, r2
            if ((psize + 8) > SYSEX_DATA_MAX_SIZE) break;
    51e0:	d9cf      	bls.n	5182 <_SysExData::pack()+0x22>
        }
        pdata[psize++] = packbyte;
    51e2:	1c58      	adds	r0, r3, #1
    51e4:	3348      	adds	r3, #72	; 0x48
    51e6:	446b      	add	r3, sp
    51e8:	b2c0      	uxtb	r0, r0
    51ea:	f803 4c3c 	strb.w	r4, [r3, #-60]
        for (int i = 0; i < pos; i++) pdata[psize++] = packet[i];
    51ee:	ac01      	add	r4, sp, #4
    51f0:	2300      	movs	r3, #0
    51f2:	18c1      	adds	r1, r0, r3
    51f4:	429a      	cmp	r2, r3
    51f6:	b2c9      	uxtb	r1, r1
    51f8:	dc07      	bgt.n	520a <_SysExData::pack()+0xaa>
        _SysExData packed;
        packed.set_data(psize, pdata);
    51fa:	4628      	mov	r0, r5
    51fc:	aa03      	add	r2, sp, #12
    51fe:	f7ff ffa3 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        return packed;
    }
    5202:	4628      	mov	r0, r5
    5204:	b013      	add	sp, #76	; 0x4c
    5206:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        for (int i = 0; i < pos; i++) pdata[psize++] = packet[i];
    520a:	3148      	adds	r1, #72	; 0x48
    520c:	4469      	add	r1, sp
    520e:	f814 6b01 	ldrb.w	r6, [r4], #1
    5212:	f801 6c3c 	strb.w	r6, [r1, #-60]
    5216:	3301      	adds	r3, #1
    5218:	e7eb      	b.n	51f2 <_SysExData::pack()+0x92>
    521a:	Address 0x000000000000521a is out of bounds.


0000521c <SystemExclusiveHandler::ListenForSysEx()>:
     * calls OnReceiveSysEx().
     *
     * IMPORTANT! Do not use ListenForSysEx() in apps that use MIDI in, because ListenForSysEx()
     * will devour most of the incoming MIDI events, and MIDI in won't work.
     */
    bool ListenForSysEx() {
    521c:	b510      	push	{r4, lr}
    521e:	4604      	mov	r4, r0
        void send_now(void) __attribute__((always_inline)) {
		usb_midi_flush_output();
	}
        uint8_t analog2velocity(uint16_t val, uint8_t range);
        bool read(uint8_t channel=0) __attribute__((always_inline)) {
		return usb_midi_read(channel);
    5220:	2000      	movs	r0, #0
    5222:	f015 fe77 	bl	1af14 <usb_midi_read>
        bool heard_sysex = 0;
        if (usbMIDI.read()) {
    5226:	b140      	cbz	r0, 523a <SystemExclusiveHandler::ListenForSysEx()+0x1e>
	}
        uint8_t getType(void) __attribute__((always_inline)) {
                return usb_midi_msg_type;
    5228:	4b05      	ldr	r3, [pc, #20]	; (5240 <SystemExclusiveHandler::ListenForSysEx()+0x24>)
            if (usbMIDI.getType() == 7) {
    522a:	781b      	ldrb	r3, [r3, #0]
    522c:	2b07      	cmp	r3, #7
    522e:	d105      	bne.n	523c <SystemExclusiveHandler::ListenForSysEx()+0x20>
                OnReceiveSysEx();
    5230:	6823      	ldr	r3, [r4, #0]
    5232:	4620      	mov	r0, r4
    5234:	685b      	ldr	r3, [r3, #4]
    5236:	4798      	blx	r3
    5238:	2001      	movs	r0, #1
                heard_sysex = 1;
            }
        }
        return heard_sysex;
    }
    523a:	bd10      	pop	{r4, pc}
        bool heard_sysex = 0;
    523c:	2000      	movs	r0, #0
    523e:	e7fc      	b.n	523a <SystemExclusiveHandler::ListenForSysEx()+0x1e>
    5240:	20006884 	.word	0x20006884

00005244 <Backup_isr()>:
        if (receiving) ListenForSysEx();
    5244:	4803      	ldr	r0, [pc, #12]	; (5254 <Backup_isr()+0x10>)
void Backup_isr() {Backup_instance.Controller();}
    5246:	b508      	push	{r3, lr}
        if (receiving) ListenForSysEx();
    5248:	7983      	ldrb	r3, [r0, #6]
    524a:	b10b      	cbz	r3, 5250 <Backup_isr()+0xc>
    524c:	f7ff ffe6 	bl	521c <SystemExclusiveHandler::ListenForSysEx()>
void Backup_isr() {Backup_instance.Controller();}
    5250:	bd08      	pop	{r3, pc}
    5252:	bf00      	nop
    5254:	1fffb1c0 	.word	0x1fffb1c0

00005258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>:

    void SendSysEx(PackedData packed, char target_id) {
    5258:	b084      	sub	sp, #16
    525a:	b500      	push	{lr}
    525c:	b091      	sub	sp, #68	; 0x44
    525e:	a813      	add	r0, sp, #76	; 0x4c
    5260:	e880 000e 	stmia.w	r0, {r1, r2, r3}
        uint8_t sysex[SYSEX_DATA_MAX_SIZE];
        uint8_t size = 0;
        sysex[size++] = 0xf0;      // Start of exclusive
    5264:	f647 53f0 	movw	r3, #32240	; 0x7df0
    5268:	f8ad 3004 	strh.w	r3, [sp, #4]
        sysex[size++] = 0x7d;      // Non-Commercial Manufacturer
        sysex[size++] = 0x62;      // Beige Maze
    526c:	2362      	movs	r3, #98	; 0x62
    526e:	f88d 3006 	strb.w	r3, [sp, #6]
        sysex[size++] = target_id; // Target product
    5272:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
    5276:	f88d 3007 	strb.w	r3, [sp, #7]
        for (uint8_t i = 0; i < packed.size; i++)
    527a:	4608      	mov	r0, r1
        sysex[size++] = target_id; // Target product
    527c:	2104      	movs	r1, #4
        for (uint8_t i = 0; i < packed.size; i++)
    527e:	1f0b      	subs	r3, r1, #4
        {
            sysex[size++] = packed.data[i];
    5280:	460a      	mov	r2, r1
        for (uint8_t i = 0; i < packed.size; i++)
    5282:	b2db      	uxtb	r3, r3
            sysex[size++] = packed.data[i];
    5284:	3101      	adds	r1, #1
    5286:	3240      	adds	r2, #64	; 0x40
        for (uint8_t i = 0; i < packed.size; i++)
    5288:	4283      	cmp	r3, r0
            sysex[size++] = packed.data[i];
    528a:	b2c9      	uxtb	r1, r1
    528c:	446a      	add	r2, sp
        for (uint8_t i = 0; i < packed.size; i++)
    528e:	db0d      	blt.n	52ac <SystemExclusiveHandler::SendSysEx(_SysExData, char)+0x54>
        }
        sysex[size++] = 0xf7; // End of exclusive
    5290:	23f7      	movs	r3, #247	; 0xf7
    5292:	f802 3c3c 	strb.w	r3, [r2, #-60]
			usb_midi_send_sysex_add_term_bytes(data, length, cable);
    5296:	a801      	add	r0, sp, #4
    5298:	2200      	movs	r2, #0
    529a:	f015 fdcf 	bl	1ae3c <usb_midi_send_sysex_add_term_bytes>
		usb_midi_flush_output();
    529e:	f015 fe21 	bl	1aee4 <usb_midi_flush_output>
        usbMIDI.sendSysEx(size, sysex);
        usbMIDI.send_now();
    }
    52a2:	b011      	add	sp, #68	; 0x44
    52a4:	f85d eb04 	ldr.w	lr, [sp], #4
    52a8:	b004      	add	sp, #16
    52aa:	4770      	bx	lr
            sysex[size++] = packed.data[i];
    52ac:	3348      	adds	r3, #72	; 0x48
    52ae:	446b      	add	r3, sp
    52b0:	7a1b      	ldrb	r3, [r3, #8]
    52b2:	f802 3c3c 	strb.w	r3, [r2, #-60]
        for (uint8_t i = 0; i < packed.size; i++)
    52b6:	e7e2      	b.n	527e <SystemExclusiveHandler::SendSysEx(_SysExData, char)+0x26>

000052b8 <Backup::OnSendSysEx()>:
    void OnSendSysEx() {
    52b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if (!receiving) {
    52bc:	7983      	ldrb	r3, [r0, #6]
    void OnSendSysEx() {
    52be:	b0b9      	sub	sp, #228	; 0xe4
    52c0:	4680      	mov	r8, r0
        if (!receiving) {
    52c2:	b973      	cbnz	r3, 52e2 <Backup::OnSendSysEx()+0x2a>
            packet = 0;
    52c4:	71c3      	strb	r3, [r0, #7]
            byte start = calibration ? 0 : (EEPROM_CALIBRATIONDATA_END / 32);
    52c6:	7943      	ldrb	r3, [r0, #5]
    52c8:	2b00      	cmp	r3, #0
    52ca:	bf15      	itete	ne
    52cc:	2700      	movne	r7, #0
    52ce:	2704      	moveq	r7, #4
    52d0:	f04f 0a04 	movne.w	sl, #4
    52d4:	f04f 0a40 	moveq.w	sl, #64	; 0x40
            for (byte p = start; p < end; p++)
    52d8:	017e      	lsls	r6, r7, #5
                PackedData packed = unpacked.pack();
    52da:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
            for (byte p = start; p < end; p++)
    52de:	4557      	cmp	r7, sl
    52e0:	d102      	bne.n	52e8 <Backup::OnSendSysEx()+0x30>
    }
    52e2:	b039      	add	sp, #228	; 0xe4
    52e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                V[ix++] = p; // Packet number
    52e8:	ad0f      	add	r5, sp, #60	; 0x3c
    52ea:	f106 0420 	add.w	r4, r6, #32
    52ee:	f88d 703c 	strb.w	r7, [sp, #60]	; 0x3c
                packet = p;
    52f2:	f888 7007 	strb.w	r7, [r8, #7]
                for (byte b = 0; b < 32; b++) V[ix++] = EEPROM.read(address++);
    52f6:	46ab      	mov	fp, r5
    52f8:	b2a4      	uxth	r4, r4
    52fa:	4630      	mov	r0, r6
    52fc:	f014 fe3e 	bl	19f7c <eeprom_read_byte>
    5300:	3601      	adds	r6, #1
    5302:	b2b6      	uxth	r6, r6
    5304:	42a6      	cmp	r6, r4
    5306:	f805 0f01 	strb.w	r0, [r5, #1]!
    530a:	d1f6      	bne.n	52fa <Backup::OnSendSysEx()+0x42>
                unpacked.set_data(ix, V);
    530c:	465a      	mov	r2, fp
    530e:	2121      	movs	r1, #33	; 0x21
    5310:	a818      	add	r0, sp, #96	; 0x60
    5312:	f7ff ff19 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
                PackedData packed = unpacked.pack();
    5316:	a918      	add	r1, sp, #96	; 0x60
    5318:	4648      	mov	r0, r9
    531a:	f7ff ff21 	bl	5160 <_SysExData::pack()>
                SendSysEx(packed, 'B');
    531e:	2342      	movs	r3, #66	; 0x42
    5320:	930d      	str	r3, [sp, #52]	; 0x34
    5322:	ad2b      	add	r5, sp, #172	; 0xac
    5324:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5326:	466c      	mov	r4, sp
    5328:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    532a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    532c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    532e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5330:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5332:	682b      	ldr	r3, [r5, #0]
    5334:	6023      	str	r3, [r4, #0]
    5336:	e899 000e 	ldmia.w	r9, {r1, r2, r3}
    533a:	4640      	mov	r0, r8
            for (byte p = start; p < end; p++)
    533c:	3701      	adds	r7, #1
                SendSysEx(packed, 'B');
    533e:	f7ff ff8b 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
            for (byte p = start; p < end; p++)
    5342:	b2ff      	uxtb	r7, r7
    5344:	e7cb      	b.n	52de <Backup::OnSendSysEx()+0x26>
    5346:	Address 0x0000000000005346 is out of bounds.


00005348 <Backup_handleButtonEvent(UI::Event const&)>:
void Backup_handleButtonEvent(const UI::Event &event) {
    5348:	b508      	push	{r3, lr}
    if (event.type == UI::EVENT_BUTTON_PRESS) {
    534a:	7803      	ldrb	r3, [r0, #0]
    534c:	2b01      	cmp	r3, #1
    534e:	d109      	bne.n	5364 <Backup_handleButtonEvent(UI::Event const&)+0x1c>
    5350:	8843      	ldrh	r3, [r0, #2]
        if (event.control == OC::CONTROL_BUTTON_L) Backup_instance.ToggleReceiveMode();
    5352:	2b04      	cmp	r3, #4
    5354:	d107      	bne.n	5366 <Backup_handleButtonEvent(UI::Event const&)+0x1e>
        receiving = 1 - receiving;
    5356:	4b07      	ldr	r3, [pc, #28]	; (5374 <Backup_handleButtonEvent(UI::Event const&)+0x2c>)
    5358:	799a      	ldrb	r2, [r3, #6]
    535a:	f082 0201 	eor.w	r2, r2, #1
    535e:	719a      	strb	r2, [r3, #6]
        packet = 0;
    5360:	2200      	movs	r2, #0
    5362:	71da      	strb	r2, [r3, #7]
        if (event.control == OC::CONTROL_BUTTON_R) Backup_instance.OnSendSysEx();
    }
}
    5364:	bd08      	pop	{r3, pc}
        if (event.control == OC::CONTROL_BUTTON_R) Backup_instance.OnSendSysEx();
    5366:	2b08      	cmp	r3, #8
    5368:	d1fc      	bne.n	5364 <Backup_handleButtonEvent(UI::Event const&)+0x1c>
    536a:	4802      	ldr	r0, [pc, #8]	; (5374 <Backup_handleButtonEvent(UI::Event const&)+0x2c>)
    536c:	f7ff ffa4 	bl	52b8 <Backup::OnSendSysEx()>
}
    5370:	e7f8      	b.n	5364 <Backup_handleButtonEvent(UI::Event const&)+0x1c>
    5372:	bf00      	nop
    5374:	1fffb1c0 	.word	0x1fffb1c0

00005378 <NeuralNetwork::OnSendSysEx()>:
    void OnSendSysEx() {
    5378:	b5f0      	push	{r4, r5, r6, r7, lr}
            byte ni = (setup * 6) + n;
    537a:	f890 33f0 	ldrb.w	r3, [r0, #1008]	; 0x3f0
    void OnSendSysEx() {
    537e:	b0b9      	sub	sp, #228	; 0xe4
    5380:	4605      	mov	r5, r0
            byte ni = (setup * 6) + n;
    5382:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    5386:	0040      	lsls	r0, r0, #1
    5388:	ac0e      	add	r4, sp, #56	; 0x38
    538a:	b2c0      	uxtb	r0, r0
    538c:	2600      	movs	r6, #0
    538e:	4622      	mov	r2, r4
            V[ix++] = (neuron[ni].type << 4) | neuron[ni].source1;
    5390:	f04f 0c24 	mov.w	ip, #36	; 0x24
            byte ni = (setup * 6) + n;
    5394:	1981      	adds	r1, r0, r6
            V[ix++] = (neuron[ni].type << 4) | neuron[ni].source1;
    5396:	b2c9      	uxtb	r1, r1
    5398:	fb0c 5101 	mla	r1, ip, r1, r5
        for (byte n = 0; n < 6; n++)
    539c:	3601      	adds	r6, #1
            V[ix++] = (neuron[ni].type << 4) | neuron[ni].source1;
    539e:	f8d1 e400 	ldr.w	lr, [r1, #1024]	; 0x400
    53a2:	f8d1 7404 	ldr.w	r7, [r1, #1028]	; 0x404
    53a6:	ea47 170e 	orr.w	r7, r7, lr, lsl #4
    53aa:	7027      	strb	r7, [r4, #0]
            V[ix++] = (neuron[ni].source2 << 4) | neuron[ni].source3;
    53ac:	f8d1 e408 	ldr.w	lr, [r1, #1032]	; 0x408
    53b0:	f8d1 740c 	ldr.w	r7, [r1, #1036]	; 0x40c
    53b4:	ea47 170e 	orr.w	r7, r7, lr, lsl #4
    53b8:	7067      	strb	r7, [r4, #1]
            V[ix++] = neuron[ni].weight1 + 128;
    53ba:	f8d1 7410 	ldr.w	r7, [r1, #1040]	; 0x410
    53be:	3f80      	subs	r7, #128	; 0x80
    53c0:	70a7      	strb	r7, [r4, #2]
            V[ix++] = neuron[ni].weight2 + 128;
    53c2:	f8d1 7414 	ldr.w	r7, [r1, #1044]	; 0x414
    53c6:	3f80      	subs	r7, #128	; 0x80
    53c8:	70e7      	strb	r7, [r4, #3]
            V[ix++] = neuron[ni].weight3 + 128;
    53ca:	f8d1 7418 	ldr.w	r7, [r1, #1048]	; 0x418
            V[ix++] = neuron[ni].threshold + 128;
    53ce:	f8d1 141c 	ldr.w	r1, [r1, #1052]	; 0x41c
            V[ix++] = neuron[ni].weight3 + 128;
    53d2:	3f80      	subs	r7, #128	; 0x80
            V[ix++] = neuron[ni].threshold + 128;
    53d4:	3980      	subs	r1, #128	; 0x80
        for (byte n = 0; n < 6; n++)
    53d6:	2e06      	cmp	r6, #6
            V[ix++] = neuron[ni].weight3 + 128;
    53d8:	7127      	strb	r7, [r4, #4]
            V[ix++] = neuron[ni].threshold + 128;
    53da:	7161      	strb	r1, [r4, #5]
        for (byte n = 0; n < 6; n++)
    53dc:	f104 0406 	add.w	r4, r4, #6
    53e0:	d1d8      	bne.n	5394 <NeuralNetwork::OnSendSysEx()+0x1c>
        V[ix++] = (output_neuron[o] << 4) | output_neuron[o + 1];
    53e2:	011b      	lsls	r3, r3, #4
    53e4:	f403 737c 	and.w	r3, r3, #1008	; 0x3f0
    53e8:	442b      	add	r3, r5
        PackedData packed = unpacked.pack();
    53ea:	af28      	add	r7, sp, #160	; 0xa0
        V[ix++] = (output_neuron[o] << 4) | output_neuron[o + 1];
    53ec:	f8d3 075c 	ldr.w	r0, [r3, #1884]	; 0x75c
    53f0:	f8d3 1760 	ldr.w	r1, [r3, #1888]	; 0x760
    53f4:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
    53f8:	f88d 105c 	strb.w	r1, [sp, #92]	; 0x5c
        V[ix++] = (output_neuron[o + 2] << 4) | output_neuron[o + 3];
    53fc:	f8d3 1764 	ldr.w	r1, [r3, #1892]	; 0x764
    5400:	f8d3 3768 	ldr.w	r3, [r3, #1896]	; 0x768
        unpacked.set_data(ix, V);
    5404:	a818      	add	r0, sp, #96	; 0x60
        V[ix++] = (output_neuron[o + 2] << 4) | output_neuron[o + 3];
    5406:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
        unpacked.set_data(ix, V);
    540a:	2126      	movs	r1, #38	; 0x26
        V[ix++] = (output_neuron[o + 2] << 4) | output_neuron[o + 3];
    540c:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
        unpacked.set_data(ix, V);
    5410:	f7ff fe9a 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        PackedData packed = unpacked.pack();
    5414:	a918      	add	r1, sp, #96	; 0x60
    5416:	4638      	mov	r0, r7
    5418:	f7ff fea2 	bl	5160 <_SysExData::pack()>
        SendSysEx(packed, 'N');
    541c:	234e      	movs	r3, #78	; 0x4e
    541e:	930d      	str	r3, [sp, #52]	; 0x34
    5420:	ae2b      	add	r6, sp, #172	; 0xac
    5422:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    5424:	466c      	mov	r4, sp
    5426:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5428:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    542a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    542c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    542e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5430:	6833      	ldr	r3, [r6, #0]
    5432:	6023      	str	r3, [r4, #0]
    5434:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
    5438:	f105 0080 	add.w	r0, r5, #128	; 0x80
    543c:	f7ff ff0c 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
    }
    5440:	b039      	add	sp, #228	; 0xe4
    5442:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005444 <non-virtual thunk to NeuralNetwork::OnSendSysEx()>:
    void OnSendSysEx() {
    5444:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    5448:	e796      	b.n	5378 <NeuralNetwork::OnSendSysEx()>
    544a:	Address 0x000000000000544a is out of bounds.


0000544c <ScaleEditor::OnSendSysEx()>:
        if (import_mode) DrawImportScreen();
        else DrawInterface();
    }

    /* Send SysEx on app suspend and when the left encoder is pressed */
    void OnSendSysEx() { // Left Enc Push
    544c:	b5f0      	push	{r4, r5, r6, r7, lr}
        uint8_t V[35];
        int ix = 0;

        // Encode span
        uint16_t span = static_cast<uint16_t>(OC::user_scales[current_scale].span);
    544e:	f990 2086 	ldrsb.w	r2, [r0, #134]	; 0x86
    5452:	4b1c      	ldr	r3, [pc, #112]	; (54c4 <ScaleEditor::OnSendSysEx()+0x78>)
    5454:	2128      	movs	r1, #40	; 0x28
    void OnSendSysEx() { // Left Enc Push
    5456:	4606      	mov	r6, r0
    5458:	fb01 f002 	mul.w	r0, r1, r2
    545c:	18c4      	adds	r4, r0, r3
    545e:	b0b9      	sub	sp, #228	; 0xe4
    5460:	5a18      	ldrh	r0, [r3, r0]
        V[ix++] = span & 0xff; // Low byte
    5462:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
        V[ix++] = (span >> 8) & 0xff; // High byte

        // Encode length
        V[ix++] = static_cast<uint8_t>(OC::user_scales[current_scale].num_notes);
    5466:	4623      	mov	r3, r4
    5468:	6860      	ldr	r0, [r4, #4]
    546a:	f88d 003e 	strb.w	r0, [sp, #62]	; 0x3e

        // Encode values
        for (int i = 0; i < 16; i++)
    546e:	ac0f      	add	r4, sp, #60	; 0x3c
    5470:	3306      	adds	r3, #6
        V[ix++] = static_cast<uint8_t>(OC::user_scales[current_scale].num_notes);
    5472:	2103      	movs	r1, #3
    5474:	4622      	mov	r2, r4
        {
            uint16_t note = static_cast<uint16_t>(OC::user_scales[current_scale].notes[i]);
    5476:	f933 0f02 	ldrsh.w	r0, [r3, #2]!
            V[ix++] = note & 0xff; // Low
    547a:	70e0      	strb	r0, [r4, #3]
            V[ix++] = (note >> 8) & 0xff; // High
    547c:	3102      	adds	r1, #2
    547e:	f3c0 2007 	ubfx	r0, r0, #8, #8
        for (int i = 0; i < 16; i++)
    5482:	2923      	cmp	r1, #35	; 0x23
            V[ix++] = (note >> 8) & 0xff; // High
    5484:	7120      	strb	r0, [r4, #4]
        for (int i = 0; i < 16; i++)
    5486:	f104 0402 	add.w	r4, r4, #2
    548a:	d1f4      	bne.n	5476 <ScaleEditor::OnSendSysEx()+0x2a>
        }

        UnpackedData unpacked;
        unpacked.set_data(ix, V);
    548c:	a818      	add	r0, sp, #96	; 0x60
        PackedData packed = unpacked.pack();
    548e:	af28      	add	r7, sp, #160	; 0xa0
        unpacked.set_data(ix, V);
    5490:	f7ff fe5a 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        PackedData packed = unpacked.pack();
    5494:	a918      	add	r1, sp, #96	; 0x60
    5496:	4638      	mov	r0, r7
    5498:	f7ff fe62 	bl	5160 <_SysExData::pack()>
        SendSysEx(packed, 'E');
    549c:	2345      	movs	r3, #69	; 0x45
    549e:	930d      	str	r3, [sp, #52]	; 0x34
    54a0:	ad2b      	add	r5, sp, #172	; 0xac
    54a2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    54a4:	466c      	mov	r4, sp
    54a6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    54a8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    54aa:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    54ac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    54ae:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    54b0:	682b      	ldr	r3, [r5, #0]
    54b2:	6023      	str	r3, [r4, #0]
    54b4:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
    54b8:	f106 0080 	add.w	r0, r6, #128	; 0x80
    54bc:	f7ff fecc 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
    }
    54c0:	b039      	add	sp, #228	; 0xe4
    54c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    54c4:	1fffa728 	.word	0x1fffa728

000054c8 <non-virtual thunk to ScaleEditor::OnSendSysEx()>:
    void OnSendSysEx() { // Left Enc Push
    54c8:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    54cc:	e7be      	b.n	544c <ScaleEditor::OnSendSysEx()>
    54ce:	bf00      	nop

000054d0 <SCALEEDITOR_handleAppEvent(OC::AppEvent)>:

void SCALEEDITOR_isr() {
	return scale_editor_instance.BaseController();
}

void SCALEEDITOR_handleAppEvent(OC::AppEvent event) {
    54d0:	b508      	push	{r3, lr}
    if (event == OC::APP_EVENT_SUSPEND) {
    54d2:	b910      	cbnz	r0, 54da <SCALEEDITOR_handleAppEvent(OC::AppEvent)+0xa>
        scale_editor_instance.OnSendSysEx();
    54d4:	4801      	ldr	r0, [pc, #4]	; (54dc <SCALEEDITOR_handleAppEvent(OC::AppEvent)+0xc>)
    54d6:	f7ff ffb9 	bl	544c <ScaleEditor::OnSendSysEx()>
    }
}
    54da:	bd08      	pop	{r3, pc}
    54dc:	20005a5c 	.word	0x20005a5c

000054e0 <WaveformEditor::OnSendSysEx()>:
        gfxHeader("Waveform Editor");
        if (add_delete_confirm) DrawAddDelete();
        else DrawInterface();
    }

    void OnSendSysEx() { // Left Enc Push
    54e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    54e4:	f8df 806c 	ldr.w	r8, [pc, #108]	; 5554 <WaveformEditor::OnSendSysEx()+0x74>
    54e8:	b0b9      	sub	sp, #228	; 0xe4
    54ea:	4681      	mov	r9, r0
    54ec:	2600      	movs	r6, #0
                V[ix++] = HS::user_waveforms[seg_ix].time;
            }

            UnpackedData unpacked;
            unpacked.set_data(ix, V);
            PackedData packed = unpacked.pack();
    54ee:	af28      	add	r7, sp, #160	; 0xa0
            V[ix++] = gr; // Add the group number, for future decoding
    54f0:	a80f      	add	r0, sp, #60	; 0x3c
    54f2:	f88d 603c 	strb.w	r6, [sp, #60]	; 0x3c
    54f6:	4643      	mov	r3, r8
    54f8:	2101      	movs	r1, #1
    54fa:	4602      	mov	r2, r0
                V[ix++] = HS::user_waveforms[seg_ix].level;
    54fc:	781c      	ldrb	r4, [r3, #0]
    54fe:	7044      	strb	r4, [r0, #1]
                V[ix++] = HS::user_waveforms[seg_ix].time;
    5500:	3102      	adds	r1, #2
    5502:	785c      	ldrb	r4, [r3, #1]
    5504:	f800 4f02 	strb.w	r4, [r0, #2]!
            for (byte s = 0; s < 16; s++)
    5508:	2921      	cmp	r1, #33	; 0x21
    550a:	f103 0302 	add.w	r3, r3, #2
    550e:	d1f5      	bne.n	54fc <WaveformEditor::OnSendSysEx()+0x1c>
            unpacked.set_data(ix, V);
    5510:	a818      	add	r0, sp, #96	; 0x60
    5512:	f7ff fe19 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
            PackedData packed = unpacked.pack();
    5516:	a918      	add	r1, sp, #96	; 0x60
    5518:	4638      	mov	r0, r7
    551a:	f7ff fe21 	bl	5160 <_SysExData::pack()>
            SendSysEx(packed, 'W');
    551e:	2357      	movs	r3, #87	; 0x57
    5520:	930d      	str	r3, [sp, #52]	; 0x34
    5522:	ad2b      	add	r5, sp, #172	; 0xac
    5524:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5526:	466c      	mov	r4, sp
    5528:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    552a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    552c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    552e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5530:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5532:	682b      	ldr	r3, [r5, #0]
    5534:	6023      	str	r3, [r4, #0]
    5536:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
    553a:	f109 0080 	add.w	r0, r9, #128	; 0x80
        for (byte gr = 0; gr < 4; gr++)
    553e:	3601      	adds	r6, #1
            SendSysEx(packed, 'W');
    5540:	f7ff fe8a 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
        for (byte gr = 0; gr < 4; gr++)
    5544:	2e04      	cmp	r6, #4
    5546:	f108 0808 	add.w	r8, r8, #8
    554a:	d1d1      	bne.n	54f0 <WaveformEditor::OnSendSysEx()+0x10>
        }
    }
    554c:	b039      	add	sp, #228	; 0xe4
    554e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5552:	bf00      	nop
    5554:	20003668 	.word	0x20003668

00005558 <non-virtual thunk to WaveformEditor::OnSendSysEx()>:
    void OnSendSysEx() { // Left Enc Push
    5558:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    555c:	e7c0      	b.n	54e0 <WaveformEditor::OnSendSysEx()>
    555e:	bf00      	nop

00005560 <CaptainMIDI::OnSendSysEx()>:
        uint8_t offset = MIDI_PARAMETER_COUNT * get_setup_number();
    5560:	f8d0 3308 	ldr.w	r3, [r0, #776]	; 0x308
    void OnSendSysEx() {
    5564:	b5f0      	push	{r4, r5, r6, r7, lr}
        uint8_t offset = MIDI_PARAMETER_COUNT * get_setup_number();
    5566:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    556a:	00db      	lsls	r3, r3, #3
    556c:	b2db      	uxtb	r3, r3
    556e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    void OnSendSysEx() {
    5572:	b0b9      	sub	sp, #228	; 0xe4
    5574:	3321      	adds	r3, #33	; 0x21
    5576:	4606      	mov	r6, r0
    5578:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    557c:	a80e      	add	r0, sp, #56	; 0x38
        uint8_t offset = MIDI_PARAMETER_COUNT * get_setup_number();
    557e:	f06f 010f 	mvn.w	r1, #15
    5582:	4602      	mov	r2, r0
            int p = values_[i + offset];
    5584:	f853 4f04 	ldr.w	r4, [r3, #4]!
            if (i > 15 && i < 24) p += 24; // These are signed, so they need to be converted
    5588:	2907      	cmp	r1, #7
        for (int i = 0; i < MIDI_PARAMETER_COUNT; i++)
    558a:	f101 0101 	add.w	r1, r1, #1
            if (i > 15 && i < 24) p += 24; // These are signed, so they need to be converted
    558e:	bf98      	it	ls
    5590:	3418      	addls	r4, #24
        for (int i = 0; i < MIDI_PARAMETER_COUNT; i++)
    5592:	2918      	cmp	r1, #24
            V[i] = static_cast<uint8_t>(p);
    5594:	f800 4b01 	strb.w	r4, [r0], #1
        for (int i = 0; i < MIDI_PARAMETER_COUNT; i++)
    5598:	d1f4      	bne.n	5584 <CaptainMIDI::OnSendSysEx()+0x24>
        unpacked.set_data(40, V);
    559a:	a818      	add	r0, sp, #96	; 0x60
        PackedData packed = unpacked.pack();
    559c:	af28      	add	r7, sp, #160	; 0xa0
        unpacked.set_data(40, V);
    559e:	2128      	movs	r1, #40	; 0x28
    55a0:	f7ff fdd2 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        PackedData packed = unpacked.pack();
    55a4:	a918      	add	r1, sp, #96	; 0x60
    55a6:	4638      	mov	r0, r7
    55a8:	f7ff fdda 	bl	5160 <_SysExData::pack()>
        SendSysEx(packed, 'M');
    55ac:	234d      	movs	r3, #77	; 0x4d
    55ae:	930d      	str	r3, [sp, #52]	; 0x34
    55b0:	ad2b      	add	r5, sp, #172	; 0xac
    55b2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    55b4:	466c      	mov	r4, sp
    55b6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    55b8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    55ba:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    55bc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    55be:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    55c0:	682b      	ldr	r3, [r5, #0]
    55c2:	6023      	str	r3, [r4, #0]
    55c4:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
    55c8:	4630      	mov	r0, r6
    55ca:	f7ff fe45 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
    }
    55ce:	b039      	add	sp, #228	; 0xe4
    55d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    55d2:	Address 0x00000000000055d2 is out of bounds.


000055d4 <MIDI_handleAppEvent(OC::AppEvent)>:

void MIDI_isr() {
	return captain_midi_instance.BaseController();
}

void MIDI_handleAppEvent(OC::AppEvent event) {
    55d4:	b508      	push	{r3, lr}
    if (event == OC::APP_EVENT_SUSPEND) {
    55d6:	b910      	cbnz	r0, 55de <MIDI_handleAppEvent(OC::AppEvent)+0xa>
        captain_midi_instance.OnSendSysEx();
    55d8:	4801      	ldr	r0, [pc, #4]	; (55e0 <MIDI_handleAppEvent(OC::AppEvent)+0xc>)
    55da:	f7ff ffc1 	bl	5560 <CaptainMIDI::OnSendSysEx()>
    }
}
    55de:	bd08      	pop	{r3, pc}
    55e0:	200046ec 	.word	0x200046ec

000055e4 <TheDarkestTimeline::OnSendSysEx()>:
    void OnSendSysEx() {
    55e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    55e8:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 56d4 <TheDarkestTimeline::OnSendSysEx()+0xf0>
    55ec:	b0b9      	sub	sp, #228	; 0xe4
    55ee:	4605      	mov	r5, r0
        for (int page = 0; page < 4; page++)
    55f0:	2700      	movs	r7, #0
            PackedData packed = unpacked.pack();
    55f2:	ae28      	add	r6, sp, #160	; 0xa0
            V[ix++] = (uint8_t)values_[DT_LENGTH]; // Store length and index with each page (legacy 1.3 support)
    55f4:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
    55f8:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
            V[ix++] = (uint8_t)values_[DT_INDEX];
    55fc:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    5600:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
    5604:	ab0f      	add	r3, sp, #60	; 0x3c
            V[ix++] = (char)page;
    5606:	f88d 703c 	strb.w	r7, [sp, #60]	; 0x3c
            V[ix++] = (uint8_t)values_[DT_INDEX];
    560a:	4640      	mov	r0, r8
    560c:	2103      	movs	r1, #3
    560e:	469b      	mov	fp, r3
                uint16_t cv = OC::user_patterns[page].notes[b];
    5610:	f930 2b02 	ldrsh.w	r2, [r0], #2
                V[ix++] = cv & 0xff; // Low byte
    5614:	70da      	strb	r2, [r3, #3]
                V[ix++] = (cv >> 8) & 0xff; // High byte
    5616:	3102      	adds	r1, #2
    5618:	f3c2 2207 	ubfx	r2, r2, #8, #8
            for (int b = 0; b < 16; b++)
    561c:	2923      	cmp	r1, #35	; 0x23
                V[ix++] = (cv >> 8) & 0xff; // High byte
    561e:	711a      	strb	r2, [r3, #4]
            for (int b = 0; b < 16; b++)
    5620:	f103 0302 	add.w	r3, r3, #2
    5624:	d1f4      	bne.n	5610 <TheDarkestTimeline::OnSendSysEx()+0x2c>
            unpacked.set_data(ix, V);
    5626:	465a      	mov	r2, fp
    5628:	a818      	add	r0, sp, #96	; 0x60
    562a:	f7ff fd8d 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
            SendSysEx(packed, 'D');
    562e:	f04f 0a44 	mov.w	sl, #68	; 0x44
            PackedData packed = unpacked.pack();
    5632:	a918      	add	r1, sp, #96	; 0x60
    5634:	4630      	mov	r0, r6
    5636:	f7ff fd93 	bl	5160 <_SysExData::pack()>
            SendSysEx(packed, 'D');
    563a:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
    563e:	f10d 0cac 	add.w	ip, sp, #172	; 0xac
    5642:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    5646:	466c      	mov	r4, sp
    5648:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    564a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    564e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5650:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    5654:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5656:	f8dc 3000 	ldr.w	r3, [ip]
    565a:	6023      	str	r3, [r4, #0]
    565c:	f105 0980 	add.w	r9, r5, #128	; 0x80
    5660:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
    5664:	4648      	mov	r0, r9
        for (int page = 0; page < 4; page++)
    5666:	3701      	adds	r7, #1
            SendSysEx(packed, 'D');
    5668:	f7ff fdf6 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
        for (int page = 0; page < 4; page++)
    566c:	2f04      	cmp	r7, #4
    566e:	f108 0820 	add.w	r8, r8, #32
    5672:	d1bf      	bne.n	55f4 <TheDarkestTimeline::OnSendSysEx()+0x10>
    uint8_t length() {return values_[DT_LENGTH];}
    5674:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
    5678:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
        V[ix++] = static_cast<char>(index());
    567c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    5680:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
    uint8_t scale() {return values_[DT_SCALE];}
    5684:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
    5688:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
        unpacked.set_data(ix, V);
    568c:	465a      	mov	r2, fp
    uint8_t root() {return values_[DT_ROOT];}
    568e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
    5692:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
        unpacked.set_data(ix, V);
    5696:	a818      	add	r0, sp, #96	; 0x60
    5698:	2105      	movs	r1, #5
        V[ix++] = static_cast<char>(4); // Page 4
    569a:	f88d 703c 	strb.w	r7, [sp, #60]	; 0x3c
        unpacked.set_data(ix, V);
    569e:	f7ff fd53 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        PackedData packed = unpacked.pack();
    56a2:	a918      	add	r1, sp, #96	; 0x60
    56a4:	4630      	mov	r0, r6
    56a6:	f7ff fd5b 	bl	5160 <_SysExData::pack()>
        SendSysEx(packed, 'D');
    56aa:	ad2b      	add	r5, sp, #172	; 0xac
    56ac:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
    56b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    56b2:	466c      	mov	r4, sp
    56b4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    56b6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    56b8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    56ba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    56bc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    56be:	682b      	ldr	r3, [r5, #0]
    56c0:	6023      	str	r3, [r4, #0]
    56c2:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
    56c6:	4648      	mov	r0, r9
    56c8:	f7ff fdc6 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
    }
    56cc:	b039      	add	sp, #228	; 0xe4
    56ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    56d2:	bf00      	nop
    56d4:	1fffa628 	.word	0x1fffa628

000056d8 <non-virtual thunk to TheDarkestTimeline::OnSendSysEx()>:
    void OnSendSysEx() {
    56d8:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    56dc:	e782      	b.n	55e4 <TheDarkestTimeline::OnSendSysEx()>
    56de:	bf00      	nop

000056e0 <TheDarkestTimeline_handleAppEvent(OC::AppEvent)>:
void TheDarkestTimeline_isr() {
	return TheDarkestTimeline_instance.BaseController();
}

void TheDarkestTimeline_handleAppEvent(OC::AppEvent event) {
    if (event ==  OC::APP_EVENT_RESUME) {
    56e0:	2801      	cmp	r0, #1
void TheDarkestTimeline_handleAppEvent(OC::AppEvent event) {
    56e2:	b508      	push	{r3, lr}
    if (event ==  OC::APP_EVENT_RESUME) {
    56e4:	d103      	bne.n	56ee <TheDarkestTimeline_handleAppEvent(OC::AppEvent)+0xe>
        TheDarkestTimeline_instance.Resume();
    56e6:	4805      	ldr	r0, [pc, #20]	; (56fc <TheDarkestTimeline_handleAppEvent(OC::AppEvent)+0x1c>)
    56e8:	f7fe fb8a 	bl	3e00 <TheDarkestTimeline::Resume()>
    }
    if (event == OC::APP_EVENT_SUSPEND) {
        TheDarkestTimeline_instance.OnSendSysEx();
    }
}
    56ec:	bd08      	pop	{r3, pc}
    if (event == OC::APP_EVENT_SUSPEND) {
    56ee:	2800      	cmp	r0, #0
    56f0:	d1fc      	bne.n	56ec <TheDarkestTimeline_handleAppEvent(OC::AppEvent)+0xc>
        TheDarkestTimeline_instance.OnSendSysEx();
    56f2:	4802      	ldr	r0, [pc, #8]	; (56fc <TheDarkestTimeline_handleAppEvent(OC::AppEvent)+0x1c>)
    56f4:	f7ff ff76 	bl	55e4 <TheDarkestTimeline::OnSendSysEx()>
}
    56f8:	e7f8      	b.n	56ec <TheDarkestTimeline_handleAppEvent(OC::AppEvent)+0xc>
    56fa:	bf00      	nop
    56fc:	20002444 	.word	0x20002444

00005700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>:

    bool ExtractSysExData(uint8_t *V, char target_id) {
    5700:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        // Get the full sysex dump from the MIDI library
        uint8_t *sysex = usbMIDI.getSysExArray();

        bool verify = (sysex[1] == 0x7d && sysex[2] == 0x62 && sysex[3] == target_id);
    5704:	4b2e      	ldr	r3, [pc, #184]	; (57c0 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0xc0>)
    bool ExtractSysExData(uint8_t *V, char target_id) {
    5706:	4616      	mov	r6, r2
        bool verify = (sysex[1] == 0x7d && sysex[2] == 0x62 && sysex[3] == target_id);
    5708:	785a      	ldrb	r2, [r3, #1]
    570a:	2a7d      	cmp	r2, #125	; 0x7d
    bool ExtractSysExData(uint8_t *V, char target_id) {
    570c:	b0be      	sub	sp, #248	; 0xf8
    570e:	4605      	mov	r5, r0
    5710:	460f      	mov	r7, r1
        bool verify = (sysex[1] == 0x7d && sysex[2] == 0x62 && sysex[3] == target_id);
    5712:	d151      	bne.n	57b8 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0xb8>
    5714:	789a      	ldrb	r2, [r3, #2]
    5716:	2a62      	cmp	r2, #98	; 0x62
    5718:	d14e      	bne.n	57b8 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0xb8>
    571a:	78da      	ldrb	r2, [r3, #3]
    571c:	42b2      	cmp	r2, r6
    571e:	d148      	bne.n	57b2 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0xb2>
    5720:	4668      	mov	r0, sp
    5722:	3303      	adds	r3, #3
    5724:	2100      	movs	r1, #0
    5726:	4602      	mov	r2, r0
            PackedData packed;
            uint8_t psize = 0;
            uint8_t data[SYSEX_DATA_MAX_SIZE];
            for (int i = 0; i < SYSEX_DATA_MAX_SIZE; i++)
            {
                uint8_t b = sysex[i + 4]; // Getting packed bytes past the header
    5728:	f813 4f01 	ldrb.w	r4, [r3, #1]!
                if (b == 0xf7) break;
    572c:	2cf7      	cmp	r4, #247	; 0xf7
    572e:	d005      	beq.n	573c <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0x3c>
                data[psize++] = b;
    5730:	3101      	adds	r1, #1
    5732:	b2c9      	uxtb	r1, r1
            for (int i = 0; i < SYSEX_DATA_MAX_SIZE; i++)
    5734:	293c      	cmp	r1, #60	; 0x3c
                data[psize++] = b;
    5736:	f800 4b01 	strb.w	r4, [r0], #1
            for (int i = 0; i < SYSEX_DATA_MAX_SIZE; i++)
    573a:	d1f5      	bne.n	5728 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0x28>
            }
            packed.set_data(psize, data);
    573c:	a81e      	add	r0, sp, #120	; 0x78
    573e:	f7ff fd03 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        for (int ixp = 0; ixp < size; ixp++)
    5742:	2300      	movs	r3, #0
    5744:	f8dd 8078 	ldr.w	r8, [sp, #120]	; 0x78
    5748:	f10d 0e7b 	add.w	lr, sp, #123	; 0x7b
        uint8_t usize = 0;     /* Unpacked voice size */
    574c:	4619      	mov	r1, r3
        uint8_t pos = 0;       /* Current position of 7 */
    574e:	461c      	mov	r4, r3
        uint8_t packbyte = 0;  /* Composite of high bits of next 7 bytes */
    5750:	4618      	mov	r0, r3
        for (int ixp = 0; ixp < size; ixp++)
    5752:	4543      	cmp	r3, r8
    5754:	db0f      	blt.n	5776 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0x76>
        unpacked.set_data(usize, udata);
    5756:	aa0f      	add	r2, sp, #60	; 0x3c
    5758:	a82e      	add	r0, sp, #184	; 0xb8
    575a:	f7ff fcf5 	bl	5148 <_SysExData::set_data(int, unsigned char*)>

            // Unpack the data and set the value array
            UnpackedData unpacked = packed.unpack();
            for (int i = 0; i < unpacked.size; i++)
            {
                V[i] = unpacked.data[i];
    575e:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    5760:	a92f      	add	r1, sp, #188	; 0xbc
    5762:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    5766:	4638      	mov	r0, r7
    5768:	f014 fc42 	bl	19ff0 <memcpy>
            }
            last_app_code = target_id;
    576c:	712e      	strb	r6, [r5, #4]
        bool verify = (sysex[1] == 0x7d && sysex[2] == 0x62 && sysex[3] == target_id);
    576e:	2001      	movs	r0, #1
            if (sysex[1] == 0x7d && sysex[2] == 0x62) {
                last_app_code = sysex[3];
            } else last_app_code = 0; // Unknown application
        }
        return verify;
    }
    5770:	b03e      	add	sp, #248	; 0xf8
    5772:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            c = data[ixp];
    5776:	f81e 2f01 	ldrb.w	r2, [lr, #1]!
            if (pos == 0) {
    577a:	b194      	cbz	r4, 57a2 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0xa2>
                if (packbyte & (1 << (pos - 1))) {c |= 0x80;}
    577c:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
    5780:	fa40 fc0c 	asr.w	ip, r0, ip
    5784:	f01c 0f01 	tst.w	ip, #1
                udata[usize++] = c;
    5788:	f101 0c01 	add.w	ip, r1, #1
    578c:	f101 01f8 	add.w	r1, r1, #248	; 0xf8
    5790:	4469      	add	r1, sp
                if (packbyte & (1 << (pos - 1))) {c |= 0x80;}
    5792:	bf18      	it	ne
    5794:	f042 0280 	orrne.w	r2, r2, #128	; 0x80
                udata[usize++] = c;
    5798:	f801 2cbc 	strb.w	r2, [r1, #-188]
    579c:	fa5f f18c 	uxtb.w	r1, ip
    57a0:	4602      	mov	r2, r0
            pos++;
    57a2:	3401      	adds	r4, #1
            if (usize > SYSEX_DATA_MAX_SIZE) break;
    57a4:	293d      	cmp	r1, #61	; 0x3d
            pos &= 0x07;
    57a6:	f004 0407 	and.w	r4, r4, #7
            if (usize > SYSEX_DATA_MAX_SIZE) break;
    57aa:	d0d4      	beq.n	5756 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0x56>
        for (int ixp = 0; ixp < size; ixp++)
    57ac:	3301      	adds	r3, #1
    57ae:	4610      	mov	r0, r2
    57b0:	e7cf      	b.n	5752 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0x52>
                last_app_code = sysex[3];
    57b2:	7102      	strb	r2, [r0, #4]
        bool verify = (sysex[1] == 0x7d && sysex[2] == 0x62 && sysex[3] == target_id);
    57b4:	2000      	movs	r0, #0
                last_app_code = sysex[3];
    57b6:	e7db      	b.n	5770 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0x70>
            } else last_app_code = 0; // Unknown application
    57b8:	2000      	movs	r0, #0
    57ba:	7128      	strb	r0, [r5, #4]
    57bc:	e7d8      	b.n	5770 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)+0x70>
    57be:	bf00      	nop
    57c0:	20006760 	.word	0x20006760

000057c4 <WaveformEditor::OnReceiveSysEx()>:

    void OnReceiveSysEx() {
    57c4:	b570      	push	{r4, r5, r6, lr}
    57c6:	b08a      	sub	sp, #40	; 0x28
    57c8:	4604      	mov	r4, r0
        uint8_t V[35];
        if (ExtractSysExData(V, 'W')) {
    57ca:	2257      	movs	r2, #87	; 0x57
    57cc:	a901      	add	r1, sp, #4
    57ce:	3080      	adds	r0, #128	; 0x80
    57d0:	f7ff ff96 	bl	5700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>
    57d4:	b1e8      	cbz	r0, 5812 <WaveformEditor::OnReceiveSysEx()+0x4e>
            int ix = 0;
            byte gr = V[ix++];
            for (byte s = 0; s < 16; s++)
            {
                byte seg_ix = (gr * 4) + s;
    57d6:	f89d 1004 	ldrb.w	r1, [sp, #4]
                HS::user_waveforms[seg_ix].level = V[ix++];
    57da:	4d0f      	ldr	r5, [pc, #60]	; (5818 <WaveformEditor::OnReceiveSysEx()+0x54>)
                byte seg_ix = (gr * 4) + s;
    57dc:	0089      	lsls	r1, r1, #2
    57de:	b2c9      	uxtb	r1, r1
    57e0:	aa01      	add	r2, sp, #4
    57e2:	2000      	movs	r0, #0
    57e4:	180b      	adds	r3, r1, r0
                HS::user_waveforms[seg_ix].level = V[ix++];
    57e6:	b2db      	uxtb	r3, r3
    57e8:	7856      	ldrb	r6, [r2, #1]
    57ea:	f805 6013 	strb.w	r6, [r5, r3, lsl #1]
            for (byte s = 0; s < 16; s++)
    57ee:	3001      	adds	r0, #1
                HS::user_waveforms[seg_ix].time = V[ix++];
    57f0:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    57f4:	f812 6f02 	ldrb.w	r6, [r2, #2]!
    57f8:	705e      	strb	r6, [r3, #1]
            for (byte s = 0; s < 16; s++)
    57fa:	2810      	cmp	r0, #16
    57fc:	d1f2      	bne.n	57e4 <WaveformEditor::OnReceiveSysEx()+0x20>
            }

            waveform_number = 0;
    57fe:	2300      	movs	r3, #0
    5800:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
            Resume();
    5804:	6823      	ldr	r3, [r4, #0]
    5806:	68db      	ldr	r3, [r3, #12]
    5808:	4620      	mov	r0, r4
        }
    }
    580a:	b00a      	add	sp, #40	; 0x28
    580c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            Resume();
    5810:	4718      	bx	r3
    }
    5812:	b00a      	add	sp, #40	; 0x28
    5814:	bd70      	pop	{r4, r5, r6, pc}
    5816:	bf00      	nop
    5818:	20003668 	.word	0x20003668

0000581c <non-virtual thunk to WaveformEditor::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    581c:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    5820:	e7d0      	b.n	57c4 <WaveformEditor::OnReceiveSysEx()>
    5822:	bf00      	nop

00005824 <TheDarkestTimeline::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    5824:	b510      	push	{r4, lr}
    5826:	b08a      	sub	sp, #40	; 0x28
    5828:	4604      	mov	r4, r0
        if (ExtractSysExData(V, 'D')) {
    582a:	2244      	movs	r2, #68	; 0x44
    582c:	a901      	add	r1, sp, #4
    582e:	3080      	adds	r0, #128	; 0x80
    5830:	f7ff ff66 	bl	5700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>
    5834:	b308      	cbz	r0, 587a <TheDarkestTimeline::OnReceiveSysEx()+0x56>
            int page = V[ix++];
    5836:	f89d 2004 	ldrb.w	r2, [sp, #4]
            if (page < 4) {
    583a:	2a03      	cmp	r2, #3
    583c:	dc1f      	bgt.n	587e <TheDarkestTimeline::OnReceiveSysEx()+0x5a>
                values_[DT_LENGTH] = V[ix++]; // V1.3 legacy support
    583e:	f89d 3005 	ldrb.w	r3, [sp, #5]
    5842:	4918      	ldr	r1, [pc, #96]	; (58a4 <TheDarkestTimeline::OnReceiveSysEx()+0x80>)
    5844:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
                values_[DT_INDEX] = V[ix++];
    5848:	f89d 3006 	ldrb.w	r3, [sp, #6]
    584c:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
                for (int b = 0; b < 16; b++)
    5850:	eb01 1142 	add.w	r1, r1, r2, lsl #5
    5854:	ab01      	add	r3, sp, #4
    5856:	2000      	movs	r0, #0
                    uint16_t cv = (uint16_t)(high << 8) | low;
    5858:	791c      	ldrb	r4, [r3, #4]
    585a:	78da      	ldrb	r2, [r3, #3]
                    OC::user_patterns[page].notes[b] = constrain(cv, 0, HSAPPLICATION_5V);
    585c:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
    5860:	f5b2 5ff0 	cmp.w	r2, #7680	; 0x1e00
                for (int b = 0; b < 16; b++)
    5864:	f100 0001 	add.w	r0, r0, #1
                    OC::user_patterns[page].notes[b] = constrain(cv, 0, HSAPPLICATION_5V);
    5868:	bfa8      	it	ge
    586a:	f44f 52f0 	movge.w	r2, #7680	; 0x1e00
                for (int b = 0; b < 16; b++)
    586e:	2810      	cmp	r0, #16
                    OC::user_patterns[page].notes[b] = constrain(cv, 0, HSAPPLICATION_5V);
    5870:	f821 2b02 	strh.w	r2, [r1], #2
                for (int b = 0; b < 16; b++)
    5874:	f103 0302 	add.w	r3, r3, #2
    5878:	d1ee      	bne.n	5858 <TheDarkestTimeline::OnReceiveSysEx()+0x34>
    }
    587a:	b00a      	add	sp, #40	; 0x28
    587c:	bd10      	pop	{r4, pc}
            } else if (page == 4) {
    587e:	2a04      	cmp	r2, #4
    5880:	d1fb      	bne.n	587a <TheDarkestTimeline::OnReceiveSysEx()+0x56>
                values_[DT_LENGTH] = V[ix++];
    5882:	f89d 3005 	ldrb.w	r3, [sp, #5]
    5886:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
                values_[DT_INDEX] = V[ix++];
    588a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    588e:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
                values_[DT_SCALE] = V[ix++];
    5892:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5896:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
                values_[DT_ROOT] = V[ix++];
    589a:	f89d 3008 	ldrb.w	r3, [sp, #8]
    589e:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
    }
    58a2:	e7ea      	b.n	587a <TheDarkestTimeline::OnReceiveSysEx()+0x56>
    58a4:	1fffa628 	.word	0x1fffa628

000058a8 <non-virtual thunk to TheDarkestTimeline::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    58a8:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    58ac:	e7ba      	b.n	5824 <TheDarkestTimeline::OnReceiveSysEx()>
    58ae:	bf00      	nop

000058b0 <NeuralNetwork::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    58b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    58b2:	b08b      	sub	sp, #44	; 0x2c
    58b4:	4604      	mov	r4, r0
        if (ExtractSysExData(V, 'N')) {
    58b6:	224e      	movs	r2, #78	; 0x4e
    58b8:	4669      	mov	r1, sp
    58ba:	3080      	adds	r0, #128	; 0x80
    58bc:	f7ff ff20 	bl	5700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>
    58c0:	2800      	cmp	r0, #0
    58c2:	d04f      	beq.n	5964 <NeuralNetwork::OnReceiveSysEx()+0xb4>
                byte ni = (setup * 6) + n;
    58c4:	f894 13f0 	ldrb.w	r1, [r4, #1008]	; 0x3f0
    58c8:	eb01 0541 	add.w	r5, r1, r1, lsl #1
    58cc:	006d      	lsls	r5, r5, #1
    58ce:	2000      	movs	r0, #0
    58d0:	b2ed      	uxtb	r5, r5
    58d2:	466a      	mov	r2, sp
                neuron[ni].type = (b >> 4) & 0x0f;
    58d4:	f04f 0c24 	mov.w	ip, #36	; 0x24
                neuron[ni].state = 0;
    58d8:	4607      	mov	r7, r0
                byte ni = (setup * 6) + n;
    58da:	182b      	adds	r3, r5, r0
                b = V[ix++]; // Type and source 1
    58dc:	7816      	ldrb	r6, [r2, #0]
                neuron[ni].type = (b >> 4) & 0x0f;
    58de:	b2db      	uxtb	r3, r3
    58e0:	fb0c 4303 	mla	r3, ip, r3, r4
    58e4:	ea4f 1e16 	mov.w	lr, r6, lsr #4
                neuron[ni].source1 = b & 0x0f;
    58e8:	f006 060f 	and.w	r6, r6, #15
    58ec:	f8c3 6404 	str.w	r6, [r3, #1028]	; 0x404
                b = V[ix++]; // Source 2 and source 3
    58f0:	7856      	ldrb	r6, [r2, #1]
                neuron[ni].type = (b >> 4) & 0x0f;
    58f2:	f8c3 e400 	str.w	lr, [r3, #1024]	; 0x400
                neuron[ni].source2 = (b >> 4) & 0x0f;
    58f6:	ea4f 1e16 	mov.w	lr, r6, lsr #4
                neuron[ni].source3 = b & 0x0f;
    58fa:	f006 060f 	and.w	r6, r6, #15
    58fe:	f8c3 640c 	str.w	r6, [r3, #1036]	; 0x40c
                neuron[ni].weight1 = static_cast<int>(V[ix++] - 128);
    5902:	7896      	ldrb	r6, [r2, #2]
                neuron[ni].source2 = (b >> 4) & 0x0f;
    5904:	f8c3 e408 	str.w	lr, [r3, #1032]	; 0x408
                neuron[ni].weight1 = static_cast<int>(V[ix++] - 128);
    5908:	3e80      	subs	r6, #128	; 0x80
    590a:	f8c3 6410 	str.w	r6, [r3, #1040]	; 0x410
                neuron[ni].weight2 = static_cast<int>(V[ix++] - 128);
    590e:	78d6      	ldrb	r6, [r2, #3]
                neuron[ni].state = 0;
    5910:	f883 73fc 	strb.w	r7, [r3, #1020]	; 0x3fc
                neuron[ni].weight2 = static_cast<int>(V[ix++] - 128);
    5914:	3e80      	subs	r6, #128	; 0x80
    5916:	f8c3 6414 	str.w	r6, [r3, #1044]	; 0x414
                neuron[ni].weight3 = static_cast<int>(V[ix++] - 128);
    591a:	7916      	ldrb	r6, [r2, #4]
                neuron[ni].source_state = 0;
    591c:	f8a3 73fe 	strh.w	r7, [r3, #1022]	; 0x3fe
                neuron[ni].weight3 = static_cast<int>(V[ix++] - 128);
    5920:	3e80      	subs	r6, #128	; 0x80
    5922:	f8c3 6418 	str.w	r6, [r3, #1048]	; 0x418
                neuron[ni].threshold = static_cast<int>(V[ix++] - 128);
    5926:	7956      	ldrb	r6, [r2, #5]
            for (byte n = 0; n < 6; n++)
    5928:	3001      	adds	r0, #1
                neuron[ni].threshold = static_cast<int>(V[ix++] - 128);
    592a:	3e80      	subs	r6, #128	; 0x80
            for (byte n = 0; n < 6; n++)
    592c:	2806      	cmp	r0, #6
                neuron[ni].threshold = static_cast<int>(V[ix++] - 128);
    592e:	f8c3 641c 	str.w	r6, [r3, #1052]	; 0x41c
            for (byte n = 0; n < 6; n++)
    5932:	f102 0206 	add.w	r2, r2, #6
    5936:	d1d0      	bne.n	58da <NeuralNetwork::OnReceiveSysEx()+0x2a>
            b = V[ix++]; // Output 1 and 2
    5938:	0109      	lsls	r1, r1, #4
    593a:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
            output_neuron[o] = (b >> 4) & 0x0f;
    593e:	f401 717c 	and.w	r1, r1, #1008	; 0x3f0
    5942:	440c      	add	r4, r1
    5944:	091a      	lsrs	r2, r3, #4
            output_neuron[o + 1] = b & 0x0f;
    5946:	f003 030f 	and.w	r3, r3, #15
    594a:	f8c4 3760 	str.w	r3, [r4, #1888]	; 0x760
            b = V[ix++]; // Output 3 and 4
    594e:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
            output_neuron[o] = (b >> 4) & 0x0f;
    5952:	f8c4 275c 	str.w	r2, [r4, #1884]	; 0x75c
            output_neuron[o + 2] = (b >> 4) & 0x0f;
    5956:	091a      	lsrs	r2, r3, #4
            output_neuron[o + 3] = b & 0x0f;
    5958:	f003 030f 	and.w	r3, r3, #15
            output_neuron[o + 2] = (b >> 4) & 0x0f;
    595c:	f8c4 2764 	str.w	r2, [r4, #1892]	; 0x764
            output_neuron[o + 3] = b & 0x0f;
    5960:	f8c4 3768 	str.w	r3, [r4, #1896]	; 0x768
    }
    5964:	b00b      	add	sp, #44	; 0x2c
    5966:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005968 <non-virtual thunk to NeuralNetwork::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    5968:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    596c:	e7a0      	b.n	58b0 <NeuralNetwork::OnReceiveSysEx()>

0000596e <MIDIQuantizer::NoteNumber(int, int)>:
class MIDIQuantizer {
public:
    /* Given a pitch CV value, return the MIDI note number */
    static uint8_t NoteNumber(int cv, int transpose = 0) {
        // CV controllers might be right on the border between voltages, so provide 1/4 tone offset
        if (cv > 0) cv += 32;
    596e:	2800      	cmp	r0, #0
    static uint8_t NoteNumber(int cv, int transpose = 0) {
    5970:	b510      	push	{r4, lr}
        if (cv > 0) cv += 32;
    5972:	dd15      	ble.n	59a0 <MIDIQuantizer::NoteNumber(int, int)+0x32>
    5974:	3020      	adds	r0, #32
        if (cv < 0) cv -= 32;
        int octave = cv / (12 << 7);
    5976:	f44f 64c0 	mov.w	r4, #1536	; 0x600
    597a:	fb90 f2f4 	sdiv	r2, r0, r4
        int semitone = (cv % (12 << 7)) / 128;
    597e:	fb04 0012 	mls	r0, r4, r2, r0
    5982:	2800      	cmp	r0, #0
        int midi_note_number = (octave * 12) + semitone + transpose + 60;
    5984:	f04f 030c 	mov.w	r3, #12
    5988:	fb02 f303 	mul.w	r3, r2, r3
        int semitone = (cv % (12 << 7)) / 128;
    598c:	bfb8      	it	lt
    598e:	307f      	addlt	r0, #127	; 0x7f
        int midi_note_number = (octave * 12) + semitone + transpose + 60;
    5990:	eb03 10e0 	add.w	r0, r3, r0, asr #7
    5994:	4408      	add	r0, r1
    5996:	303c      	adds	r0, #60	; 0x3c
        if (midi_note_number > 127) midi_note_number = 127;
        if (midi_note_number < 0) midi_note_number = 0;
        return static_cast<uint8_t>(midi_note_number);
    5998:	f380 0007 	usat	r0, #7, r0
    }
    599c:	b2c0      	uxtb	r0, r0
    599e:	bd10      	pop	{r4, pc}
        if (cv < 0) cv -= 32;
    59a0:	bf18      	it	ne
    59a2:	3820      	subne	r0, #32
    59a4:	e7e7      	b.n	5976 <MIDIQuantizer::NoteNumber(int, int)+0x8>

000059a6 <MIDIQuantizer::CV(unsigned char, int)>:

    /* Given a MIDI note number, return the pitch CV value */
    static int CV(uint8_t midi_note_number, int transpose = 0) {
        int octave = midi_note_number / 12;
    59a6:	230c      	movs	r3, #12
    59a8:	fbb0 f2f3 	udiv	r2, r0, r3
        int semitone = midi_note_number % 12;
    59ac:	fb03 0012 	mls	r0, r3, r2, r0
        int cv = (octave * (12 << 7)) + (semitone * 128) + (transpose * 128) - (5 * (12 << 7));
    59b0:	b2c0      	uxtb	r0, r0
    59b2:	fb03 0002 	mla	r0, r3, r2, r0
    59b6:	4408      	add	r0, r1
    59b8:	383c      	subs	r0, #60	; 0x3c
        return cv;
    }
    59ba:	01c0      	lsls	r0, r0, #7
    59bc:	4770      	bx	lr
    59be:	Address 0x00000000000059be is out of bounds.


000059c0 <Backup::DrawInterface()>:
    void DrawInterface() {
    59c0:	b573      	push	{r0, r1, r4, r5, r6, lr}
        graphics.drawLine(0, 10, 127, 10);
    59c2:	4c2f      	ldr	r4, [pc, #188]	; (5a80 <Backup::DrawInterface()+0xc0>)
    59c4:	220a      	movs	r2, #10
    void DrawInterface() {
    59c6:	4605      	mov	r5, r0
        graphics.drawLine(0, 10, 127, 10);
    59c8:	9200      	str	r2, [sp, #0]
    59ca:	237f      	movs	r3, #127	; 0x7f
    59cc:	2100      	movs	r1, #0
    59ce:	4620      	mov	r0, r4
    59d0:	f013 ff0e 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        graphics.drawLine(0, 12, 127, 12);
    59d4:	220c      	movs	r2, #12
    59d6:	9200      	str	r2, [sp, #0]
    59d8:	237f      	movs	r3, #127	; 0x7f
    59da:	2100      	movs	r1, #0
    59dc:	4620      	mov	r0, r4
    59de:	f013 ff07 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
  text_x_ = x;
    59e2:	2600      	movs	r6, #0
  text_y_ = y;
    59e4:	2301      	movs	r3, #1
        graphics.print("Backup / Restore");
    59e6:	4927      	ldr	r1, [pc, #156]	; (5a84 <Backup::DrawInterface()+0xc4>)
    59e8:	60a3      	str	r3, [r4, #8]
    59ea:	4620      	mov	r0, r4
  text_x_ = x;
    59ec:	6066      	str	r6, [r4, #4]
    59ee:	f014 f872 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_y_ = y;
    59f2:	230f      	movs	r3, #15
        if (receiving) {
    59f4:	79aa      	ldrb	r2, [r5, #6]
  text_x_ = x;
    59f6:	6066      	str	r6, [r4, #4]
  text_y_ = y;
    59f8:	60a3      	str	r3, [r4, #8]
    59fa:	79eb      	ldrb	r3, [r5, #7]
    59fc:	b302      	cbz	r2, 5a40 <Backup::DrawInterface()+0x80>
            if (packet > 0) {
    59fe:	b1d3      	cbz	r3, 5a36 <Backup::DrawInterface()+0x76>
                graphics.print("Receiving...");
    5a00:	4921      	ldr	r1, [pc, #132]	; (5a88 <Backup::DrawInterface()+0xc8>)
    5a02:	4620      	mov	r0, r4
    5a04:	f014 f867 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                graphics.drawRect(0, 33, (packet + 4) * 2, 8);
    5a08:	79eb      	ldrb	r3, [r5, #7]
    5a0a:	2208      	movs	r2, #8
    5a0c:	3304      	adds	r3, #4
    5a0e:	9200      	str	r2, [sp, #0]
    5a10:	005b      	lsls	r3, r3, #1
    5a12:	2221      	movs	r2, #33	; 0x21
    5a14:	4631      	mov	r1, r6
    5a16:	4620      	mov	r0, r4
    5a18:	f013 fc3c 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
  text_x_ = x;
    5a1c:	2300      	movs	r3, #0
    5a1e:	6063      	str	r3, [r4, #4]
        if (receiving) graphics.print("[CANCEL]");
    5a20:	79ab      	ldrb	r3, [r5, #6]
  text_y_ = y;
    5a22:	2637      	movs	r6, #55	; 0x37
    5a24:	60a6      	str	r6, [r4, #8]
    5a26:	b183      	cbz	r3, 5a4a <Backup::DrawInterface()+0x8a>
    5a28:	4918      	ldr	r1, [pc, #96]	; (5a8c <Backup::DrawInterface()+0xcc>)
            graphics.print(calibration ? "Calibration" : "Data");
    5a2a:	4815      	ldr	r0, [pc, #84]	; (5a80 <Backup::DrawInterface()+0xc0>)
    }
    5a2c:	b002      	add	sp, #8
    5a2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            graphics.print(calibration ? "Calibration" : "Data");
    5a32:	f014 b850 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
            else graphics.print("Listening...");
    5a36:	4916      	ldr	r1, [pc, #88]	; (5a90 <Backup::DrawInterface()+0xd0>)
            else graphics.print("Restore or Backup?");
    5a38:	4620      	mov	r0, r4
    5a3a:	f014 f84c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    5a3e:	e7ed      	b.n	5a1c <Backup::DrawInterface()+0x5c>
            if (packet > 0) graphics.print("Done!");
    5a40:	b10b      	cbz	r3, 5a46 <Backup::DrawInterface()+0x86>
    5a42:	4914      	ldr	r1, [pc, #80]	; (5a94 <Backup::DrawInterface()+0xd4>)
    5a44:	e7f8      	b.n	5a38 <Backup::DrawInterface()+0x78>
            else graphics.print("Restore or Backup?");
    5a46:	4914      	ldr	r1, [pc, #80]	; (5a98 <Backup::DrawInterface()+0xd8>)
    5a48:	e7f6      	b.n	5a38 <Backup::DrawInterface()+0x78>
            graphics.print("[RESTORE]");
    5a4a:	4914      	ldr	r1, [pc, #80]	; (5a9c <Backup::DrawInterface()+0xdc>)
    5a4c:	480c      	ldr	r0, [pc, #48]	; (5a80 <Backup::DrawInterface()+0xc0>)
    5a4e:	f014 f842 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    5a52:	234e      	movs	r3, #78	; 0x4e
            graphics.print("[BACKUP]");
    5a54:	4912      	ldr	r1, [pc, #72]	; (5aa0 <Backup::DrawInterface()+0xe0>)
    5a56:	480a      	ldr	r0, [pc, #40]	; (5a80 <Backup::DrawInterface()+0xc0>)
    5a58:	6063      	str	r3, [r4, #4]
  text_y_ = y;
    5a5a:	60a6      	str	r6, [r4, #8]
    5a5c:	f014 f83b 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    5a60:	2306      	movs	r3, #6
            graphics.print("Backup: ");
    5a62:	4910      	ldr	r1, [pc, #64]	; (5aa4 <Backup::DrawInterface()+0xe4>)
    5a64:	6063      	str	r3, [r4, #4]
    5a66:	4806      	ldr	r0, [pc, #24]	; (5a80 <Backup::DrawInterface()+0xc0>)
  text_y_ = y;
    5a68:	2323      	movs	r3, #35	; 0x23
    5a6a:	60a3      	str	r3, [r4, #8]
    5a6c:	f014 f833 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.print(calibration ? "Calibration" : "Data");
    5a70:	7969      	ldrb	r1, [r5, #5]
    5a72:	4a0d      	ldr	r2, [pc, #52]	; (5aa8 <Backup::DrawInterface()+0xe8>)
    5a74:	4b0d      	ldr	r3, [pc, #52]	; (5aac <Backup::DrawInterface()+0xec>)
    5a76:	2900      	cmp	r1, #0
    5a78:	bf14      	ite	ne
    5a7a:	4611      	movne	r1, r2
    5a7c:	4619      	moveq	r1, r3
    5a7e:	e7d4      	b.n	5a2a <Backup::DrawInterface()+0x6a>
    5a80:	200065e0 	.word	0x200065e0
    5a84:	00020f03 	.word	0x00020f03
    5a88:	00020f14 	.word	0x00020f14
    5a8c:	00020f47 	.word	0x00020f47
    5a90:	00020f21 	.word	0x00020f21
    5a94:	00020f2e 	.word	0x00020f2e
    5a98:	00020f34 	.word	0x00020f34
    5a9c:	00020f50 	.word	0x00020f50
    5aa0:	00020f5a 	.word	0x00020f5a
    5aa4:	00020f63 	.word	0x00020f63
    5aa8:	00021401 	.word	0x00021401
    5aac:	00020efe 	.word	0x00020efe

00005ab0 <Backup_menu()>:
void Backup_menu() {Backup_instance.View();}
    5ab0:	b508      	push	{r3, lr}
        DrawInterface();
    5ab2:	4802      	ldr	r0, [pc, #8]	; (5abc <Backup_menu()+0xc>)
    5ab4:	f7ff ff84 	bl	59c0 <Backup::DrawInterface()>
void Backup_menu() {Backup_instance.View();}
    5ab8:	bd08      	pop	{r3, pc}
    5aba:	bf00      	nop
    5abc:	1fffb1c0 	.word	0x1fffb1c0

00005ac0 <Backup_screensaver()>:
    5ac0:	f7ff bff6 	b.w	5ab0 <Backup_menu()>

00005ac4 <HSApplication::BaseStart()>:
            clock_countdown[ch]  = 0;
    5ac4:	2200      	movs	r2, #0
        Start();
    5ac6:	6803      	ldr	r3, [r0, #0]
            clock_countdown[ch]  = 0;
    5ac8:	6042      	str	r2, [r0, #4]
            adc_lag_countdown[ch] = 0;
    5aca:	6142      	str	r2, [r0, #20]
            clock_countdown[ch]  = 0;
    5acc:	6082      	str	r2, [r0, #8]
            adc_lag_countdown[ch] = 0;
    5ace:	6182      	str	r2, [r0, #24]
            clock_countdown[ch]  = 0;
    5ad0:	60c2      	str	r2, [r0, #12]
            adc_lag_countdown[ch] = 0;
    5ad2:	61c2      	str	r2, [r0, #28]
            clock_countdown[ch]  = 0;
    5ad4:	6102      	str	r2, [r0, #16]
            adc_lag_countdown[ch] = 0;
    5ad6:	6202      	str	r2, [r0, #32]
        cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    5ad8:	f642 62e0 	movw	r2, #12000	; 0x2ee0
        Start();
    5adc:	681b      	ldr	r3, [r3, #0]
        cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    5ade:	6242      	str	r2, [r0, #36]	; 0x24
        Start();
    5ae0:	4718      	bx	r3
    5ae2:	Address 0x0000000000005ae2 is out of bounds.


00005ae4 <EnigmaTMWS_init()>:
void EnigmaTMWS_init() {
    5ae4:	b508      	push	{r3, lr}
    EnigmaTMWS_instance.BaseStart();
    5ae6:	4802      	ldr	r0, [pc, #8]	; (5af0 <EnigmaTMWS_init()+0xc>)
    5ae8:	f7ff ffec 	bl	5ac4 <HSApplication::BaseStart()>
}
    5aec:	bd08      	pop	{r3, pc}
    5aee:	bf00      	nop
    5af0:	1fffd9ac 	.word	0x1fffd9ac

00005af4 <NeuralNetwork_init()>:
void NeuralNetwork_init() {
    5af4:	b508      	push	{r3, lr}
    NeuralNetwork_instance.BaseStart();
    5af6:	4802      	ldr	r0, [pc, #8]	; (5b00 <NeuralNetwork_init()+0xc>)
    5af8:	f7ff ffe4 	bl	5ac4 <HSApplication::BaseStart()>
}
    5afc:	bd08      	pop	{r3, pc}
    5afe:	bf00      	nop
    5b00:	2000058c 	.word	0x2000058c

00005b04 <SCALEEDITOR_init()>:
void SCALEEDITOR_init() {
    5b04:	b508      	push	{r3, lr}
    scale_editor_instance.BaseStart();
    5b06:	4802      	ldr	r0, [pc, #8]	; (5b10 <SCALEEDITOR_init()+0xc>)
    5b08:	f7ff ffdc 	bl	5ac4 <HSApplication::BaseStart()>
}
    5b0c:	bd08      	pop	{r3, pc}
    5b0e:	bf00      	nop
    5b10:	20005a5c 	.word	0x20005a5c

00005b14 <Settings_init()>:
void Settings_init() {
    5b14:	b508      	push	{r3, lr}
    Settings_instance.BaseStart();
    5b16:	4802      	ldr	r0, [pc, #8]	; (5b20 <Settings_init()+0xc>)
    5b18:	f7ff ffd4 	bl	5ac4 <HSApplication::BaseStart()>
}
    5b1c:	bd08      	pop	{r3, pc}
    5b1e:	bf00      	nop
    5b20:	200016c4 	.word	0x200016c4

00005b24 <TheDarkestTimeline_init()>:
void TheDarkestTimeline_init() {
    5b24:	b508      	push	{r3, lr}
    TheDarkestTimeline_instance.BaseStart();
    5b26:	4802      	ldr	r0, [pc, #8]	; (5b30 <TheDarkestTimeline_init()+0xc>)
    5b28:	f7ff ffcc 	bl	5ac4 <HSApplication::BaseStart()>
}
    5b2c:	bd08      	pop	{r3, pc}
    5b2e:	bf00      	nop
    5b30:	20002444 	.word	0x20002444

00005b34 <WaveformEditor_init()>:
};

WaveformEditor WaveformEditor_instance;

// App stubs
void WaveformEditor_init() {
    5b34:	b508      	push	{r3, lr}
    WaveformEditor_instance.BaseStart();
    5b36:	4802      	ldr	r0, [pc, #8]	; (5b40 <WaveformEditor_init()+0xc>)
    5b38:	f7ff ffc4 	bl	5ac4 <HSApplication::BaseStart()>
}
    5b3c:	bd08      	pop	{r3, pc}
    5b3e:	bf00      	nop
    5b40:	20003450 	.word	0x20003450

00005b44 <HSApplication::BaseView()>:
        View();
    5b44:	6803      	ldr	r3, [r0, #0]
    void BaseView() {
    5b46:	b510      	push	{r4, lr}
        View();
    5b48:	689b      	ldr	r3, [r3, #8]
    void BaseView() {
    5b4a:	4604      	mov	r4, r0
        View();
    5b4c:	4798      	blx	r3
        last_view_tick = OC::CORE::ticks;
    5b4e:	4b02      	ldr	r3, [pc, #8]	; (5b58 <HSApplication::BaseView()+0x14>)
    5b50:	681b      	ldr	r3, [r3, #0]
    5b52:	62a3      	str	r3, [r4, #40]	; 0x28
    }
    5b54:	bd10      	pop	{r4, pc}
    5b56:	bf00      	nop
    5b58:	200046cc 	.word	0x200046cc

00005b5c <EnigmaTMWS_menu()>:
    }
}

void EnigmaTMWS_loop() {} // Deprecated

void EnigmaTMWS_menu() {
    5b5c:	b508      	push	{r3, lr}
    EnigmaTMWS_instance.BaseView();
    5b5e:	4802      	ldr	r0, [pc, #8]	; (5b68 <EnigmaTMWS_menu()+0xc>)
    5b60:	f7ff fff0 	bl	5b44 <HSApplication::BaseView()>
}
    5b64:	bd08      	pop	{r3, pc}
    5b66:	bf00      	nop
    5b68:	1fffd9ac 	.word	0x1fffd9ac

00005b6c <MIDI_menu()>:

void MIDI_loop() {}

void MIDI_menu() {
    5b6c:	b508      	push	{r3, lr}
    captain_midi_instance.BaseView();
    5b6e:	4802      	ldr	r0, [pc, #8]	; (5b78 <MIDI_menu()+0xc>)
    5b70:	f7ff ffe8 	bl	5b44 <HSApplication::BaseView()>
}
    5b74:	bd08      	pop	{r3, pc}
    5b76:	bf00      	nop
    5b78:	200046f4 	.word	0x200046f4

00005b7c <NeuralNetwork_menu()>:
void NeuralNetwork_menu() {
    5b7c:	b508      	push	{r3, lr}
    NeuralNetwork_instance.BaseView();
    5b7e:	4802      	ldr	r0, [pc, #8]	; (5b88 <NeuralNetwork_menu()+0xc>)
    5b80:	f7ff ffe0 	bl	5b44 <HSApplication::BaseView()>
}
    5b84:	bd08      	pop	{r3, pc}
    5b86:	bf00      	nop
    5b88:	2000058c 	.word	0x2000058c

00005b8c <SCALEEDITOR_menu()>:

void SCALEEDITOR_loop() {}

void SCALEEDITOR_menu() {
    5b8c:	b508      	push	{r3, lr}
    scale_editor_instance.BaseView();
    5b8e:	4802      	ldr	r0, [pc, #8]	; (5b98 <SCALEEDITOR_menu()+0xc>)
    5b90:	f7ff ffd8 	bl	5b44 <HSApplication::BaseView()>
}
    5b94:	bd08      	pop	{r3, pc}
    5b96:	bf00      	nop
    5b98:	20005a5c 	.word	0x20005a5c

00005b9c <Settings_menu()>:
void Settings_menu() {
    5b9c:	b508      	push	{r3, lr}
    Settings_instance.BaseView();
    5b9e:	4802      	ldr	r0, [pc, #8]	; (5ba8 <Settings_menu()+0xc>)
    5ba0:	f7ff ffd0 	bl	5b44 <HSApplication::BaseView()>
}
    5ba4:	bd08      	pop	{r3, pc}
    5ba6:	bf00      	nop
    5ba8:	200016c4 	.word	0x200016c4

00005bac <TheDarkestTimeline_menu()>:

void TheDarkestTimeline_loop() {} // Deprecated

void TheDarkestTimeline_menu() {
    5bac:	b508      	push	{r3, lr}
    TheDarkestTimeline_instance.BaseView();
    5bae:	4802      	ldr	r0, [pc, #8]	; (5bb8 <TheDarkestTimeline_menu()+0xc>)
    5bb0:	f7ff ffc8 	bl	5b44 <HSApplication::BaseView()>
}
    5bb4:	bd08      	pop	{r3, pc}
    5bb6:	bf00      	nop
    5bb8:	20002444 	.word	0x20002444

00005bbc <WaveformEditor_menu()>:
    }
}

void WaveformEditor_loop() {} // Deprecated

void WaveformEditor_menu() {
    5bbc:	b508      	push	{r3, lr}
    WaveformEditor_instance.BaseView();
    5bbe:	4802      	ldr	r0, [pc, #8]	; (5bc8 <WaveformEditor_menu()+0xc>)
    5bc0:	f7ff ffc0 	bl	5b44 <HSApplication::BaseView()>
}
    5bc4:	bd08      	pop	{r3, pc}
    5bc6:	bf00      	nop
    5bc8:	20003450 	.word	0x20003450

00005bcc <HSApplication::Out(int, int, int)>:
    void Out(int ch, int value, int octave = 0) {
    5bcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5bce:	460f      	mov	r7, r1
    5bd0:	4614      	mov	r4, r2
    5bd2:	4605      	mov	r5, r0
        OC::DAC::set_pitch((DAC_CHANNEL)ch, value, octave);
    5bd4:	461a      	mov	r2, r3
    5bd6:	4621      	mov	r1, r4
    5bd8:	b2f8      	uxtb	r0, r7
    void Out(int ch, int value, int octave = 0) {
    5bda:	461e      	mov	r6, r3
        outputs[ch] = value + (octave * (12 << 7));
    5bdc:	eb05 0587 	add.w	r5, r5, r7, lsl #2
        OC::DAC::set_pitch((DAC_CHANNEL)ch, value, octave);
    5be0:	f7ff f966 	bl	4eb0 <OC::DAC::set_pitch(DAC_CHANNEL, long, long)>
        outputs[ch] = value + (octave * (12 << 7));
    5be4:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    5be8:	fb03 4406 	mla	r4, r3, r6, r4
    5bec:	63ec      	str	r4, [r5, #60]	; 0x3c
    }
    5bee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00005bf0 <HSApplication::BaseController()>:
    void BaseController() {
    5bf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5bf4:	2500      	movs	r5, #0
    5bf6:	4604      	mov	r4, r0
    5bf8:	4606      	mov	r6, r0
    5bfa:	f100 074c 	add.w	r7, r0, #76	; 0x4c
            } else changed_cv[ch] = 0;
    5bfe:	46a8      	mov	r8, r5
                changed_cv[ch] = 1;
    5c00:	f04f 0901 	mov.w	r9, #1
            inputs[ch] = OC::ADC::raw_pitch_value((ADC_CHANNEL)ch);
    5c04:	b2e8      	uxtb	r0, r5
    5c06:	f7ff f9cf 	bl	4fa8 <OC::ADC::raw_pitch_value(ADC_CHANNEL)>
            if (abs(inputs[ch] - last_cv[ch]) > HSAPPLICATION_CHANGE_THRESHOLD) {
    5c0a:	6d33      	ldr	r3, [r6, #80]	; 0x50
            inputs[ch] = OC::ADC::raw_pitch_value((ADC_CHANNEL)ch);
    5c0c:	62f0      	str	r0, [r6, #44]	; 0x2c
            if (abs(inputs[ch] - last_cv[ch]) > HSAPPLICATION_CHANGE_THRESHOLD) {
    5c0e:	1ac3      	subs	r3, r0, r3
    5c10:	2b00      	cmp	r3, #0
    5c12:	bfb8      	it	lt
    5c14:	425b      	neglt	r3, r3
    5c16:	2b20      	cmp	r3, #32
                changed_cv[ch] = 1;
    5c18:	bfc4      	itt	gt
    5c1a:	f887 9000 	strbgt.w	r9, [r7]
                last_cv[ch] = inputs[ch];
    5c1e:	6530      	strgt	r0, [r6, #80]	; 0x50
            if (clock_countdown[ch] > 0) {
    5c20:	f856 3f04 	ldr.w	r3, [r6, #4]!
            } else changed_cv[ch] = 0;
    5c24:	bfd8      	it	le
    5c26:	f887 8000 	strble.w	r8, [r7]
            if (clock_countdown[ch] > 0) {
    5c2a:	2b00      	cmp	r3, #0
    5c2c:	dd07      	ble.n	5c3e <HSApplication::BaseController()+0x4e>
                if (--clock_countdown[ch] == 0) Out(ch, 0);
    5c2e:	3b01      	subs	r3, #1
    5c30:	6033      	str	r3, [r6, #0]
    5c32:	b923      	cbnz	r3, 5c3e <HSApplication::BaseController()+0x4e>
    5c34:	461a      	mov	r2, r3
    5c36:	4629      	mov	r1, r5
    5c38:	4620      	mov	r0, r4
    5c3a:	f7ff ffc7 	bl	5bcc <HSApplication::Out(int, int, int)>
        for (uint8_t ch = 0; ch < 4; ch++)
    5c3e:	3501      	adds	r5, #1
    5c40:	2d04      	cmp	r5, #4
    5c42:	f107 0701 	add.w	r7, r7, #1
    5c46:	d1dd      	bne.n	5c04 <HSApplication::BaseController()+0x14>
        if (--cursor_countdown < -HSAPPLICATION_CURSOR_TICKS) cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    5c48:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5c4a:	4907      	ldr	r1, [pc, #28]	; (5c68 <HSApplication::BaseController()+0x78>)
    5c4c:	3b01      	subs	r3, #1
    5c4e:	f642 62e0 	movw	r2, #12000	; 0x2ee0
    5c52:	428b      	cmp	r3, r1
    5c54:	bfb8      	it	lt
    5c56:	4613      	movlt	r3, r2
    5c58:	6263      	str	r3, [r4, #36]	; 0x24
        Controller();
    5c5a:	6823      	ldr	r3, [r4, #0]
    5c5c:	4620      	mov	r0, r4
    5c5e:	685b      	ldr	r3, [r3, #4]
    }
    5c60:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        Controller();
    5c64:	4718      	bx	r3
    5c66:	bf00      	nop
    5c68:	ffffd120 	.word	0xffffd120

00005c6c <EnigmaTMWS_isr()>:
void EnigmaTMWS_isr() {
    5c6c:	b508      	push	{r3, lr}
	return EnigmaTMWS_instance.BaseController();
    5c6e:	4802      	ldr	r0, [pc, #8]	; (5c78 <EnigmaTMWS_isr()+0xc>)
    5c70:	f7ff ffbe 	bl	5bf0 <HSApplication::BaseController()>
}
    5c74:	bd08      	pop	{r3, pc}
    5c76:	bf00      	nop
    5c78:	1fffd9ac 	.word	0x1fffd9ac

00005c7c <MIDI_isr()>:
void MIDI_isr() {
    5c7c:	b508      	push	{r3, lr}
	return captain_midi_instance.BaseController();
    5c7e:	4802      	ldr	r0, [pc, #8]	; (5c88 <MIDI_isr()+0xc>)
    5c80:	f7ff ffb6 	bl	5bf0 <HSApplication::BaseController()>
}
    5c84:	bd08      	pop	{r3, pc}
    5c86:	bf00      	nop
    5c88:	200046f4 	.word	0x200046f4

00005c8c <NeuralNetwork_isr()>:
void NeuralNetwork_isr() {
    5c8c:	b508      	push	{r3, lr}
    return NeuralNetwork_instance.BaseController();
    5c8e:	4802      	ldr	r0, [pc, #8]	; (5c98 <NeuralNetwork_isr()+0xc>)
    5c90:	f7ff ffae 	bl	5bf0 <HSApplication::BaseController()>
}
    5c94:	bd08      	pop	{r3, pc}
    5c96:	bf00      	nop
    5c98:	2000058c 	.word	0x2000058c

00005c9c <SCALEEDITOR_isr()>:
void SCALEEDITOR_isr() {
    5c9c:	b508      	push	{r3, lr}
	return scale_editor_instance.BaseController();
    5c9e:	4802      	ldr	r0, [pc, #8]	; (5ca8 <SCALEEDITOR_isr()+0xc>)
    5ca0:	f7ff ffa6 	bl	5bf0 <HSApplication::BaseController()>
}
    5ca4:	bd08      	pop	{r3, pc}
    5ca6:	bf00      	nop
    5ca8:	20005a5c 	.word	0x20005a5c

00005cac <Settings_isr()>:
void Settings_isr() {
    5cac:	b508      	push	{r3, lr}
	return Settings_instance.BaseController();
    5cae:	4802      	ldr	r0, [pc, #8]	; (5cb8 <Settings_isr()+0xc>)
    5cb0:	f7ff ff9e 	bl	5bf0 <HSApplication::BaseController()>
}
    5cb4:	bd08      	pop	{r3, pc}
    5cb6:	bf00      	nop
    5cb8:	200016c4 	.word	0x200016c4

00005cbc <TheDarkestTimeline_isr()>:
void TheDarkestTimeline_isr() {
    5cbc:	b508      	push	{r3, lr}
	return TheDarkestTimeline_instance.BaseController();
    5cbe:	4802      	ldr	r0, [pc, #8]	; (5cc8 <TheDarkestTimeline_isr()+0xc>)
    5cc0:	f7ff ff96 	bl	5bf0 <HSApplication::BaseController()>
}
    5cc4:	bd08      	pop	{r3, pc}
    5cc6:	bf00      	nop
    5cc8:	20002444 	.word	0x20002444

00005ccc <WaveformEditor_isr()>:
void WaveformEditor_isr() {
    5ccc:	b508      	push	{r3, lr}
    return WaveformEditor_instance.BaseController();
    5cce:	4802      	ldr	r0, [pc, #8]	; (5cd8 <WaveformEditor_isr()+0xc>)
    5cd0:	f7ff ff8e 	bl	5bf0 <HSApplication::BaseController()>
}
    5cd4:	bd08      	pop	{r3, pc}
    5cd6:	bf00      	nop
    5cd8:	20003450 	.word	0x20003450

00005cdc <ScaleEditor::Controller()>:
    void Controller() {
    5cdc:	b510      	push	{r4, lr}
    5cde:	4604      	mov	r4, r0
        ListenForSysEx();
    5ce0:	3080      	adds	r0, #128	; 0x80
    5ce2:	f7ff fa9b 	bl	521c <SystemExclusiveHandler::ListenForSysEx()>
        int32_t quantized = quantizer.Process(pitch, 0, 0);
    5ce6:	2300      	movs	r3, #0
    5ce8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    5cea:	461a      	mov	r2, r3
    5cec:	f104 0094 	add.w	r0, r4, #148	; 0x94
    5cf0:	f7fb fb4e 	bl	1390 <braids::Quantizer::Process(long, long, long)>
        Out(0, quantized);
    5cf4:	2300      	movs	r3, #0
        int32_t quantized = quantizer.Process(pitch, 0, 0);
    5cf6:	4602      	mov	r2, r0
        Out(0, quantized);
    5cf8:	4619      	mov	r1, r3
    5cfa:	4620      	mov	r0, r4
    5cfc:	f7ff ff66 	bl	5bcc <HSApplication::Out(int, int, int)>
        Out(1, current_quantized);
    5d00:	f8d4 21cc 	ldr.w	r2, [r4, #460]	; 0x1cc
    5d04:	2300      	movs	r3, #0
    5d06:	2101      	movs	r1, #1
    5d08:	4620      	mov	r0, r4
    5d0a:	f7ff ff5f 	bl	5bcc <HSApplication::Out(int, int, int)>
    }
    5d0e:	bd10      	pop	{r4, pc}

00005d10 <HSApplication::Clock(int)>:
    bool Clock(int ch) {
    5d10:	4602      	mov	r2, r0
        if (ch == 0) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_1>();
    5d12:	b929      	cbnz	r1, 5d20 <HSApplication::Clock(int)+0x10>
    return clocked_mask_ & (0x1 << input);
    5d14:	4b14      	ldr	r3, [pc, #80]	; (5d68 <HSApplication::Clock(int)+0x58>)
    5d16:	6818      	ldr	r0, [r3, #0]
        if (clocked) {
    5d18:	f010 0001 	ands.w	r0, r0, #1
    5d1c:	d119      	bne.n	5d52 <HSApplication::Clock(int)+0x42>
    5d1e:	4770      	bx	lr
        if (ch == 1) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_2>();
    5d20:	2901      	cmp	r1, #1
    5d22:	d005      	beq.n	5d30 <HSApplication::Clock(int)+0x20>
        if (ch == 2) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_3>();
    5d24:	2902      	cmp	r1, #2
    5d26:	d009      	beq.n	5d3c <HSApplication::Clock(int)+0x2c>
        if (ch == 3) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_4>();
    5d28:	2903      	cmp	r1, #3
    5d2a:	d00d      	beq.n	5d48 <HSApplication::Clock(int)+0x38>
    5d2c:	2000      	movs	r0, #0
    }
    5d2e:	4770      	bx	lr
    5d30:	4b0d      	ldr	r3, [pc, #52]	; (5d68 <HSApplication::Clock(int)+0x58>)
    5d32:	6818      	ldr	r0, [r3, #0]
        if (clocked) {
    5d34:	f010 0002 	ands.w	r0, r0, #2
    5d38:	d10b      	bne.n	5d52 <HSApplication::Clock(int)+0x42>
    5d3a:	4770      	bx	lr
    5d3c:	4b0a      	ldr	r3, [pc, #40]	; (5d68 <HSApplication::Clock(int)+0x58>)
    5d3e:	6818      	ldr	r0, [r3, #0]
    5d40:	f010 0004 	ands.w	r0, r0, #4
    5d44:	d105      	bne.n	5d52 <HSApplication::Clock(int)+0x42>
    5d46:	4770      	bx	lr
    5d48:	4b07      	ldr	r3, [pc, #28]	; (5d68 <HSApplication::Clock(int)+0x58>)
    5d4a:	6818      	ldr	r0, [r3, #0]
    5d4c:	f010 0008 	ands.w	r0, r0, #8
    5d50:	d0ed      	beq.n	5d2e <HSApplication::Clock(int)+0x1e>
        		cycle_ticks[ch] = OC::CORE::ticks - last_clock[ch];
    5d52:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    5d56:	4805      	ldr	r0, [pc, #20]	; (5d6c <HSApplication::Clock(int)+0x5c>)
    5d58:	6e0a      	ldr	r2, [r1, #96]	; 0x60
    5d5a:	6803      	ldr	r3, [r0, #0]
    5d5c:	1a9b      	subs	r3, r3, r2
    5d5e:	670b      	str	r3, [r1, #112]	; 0x70
        		last_clock[ch] = OC::CORE::ticks;
    5d60:	6803      	ldr	r3, [r0, #0]
    5d62:	660b      	str	r3, [r1, #96]	; 0x60
    5d64:	2001      	movs	r0, #1
    5d66:	4770      	bx	lr
    5d68:	1fffa5b4 	.word	0x1fffa5b4
    5d6c:	200046cc 	.word	0x200046cc

00005d70 <HSApplication::ClockOut(int, int)>:
    void ClockOut(int ch, int ticks = 100) {
    5d70:	b508      	push	{r3, lr}
        clock_countdown[ch] = ticks;
    5d72:	eb00 0381 	add.w	r3, r0, r1, lsl #2
    5d76:	605a      	str	r2, [r3, #4]
        Out(ch, 0, PULSE_VOLTAGE);
    5d78:	2305      	movs	r3, #5
    5d7a:	2200      	movs	r2, #0
    5d7c:	f7ff ff26 	bl	5bcc <HSApplication::Out(int, int, int)>
    }
    5d80:	bd08      	pop	{r3, pc}
    5d82:	Address 0x0000000000005d82 is out of bounds.


00005d84 <HSApplication::gfxHeader(char const*)>:
    void gfxHeader(const char *str) {
    5d84:	b513      	push	{r0, r1, r4, lr}
  text_x_ = x;
    5d86:	4c0c      	ldr	r4, [pc, #48]	; (5db8 <HSApplication::gfxHeader(char const*)+0x34>)
    5d88:	2301      	movs	r3, #1
    5d8a:	6063      	str	r3, [r4, #4]
        graphics.print(str);
    5d8c:	4620      	mov	r0, r4
  text_y_ = y;
    5d8e:	2302      	movs	r3, #2
    5d90:	60a3      	str	r3, [r4, #8]
    5d92:	f013 fea0 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.drawLine(x, y, x2, y2);
    5d96:	220a      	movs	r2, #10
    5d98:	9200      	str	r2, [sp, #0]
    5d9a:	4620      	mov	r0, r4
    5d9c:	237f      	movs	r3, #127	; 0x7f
    5d9e:	2100      	movs	r1, #0
    5da0:	f013 fd26 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    5da4:	220c      	movs	r2, #12
    5da6:	9200      	str	r2, [sp, #0]
    5da8:	237f      	movs	r3, #127	; 0x7f
    5daa:	2100      	movs	r1, #0
    5dac:	4620      	mov	r0, r4
    5dae:	f013 fd1f 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    }
    5db2:	b002      	add	sp, #8
    5db4:	bd10      	pop	{r4, pc}
    5db6:	bf00      	nop
    5db8:	200065e0 	.word	0x200065e0

00005dbc <Settings::View()>:
    void View() {
    5dbc:	b538      	push	{r3, r4, r5, lr}
  text_x_ = x;
    5dbe:	4c11      	ldr	r4, [pc, #68]	; (5e04 <Settings::View()+0x48>)
        gfxHeader("Setup / About");
    5dc0:	4911      	ldr	r1, [pc, #68]	; (5e08 <Settings::View()+0x4c>)
    5dc2:	f7ff ffdf 	bl	5d84 <HSApplication::gfxHeader(char const*)>
    5dc6:	2500      	movs	r5, #0
  text_y_ = y;
    5dc8:	230f      	movs	r3, #15
        graphics.print(str);
    5dca:	4620      	mov	r0, r4
    5dcc:	490f      	ldr	r1, [pc, #60]	; (5e0c <Settings::View()+0x50>)
    5dce:	60a3      	str	r3, [r4, #8]
  text_x_ = x;
    5dd0:	6065      	str	r5, [r4, #4]
    5dd2:	f013 fe80 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_y_ = y;
    5dd6:	2319      	movs	r3, #25
    5dd8:	4620      	mov	r0, r4
    5dda:	490d      	ldr	r1, [pc, #52]	; (5e10 <Settings::View()+0x54>)
    5ddc:	60a3      	str	r3, [r4, #8]
  text_x_ = x;
    5dde:	6065      	str	r5, [r4, #4]
    5de0:	f013 fe79 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_y_ = y;
    5de4:	2323      	movs	r3, #35	; 0x23
    5de6:	4620      	mov	r0, r4
    5de8:	490a      	ldr	r1, [pc, #40]	; (5e14 <Settings::View()+0x58>)
    5dea:	60a3      	str	r3, [r4, #8]
  text_x_ = x;
    5dec:	6065      	str	r5, [r4, #4]
    5dee:	f013 fe72 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_y_ = y;
    5df2:	2337      	movs	r3, #55	; 0x37
  text_x_ = x;
    5df4:	6065      	str	r5, [r4, #4]
  text_y_ = y;
    5df6:	60a3      	str	r3, [r4, #8]
    5df8:	4620      	mov	r0, r4
    5dfa:	4907      	ldr	r1, [pc, #28]	; (5e18 <Settings::View()+0x5c>)
    }
    5dfc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5e00:	f013 be69 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    5e04:	200065e0 	.word	0x200065e0
    5e08:	00020f6c 	.word	0x00020f6c
    5e0c:	00020f7a 	.word	0x00020f7a
    5e10:	00020f8b 	.word	0x00020f8b
    5e14:	00020f95 	.word	0x00020f95
    5e18:	00020fa6 	.word	0x00020fa6

00005e1c <HS::TuringMachine::SetName(char*, unsigned char)>:
    uint16_t reg; // 16-bit shift register containing data
    byte len; // Length of this machine, in steps. 0 indicates an uninitialized TM
    bool favorite; // Basically locks this Turing Machine

    static void SetName(char *n, byte ix) {
        n[0] = 'A' + (ix / 8);
    5e1c:	08cb      	lsrs	r3, r1, #3
    5e1e:	3341      	adds	r3, #65	; 0x41
    5e20:	7003      	strb	r3, [r0, #0]
        n[1] = '-';
        n[2] = '1'  + (ix % 8);
    5e22:	f001 0107 	and.w	r1, r1, #7
        n[1] = '-';
    5e26:	232d      	movs	r3, #45	; 0x2d
    5e28:	7043      	strb	r3, [r0, #1]
        n[2] = '1'  + (ix % 8);
    5e2a:	3131      	adds	r1, #49	; 0x31
        n[3] = '\0';
    5e2c:	2300      	movs	r3, #0
        n[2] = '1'  + (ix % 8);
    5e2e:	7081      	strb	r1, [r0, #2]
        n[3] = '\0';
    5e30:	70c3      	strb	r3, [r0, #3]
    }
    5e32:	4770      	bx	lr

00005e34 <TuringMachineState::Init(unsigned char)>:
#ifndef TURINGMACHINESTATE_H
#define TURINGMACHINESTATE_H

class TuringMachineState {
public:
    void Init(byte ix_) {
    5e34:	b570      	push	{r4, r5, r6, lr}
        ix = constrain(ix_, 0, HS::TURING_MACHINE_COUNT - 1);
    5e36:	2927      	cmp	r1, #39	; 0x27
        if (HS::user_turing_machines[ix].len == 0 || HS::user_turing_machines[ix].len > 17) {
    5e38:	4d14      	ldr	r5, [pc, #80]	; (5e8c <TuringMachineState::Init(unsigned char)+0x58>)
        ix = constrain(ix_, 0, HS::TURING_MACHINE_COUNT - 1);
    5e3a:	bfa8      	it	ge
    5e3c:	2127      	movge	r1, #39	; 0x27
    5e3e:	7001      	strb	r1, [r0, #0]
        if (HS::user_turing_machines[ix].len == 0 || HS::user_turing_machines[ix].len > 17) {
    5e40:	eb05 0181 	add.w	r1, r5, r1, lsl #2
    void Init(byte ix_) {
    5e44:	4604      	mov	r4, r0
        if (HS::user_turing_machines[ix].len == 0 || HS::user_turing_machines[ix].len > 17) {
    5e46:	788b      	ldrb	r3, [r1, #2]
    5e48:	3b01      	subs	r3, #1
    5e4a:	2b10      	cmp	r3, #16
    5e4c:	d911      	bls.n	5e72 <TuringMachineState::Init(unsigned char)+0x3e>
            HS::user_turing_machines[ix].reg = (random(0, 0xff) << 8) + random(0, 0xff);
    5e4e:	21ff      	movs	r1, #255	; 0xff
    5e50:	2000      	movs	r0, #0
    5e52:	f014 f84c 	bl	19eee <random(long, long)>
    5e56:	21ff      	movs	r1, #255	; 0xff
    5e58:	4606      	mov	r6, r0
    5e5a:	2000      	movs	r0, #0
    5e5c:	f014 f847 	bl	19eee <random(long, long)>
    5e60:	7823      	ldrb	r3, [r4, #0]
    5e62:	eb00 2006 	add.w	r0, r0, r6, lsl #8
    5e66:	f825 0023 	strh.w	r0, [r5, r3, lsl #2]
            HS::user_turing_machines[ix].len = 16;
    5e6a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    5e6e:	2210      	movs	r2, #16
    5e70:	805a      	strh	r2, [r3, #2]
            HS::user_turing_machines[ix].favorite = 0;
        }
        reg = HS::user_turing_machines[ix].reg;
    5e72:	7823      	ldrb	r3, [r4, #0]
    5e74:	f835 2023 	ldrh.w	r2, [r5, r3, lsl #2]
    5e78:	8062      	strh	r2, [r4, #2]
        len = HS::user_turing_machines[ix].len;
    5e7a:	eb05 0583 	add.w	r5, r5, r3, lsl #2
    5e7e:	78ab      	ldrb	r3, [r5, #2]
    5e80:	7123      	strb	r3, [r4, #4]
        fav = HS::user_turing_machines[ix].favorite;
    5e82:	78eb      	ldrb	r3, [r5, #3]
    5e84:	7163      	strb	r3, [r4, #5]
        write = 0;
    5e86:	2300      	movs	r3, #0
    5e88:	71a3      	strb	r3, [r4, #6]
    }
    5e8a:	bd70      	pop	{r4, r5, r6, pc}
    5e8c:	200036e8 	.word	0x200036e8

00005e90 <TuringMachineState::Advance(unsigned char)>:
    void ChangeLength(int direction) {
        len = constrain(len + direction, 1, 16);
        if (write && !fav) HS::user_turing_machines[ix].len = len;
    }

    void Advance(byte p) {
    5e90:	b570      	push	{r4, r5, r6, lr}
        // Grab the bit that's about to be shifted away
        uint16_t last = (reg >> (len - 1)) & 0x01;
    5e92:	7903      	ldrb	r3, [r0, #4]
    5e94:	8844      	ldrh	r4, [r0, #2]
    void Advance(byte p) {
    5e96:	4605      	mov	r5, r0
        uint16_t last = (reg >> (len - 1)) & 0x01;
    5e98:	3b01      	subs	r3, #1

        // Does it change?
        if (!fav && random(0, 99) < p) last = 1 - last;
    5e9a:	7940      	ldrb	r0, [r0, #5]
        uint16_t last = (reg >> (len - 1)) & 0x01;
    5e9c:	411c      	asrs	r4, r3
    void Advance(byte p) {
    5e9e:	460e      	mov	r6, r1
        uint16_t last = (reg >> (len - 1)) & 0x01;
    5ea0:	f004 0401 	and.w	r4, r4, #1
        if (!fav && random(0, 99) < p) last = 1 - last;
    5ea4:	b930      	cbnz	r0, 5eb4 <TuringMachineState::Advance(unsigned char)+0x24>
    5ea6:	2163      	movs	r1, #99	; 0x63
    5ea8:	f014 f821 	bl	19eee <random(long, long)>
    5eac:	42b0      	cmp	r0, r6
    5eae:	bfb8      	it	lt
    5eb0:	f084 0401 	eorlt.w	r4, r4, #1

        // Shift left, then potentially add the bit from the other side
        reg = (reg << 1) + last;
    5eb4:	886b      	ldrh	r3, [r5, #2]
    5eb6:	eb04 0443 	add.w	r4, r4, r3, lsl #1

        if (write && !fav) HS::user_turing_machines[ix].reg = reg;
    5eba:	79ab      	ldrb	r3, [r5, #6]
        reg = (reg << 1) + last;
    5ebc:	b2a4      	uxth	r4, r4
    5ebe:	806c      	strh	r4, [r5, #2]
        if (write && !fav) HS::user_turing_machines[ix].reg = reg;
    5ec0:	b12b      	cbz	r3, 5ece <TuringMachineState::Advance(unsigned char)+0x3e>
    5ec2:	796b      	ldrb	r3, [r5, #5]
    5ec4:	b91b      	cbnz	r3, 5ece <TuringMachineState::Advance(unsigned char)+0x3e>
    5ec6:	782a      	ldrb	r2, [r5, #0]
    5ec8:	4b01      	ldr	r3, [pc, #4]	; (5ed0 <TuringMachineState::Advance(unsigned char)+0x40>)
    5eca:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
    }
    5ece:	bd70      	pop	{r4, r5, r6, pc}
    5ed0:	200036e8 	.word	0x200036e8

00005ed4 <TuringMachineState::DrawAt(unsigned char, unsigned char)>:

    byte GetLength() {return len;}

    bool IsFavorite() {return fav;}

    void DrawAt(byte x, byte y) {
    5ed4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
        // Adjust height if the display needs to go lower
        byte height = 19;
        if (y > 40) height -= (y - 40);
    5ed8:	2a28      	cmp	r2, #40	; 0x28

        graphics.drawLine(x, y, x + 63, y);
    5eda:	f101 073f 	add.w	r7, r1, #63	; 0x3f
        if (y > 40) height -= (y - 40);
    5ede:	bf88      	it	hi
    5ee0:	f1c2 063b 	rsbhi	r6, r2, #59	; 0x3b
    void DrawAt(byte x, byte y) {
    5ee4:	4615      	mov	r5, r2
        if (y > 40) height -= (y - 40);
    5ee6:	bf8c      	ite	hi
    5ee8:	b2f6      	uxtbhi	r6, r6
        byte height = 19;
    5eea:	2613      	movls	r6, #19
        graphics.drawLine(x, y, x + 63, y);
    5eec:	463b      	mov	r3, r7
    5eee:	9200      	str	r2, [sp, #0]
    void DrawAt(byte x, byte y) {
    5ef0:	4680      	mov	r8, r0
        graphics.drawLine(x, y, x + 63, y);
    5ef2:	4812      	ldr	r0, [pc, #72]	; (5f3c <TuringMachineState::DrawAt(unsigned char, unsigned char)+0x68>)
        graphics.drawLine(x, y + height + 3, x + 63, y + height + 3);
        for (byte b = 0; b < 16; b++)
        {
            int v = (reg >> b) & 0x01;
            if (v) graphics.drawRect(60 + x - (4 * b), y + 2, 3, height);
    5ef4:	f8df 9044 	ldr.w	r9, [pc, #68]	; 5f3c <TuringMachineState::DrawAt(unsigned char, unsigned char)+0x68>
    void DrawAt(byte x, byte y) {
    5ef8:	460c      	mov	r4, r1
        graphics.drawLine(x, y, x + 63, y);
    5efa:	f013 fc79 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        graphics.drawLine(x, y + height + 3, x + 63, y + height + 3);
    5efe:	19aa      	adds	r2, r5, r6
    5f00:	3203      	adds	r2, #3
    5f02:	463b      	mov	r3, r7
    5f04:	4621      	mov	r1, r4
    5f06:	480d      	ldr	r0, [pc, #52]	; (5f3c <TuringMachineState::DrawAt(unsigned char, unsigned char)+0x68>)
    5f08:	9200      	str	r2, [sp, #0]
    5f0a:	f013 fc71 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        for (byte b = 0; b < 16; b++)
    5f0e:	343c      	adds	r4, #60	; 0x3c
        graphics.drawLine(x, y + height + 3, x + 63, y + height + 3);
    5f10:	2700      	movs	r7, #0
            if (v) graphics.drawRect(60 + x - (4 * b), y + 2, 3, height);
    5f12:	3502      	adds	r5, #2
            int v = (reg >> b) & 0x01;
    5f14:	f8b8 3002 	ldrh.w	r3, [r8, #2]
    5f18:	413b      	asrs	r3, r7
            if (v) graphics.drawRect(60 + x - (4 * b), y + 2, 3, height);
    5f1a:	07db      	lsls	r3, r3, #31
    5f1c:	d506      	bpl.n	5f2c <TuringMachineState::DrawAt(unsigned char, unsigned char)+0x58>
    5f1e:	9600      	str	r6, [sp, #0]
    5f20:	2303      	movs	r3, #3
    5f22:	462a      	mov	r2, r5
    5f24:	4621      	mov	r1, r4
    5f26:	4648      	mov	r0, r9
    5f28:	f013 f9b4 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
        for (byte b = 0; b < 16; b++)
    5f2c:	3701      	adds	r7, #1
    5f2e:	2f10      	cmp	r7, #16
    5f30:	f1a4 0404 	sub.w	r4, r4, #4
    5f34:	d1ee      	bne.n	5f14 <TuringMachineState::DrawAt(unsigned char, unsigned char)+0x40>
        }
    }
    5f36:	b003      	add	sp, #12
    5f38:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5f3c:	200065e0 	.word	0x200065e0

00005f40 <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)>:
  int32_t previous_boundary_;
  int32_t next_boundary_;
  uint16_t note_number_;
  bool requantize_;

  inline void Configure(const int16_t* notes, int16_t scale_span, size_t num_notes, uint16_t mask)
    5f40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5f44:	f8bd 6020 	ldrh.w	r6, [sp, #32]
  {  
    enabled_ = notes != NULL && num_notes != 0 && scale_span != 0 && (mask & ~(0xffff<<num_notes));
    5f48:	2900      	cmp	r1, #0
    5f4a:	d050      	beq.n	5fee <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)+0xae>
    5f4c:	2b00      	cmp	r3, #0
    5f4e:	d04e      	beq.n	5fee <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)+0xae>
    5f50:	2a00      	cmp	r2, #0
    5f52:	d04c      	beq.n	5fee <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)+0xae>
    5f54:	f64f 74ff 	movw	r4, #65535	; 0xffff
    5f58:	409c      	lsls	r4, r3
    5f5a:	ea36 0404 	bics.w	r4, r6, r4
    5f5e:	d046      	beq.n	5fee <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)+0xae>
    5f60:	2401      	movs	r4, #1
    5f62:	7004      	strb	r4, [r0, #0]
  
      // Build up array that contains only the enabled notes, and use that to
      // generate the codebook. This avoids a bunch of issues and checks in the
      // main generating loop.
      size_t num_enabled_notes = 0;
      for (size_t i = 0; i < num_notes; ++i) {
    5f64:	2400      	movs	r4, #0
      size_t num_enabled_notes = 0;
    5f66:	4625      	mov	r5, r4
        if (mask & 1)
    5f68:	07f7      	lsls	r7, r6, #31
          enabled_notes_[num_enabled_notes++] = notes[i];
    5f6a:	bf42      	ittt	mi
    5f6c:	eb00 0745 	addmi.w	r7, r0, r5, lsl #1
    5f70:	f931 c014 	ldrshmi.w	ip, [r1, r4, lsl #1]
    5f74:	f8a7 c002 	strhmi.w	ip, [r7, #2]
      for (size_t i = 0; i < num_notes; ++i) {
    5f78:	f104 0401 	add.w	r4, r4, #1
          enabled_notes_[num_enabled_notes++] = notes[i];
    5f7c:	bf48      	it	mi
    5f7e:	3501      	addmi	r5, #1
      for (size_t i = 0; i < num_notes; ++i) {
    5f80:	42a3      	cmp	r3, r4
        mask >>= 1;
    5f82:	ea4f 0656 	mov.w	r6, r6, lsr #1
      for (size_t i = 0; i < num_notes; ++i) {
    5f86:	d1ef      	bne.n	5f68 <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)+0x28>
      }
      notes = enabled_notes_;
     
      int32_t octave = 0;
      size_t note = 0;
    5f88:	2300      	movs	r3, #0
    5f8a:	f8df 906c 	ldr.w	r9, [pc, #108]	; 5ff8 <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)+0xb8>
      notes = enabled_notes_;
    5f8e:	f100 0c02 	add.w	ip, r0, #2
      int16_t span = scale_span;
      int16_t *codebook;
      
      codebook = &codebook_[0];
    
      for (int32_t i = 0; i < 64; ++i) {
    5f92:	f100 07a0 	add.w	r7, r0, #160	; 0xa0
    5f96:	f100 0ea2 	add.w	lr, r0, #162	; 0xa2
      int32_t octave = 0;
    5f9a:	461e      	mov	r6, r3
    5f9c:	f500 7090 	add.w	r0, r0, #288	; 0x120
        int32_t up = notes[note] + span * octave;
        int32_t down = notes[num_enabled_notes - 1 - note] + (-octave - 1) * span;
    5fa0:	f105 3aff 	add.w	sl, r5, #4294967295	; 0xffffffff
    5fa4:	f647 78ff 	movw	r8, #32767	; 0x7fff
    5fa8:	ebaa 0103 	sub.w	r1, sl, r3
    5fac:	43f4      	mvns	r4, r6
    5fae:	f93c 1011 	ldrsh.w	r1, [ip, r1, lsl #1]
    5fb2:	fb02 1104 	mla	r1, r2, r4, r1
    5fb6:	4541      	cmp	r1, r8
        int32_t up = notes[note] + span * octave;
    5fb8:	f93c 4013 	ldrsh.w	r4, [ip, r3, lsl #1]
    5fbc:	bfa8      	it	ge
    5fbe:	4641      	movge	r1, r8
    5fc0:	fb06 4402 	mla	r4, r6, r2, r4
    5fc4:	4549      	cmp	r1, r9
    5fc6:	bfb8      	it	lt
    5fc8:	4649      	movlt	r1, r9
        CLIP(up)
        CLIP(down)
        *(codebook + 64 + i) = up;
    5fca:	4544      	cmp	r4, r8
    5fcc:	bfa8      	it	ge
    5fce:	4644      	movge	r4, r8
    5fd0:	454c      	cmp	r4, r9
    5fd2:	bfb8      	it	lt
    5fd4:	464c      	movlt	r4, r9
    5fd6:	f827 4f02 	strh.w	r4, [r7, #2]!
        *(codebook + 63 - i) = down;
        ++note;
    5fda:	3301      	adds	r3, #1
        if (note >= num_enabled_notes) {
    5fdc:	429d      	cmp	r5, r3
          note = 0;
          ++octave;
    5fde:	bf9c      	itt	ls
    5fe0:	3601      	addls	r6, #1
          note = 0;
    5fe2:	2300      	movls	r3, #0
      for (int32_t i = 0; i < 64; ++i) {
    5fe4:	42b8      	cmp	r0, r7
        *(codebook + 63 - i) = down;
    5fe6:	f82e 1d02 	strh.w	r1, [lr, #-2]!
      for (int32_t i = 0; i < 64; ++i) {
    5fea:	d1dd      	bne.n	5fa8 <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)+0x68>
    5fec:	e001      	b.n	5ff2 <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)+0xb2>
    enabled_ = notes != NULL && num_notes != 0 && scale_span != 0 && (mask & ~(0xffff<<num_notes));
    5fee:	2300      	movs	r3, #0
    5ff0:	7003      	strb	r3, [r0, #0]
        }
      }
    }
  }
    5ff2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5ff6:	bf00      	nop
    5ff8:	ffff8001 	.word	0xffff8001

00005ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>:
  void Configure(const Scale& scale, uint16_t mask = 0xffff) {
    5ffc:	b507      	push	{r0, r1, r2, lr}
    Configure(scale.notes, scale.span, scale.num_notes, mask);
    5ffe:	684b      	ldr	r3, [r1, #4]
    6000:	9200      	str	r2, [sp, #0]
    6002:	f931 2b08 	ldrsh.w	r2, [r1], #8
    6006:	f7ff ff9b 	bl	5f40 <braids::Quantizer::Configure(short const*, short, unsigned int, unsigned short)>
  }
    600a:	b003      	add	sp, #12
    600c:	f85d fb04 	ldr.w	pc, [sp], #4

00006010 <TheDarkestTimeline::Start()>:
	void Start() {
    6010:	b570      	push	{r4, r5, r6, lr}
        quantizer.Init();
    6012:	f100 05b0 	add.w	r5, r0, #176	; 0xb0
	void Start() {
    6016:	4604      	mov	r4, r0
        quantizer.Init();
    6018:	4628      	mov	r0, r5
    601a:	f7fb f9a3 	bl	1364 <braids::Quantizer::Init()>
        quantizer.Configure(OC::Scales::GetScale(5), 0xffff);
    601e:	2005      	movs	r0, #5
    6020:	f7fa ffa8 	bl	f74 <OC::Scales::GetScale(int)>
    6024:	f64f 72ff 	movw	r2, #65535	; 0xffff
    6028:	4601      	mov	r1, r0
    602a:	4628      	mov	r0, r5
    602c:	f7ff ffe6 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
        Resume();
    6030:	6823      	ldr	r3, [r4, #0]
    6032:	4620      	mov	r0, r4
    6034:	68db      	ldr	r3, [r3, #12]
	}
    6036:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        Resume();
    603a:	4718      	bx	r3

0000603c <TM::Start()>:
    void Start() {
    603c:	b538      	push	{r3, r4, r5, lr}
        reg = random(0, 65535);
    603e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    void Start() {
    6042:	4604      	mov	r4, r0
        reg = random(0, 65535);
    6044:	2000      	movs	r0, #0
    6046:	f013 ff52 	bl	19eee <random(long, long)>
        quantizer.Init();
    604a:	f104 0574 	add.w	r5, r4, #116	; 0x74
        p = 0;
    604e:	2300      	movs	r3, #0
        length = 16;
    6050:	2210      	movs	r2, #16
    6052:	66e2      	str	r2, [r4, #108]	; 0x6c
        reg = random(0, 65535);
    6054:	f8a4 01ac 	strh.w	r0, [r4, #428]	; 0x1ac
        p = 0;
    6058:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
        cursor = 0;
    605c:	6723      	str	r3, [r4, #112]	; 0x70
        quantizer.Init();
    605e:	4628      	mov	r0, r5
    6060:	f7fb f980 	bl	1364 <braids::Quantizer::Init()>
        scale = OC::Scales::SCALE_SEMI;
    6064:	2005      	movs	r0, #5
    6066:	f884 01b4 	strb.w	r0, [r4, #436]	; 0x1b4
        quantizer.Configure(OC::Scales::GetScale(scale), 0xffff); // Semi-tone
    606a:	f7fa ff83 	bl	f74 <OC::Scales::GetScale(int)>
    606e:	f64f 72ff 	movw	r2, #65535	; 0xffff
    6072:	4601      	mov	r1, r0
    6074:	4628      	mov	r0, r5
    6076:	f7ff ffc1 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    }
    607a:	bd38      	pop	{r3, r4, r5, pc}

0000607c <Squanch::Start()>:
    void Start() {
    607c:	b538      	push	{r3, r4, r5, lr}
        quantizer.Init();
    607e:	f100 057c 	add.w	r5, r0, #124	; 0x7c
    void Start() {
    6082:	4604      	mov	r4, r0
        quantizer.Init();
    6084:	4628      	mov	r0, r5
    6086:	f7fb f96d 	bl	1364 <braids::Quantizer::Init()>
        scale = 5;
    608a:	2005      	movs	r0, #5
    608c:	f8c4 01b4 	str.w	r0, [r4, #436]	; 0x1b4
        quantizer.Configure(OC::Scales::GetScale(scale), 0xffff);
    6090:	f7fa ff70 	bl	f74 <OC::Scales::GetScale(int)>
    6094:	f64f 72ff 	movw	r2, #65535	; 0xffff
    6098:	4601      	mov	r1, r0
    609a:	4628      	mov	r0, r5
    609c:	f7ff ffae 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    }
    60a0:	bd38      	pop	{r3, r4, r5, pc}

000060a2 <ScaleDuet::Start()>:
    void Start() {
    60a2:	b538      	push	{r3, r4, r5, lr}
            mask[scale] = 0xffff;
    60a4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
        quantizer.Init();
    60a8:	f100 056c 	add.w	r5, r0, #108	; 0x6c
            mask[scale] = 0xffff;
    60ac:	f8c0 31a4 	str.w	r3, [r0, #420]	; 0x1a4
    void Start() {
    60b0:	4604      	mov	r4, r0
        quantizer.Init();
    60b2:	4628      	mov	r0, r5
    60b4:	f7fb f956 	bl	1364 <braids::Quantizer::Init()>
        quantizer.Configure(OC::Scales::GetScale(5), mask[0]);
    60b8:	2005      	movs	r0, #5
    60ba:	f7fa ff5b 	bl	f74 <OC::Scales::GetScale(int)>
    60be:	f8b4 21a4 	ldrh.w	r2, [r4, #420]	; 0x1a4
    60c2:	4601      	mov	r1, r0
    60c4:	4628      	mov	r0, r5
    60c6:	f7ff ff99 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
        last_scale = 0;
    60ca:	2300      	movs	r3, #0
    60cc:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
        adc_lag_countdown = 0;
    60d0:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
    }
    60d4:	bd38      	pop	{r3, r4, r5, pc}

000060d6 <DualQuant::Start()>:
    void Start() {
    60d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        cursor = 0;
    60d8:	2500      	movs	r5, #0
            quantizer[ch].Init();
    60da:	f100 066c 	add.w	r6, r0, #108	; 0x6c
    void Start() {
    60de:	4604      	mov	r4, r0
        cursor = 0;
    60e0:	f8c0 52e8 	str.w	r5, [r0, #744]	; 0x2e8
            quantizer[ch].Init();
    60e4:	4630      	mov	r0, r6
    60e6:	f7fb f93d 	bl	1364 <braids::Quantizer::Init()>
            scale[ch] = ch + 5;
    60ea:	2005      	movs	r0, #5
    60ec:	f8c4 02ec 	str.w	r0, [r4, #748]	; 0x2ec
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    60f0:	f7fa ff40 	bl	f74 <OC::Scales::GetScale(int)>
            quantizer[ch].Init();
    60f4:	f504 77d2 	add.w	r7, r4, #420	; 0x1a4
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    60f8:	4601      	mov	r1, r0
    60fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
    60fe:	4630      	mov	r0, r6
            continuous[ch] = 1;
    6100:	2601      	movs	r6, #1
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    6102:	f7ff ff7b 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
            quantizer[ch].Init();
    6106:	4638      	mov	r0, r7
            last_note[ch] = 0;
    6108:	f8c4 52dc 	str.w	r5, [r4, #732]	; 0x2dc
            continuous[ch] = 1;
    610c:	f884 62e4 	strb.w	r6, [r4, #740]	; 0x2e4
            quantizer[ch].Init();
    6110:	f7fb f928 	bl	1364 <braids::Quantizer::Init()>
            scale[ch] = ch + 5;
    6114:	2006      	movs	r0, #6
    6116:	f8c4 02f0 	str.w	r0, [r4, #752]	; 0x2f0
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    611a:	f7fa ff2b 	bl	f74 <OC::Scales::GetScale(int)>
    611e:	f64f 72ff 	movw	r2, #65535	; 0xffff
    6122:	4601      	mov	r1, r0
    6124:	4638      	mov	r0, r7
    6126:	f7ff ff69 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
            last_note[ch] = 0;
    612a:	f8c4 52e0 	str.w	r5, [r4, #736]	; 0x2e0
            continuous[ch] = 1;
    612e:	f884 62e5 	strb.w	r6, [r4, #741]	; 0x2e5
    }
    6132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00006134 <ASR::Start()>:
    void Start() {
    6134:	b510      	push	{r4, lr}
    6136:	4604      	mov	r4, r0
    void SetIndex(byte ix) {index = ix;}
    6138:	2201      	movs	r2, #1
    613a:	6f23      	ldr	r3, [r4, #112]	; 0x70
        scale = OC::Scales::SCALE_SEMI;
    613c:	2005      	movs	r0, #5
    613e:	f8c4 01ac 	str.w	r0, [r4, #428]	; 0x1ac
    6142:	f883 2401 	strb.w	r2, [r3, #1025]	; 0x401
        quantizer.Configure(OC::Scales::GetScale(scale), 0xffff); // Semi-tone
    6146:	f7fa ff15 	bl	f74 <OC::Scales::GetScale(int)>
    614a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    614e:	4601      	mov	r1, r0
    6150:	f104 0074 	add.w	r0, r4, #116	; 0x74
    6154:	f7ff ff52 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    }
    6158:	bd10      	pop	{r4, pc}
    615a:	Address 0x000000000000615a is out of bounds.


0000615c <ASR_OnEncoderMove(bool, int)>:
void ASR_OnEncoderMove(bool hemisphere, int direction) {ASR_instance[hemisphere].OnEncoderMove(direction);}
    615c:	b538      	push	{r3, r4, r5, lr}
        if (cursor == 0) { // Index
    615e:	4d1b      	ldr	r5, [pc, #108]	; (61cc <ASR_OnEncoderMove(bool, int)+0x70>)
    6160:	f44f 73da 	mov.w	r3, #436	; 0x1b4
    6164:	fb03 5300 	mla	r3, r3, r0, r5
    6168:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    616a:	b932      	cbnz	r2, 617a <ASR_OnEncoderMove(bool, int)+0x1e>
            byte ix = buffer_m->GetIndex();
    616c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
            buffer_m->SetIndex(ix + direction);
    616e:	f892 3401 	ldrb.w	r3, [r2, #1025]	; 0x401
    6172:	440b      	add	r3, r1
    6174:	f882 3401 	strb.w	r3, [r2, #1025]	; 0x401
void ASR_OnEncoderMove(bool hemisphere, int direction) {ASR_instance[hemisphere].OnEncoderMove(direction);}
    6178:	bd38      	pop	{r3, r4, r5, pc}
        if (cursor == 1) { // Scale selection
    617a:	2a01      	cmp	r2, #1
    617c:	d1fc      	bne.n	6178 <ASR_OnEncoderMove(bool, int)+0x1c>
            scale += direction;
    617e:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
    6182:	4411      	add	r1, r2
            if (scale >= OC::Scales::NUM_SCALES) scale = 0;
    6184:	4a12      	ldr	r2, [pc, #72]	; (61d0 <ASR_OnEncoderMove(bool, int)+0x74>)
    6186:	6812      	ldr	r2, [r2, #0]
    6188:	4291      	cmp	r1, r2
    618a:	da18      	bge.n	61be <ASR_OnEncoderMove(bool, int)+0x62>
            if (scale < 0) scale = OC::Scales::NUM_SCALES - 1;
    618c:	2900      	cmp	r1, #0
    618e:	db18      	blt.n	61c2 <ASR_OnEncoderMove(bool, int)+0x66>
    6190:	f44f 73da 	mov.w	r3, #436	; 0x1b4
    6194:	fb03 5300 	mla	r3, r3, r0, r5
    6198:	f8c3 11ac 	str.w	r1, [r3, #428]	; 0x1ac
            quantizer.Configure(OC::Scales::GetScale(scale), 0xffff);
    619c:	f44f 73da 	mov.w	r3, #436	; 0x1b4
    61a0:	fb03 f400 	mul.w	r4, r3, r0
    61a4:	192b      	adds	r3, r5, r4
    61a6:	3474      	adds	r4, #116	; 0x74
    61a8:	f8d3 01ac 	ldr.w	r0, [r3, #428]	; 0x1ac
    61ac:	f7fa fee2 	bl	f74 <OC::Scales::GetScale(int)>
    61b0:	f64f 72ff 	movw	r2, #65535	; 0xffff
    61b4:	4601      	mov	r1, r0
    61b6:	1928      	adds	r0, r5, r4
    61b8:	f7ff ff20 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
void ASR_OnEncoderMove(bool hemisphere, int direction) {ASR_instance[hemisphere].OnEncoderMove(direction);}
    61bc:	e7dc      	b.n	6178 <ASR_OnEncoderMove(bool, int)+0x1c>
            if (scale >= OC::Scales::NUM_SCALES) scale = 0;
    61be:	2100      	movs	r1, #0
    61c0:	e7e6      	b.n	6190 <ASR_OnEncoderMove(bool, int)+0x34>
            if (scale < 0) scale = OC::Scales::NUM_SCALES - 1;
    61c2:	3a01      	subs	r2, #1
    61c4:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
    61c8:	e7e8      	b.n	619c <ASR_OnEncoderMove(bool, int)+0x40>
    61ca:	bf00      	nop
    61cc:	1fffab30 	.word	0x1fffab30
    61d0:	0001e700 	.word	0x0001e700

000061d4 <DualQuant_OnEncoderMove(bool, int)>:
void DualQuant_OnEncoderMove(bool hemisphere, int direction) {
    61d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        uint8_t ch = cursor / 2;
    61d6:	4c29      	ldr	r4, [pc, #164]	; (627c <DualQuant_OnEncoderMove(bool, int)+0xa8>)
    61d8:	f44f 733e 	mov.w	r3, #760	; 0x2f8
    61dc:	fb03 4300 	mla	r3, r3, r0, r4
void DualQuant_OnEncoderMove(bool hemisphere, int direction) {
    61e0:	4605      	mov	r5, r0
        uint8_t ch = cursor / 2;
    61e2:	f8d3 72e8 	ldr.w	r7, [r3, #744]	; 0x2e8
    61e6:	eb07 76d7 	add.w	r6, r7, r7, lsr #31
        if (cursor == 0 || cursor == 2) {
    61ea:	f037 0702 	bics.w	r7, r7, #2
    61ee:	f3c6 0647 	ubfx	r6, r6, #1, #8
    61f2:	d136      	bne.n	6262 <DualQuant_OnEncoderMove(bool, int)+0x8e>
            scale[ch] += direction;
    61f4:	22be      	movs	r2, #190	; 0xbe
    61f6:	fb02 6300 	mla	r3, r2, r0, r6
    61fa:	33ba      	adds	r3, #186	; 0xba
    61fc:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    6200:	6858      	ldr	r0, [r3, #4]
    6202:	4401      	add	r1, r0
            if (scale[ch] >= OC::Scales::NUM_SCALES) scale[ch] = 0;
    6204:	481e      	ldr	r0, [pc, #120]	; (6280 <DualQuant_OnEncoderMove(bool, int)+0xac>)
    6206:	6800      	ldr	r0, [r0, #0]
    6208:	4281      	cmp	r1, r0
    620a:	da25      	bge.n	6258 <DualQuant_OnEncoderMove(bool, int)+0x84>
            if (scale[ch] < 0) scale[ch] = OC::Scales::NUM_SCALES - 1;
    620c:	2900      	cmp	r1, #0
    620e:	db25      	blt.n	625c <DualQuant_OnEncoderMove(bool, int)+0x88>
    6210:	fb02 6205 	mla	r2, r2, r5, r6
    6214:	eb04 0282 	add.w	r2, r4, r2, lsl #2
    6218:	f8c2 12ec 	str.w	r1, [r2, #748]	; 0x2ec
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    621c:	23be      	movs	r3, #190	; 0xbe
    621e:	fb03 6305 	mla	r3, r3, r5, r6
    6222:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    6226:	f8d3 02ec 	ldr.w	r0, [r3, #748]	; 0x2ec
    622a:	f7fa fea3 	bl	f74 <OC::Scales::GetScale(int)>
    622e:	f44f 733e 	mov.w	r3, #760	; 0x2f8
    6232:	435d      	muls	r5, r3
    6234:	f44f 729c 	mov.w	r2, #312	; 0x138
    6238:	f105 036c 	add.w	r3, r5, #108	; 0x6c
    623c:	fb02 3306 	mla	r3, r2, r6, r3
    6240:	4601      	mov	r1, r0
    6242:	18e0      	adds	r0, r4, r3
            continuous[ch] = 1; // Re-enable continuous mode when scale is changed
    6244:	442c      	add	r4, r5
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    6246:	f64f 72ff 	movw	r2, #65535	; 0xffff
            continuous[ch] = 1; // Re-enable continuous mode when scale is changed
    624a:	4434      	add	r4, r6
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    624c:	f7ff fed6 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
            continuous[ch] = 1; // Re-enable continuous mode when scale is changed
    6250:	2301      	movs	r3, #1
    6252:	f884 32e4 	strb.w	r3, [r4, #740]	; 0x2e4
}
    6256:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if (scale[ch] >= OC::Scales::NUM_SCALES) scale[ch] = 0;
    6258:	4639      	mov	r1, r7
    625a:	e7d9      	b.n	6210 <DualQuant_OnEncoderMove(bool, int)+0x3c>
            if (scale[ch] < 0) scale[ch] = OC::Scales::NUM_SCALES - 1;
    625c:	3801      	subs	r0, #1
    625e:	6058      	str	r0, [r3, #4]
    6260:	e7dc      	b.n	621c <DualQuant_OnEncoderMove(bool, int)+0x48>
            root[ch] = constrain(root[ch] + direction, 0, 11);
    6262:	4433      	add	r3, r6
    6264:	f893 22f4 	ldrb.w	r2, [r3, #756]	; 0x2f4
    6268:	4411      	add	r1, r2
    626a:	290b      	cmp	r1, #11
    626c:	bfa8      	it	ge
    626e:	210b      	movge	r1, #11
    6270:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
    6274:	f883 12f4 	strb.w	r1, [r3, #756]	; 0x2f4
}
    6278:	e7ed      	b.n	6256 <DualQuant_OnEncoderMove(bool, int)+0x82>
    627a:	bf00      	nop
    627c:	1fffcda4 	.word	0x1fffcda4
    6280:	0001e700 	.word	0x0001e700

00006284 <ScaleDuet_OnButtonPress(bool)>:
void ScaleDuet_OnButtonPress(bool hemisphere) {
    6284:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        uint8_t scale = cursor > 11 ? 1 : 0;
    6286:	4e16      	ldr	r6, [pc, #88]	; (62e0 <ScaleDuet_OnButtonPress(bool)+0x5c>)
    6288:	f44f 75d8 	mov.w	r5, #432	; 0x1b0
    628c:	4345      	muls	r5, r0
    628e:	1977      	adds	r7, r6, r5
        mask[scale] ^= (0x01 << bit);
    6290:	22d8      	movs	r2, #216	; 0xd8
        uint8_t scale = cursor > 11 ? 1 : 0;
    6292:	f897 31a8 	ldrb.w	r3, [r7, #424]	; 0x1a8
    6296:	2b0b      	cmp	r3, #11
    6298:	bf8c      	ite	hi
    629a:	2101      	movhi	r1, #1
    629c:	2100      	movls	r1, #0
        mask[scale] ^= (0x01 << bit);
    629e:	fb02 1400 	mla	r4, r2, r0, r1
    62a2:	f104 04d0 	add.w	r4, r4, #208	; 0xd0
        uint8_t bit = cursor - (scale * 12);
    62a6:	bf8c      	ite	hi
    62a8:	f06f 020b 	mvnhi.w	r2, #11
    62ac:	2200      	movls	r2, #0
        mask[scale] ^= (0x01 << bit);
    62ae:	eb06 0444 	add.w	r4, r6, r4, lsl #1
        uint8_t bit = cursor - (scale * 12);
    62b2:	4413      	add	r3, r2
        mask[scale] ^= (0x01 << bit);
    62b4:	b2db      	uxtb	r3, r3
    62b6:	2201      	movs	r2, #1
    62b8:	fa02 f303 	lsl.w	r3, r2, r3
    62bc:	88a2      	ldrh	r2, [r4, #4]
    62be:	4053      	eors	r3, r2
    62c0:	80a3      	strh	r3, [r4, #4]
        if (scale == last_scale) quantizer.Configure(OC::Scales::GetScale(5), mask[scale]);
    62c2:	f897 31a9 	ldrb.w	r3, [r7, #425]	; 0x1a9
    62c6:	428b      	cmp	r3, r1
    62c8:	d108      	bne.n	62dc <ScaleDuet_OnButtonPress(bool)+0x58>
    62ca:	2005      	movs	r0, #5
    62cc:	f7fa fe52 	bl	f74 <OC::Scales::GetScale(int)>
    62d0:	356c      	adds	r5, #108	; 0x6c
    62d2:	4601      	mov	r1, r0
    62d4:	88a2      	ldrh	r2, [r4, #4]
    62d6:	1970      	adds	r0, r6, r5
    62d8:	f7ff fe90 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
}
    62dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    62de:	bf00      	nop
    62e0:	20000fac 	.word	0x20000fac

000062e4 <ScaleDuet_OnDataReceive(bool, unsigned long)>:

void ScaleDuet_OnDataReceive(bool hemisphere, uint32_t data) {
    62e4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
        mask[0] = Unpack(data, PackLocation {0,12});
    62e8:	f04f 080c 	mov.w	r8, #12
    62ec:	2300      	movs	r3, #0
    62ee:	e9cd 3802 	strd	r3, r8, [sp, #8]
void ScaleDuet_OnDataReceive(bool hemisphere, uint32_t data) {
    62f2:	460f      	mov	r7, r1
        mask[0] = Unpack(data, PackLocation {0,12});
    62f4:	ab04      	add	r3, sp, #16
    62f6:	e913 0006 	ldmdb	r3, {r1, r2}
void ScaleDuet_OnDataReceive(bool hemisphere, uint32_t data) {
    62fa:	4604      	mov	r4, r0
        mask[0] = Unpack(data, PackLocation {0,12});
    62fc:	4638      	mov	r0, r7
    62fe:	f7fd fd97 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    6302:	4d13      	ldr	r5, [pc, #76]	; (6350 <ScaleDuet_OnDataReceive(bool, unsigned long)+0x6c>)
    6304:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
    6308:	435c      	muls	r4, r3
    630a:	192e      	adds	r6, r5, r4
        mask[1] = Unpack(data, PackLocation {12,12});
    630c:	4642      	mov	r2, r8
    630e:	4641      	mov	r1, r8
        mask[0] = Unpack(data, PackLocation {0,12});
    6310:	f8a6 01a4 	strh.w	r0, [r6, #420]	; 0x1a4
        mask[1] = Unpack(data, PackLocation {12,12});
    6314:	4638      	mov	r0, r7
    6316:	e9cd 8800 	strd	r8, r8, [sp]
    631a:	f7fd fd89 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    631e:	f8a6 01a6 	strh.w	r0, [r6, #422]	; 0x1a6
        ForEachChannel(ch) quantizer.Configure(OC::Scales::GetScale(5), mask[ch]);
    6322:	2005      	movs	r0, #5
    6324:	f7fa fe26 	bl	f74 <OC::Scales::GetScale(int)>
    6328:	346c      	adds	r4, #108	; 0x6c
    632a:	442c      	add	r4, r5
    632c:	f8b6 21a4 	ldrh.w	r2, [r6, #420]	; 0x1a4
    6330:	4601      	mov	r1, r0
    6332:	4620      	mov	r0, r4
    6334:	f7ff fe62 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    6338:	2005      	movs	r0, #5
    633a:	f7fa fe1b 	bl	f74 <OC::Scales::GetScale(int)>
    633e:	f8b6 21a6 	ldrh.w	r2, [r6, #422]	; 0x1a6
    6342:	4601      	mov	r1, r0
    6344:	4620      	mov	r0, r4
    6346:	f7ff fe59 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    ScaleDuet_instance[hemisphere].OnDataReceive(data);
}
    634a:	b004      	add	sp, #16
    634c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6350:	20000fac 	.word	0x20000fac

00006354 <Squanch_OnEncoderMove(bool, int)>:
void Squanch_OnEncoderMove(bool hemisphere, int direction) {Squanch_instance[hemisphere].OnEncoderMove(direction);}
    6354:	b570      	push	{r4, r5, r6, lr}
        if (cursor == 2) { // Scale selection
    6356:	4c21      	ldr	r4, [pc, #132]	; (63dc <Squanch_OnEncoderMove(bool, int)+0x88>)
    6358:	f44f 72de 	mov.w	r2, #444	; 0x1bc
    635c:	fb02 4200 	mla	r2, r2, r0, r4
    6360:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
    6362:	2b02      	cmp	r3, #2
    6364:	d127      	bne.n	63b6 <Squanch_OnEncoderMove(bool, int)+0x62>
            scale += direction;
    6366:	f8d2 31b4 	ldr.w	r3, [r2, #436]	; 0x1b4
    636a:	4419      	add	r1, r3
            if (scale >= OC::Scales::NUM_SCALES) scale = 0;
    636c:	4b1c      	ldr	r3, [pc, #112]	; (63e0 <Squanch_OnEncoderMove(bool, int)+0x8c>)
    636e:	681b      	ldr	r3, [r3, #0]
    6370:	4299      	cmp	r1, r3
    6372:	da1a      	bge.n	63aa <Squanch_OnEncoderMove(bool, int)+0x56>
            if (scale < 0) scale = OC::Scales::NUM_SCALES - 1;
    6374:	2900      	cmp	r1, #0
    6376:	db1a      	blt.n	63ae <Squanch_OnEncoderMove(bool, int)+0x5a>
    6378:	f44f 73de 	mov.w	r3, #444	; 0x1bc
    637c:	fb03 4300 	mla	r3, r3, r0, r4
    6380:	f8c3 11b4 	str.w	r1, [r3, #436]	; 0x1b4
            quantizer.Configure(OC::Scales::GetScale(scale), 0xffff);
    6384:	f44f 75de 	mov.w	r5, #444	; 0x1bc
    6388:	4345      	muls	r5, r0
    638a:	1966      	adds	r6, r4, r5
    638c:	357c      	adds	r5, #124	; 0x7c
    638e:	f8d6 01b4 	ldr.w	r0, [r6, #436]	; 0x1b4
    6392:	f7fa fdef 	bl	f74 <OC::Scales::GetScale(int)>
    6396:	f64f 72ff 	movw	r2, #65535	; 0xffff
    639a:	4601      	mov	r1, r0
    639c:	1960      	adds	r0, r4, r5
    639e:	f7ff fe2d 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
            continuous = 1; // Re-enable continuous mode when scale is changed
    63a2:	2301      	movs	r3, #1
    63a4:	f886 3070 	strb.w	r3, [r6, #112]	; 0x70
void Squanch_OnEncoderMove(bool hemisphere, int direction) {Squanch_instance[hemisphere].OnEncoderMove(direction);}
    63a8:	bd70      	pop	{r4, r5, r6, pc}
            if (scale >= OC::Scales::NUM_SCALES) scale = 0;
    63aa:	2100      	movs	r1, #0
    63ac:	e7e4      	b.n	6378 <Squanch_OnEncoderMove(bool, int)+0x24>
            if (scale < 0) scale = OC::Scales::NUM_SCALES - 1;
    63ae:	3b01      	subs	r3, #1
    63b0:	f8c2 31b4 	str.w	r3, [r2, #436]	; 0x1b4
    63b4:	e7e6      	b.n	6384 <Squanch_OnEncoderMove(bool, int)+0x30>
            shift[cursor] = constrain(shift[cursor] + direction, -48, 48);
    63b6:	22de      	movs	r2, #222	; 0xde
    63b8:	fb02 3000 	mla	r0, r2, r0, r3
    63bc:	30dc      	adds	r0, #220	; 0xdc
    63be:	f06f 022f 	mvn.w	r2, #47	; 0x2f
    63c2:	f934 3010 	ldrsh.w	r3, [r4, r0, lsl #1]
    63c6:	440b      	add	r3, r1
    63c8:	2b30      	cmp	r3, #48	; 0x30
    63ca:	bfa8      	it	ge
    63cc:	2330      	movge	r3, #48	; 0x30
    63ce:	4293      	cmp	r3, r2
    63d0:	bfb8      	it	lt
    63d2:	4613      	movlt	r3, r2
    63d4:	f824 3010 	strh.w	r3, [r4, r0, lsl #1]
void Squanch_OnEncoderMove(bool hemisphere, int direction) {Squanch_instance[hemisphere].OnEncoderMove(direction);}
    63d8:	e7e6      	b.n	63a8 <Squanch_OnEncoderMove(bool, int)+0x54>
    63da:	bf00      	nop
    63dc:	20001b54 	.word	0x20001b54
    63e0:	0001e700 	.word	0x0001e700

000063e4 <TM_OnEncoderMove(bool, int)>:
void TM_OnEncoderMove(bool hemisphere, int direction) {
    63e4:	b538      	push	{r3, r4, r5, lr}
        if (cursor == 0) length = constrain(length += direction, TM_MIN_LENGTH, TM_MAX_LENGTH);
    63e6:	4d1e      	ldr	r5, [pc, #120]	; (6460 <TM_OnEncoderMove(bool, int)+0x7c>)
    63e8:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
    63ec:	fb03 5300 	mla	r3, r3, r0, r5
void TM_OnEncoderMove(bool hemisphere, int direction) {
    63f0:	4604      	mov	r4, r0
        if (cursor == 0) length = constrain(length += direction, TM_MIN_LENGTH, TM_MAX_LENGTH);
    63f2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    63f4:	b94a      	cbnz	r2, 640a <TM_OnEncoderMove(bool, int)+0x26>
    63f6:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    63f8:	440a      	add	r2, r1
    63fa:	2a10      	cmp	r2, #16
    63fc:	bfa8      	it	ge
    63fe:	2210      	movge	r2, #16
    6400:	2a02      	cmp	r2, #2
    6402:	bfb8      	it	lt
    6404:	2202      	movlt	r2, #2
    6406:	66da      	str	r2, [r3, #108]	; 0x6c
}
    6408:	bd38      	pop	{r3, r4, r5, pc}
        if (cursor == 1) p = constrain(p += direction, 0, 100);
    640a:	2a01      	cmp	r2, #1
    640c:	d01a      	beq.n	6444 <TM_OnEncoderMove(bool, int)+0x60>
        if (cursor == 2) {
    640e:	2a02      	cmp	r2, #2
    6410:	d1fa      	bne.n	6408 <TM_OnEncoderMove(bool, int)+0x24>
            scale += direction;
    6412:	f893 31b4 	ldrb.w	r3, [r3, #436]	; 0x1b4
    6416:	4419      	add	r1, r3
    6418:	b248      	sxtb	r0, r1
            if (scale >= TM_MAX_SCALE) scale = 0;
    641a:	283e      	cmp	r0, #62	; 0x3e
    641c:	dc1d      	bgt.n	645a <TM_OnEncoderMove(bool, int)+0x76>
            if (scale < 0) scale = TM_MAX_SCALE - 1;
    641e:	2800      	cmp	r0, #0
    6420:	bfb8      	it	lt
    6422:	203e      	movlt	r0, #62	; 0x3e
    6424:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
    6428:	435c      	muls	r4, r3
    642a:	192b      	adds	r3, r5, r4
            quantizer.Configure(OC::Scales::GetScale(scale), 0xffff);
    642c:	3474      	adds	r4, #116	; 0x74
    642e:	f883 01b4 	strb.w	r0, [r3, #436]	; 0x1b4
    6432:	f7fa fd9f 	bl	f74 <OC::Scales::GetScale(int)>
    6436:	f64f 72ff 	movw	r2, #65535	; 0xffff
    643a:	4601      	mov	r1, r0
    643c:	1928      	adds	r0, r5, r4
    643e:	f7ff fddd 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
}
    6442:	e7e1      	b.n	6408 <TM_OnEncoderMove(bool, int)+0x24>
        if (cursor == 1) p = constrain(p += direction, 0, 100);
    6444:	f8d3 21b0 	ldr.w	r2, [r3, #432]	; 0x1b0
    6448:	440a      	add	r2, r1
    644a:	2a64      	cmp	r2, #100	; 0x64
    644c:	bfa8      	it	ge
    644e:	2264      	movge	r2, #100	; 0x64
    6450:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    6454:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
        if (cursor == 2) {
    6458:	e7d6      	b.n	6408 <TM_OnEncoderMove(bool, int)+0x24>
            if (scale >= TM_MAX_SCALE) scale = 0;
    645a:	2000      	movs	r0, #0
    645c:	e7e2      	b.n	6424 <TM_OnEncoderMove(bool, int)+0x40>
    645e:	bf00      	nop
    6460:	200020d4 	.word	0x200020d4

00006464 <EnigmaOutput::InitAs(unsigned char)>:
    byte tk; // Track 0-4
    byte ty; // Type (see enum above)
    byte sc; // Scale
    byte mc; // MIDI channel (1-16, 0=off)

    void InitAs(byte o) {
    6464:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6466:	4604      	mov	r4, r0
        tk = o;
        sc = 5;
        mc = 0;

        // Initialize quantizer
        quantizer.Init();
    6468:	1d07      	adds	r7, r0, #4
        sc = 5;
    646a:	2605      	movs	r6, #5
        out = o;
    646c:	7001      	strb	r1, [r0, #0]
        tk = o;
    646e:	f880 1144 	strb.w	r1, [r0, #324]	; 0x144
        sc = 5;
    6472:	f8a0 6146 	strh.w	r6, [r0, #326]	; 0x146
        quantizer.Init();
    6476:	4638      	mov	r0, r7
    void InitAs(byte o) {
    6478:	460d      	mov	r5, r1
        quantizer.Init();
    647a:	f7fa ff73 	bl	1364 <braids::Quantizer::Init()>
        quantizer.Configure(OC::Scales::GetScale(sc), 0xffff);
    647e:	f894 0146 	ldrb.w	r0, [r4, #326]	; 0x146
    6482:	f7fa fd77 	bl	f74 <OC::Scales::GetScale(int)>
    6486:	f64f 72ff 	movw	r2, #65535	; 0xffff
    648a:	4601      	mov	r1, r0
    648c:	4638      	mov	r0, r7
    648e:	f7ff fdb5 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>

        // Set type based on output initialization
        if (o == 0) set_type(EnigmaOutputType::NOTE5);
    6492:	b91d      	cbnz	r5, 649c <EnigmaOutput::InitAs(unsigned char)+0x38>
    int GetDeferredNote() {return deferred_note;}

    // Setters
    void set_output(byte output_) {out = constrain(output_, 0, 3);}
    void set_track(byte track_) {tk = constrain(track_, 0, 3);}
    void set_type(byte type_) {ty = constrain(type_, 0, EnigmaOutputType::GATE);}
    6494:	2302      	movs	r3, #2
    6496:	f884 3145 	strb.w	r3, [r4, #325]	; 0x145
    }
    649a:	e009      	b.n	64b0 <EnigmaOutput::InitAs(unsigned char)+0x4c>
        if (o == 1) set_type(EnigmaOutputType::MODULATION);
    649c:	2d01      	cmp	r5, #1
    649e:	d005      	beq.n	64ac <EnigmaOutput::InitAs(unsigned char)+0x48>
        if (o == 2) set_type(EnigmaOutputType::TRIGGER);
    64a0:	2d02      	cmp	r5, #2
    64a2:	d006      	beq.n	64b2 <EnigmaOutput::InitAs(unsigned char)+0x4e>
        if (o == 3) set_type(EnigmaOutputType::GATE);
    64a4:	2d03      	cmp	r5, #3
    64a6:	d103      	bne.n	64b0 <EnigmaOutput::InitAs(unsigned char)+0x4c>
    void set_type(byte type_) {ty = constrain(type_, 0, EnigmaOutputType::GATE);}
    64a8:	2308      	movs	r3, #8
    64aa:	e7f4      	b.n	6496 <EnigmaOutput::InitAs(unsigned char)+0x32>
    64ac:	f884 6145 	strb.w	r6, [r4, #325]	; 0x145
    }
    64b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    void set_type(byte type_) {ty = constrain(type_, 0, EnigmaOutputType::GATE);}
    64b2:	2307      	movs	r3, #7
    64b4:	e7ef      	b.n	6496 <EnigmaOutput::InitAs(unsigned char)+0x32>
    64b6:	Address 0x00000000000064b6 is out of bounds.


000064b8 <EnigmaOutput::SendToMIDI(unsigned short, int)>:
            app->GateOut(out, clock);
        }
    }

    /* Sends data vi MIDI based on the current output type. */
    void SendToMIDI(uint16_t reg, int transpose = 0) {
    64b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    64ba:	460e      	mov	r6, r1
        // Quantize a note based on how many bits
        if (ty <= EnigmaOutputType::NOTE7) {
    64bc:	f890 1145 	ldrb.w	r1, [r0, #325]	; 0x145
    64c0:	2904      	cmp	r1, #4
    void SendToMIDI(uint16_t reg, int transpose = 0) {
    64c2:	4604      	mov	r4, r0
        if (ty <= EnigmaOutputType::NOTE7) {
    64c4:	d83e      	bhi.n	6544 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x8c>
            byte bits = ty + 3; // Number of bits
    64c6:	1cc8      	adds	r0, r1, #3
    64c8:	2300      	movs	r3, #0
    64ca:	b2c0      	uxtb	r0, r0
            uint8_t mask = 0;
    64cc:	461d      	mov	r5, r3
            for (byte s = 0; s < bits; s++) mask |= (0x01 << s);
    64ce:	f04f 0c01 	mov.w	ip, #1
    64d2:	fa0c f703 	lsl.w	r7, ip, r3
    64d6:	3301      	adds	r3, #1
    64d8:	433d      	orrs	r5, r7
    64da:	b2df      	uxtb	r7, r3
    64dc:	42b8      	cmp	r0, r7
    64de:	b2ed      	uxtb	r5, r5
    64e0:	d8f7      	bhi.n	64d2 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x1a>
            int note_shift = ty == EnigmaOutputType::NOTE7 ? 0 : 60; // Note types under 7-bit start at Middle C
    64e2:	2904      	cmp	r1, #4
    64e4:	bf0c      	ite	eq
    64e6:	2300      	moveq	r3, #0
    64e8:	233c      	movne	r3, #60	; 0x3c
            int note_number = (reg & mask) + note_shift + (transpose / 128);
    64ea:	4035      	ands	r5, r6
    64ec:	2a00      	cmp	r2, #0
    64ee:	441d      	add	r5, r3
    64f0:	bfb8      	it	lt
    64f2:	327f      	addlt	r2, #127	; 0x7f
    byte midi_channel() {return mc;}
    64f4:	f894 0147 	ldrb.w	r0, [r4, #327]	; 0x147
            int note_number = (reg & mask) + note_shift + (transpose / 128);
    64f8:	eb05 15e2 	add.w	r5, r5, r2, asr #7
    64fc:	f385 0507 	usat	r5, #7, r5
            note_number = constrain(note_number, 0, 127);

            if (midi_channel()) {
    6500:	2800      	cmp	r0, #0
    6502:	d04c      	beq.n	659e <EnigmaOutput::SendToMIDI(unsigned short, int)+0xe6>
                if (last_note > -1) usbMIDI.sendNoteOn(last_note, 0, midi_channel());
    6504:	f8d4 213c 	ldr.w	r2, [r4, #316]	; 0x13c
    6508:	2a00      	cmp	r2, #0
    650a:	db0d      	blt.n	6528 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x70>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    650c:	3801      	subs	r0, #1
    650e:	0200      	lsls	r0, r0, #8
    6510:	0412      	lsls	r2, r2, #16
    6512:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
    6516:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
    651a:	4310      	orrs	r0, r2
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    651c:	f440 4010 	orr.w	r0, r0, #36864	; 0x9000
    6520:	f040 0009 	orr.w	r0, r0, #9
    6524:	f014 fc42 	bl	1adac <usb_midi_write_packed>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    6528:	f894 3147 	ldrb.w	r3, [r4, #327]	; 0x147
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    652c:	483a      	ldr	r0, [pc, #232]	; (6618 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x160>)
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    652e:	3b01      	subs	r3, #1
    6530:	021b      	lsls	r3, r3, #8
    6532:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
    6536:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    653a:	4318      	orrs	r0, r3
    653c:	f014 fc36 	bl	1adac <usb_midi_write_packed>
                usbMIDI.sendNoteOn(note_number, 0x60, midi_channel());
                last_note = note_number;
    6540:	f8c4 513c 	str.w	r5, [r4, #316]	; 0x13c
                deferred_note = note_number;
            }
        }

        // Modulation based on low 8 bits, shifted right for MIDI range
        if (ty == EnigmaOutputType::MODULATION && midi_channel()) {
    6544:	f894 3145 	ldrb.w	r3, [r4, #325]	; 0x145
    6548:	2b05      	cmp	r3, #5
    654a:	d111      	bne.n	6570 <EnigmaOutput::SendToMIDI(unsigned short, int)+0xb8>
    byte midi_channel() {return mc;}
    654c:	f894 0147 	ldrb.w	r0, [r4, #327]	; 0x147
        if (ty == EnigmaOutputType::MODULATION && midi_channel()) {
    6550:	2800      	cmp	r0, #0
    6552:	d05d      	beq.n	6610 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x158>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    6554:	3801      	subs	r0, #1
    6556:	0200      	lsls	r0, r0, #8
    6558:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
    655c:	f3c6 0346 	ubfx	r3, r6, #1, #7
    6560:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    6564:	f440 30d8 	orr.w	r0, r0, #110592	; 0x1b000
    6568:	f040 000b 	orr.w	r0, r0, #11
    656c:	f014 fc1e 	bl	1adac <usb_midi_write_packed>
            usbMIDI.sendControlChange(1, (reg & 0x00ff) >> 1, midi_channel());
        }

        // Expression based on low 8 bits; for MIDI, expression is a percentage of channel volume
        if (ty == EnigmaOutputType::EXPRESSION && midi_channel()) {
    6570:	f894 3145 	ldrb.w	r3, [r4, #325]	; 0x145
    6574:	2b06      	cmp	r3, #6
    6576:	d114      	bne.n	65a2 <EnigmaOutput::SendToMIDI(unsigned short, int)+0xea>
    byte midi_channel() {return mc;}
    6578:	f894 0147 	ldrb.w	r0, [r4, #327]	; 0x147
        if (ty == EnigmaOutputType::EXPRESSION && midi_channel()) {
    657c:	2800      	cmp	r0, #0
    657e:	d047      	beq.n	6610 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x158>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    6580:	3801      	subs	r0, #1
    6582:	0200      	lsls	r0, r0, #8
			  | ((data2 & 0x7F) << 24));
    6584:	f3c6 0346 	ubfx	r3, r6, #1, #7
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    6588:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
    658c:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    6590:	f040 100b 	orr.w	r0, r0, #720907	; 0xb000b
    6594:	f440 4030 	orr.w	r0, r0, #45056	; 0xb000
    6598:	f014 fc08 	bl	1adac <usb_midi_write_packed>
    659c:	e001      	b.n	65a2 <EnigmaOutput::SendToMIDI(unsigned short, int)+0xea>
                deferred_note = note_number;
    659e:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
            usbMIDI.sendControlChange(11, (reg & 0x00ff) >> 1, midi_channel());
        }

        // Trigger and Gate behave the same way with MIDI; They'll use the last note that wasn't sent
        // out via MIDI on its own output. If no such note is available, then Trigger/Gate will do nothing.
        if ((ty == EnigmaOutputType::TRIGGER || ty == EnigmaOutputType::TRIGGER) && midi_channel()) {
    65a2:	f894 3145 	ldrb.w	r3, [r4, #325]	; 0x145
    65a6:	2b07      	cmp	r3, #7
    65a8:	d132      	bne.n	6610 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x158>
    byte midi_channel() {return mc;}
    65aa:	f894 0147 	ldrb.w	r0, [r4, #327]	; 0x147
        if ((ty == EnigmaOutputType::TRIGGER || ty == EnigmaOutputType::TRIGGER) && midi_channel()) {
    65ae:	b378      	cbz	r0, 6610 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x158>
            if (deferred_note >  -1 && (reg & 0x01)) {
    65b0:	f8d4 2140 	ldr.w	r2, [r4, #320]	; 0x140
    65b4:	2a00      	cmp	r2, #0
    65b6:	db2b      	blt.n	6610 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x158>
    65b8:	07f3      	lsls	r3, r6, #31
    65ba:	d529      	bpl.n	6610 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x158>
                if (last_note > -1) usbMIDI.sendNoteOff(last_note, 0, midi_channel());
    65bc:	f8d4 213c 	ldr.w	r2, [r4, #316]	; 0x13c
    65c0:	2a00      	cmp	r2, #0
    65c2:	db0d      	blt.n	65e0 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x128>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    65c4:	3801      	subs	r0, #1
    65c6:	0200      	lsls	r0, r0, #8
    65c8:	0412      	lsls	r2, r2, #16
    65ca:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
    65ce:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
    65d2:	4310      	orrs	r0, r2
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    65d4:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
    65d8:	f040 0008 	orr.w	r0, r0, #8
    65dc:	f014 fbe6 	bl	1adac <usb_midi_write_packed>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    65e0:	f894 3147 	ldrb.w	r3, [r4, #327]	; 0x147
    65e4:	f8d4 2140 	ldr.w	r2, [r4, #320]	; 0x140
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    65e8:	480b      	ldr	r0, [pc, #44]	; (6618 <EnigmaOutput::SendToMIDI(unsigned short, int)+0x160>)
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    65ea:	3b01      	subs	r3, #1
    65ec:	021b      	lsls	r3, r3, #8
    65ee:	0412      	lsls	r2, r2, #16
    65f0:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
    65f4:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
    65f8:	4313      	orrs	r3, r2
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    65fa:	4318      	orrs	r0, r3
    65fc:	f014 fbd6 	bl	1adac <usb_midi_write_packed>
                usbMIDI.sendNoteOn(deferred_note, 0x60, midi_channel());
                last_note = deferred_note;
    6600:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    6604:	f8c4 313c 	str.w	r3, [r4, #316]	; 0x13c
                deferred_note = -1;
    6608:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    660c:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
            }
        }

        usbMIDI.send_now();
    }
    6610:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		usb_midi_flush_output();
    6614:	f014 bc66 	b.w	1aee4 <usb_midi_flush_output>
    6618:	60009009 	.word	0x60009009

0000661c <EnigmaTMWS::DrawLibraryInterface()>:
    void DrawLibraryInterface() {
    661c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  text_x_ = x;
    6620:	4e54      	ldr	r6, [pc, #336]	; (6774 <EnigmaTMWS::DrawLibraryInterface()+0x158>)
            if (HS::user_turing_machines[ix].favorite) gfxIcon(36, y, FAVORITE_ICON);
    6622:	4f55      	ldr	r7, [pc, #340]	; (6778 <EnigmaTMWS::DrawLibraryInterface()+0x15c>)
    6624:	f8df 8154 	ldr.w	r8, [pc, #340]	; 677c <EnigmaTMWS::DrawLibraryInterface()+0x160>
    void DrawLibraryInterface() {
    6628:	4604      	mov	r4, r0
    662a:	f04f 0900 	mov.w	r9, #0
            byte ix = (tm_cursor + line) % HS::TURING_MACHINE_COUNT;
    662e:	f994 5f8c 	ldrsb.w	r5, [r4, #3980]	; 0xf8c
    6632:	2328      	movs	r3, #40	; 0x28
    6634:	444d      	add	r5, r9
    6636:	fb95 f2f3 	sdiv	r2, r5, r3
    663a:	fb03 5512 	mls	r5, r3, r2, r5
            HS::TuringMachine::SetName(name, ix);
    663e:	b2ed      	uxtb	r5, r5
    6640:	f04f 0a0a 	mov.w	sl, #10
    6644:	4629      	mov	r1, r5
    6646:	a801      	add	r0, sp, #4
    6648:	fb0a fa09 	mul.w	sl, sl, r9
            if (HS::user_turing_machines[ix].favorite) gfxIcon(36, y, FAVORITE_ICON);
    664c:	eb07 0585 	add.w	r5, r7, r5, lsl #2
            HS::TuringMachine::SetName(name, ix);
    6650:	f7ff fbe4 	bl	5e1c <HS::TuringMachine::SetName(char*, unsigned char)>
            gfxPrint(3, y, name);
    6654:	f10a 0a18 	add.w	sl, sl, #24
    6658:	2303      	movs	r3, #3
    665a:	4846      	ldr	r0, [pc, #280]	; (6774 <EnigmaTMWS::DrawLibraryInterface()+0x158>)
    665c:	6073      	str	r3, [r6, #4]
    665e:	a901      	add	r1, sp, #4
  text_y_ = y;
    6660:	f8c6 a008 	str.w	sl, [r6, #8]
    6664:	f013 fa37 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (HS::user_turing_machines[ix].favorite) gfxIcon(36, y, FAVORITE_ICON);
    6668:	78eb      	ldrb	r3, [r5, #3]
    666a:	b123      	cbz	r3, 6676 <EnigmaTMWS::DrawLibraryInterface()+0x5a>
    666c:	4642      	mov	r2, r8
    666e:	4651      	mov	r1, sl
    6670:	2024      	movs	r0, #36	; 0x24
    6672:	f7fe f817 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        for (byte line = 0; line < 4; line++)
    6676:	f109 0901 	add.w	r9, r9, #1
    667a:	f1b9 0f04 	cmp.w	r9, #4
    667e:	d1d6      	bne.n	662e <EnigmaTMWS::DrawLibraryInterface()+0x12>
        DrawSelectorBox("Register");
    6680:	483f      	ldr	r0, [pc, #252]	; (6780 <EnigmaTMWS::DrawLibraryInterface()+0x164>)
    6682:	f7fe fa01 	bl	4a88 <EnigmaTMWS::DrawSelectorBox(char const*) [clone .isra.0]>
        if (help_countdown) DrawLibraryHelp();
    6686:	f8b4 33e0 	ldrh.w	r3, [r4, #992]	; 0x3e0
    668a:	b1cb      	cbz	r3, 66c0 <EnigmaTMWS::DrawLibraryInterface()+0xa4>
        gfxIcon(56, 15, UP_BTN_ICON);
    668c:	4a3d      	ldr	r2, [pc, #244]	; (6784 <EnigmaTMWS::DrawLibraryInterface()+0x168>)
    668e:	210f      	movs	r1, #15
    6690:	2038      	movs	r0, #56	; 0x38
    6692:	f7fe f807 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxIcon(66, 15, FAVORITE_ICON);
    6696:	4a39      	ldr	r2, [pc, #228]	; (677c <EnigmaTMWS::DrawLibraryInterface()+0x160>)
    6698:	210f      	movs	r1, #15
    669a:	2042      	movs	r0, #66	; 0x42
    669c:	f7fe f802 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxIcon(56, 25, DOWN_BTN_ICON);
    66a0:	4a39      	ldr	r2, [pc, #228]	; (6788 <EnigmaTMWS::DrawLibraryInterface()+0x16c>)
    66a2:	2119      	movs	r1, #25
    66a4:	2038      	movs	r0, #56	; 0x38
    66a6:	f7fd fffd 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
  text_x_ = x;
    66aa:	2342      	movs	r3, #66	; 0x42
    66ac:	4937      	ldr	r1, [pc, #220]	; (678c <EnigmaTMWS::DrawLibraryInterface()+0x170>)
    66ae:	4831      	ldr	r0, [pc, #196]	; (6774 <EnigmaTMWS::DrawLibraryInterface()+0x158>)
    66b0:	6073      	str	r3, [r6, #4]
  text_y_ = y;
    66b2:	2319      	movs	r3, #25
    66b4:	60b3      	str	r3, [r6, #8]
    }
    66b6:	b002      	add	sp, #8
    66b8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    66bc:	f013 ba0b 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    byte GetLength() {return len;}
    66c0:	f894 52e6 	ldrb.w	r5, [r4, #742]	; 0x2e6
            gfxIcon(64, 14, NOTE_ICON);
    66c4:	4a32      	ldr	r2, [pc, #200]	; (6790 <EnigmaTMWS::DrawLibraryInterface()+0x174>)
    66c6:	210e      	movs	r1, #14
    66c8:	2040      	movs	r0, #64	; 0x40
    66ca:	f7fd ffeb 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
            gfxPrint(76 + pad(10, length), 15, length);
    66ce:	4629      	mov	r1, r5
    66d0:	200a      	movs	r0, #10
    66d2:	f7fe fa35 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    66d6:	304c      	adds	r0, #76	; 0x4c
  text_x_ = x;
    66d8:	6070      	str	r0, [r6, #4]
  text_y_ = y;
    66da:	250f      	movs	r5, #15
        graphics.print(num);
    66dc:	4825      	ldr	r0, [pc, #148]	; (6774 <EnigmaTMWS::DrawLibraryInterface()+0x158>)
    66de:	60b5      	str	r5, [r6, #8]
    66e0:	f013 fa6d 	bl	19bbe <weegfx::Graphics::print(int)>
            byte p = state_prob[tm_cursor];
    66e4:	f994 3f8c 	ldrsb.w	r3, [r4, #3980]	; 0xf8c
        graphics.print(str);
    66e8:	492a      	ldr	r1, [pc, #168]	; (6794 <EnigmaTMWS::DrawLibraryInterface()+0x178>)
    66ea:	4822      	ldr	r0, [pc, #136]	; (6774 <EnigmaTMWS::DrawLibraryInterface()+0x158>)
    66ec:	60b5      	str	r5, [r6, #8]
    66ee:	4423      	add	r3, r4
    66f0:	f893 72ea 	ldrb.w	r7, [r3, #746]	; 0x2ea
  text_x_ = x;
    66f4:	2360      	movs	r3, #96	; 0x60
    66f6:	6073      	str	r3, [r6, #4]
    66f8:	f013 f9ed 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (tm_state.IsFavorite()) gfxIcon(116, 15, FAVORITE_ICON);
    66fc:	f894 32e7 	ldrb.w	r3, [r4, #743]	; 0x2e7
    6700:	b38b      	cbz	r3, 6766 <EnigmaTMWS::DrawLibraryInterface()+0x14a>
    6702:	4a1e      	ldr	r2, [pc, #120]	; (677c <EnigmaTMWS::DrawLibraryInterface()+0x160>)
    6704:	4629      	mov	r1, r5
    6706:	2074      	movs	r0, #116	; 0x74
    6708:	f7fd ffcc 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
            if (!tm_state.IsFavorite()) {
    670c:	f894 22e7 	ldrb.w	r2, [r4, #743]	; 0x2e7
                if (tm_param == ENIGMA_TM_PROBABILITY) gfxCursor(109, 23, 18);
    6710:	f994 3f8f 	ldrsb.w	r3, [r4, #3983]	; 0xf8f
            if (!tm_state.IsFavorite()) {
    6714:	b982      	cbnz	r2, 6738 <EnigmaTMWS::DrawLibraryInterface()+0x11c>
                if (tm_param == ENIGMA_TM_PROBABILITY) gfxCursor(109, 23, 18);
    6716:	2b01      	cmp	r3, #1
    6718:	d105      	bne.n	6726 <EnigmaTMWS::DrawLibraryInterface()+0x10a>
    671a:	6a60      	ldr	r0, [r4, #36]	; 0x24
    671c:	2312      	movs	r3, #18
    671e:	2217      	movs	r2, #23
    6720:	216d      	movs	r1, #109	; 0x6d
    6722:	f7fe fa41 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
                if (tm_param == ENIGMA_TM_LENGTH) gfxCursor(77, 23, 12);
    6726:	f994 3f8f 	ldrsb.w	r3, [r4, #3983]	; 0xf8f
    672a:	b92b      	cbnz	r3, 6738 <EnigmaTMWS::DrawLibraryInterface()+0x11c>
    672c:	6a60      	ldr	r0, [r4, #36]	; 0x24
    672e:	230c      	movs	r3, #12
    6730:	2217      	movs	r2, #23
    6732:	214d      	movs	r1, #77	; 0x4d
    6734:	f7fe fa38 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            if (tm_param == ENIGMA_TM_ROTATE) {
    6738:	f994 3f8f 	ldrsb.w	r3, [r4, #3983]	; 0xf8f
    673c:	2b02      	cmp	r3, #2
    673e:	d109      	bne.n	6754 <EnigmaTMWS::DrawLibraryInterface()+0x138>
                gfxIcon(87, 27, ROTATE_L_ICON);
    6740:	4a15      	ldr	r2, [pc, #84]	; (6798 <EnigmaTMWS::DrawLibraryInterface()+0x17c>)
    6742:	211b      	movs	r1, #27
    6744:	2057      	movs	r0, #87	; 0x57
    6746:	f7fd ffad 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
                gfxIcon(95, 27, ROTATE_R_ICON);
    674a:	4a14      	ldr	r2, [pc, #80]	; (679c <EnigmaTMWS::DrawLibraryInterface()+0x180>)
    674c:	211b      	movs	r1, #27
    674e:	205f      	movs	r0, #95	; 0x5f
    6750:	f7fd ffa8 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
            tm_state.DrawAt(64, 40);
    6754:	2228      	movs	r2, #40	; 0x28
    6756:	2140      	movs	r1, #64	; 0x40
    6758:	f204 20e2 	addw	r0, r4, #738	; 0x2e2
    675c:	f7ff fbba 	bl	5ed4 <TuringMachineState::DrawAt(unsigned char, unsigned char)>
    }
    6760:	b002      	add	sp, #8
    6762:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            else gfxPrint(pad(100, p), p);
    6766:	4639      	mov	r1, r7
    6768:	2064      	movs	r0, #100	; 0x64
    676a:	f7fe f9e9 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    676e:	f7fe f9ff 	bl	4b70 <HSApplication::gfxPrint(int, int) [clone .isra.0]>
    6772:	e7cb      	b.n	670c <EnigmaTMWS::DrawLibraryInterface()+0xf0>
    6774:	200065e0 	.word	0x200065e0
    6778:	200036e8 	.word	0x200036e8
    677c:	00023d58 	.word	0x00023d58
    6780:	00020fbc 	.word	0x00020fbc
    6784:	00023ca0 	.word	0x00023ca0
    6788:	00023d50 	.word	0x00023d50
    678c:	0002135a 	.word	0x0002135a
    6790:	00024228 	.word	0x00024228
    6794:	00020fc5 	.word	0x00020fc5
    6798:	00023e28 	.word	0x00023e28
    679c:	00023e30 	.word	0x00023e30

000067a0 <EnigmaTMWS::DrawAssignInterface()>:
    void DrawAssignInterface() {
    67a0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
        if (play) gfxIcon(118, 0, PLAY_ICON);
    67a4:	f890 13e4 	ldrb.w	r1, [r0, #996]	; 0x3e4
    void DrawAssignInterface() {
    67a8:	4604      	mov	r4, r0
        if (play) gfxIcon(118, 0, PLAY_ICON);
    67aa:	2900      	cmp	r1, #0
    67ac:	d063      	beq.n	6876 <EnigmaTMWS::DrawAssignInterface()+0xd6>
    67ae:	4a7a      	ldr	r2, [pc, #488]	; (6998 <EnigmaTMWS::DrawAssignInterface()+0x1f8>)
    67b0:	2100      	movs	r1, #0
    67b2:	2076      	movs	r0, #118	; 0x76
    67b4:	f7fd ff76 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
    67b8:	4d78      	ldr	r5, [pc, #480]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
        graphics.print(str);
    67ba:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 69a0 <EnigmaTMWS::DrawAssignInterface()+0x200>
    void DrawAssignInterface() {
    67be:	2700      	movs	r7, #0
    67c0:	f04f 0903 	mov.w	r9, #3
            byte ix = (output_cursor + line) % 4;
    67c4:	f994 6f8d 	ldrsb.w	r6, [r4, #3981]	; 0xf8d
        graphics.print(str);
    67c8:	4874      	ldr	r0, [pc, #464]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    67ca:	f8c5 9004 	str.w	r9, [r5, #4]
    67ce:	443e      	add	r6, r7
    67d0:	4273      	negs	r3, r6
    67d2:	f003 0303 	and.w	r3, r3, #3
    67d6:	f006 0603 	and.w	r6, r6, #3
    67da:	bf58      	it	pl
    67dc:	425e      	negpl	r6, r3
            char out_name[2] = {static_cast<char>(ix + 'A'), '\0'};
    67de:	2300      	movs	r3, #0
    67e0:	f88d 300d 	strb.w	r3, [sp, #13]
    67e4:	f106 0341 	add.w	r3, r6, #65	; 0x41
    67e8:	f88d 300c 	strb.w	r3, [sp, #12]
  text_y_ = y;
    67ec:	230a      	movs	r3, #10
    67ee:	437b      	muls	r3, r7
    byte track() {return tk;}
    67f0:	b2f6      	uxtb	r6, r6
    67f2:	f44f 7aa4 	mov.w	sl, #328	; 0x148
    67f6:	3318      	adds	r3, #24
    67f8:	a903      	add	r1, sp, #12
    67fa:	fb0a 4606 	mla	r6, sl, r6, r4
    67fe:	60ab      	str	r3, [r5, #8]
    6800:	f013 f969 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(str);
    6804:	4865      	ldr	r0, [pc, #404]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    6806:	4641      	mov	r1, r8
    6808:	f013 f965 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            gfxPrint(output[ix].track() + 1);
    680c:	f896 1ba8 	ldrb.w	r1, [r6, #2984]	; 0xba8
        graphics.print(num);
    6810:	4862      	ldr	r0, [pc, #392]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    6812:	3101      	adds	r1, #1
        for (byte line = 0; line < 4; line++)
    6814:	3701      	adds	r7, #1
    6816:	f013 f9d2 	bl	19bbe <weegfx::Graphics::print(int)>
    681a:	2f04      	cmp	r7, #4
    681c:	d1d2      	bne.n	67c4 <EnigmaTMWS::DrawAssignInterface()+0x24>
        DrawSelectorBox("Output");
    681e:	4861      	ldr	r0, [pc, #388]	; (69a4 <EnigmaTMWS::DrawAssignInterface()+0x204>)
    6820:	f7fe f932 	bl	4a88 <EnigmaTMWS::DrawSelectorBox(char const*) [clone .isra.0]>
        if (help_countdown) DrawAssignHelp();
    6824:	f8b4 33e0 	ldrh.w	r3, [r4, #992]	; 0x3e0
    6828:	b33b      	cbz	r3, 687a <EnigmaTMWS::DrawAssignInterface()+0xda>
        gfxIcon(56, 15, UP_BTN_ICON);
    682a:	4a5f      	ldr	r2, [pc, #380]	; (69a8 <EnigmaTMWS::DrawAssignInterface()+0x208>)
    682c:	210f      	movs	r1, #15
    682e:	2038      	movs	r0, #56	; 0x38
    6830:	f7fd ff38 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxIcon(66, 15, AUDITION_ICON);
    6834:	4a5d      	ldr	r2, [pc, #372]	; (69ac <EnigmaTMWS::DrawAssignInterface()+0x20c>)
    6836:	210f      	movs	r1, #15
    6838:	2042      	movs	r0, #66	; 0x42
    683a:	f7fd ff33 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
  text_x_ = x;
    683e:	244c      	movs	r4, #76	; 0x4c
  text_y_ = y;
    6840:	230f      	movs	r3, #15
        graphics.print(str);
    6842:	495b      	ldr	r1, [pc, #364]	; (69b0 <EnigmaTMWS::DrawAssignInterface()+0x210>)
    6844:	4855      	ldr	r0, [pc, #340]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    6846:	60ab      	str	r3, [r5, #8]
  text_x_ = x;
    6848:	606c      	str	r4, [r5, #4]
    684a:	f013 f944 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxIcon(56, 25, DOWN_BTN_ICON);
    684e:	4a59      	ldr	r2, [pc, #356]	; (69b4 <EnigmaTMWS::DrawAssignInterface()+0x214>)
    6850:	2119      	movs	r1, #25
    6852:	2038      	movs	r0, #56	; 0x38
    6854:	f7fd ff26 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxIcon(66, 25, AUDITION_ICON);
    6858:	4a54      	ldr	r2, [pc, #336]	; (69ac <EnigmaTMWS::DrawAssignInterface()+0x20c>)
    685a:	2119      	movs	r1, #25
    685c:	2042      	movs	r0, #66	; 0x42
    685e:	f7fd ff21 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
    6862:	4955      	ldr	r1, [pc, #340]	; (69b8 <EnigmaTMWS::DrawAssignInterface()+0x218>)
    6864:	484d      	ldr	r0, [pc, #308]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    6866:	606c      	str	r4, [r5, #4]
  text_y_ = y;
    6868:	2319      	movs	r3, #25
    686a:	60ab      	str	r3, [r5, #8]
    }
    686c:	b004      	add	sp, #16
    686e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6872:	f013 b930 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
        else gfxIcon(118, 0, PAUSE_ICON);
    6876:	4a51      	ldr	r2, [pc, #324]	; (69bc <EnigmaTMWS::DrawAssignInterface()+0x21c>)
    6878:	e79b      	b.n	67b2 <EnigmaTMWS::DrawAssignInterface()+0x12>
    687a:	2319      	movs	r3, #25
    687c:	4950      	ldr	r1, [pc, #320]	; (69c0 <EnigmaTMWS::DrawAssignInterface()+0x220>)
    687e:	4847      	ldr	r0, [pc, #284]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    6880:	60ab      	str	r3, [r5, #8]
  text_x_ = x;
    6882:	2638      	movs	r6, #56	; 0x38
    6884:	606e      	str	r6, [r5, #4]
    6886:	f013 f926 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            gfxPrint(output[output_cursor].track() + 1);
    688a:	f994 3f8d 	ldrsb.w	r3, [r4, #3981]	; 0xf8d
        graphics.print(num);
    688e:	4843      	ldr	r0, [pc, #268]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    6890:	fb0a 4303 	mla	r3, sl, r3, r4
    6894:	f893 1ba8 	ldrb.w	r1, [r3, #2984]	; 0xba8
    6898:	3101      	adds	r1, #1
    689a:	f013 f990 	bl	19bbe <weegfx::Graphics::print(int)>
            gfxPrint(56, 35, enigma_type_names[output[output_cursor].type()]);
    689e:	f994 3f8d 	ldrsb.w	r3, [r4, #3981]	; 0xf8d
        graphics.print(str);
    68a2:	483e      	ldr	r0, [pc, #248]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    68a4:	606e      	str	r6, [r5, #4]
    byte type() {return ty;}
    68a6:	fb0a 4303 	mla	r3, sl, r3, r4
    68aa:	f893 2ba9 	ldrb.w	r2, [r3, #2985]	; 0xba9
  text_y_ = y;
    68ae:	2323      	movs	r3, #35	; 0x23
    68b0:	60ab      	str	r3, [r5, #8]
    68b2:	4b44      	ldr	r3, [pc, #272]	; (69c4 <EnigmaTMWS::DrawAssignInterface()+0x224>)
    68b4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    68b8:	f013 f90d 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (output[output_cursor].type() <= EnigmaOutputType::NOTE7) {
    68bc:	f994 3f8d 	ldrsb.w	r3, [r4, #3981]	; 0xf8d
    68c0:	fb0a 4303 	mla	r3, sl, r3, r4
    68c4:	f893 2ba9 	ldrb.w	r2, [r3, #2985]	; 0xba9
    68c8:	2a04      	cmp	r2, #4
    68ca:	d80a      	bhi.n	68e2 <EnigmaTMWS::DrawAssignInterface()+0x142>
                gfxPrint(56, 45, OC::scale_names_short[output[output_cursor].scale()]);
    68cc:	f893 2baa 	ldrb.w	r2, [r3, #2986]	; 0xbaa
    68d0:	4832      	ldr	r0, [pc, #200]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
  text_x_ = x;
    68d2:	606e      	str	r6, [r5, #4]
  text_y_ = y;
    68d4:	232d      	movs	r3, #45	; 0x2d
    68d6:	60ab      	str	r3, [r5, #8]
    68d8:	4b3b      	ldr	r3, [pc, #236]	; (69c8 <EnigmaTMWS::DrawAssignInterface()+0x228>)
    68da:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    68de:	f013 f8fa 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    68e2:	2338      	movs	r3, #56	; 0x38
    68e4:	4939      	ldr	r1, [pc, #228]	; (69cc <EnigmaTMWS::DrawAssignInterface()+0x22c>)
    68e6:	482d      	ldr	r0, [pc, #180]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    68e8:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    68ea:	2337      	movs	r3, #55	; 0x37
    68ec:	60ab      	str	r3, [r5, #8]
    68ee:	f013 f8f2 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            gfxPrint(midi_channels[output[output_cursor].midi_channel()]);
    68f2:	f994 3f8d 	ldrsb.w	r3, [r4, #3981]	; 0xf8d
        graphics.print(str);
    68f6:	4829      	ldr	r0, [pc, #164]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    byte midi_channel() {return mc;}
    68f8:	f44f 72a4 	mov.w	r2, #328	; 0x148
    68fc:	fb02 4303 	mla	r3, r2, r3, r4
    6900:	f893 2bab 	ldrb.w	r2, [r3, #2987]	; 0xbab
    6904:	4b32      	ldr	r3, [pc, #200]	; (69d0 <EnigmaTMWS::DrawAssignInterface()+0x230>)
    6906:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    690a:	f013 f8e4 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (output_param == ENIGMA_OUTPUT_TRACK) gfxCursor(57, 33, 42);
    690e:	f994 3f90 	ldrsb.w	r3, [r4, #3984]	; 0xf90
    6912:	b92b      	cbnz	r3, 6920 <EnigmaTMWS::DrawAssignInterface()+0x180>
    6914:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6916:	232a      	movs	r3, #42	; 0x2a
    6918:	2221      	movs	r2, #33	; 0x21
    691a:	2139      	movs	r1, #57	; 0x39
    691c:	f7fe f944 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            if (output_param == ENIGMA_OUTPUT_TYPE) gfxCursor(57, 43, 70);
    6920:	f994 3f90 	ldrsb.w	r3, [r4, #3984]	; 0xf90
    6924:	2b01      	cmp	r3, #1
    6926:	d105      	bne.n	6934 <EnigmaTMWS::DrawAssignInterface()+0x194>
    6928:	6a60      	ldr	r0, [r4, #36]	; 0x24
    692a:	2346      	movs	r3, #70	; 0x46
    692c:	222b      	movs	r2, #43	; 0x2b
    692e:	2139      	movs	r1, #57	; 0x39
    6930:	f7fe f93a 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            if (output_param == ENIGMA_OUTPUT_SCALE) gfxCursor(57, 53, 30);
    6934:	f994 3f90 	ldrsb.w	r3, [r4, #3984]	; 0xf90
    6938:	2b02      	cmp	r3, #2
    693a:	d105      	bne.n	6948 <EnigmaTMWS::DrawAssignInterface()+0x1a8>
    693c:	6a60      	ldr	r0, [r4, #36]	; 0x24
    693e:	231e      	movs	r3, #30
    6940:	2235      	movs	r2, #53	; 0x35
    6942:	2139      	movs	r1, #57	; 0x39
    6944:	f7fe f930 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            if (output_param == ENIGMA_OUTPUT_MIDI_CH) gfxCursor(105, 63, 18);
    6948:	f994 3f90 	ldrsb.w	r3, [r4, #3984]	; 0xf90
    694c:	2b03      	cmp	r3, #3
    694e:	d105      	bne.n	695c <EnigmaTMWS::DrawAssignInterface()+0x1bc>
    6950:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6952:	2312      	movs	r3, #18
    6954:	223f      	movs	r2, #63	; 0x3f
    6956:	2169      	movs	r1, #105	; 0x69
    6958:	f7fe f926 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            gfxIcon(56, 15, AUDITION_ICON);
    695c:	4a13      	ldr	r2, [pc, #76]	; (69ac <EnigmaTMWS::DrawAssignInterface()+0x20c>)
    695e:	210f      	movs	r1, #15
    6960:	2038      	movs	r0, #56	; 0x38
    6962:	f7fd fe9f 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
  text_x_ = x;
    6966:	2344      	movs	r3, #68	; 0x44
    6968:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    696a:	230f      	movs	r3, #15
            gfxPrint(68, 15, assign_audition ? "Song" : "Library");
    696c:	f894 1312 	ldrb.w	r1, [r4, #786]	; 0x312
        graphics.print(str);
    6970:	4a11      	ldr	r2, [pc, #68]	; (69b8 <EnigmaTMWS::DrawAssignInterface()+0x218>)
    6972:	60ab      	str	r3, [r5, #8]
    6974:	4b0e      	ldr	r3, [pc, #56]	; (69b0 <EnigmaTMWS::DrawAssignInterface()+0x210>)
    6976:	4809      	ldr	r0, [pc, #36]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    6978:	2900      	cmp	r1, #0
    697a:	bf14      	ite	ne
    697c:	4611      	movne	r1, r2
    697e:	4619      	moveq	r1, r3
    6980:	f013 f8a9 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.drawLine(x, y, x2, y2);
    6984:	2217      	movs	r2, #23
    6986:	4805      	ldr	r0, [pc, #20]	; (699c <EnigmaTMWS::DrawAssignInterface()+0x1fc>)
    6988:	9200      	str	r2, [sp, #0]
    698a:	237f      	movs	r3, #127	; 0x7f
    698c:	2130      	movs	r1, #48	; 0x30
    698e:	f012 ff2f 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    }
    6992:	b004      	add	sp, #16
    6994:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6998:	00024230 	.word	0x00024230
    699c:	200065e0 	.word	0x200065e0
    69a0:	00020fd0 	.word	0x00020fd0
    69a4:	00020c66 	.word	0x00020c66
    69a8:	00023ca0 	.word	0x00023ca0
    69ac:	00023d30 	.word	0x00023d30
    69b0:	00020fc8 	.word	0x00020fc8
    69b4:	00023d50 	.word	0x00023d50
    69b8:	00021028 	.word	0x00021028
    69bc:	00023c80 	.word	0x00023c80
    69c0:	00020fd5 	.word	0x00020fd5
    69c4:	1fffa068 	.word	0x1fffa068
    69c8:	0001e600 	.word	0x0001e600
    69cc:	00020fdc 	.word	0x00020fdc
    69d0:	00023e60 	.word	0x00023e60

000069d4 <EnigmaTMWS::DrawSongInterface()>:
    void DrawSongInterface() {
    69d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        int pct = (39600 - (total_steps * 100)) / 396;
    69d8:	f8b0 23dc 	ldrh.w	r2, [r0, #988]	; 0x3dc
  text_x_ = x;
    69dc:	4dbc      	ldr	r5, [pc, #752]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    69de:	f06f 0163 	mvn.w	r1, #99	; 0x63
    69e2:	f649 23b0 	movw	r3, #39600	; 0x9ab0
    69e6:	fb01 3302 	mla	r3, r1, r2, r3
    void DrawSongInterface() {
    69ea:	b085      	sub	sp, #20
    69ec:	4604      	mov	r4, r0
        gfxPrint(104 + pad(100, pct), 1, pct);
    69ee:	f44f 71c6 	mov.w	r1, #396	; 0x18c
    69f2:	2064      	movs	r0, #100	; 0x64
    69f4:	fb93 f1f1 	sdiv	r1, r3, r1
    69f8:	f7fe f8a2 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    69fc:	3068      	adds	r0, #104	; 0x68
  text_y_ = y;
    69fe:	2301      	movs	r3, #1
  text_x_ = x;
    6a00:	6068      	str	r0, [r5, #4]
        graphics.print(num);
    6a02:	4628      	mov	r0, r5
  text_y_ = y;
    6a04:	60ab      	str	r3, [r5, #8]
    6a06:	f013 f8da 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    6a0a:	49b2      	ldr	r1, [pc, #712]	; (6cd4 <EnigmaTMWS::DrawSongInterface()+0x300>)
    6a0c:	4628      	mov	r0, r5
    6a0e:	f013 f862 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (total_steps > 32) gfxInvert(110, 0, 18, 9);
    6a12:	f8b4 33dc 	ldrh.w	r3, [r4, #988]	; 0x3dc
    6a16:	2b20      	cmp	r3, #32
    6a18:	d907      	bls.n	6a2a <EnigmaTMWS::DrawSongInterface()+0x56>
        graphics.invertRect(x, y, w, h);
    6a1a:	2309      	movs	r3, #9
    6a1c:	9300      	str	r3, [sp, #0]
    6a1e:	2200      	movs	r2, #0
    6a20:	2312      	movs	r3, #18
    6a22:	216e      	movs	r1, #110	; 0x6e
    6a24:	4628      	mov	r0, r5
    6a26:	f012 fcfa 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
        graphics.print(str);
    6a2a:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 6cd8 <EnigmaTMWS::DrawSongInterface()+0x304>
    6a2e:	f8df b2a0 	ldr.w	fp, [pc, #672]	; 6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>
    void DrawSongInterface() {
    6a32:	2700      	movs	r7, #0
    6a34:	f04f 0a0a 	mov.w	sl, #10
            byte t = (track_cursor + line) % 4;
    6a38:	f994 6f8e 	ldrsb.w	r6, [r4, #3982]	; 0xf8e
    6a3c:	443e      	add	r6, r7
    6a3e:	4273      	negs	r3, r6
    6a40:	f003 0303 	and.w	r3, r3, #3
    6a44:	fb0a f807 	mul.w	r8, sl, r7
    6a48:	f006 0603 	and.w	r6, r6, #3
    6a4c:	f108 0818 	add.w	r8, r8, #24
    6a50:	bf58      	it	pl
    6a52:	425e      	negpl	r6, r3
    6a54:	4649      	mov	r1, r9
  text_x_ = x;
    6a56:	2303      	movs	r3, #3
    6a58:	4658      	mov	r0, fp
    6a5a:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    6a5c:	f8c5 8008 	str.w	r8, [r5, #8]
    6a60:	f013 f839 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            gfxPrint(39, y, t + 1);
    6a64:	b2f1      	uxtb	r1, r6
  text_x_ = x;
    6a66:	2327      	movs	r3, #39	; 0x27
        graphics.print(num);
    6a68:	3101      	adds	r1, #1
    6a6a:	4658      	mov	r0, fp
        for (byte line = 0; line < 4; line++)
    6a6c:	3701      	adds	r7, #1
    6a6e:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    6a70:	f8c5 8008 	str.w	r8, [r5, #8]
    6a74:	f013 f8a3 	bl	19bbe <weegfx::Graphics::print(int)>
    6a78:	2f04      	cmp	r7, #4
    6a7a:	d1dd      	bne.n	6a38 <EnigmaTMWS::DrawSongInterface()+0x64>
        DrawSelectorBox("Track");
    6a7c:	4896      	ldr	r0, [pc, #600]	; (6cd8 <EnigmaTMWS::DrawSongInterface()+0x304>)
    6a7e:	f7fe f803 	bl	4a88 <EnigmaTMWS::DrawSelectorBox(char const*) [clone .isra.0]>
        if (help_countdown) DrawSongHelp();
    6a82:	f8b4 33e0 	ldrh.w	r3, [r4, #992]	; 0x3e0
    6a86:	b123      	cbz	r3, 6a92 <EnigmaTMWS::DrawSongInterface()+0xbe>
    }
    6a88:	b005      	add	sp, #20
    6a8a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if (help_countdown) DrawSongHelp();
    6a8e:	f7fe b82f 	b.w	4af0 <EnigmaTMWS::DrawSongHelp() [clone .isra.0]>
            uint16_t ssi = track_step[edit_index]; // The song step index
    6a92:	f9b4 1f8a 	ldrsh.w	r1, [r4, #3978]	; 0xf8a
    6a96:	eb04 0341 	add.w	r3, r4, r1, lsl #1
    6a9a:	f8b3 6314 	ldrh.w	r6, [r3, #788]	; 0x314
            if (ssi < ENIGMA_NO_STEP_AVAILABLE) {
    6a9e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6aa2:	429e      	cmp	r6, r3
    6aa4:	f000 80ef 	beq.w	6c86 <EnigmaTMWS::DrawSongInterface()+0x2b2>
                gfxPrint(56 + pad(10, edit_index + 1), 15, edit_index + 1); // Step number (1-99)
    6aa8:	3101      	adds	r1, #1
    6aaa:	200a      	movs	r0, #10
    6aac:	f7fe f848 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    6ab0:	3038      	adds	r0, #56	; 0x38
    6ab2:	230f      	movs	r3, #15
  text_x_ = x;
    6ab4:	6068      	str	r0, [r5, #4]
  text_y_ = y;
    6ab6:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    6aba:	4885      	ldr	r0, [pc, #532]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6abc:	60ab      	str	r3, [r5, #8]
    6abe:	f013 f87e 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    6ac2:	4986      	ldr	r1, [pc, #536]	; (6cdc <EnigmaTMWS::DrawSongInterface()+0x308>)
    6ac4:	4882      	ldr	r0, [pc, #520]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6ac6:	f013 f806 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        set_transpose(0);
    }

    // Getters
    byte track() {return (tk >> 6) & 0x03;} // High two bits
    byte tm() {return (tk & 0x3f);} // Low six bits
    6aca:	f896 1424 	ldrb.w	r1, [r6, #1060]	; 0x424
                HS::TuringMachine::SetName(name, song_step[ssi].tm());
    6ace:	a803      	add	r0, sp, #12
    6ad0:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    6ad4:	f7ff f9a2 	bl	5e1c <HS::TuringMachine::SetName(char*, unsigned char)>
    6ad8:	487d      	ldr	r0, [pc, #500]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6ada:	a903      	add	r1, sp, #12
    6adc:	f012 fffb 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    6ae0:	497f      	ldr	r1, [pc, #508]	; (6ce0 <EnigmaTMWS::DrawSongInterface()+0x30c>)
    6ae2:	487b      	ldr	r0, [pc, #492]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6ae4:	f012 fff7 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                if (step_param == ENIGMA_STEP_TM) {
    6ae8:	f994 3f91 	ldrsb.w	r3, [r4, #3985]	; 0xf91
    6aec:	2b01      	cmp	r3, #1
    6aee:	f040 80be 	bne.w	6c6e <EnigmaTMWS::DrawSongInterface()+0x29a>
    6af2:	f896 2424 	ldrb.w	r2, [r6, #1060]	; 0x424
                    byte length = HS::user_turing_machines[song_step[ssi].tm()].len;
    6af6:	4b7b      	ldr	r3, [pc, #492]	; (6ce4 <EnigmaTMWS::DrawSongInterface()+0x310>)
    6af8:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    6afc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    6b00:	7899      	ldrb	r1, [r3, #2]
                    bool favorite = HS::user_turing_machines[song_step[ssi].tm()].favorite;
    6b02:	78df      	ldrb	r7, [r3, #3]
                    if (length > 0) gfxPrint(pad(10, length), length);
    6b04:	2900      	cmp	r1, #0
    6b06:	f000 80ad 	beq.w	6c64 <EnigmaTMWS::DrawSongInterface()+0x290>
    6b0a:	200a      	movs	r0, #10
    6b0c:	f7fe f818 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    6b10:	f7fe f82e 	bl	4b70 <HSApplication::gfxPrint(int, int) [clone .isra.0]>
                    if (favorite) gfxIcon(119, 15, FAVORITE_ICON);
    6b14:	b127      	cbz	r7, 6b20 <EnigmaTMWS::DrawSongInterface()+0x14c>
    6b16:	4a74      	ldr	r2, [pc, #464]	; (6ce8 <EnigmaTMWS::DrawSongInterface()+0x314>)
    6b18:	210f      	movs	r1, #15
    6b1a:	2077      	movs	r0, #119	; 0x77
    6b1c:	f7fd fdc2 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
  text_x_ = x;
    6b20:	2350      	movs	r3, #80	; 0x50
        graphics.print(str);
    6b22:	4972      	ldr	r1, [pc, #456]	; (6cec <EnigmaTMWS::DrawSongInterface()+0x318>)
    6b24:	486a      	ldr	r0, [pc, #424]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6b26:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    6b28:	2319      	movs	r3, #25
    6b2a:	60ab      	str	r3, [r5, #8]
    6b2c:	f012 ffd3 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                gfxPrint(pad(10, song_step[ssi].repeats()), song_step[ssi].repeats()); // Number of times played
    6b30:	f896 1426 	ldrb.w	r1, [r6, #1062]	; 0x426
    6b34:	200a      	movs	r0, #10
    6b36:	f7fe f803 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    6b3a:	f7fe f819 	bl	4b70 <HSApplication::gfxPrint(int, int) [clone .isra.0]>
        graphics.print(str);
    6b3e:	496c      	ldr	r1, [pc, #432]	; (6cf0 <EnigmaTMWS::DrawSongInterface()+0x31c>)
    6b40:	4863      	ldr	r0, [pc, #396]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6b42:	f012 ffc8 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    byte p() {return pr;}
    byte repeats() {return re;}
    int8_t transpose() {return static_cast<int8_t>(tr - 48);}
    6b46:	f896 3427 	ldrb.w	r3, [r6, #1063]	; 0x427
    6b4a:	496a      	ldr	r1, [pc, #424]	; (6cf4 <EnigmaTMWS::DrawSongInterface()+0x320>)
    6b4c:	4860      	ldr	r0, [pc, #384]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6b4e:	3b30      	subs	r3, #48	; 0x30
                gfxPrint(song_step[ssi].transpose() > -1 ? "+" : "");
    6b50:	f013 0f80 	tst.w	r3, #128	; 0x80
    6b54:	4b68      	ldr	r3, [pc, #416]	; (6cf8 <EnigmaTMWS::DrawSongInterface()+0x324>)
    6b56:	bf18      	it	ne
    6b58:	4619      	movne	r1, r3
    6b5a:	f012 ffbc 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    6b5e:	f896 1427 	ldrb.w	r1, [r6, #1063]	; 0x427
        graphics.print(num);
    6b62:	485b      	ldr	r0, [pc, #364]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6b64:	3930      	subs	r1, #48	; 0x30
    6b66:	b249      	sxtb	r1, r1
    6b68:	f013 f829 	bl	19bbe <weegfx::Graphics::print(int)>
                if (step_param == ENIGMA_STEP_NUMBER && CursorBlink()) gfxInvert(56, 14, 12, 9);
    6b6c:	f994 3f91 	ldrsb.w	r3, [r4, #3985]	; 0xf91
    6b70:	b953      	cbnz	r3, 6b88 <EnigmaTMWS::DrawSongInterface()+0x1b4>
    6b72:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6b74:	2b00      	cmp	r3, #0
    6b76:	dd1b      	ble.n	6bb0 <EnigmaTMWS::DrawSongInterface()+0x1dc>
        graphics.invertRect(x, y, w, h);
    6b78:	2309      	movs	r3, #9
    6b7a:	9300      	str	r3, [sp, #0]
    6b7c:	4854      	ldr	r0, [pc, #336]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6b7e:	230c      	movs	r3, #12
    6b80:	220e      	movs	r2, #14
    6b82:	2138      	movs	r1, #56	; 0x38
    6b84:	f012 fc4b 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
                if (step_param == ENIGMA_STEP_TM) gfxCursor(81, 23, 18);
    6b88:	f994 3f91 	ldrsb.w	r3, [r4, #3985]	; 0xf91
    6b8c:	2b01      	cmp	r3, #1
    6b8e:	d105      	bne.n	6b9c <EnigmaTMWS::DrawSongInterface()+0x1c8>
    6b90:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6b92:	2312      	movs	r3, #18
    6b94:	2217      	movs	r2, #23
    6b96:	2151      	movs	r1, #81	; 0x51
    6b98:	f7fe f806 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
                if (step_param == ENIGMA_STEP_P) gfxCursor(105, 23, 18);
    6b9c:	f994 3f91 	ldrsb.w	r3, [r4, #3985]	; 0xf91
    6ba0:	2b02      	cmp	r3, #2
    6ba2:	d105      	bne.n	6bb0 <EnigmaTMWS::DrawSongInterface()+0x1dc>
    6ba4:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6ba6:	2312      	movs	r3, #18
    6ba8:	2217      	movs	r2, #23
    6baa:	2169      	movs	r1, #105	; 0x69
    6bac:	f7fd fffc 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
                if (step_param == ENIGMA_STEP_REPEATS) gfxCursor(87, 33, 12);
    6bb0:	f994 3f91 	ldrsb.w	r3, [r4, #3985]	; 0xf91
    6bb4:	2b03      	cmp	r3, #3
    6bb6:	d105      	bne.n	6bc4 <EnigmaTMWS::DrawSongInterface()+0x1f0>
    6bb8:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6bba:	230c      	movs	r3, #12
    6bbc:	2221      	movs	r2, #33	; 0x21
    6bbe:	2157      	movs	r1, #87	; 0x57
    6bc0:	f7fd fff2 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
                if (step_param == ENIGMA_STEP_TRANSPOSE) gfxCursor(117, 33, 12);
    6bc4:	f994 3f91 	ldrsb.w	r3, [r4, #3985]	; 0xf91
    6bc8:	2b04      	cmp	r3, #4
    6bca:	d105      	bne.n	6bd8 <EnigmaTMWS::DrawSongInterface()+0x204>
    6bcc:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6bce:	230c      	movs	r3, #12
    6bd0:	2221      	movs	r2, #33	; 0x21
    6bd2:	2175      	movs	r1, #117	; 0x75
    6bd4:	f7fd ffe8 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            if (last_track_step_index > 0) {
    6bd8:	f894 33de 	ldrb.w	r3, [r4, #990]	; 0x3de
    6bdc:	2b00      	cmp	r3, #0
    6bde:	d03e      	beq.n	6c5e <EnigmaTMWS::DrawSongInterface()+0x28a>
    6be0:	f04f 0a00 	mov.w	sl, #0
        graphics.print(num);
    6be4:	4e3a      	ldr	r6, [pc, #232]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
        graphics.print(str);
    6be6:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 6cdc <EnigmaTMWS::DrawSongInterface()+0x308>
    6bea:	2723      	movs	r7, #35	; 0x23
                bool stop = 0; // Show the Stop/Loop step only once
    6bec:	46d3      	mov	fp, sl
                    if (edit_index + n + 1 < 99) {
    6bee:	f9b4 1f8a 	ldrsh.w	r1, [r4, #3978]	; 0xf8a
    6bf2:	4451      	add	r1, sl
    6bf4:	2961      	cmp	r1, #97	; 0x61
    6bf6:	dc2b      	bgt.n	6c50 <EnigmaTMWS::DrawSongInterface()+0x27c>
                        uint16_t ssi = track_step[edit_index + n + 1];
    6bf8:	eb04 0341 	add.w	r3, r4, r1, lsl #1
                        if (ssi < ENIGMA_NO_STEP_AVAILABLE) {
    6bfc:	f64f 72ff 	movw	r2, #65535	; 0xffff
                        uint16_t ssi = track_step[edit_index + n + 1];
    6c00:	f8b3 9316 	ldrh.w	r9, [r3, #790]	; 0x316
                        if (ssi < ENIGMA_NO_STEP_AVAILABLE) {
    6c04:	4591      	cmp	r9, r2
    6c06:	d041      	beq.n	6c8c <EnigmaTMWS::DrawSongInterface()+0x2b8>
                            gfxPrint(56 + pad(10, edit_index + n + 2), y, edit_index + n + 2); // Step number (1-99)
    6c08:	3102      	adds	r1, #2
    6c0a:	200a      	movs	r0, #10
    6c0c:	f7fd ff98 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    6c10:	3038      	adds	r0, #56	; 0x38
  text_x_ = x;
    6c12:	6068      	str	r0, [r5, #4]
  text_y_ = y;
    6c14:	eb04 0989 	add.w	r9, r4, r9, lsl #2
        graphics.print(num);
    6c18:	4630      	mov	r0, r6
    6c1a:	60af      	str	r7, [r5, #8]
    6c1c:	f012 ffcf 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    6c20:	4641      	mov	r1, r8
    6c22:	4630      	mov	r0, r6
    6c24:	f012 ff57 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    byte tm() {return (tk & 0x3f);} // Low six bits
    6c28:	f899 1424 	ldrb.w	r1, [r9, #1060]	; 0x424
                            HS::TuringMachine::SetName(name, song_step[ssi].tm());
    6c2c:	a803      	add	r0, sp, #12
    6c2e:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    6c32:	f7ff f8f3 	bl	5e1c <HS::TuringMachine::SetName(char*, unsigned char)>
    6c36:	a903      	add	r1, sp, #12
    6c38:	4630      	mov	r0, r6
    6c3a:	f012 ff4c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    6c3e:	492f      	ldr	r1, [pc, #188]	; (6cfc <EnigmaTMWS::DrawSongInterface()+0x328>)
    6c40:	4630      	mov	r0, r6
    6c42:	f012 ff48 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
    6c46:	f899 1426 	ldrb.w	r1, [r9, #1062]	; 0x426
    6c4a:	4630      	mov	r0, r6
    6c4c:	f012 ffb7 	bl	19bbe <weegfx::Graphics::print(int)>
                for (byte n = 0; n < 3; n++)
    6c50:	f10a 0a01 	add.w	sl, sl, #1
    6c54:	f1ba 0f03 	cmp.w	sl, #3
    6c58:	f107 070a 	add.w	r7, r7, #10
    6c5c:	d1c7      	bne.n	6bee <EnigmaTMWS::DrawSongInterface()+0x21a>
    }
    6c5e:	b005      	add	sp, #20
    6c60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        graphics.print(str);
    6c64:	4926      	ldr	r1, [pc, #152]	; (6d00 <EnigmaTMWS::DrawSongInterface()+0x32c>)
    6c66:	481a      	ldr	r0, [pc, #104]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6c68:	f012 ff35 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    }
    6c6c:	e752      	b.n	6b14 <EnigmaTMWS::DrawSongInterface()+0x140>
                    gfxPrint(pad(100, song_step[ssi].p()), song_step[ssi].p());
    6c6e:	f896 1425 	ldrb.w	r1, [r6, #1061]	; 0x425
    6c72:	2064      	movs	r0, #100	; 0x64
    6c74:	f7fd ff64 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    6c78:	f7fd ff7a 	bl	4b70 <HSApplication::gfxPrint(int, int) [clone .isra.0]>
        graphics.print(str);
    6c7c:	4915      	ldr	r1, [pc, #84]	; (6cd4 <EnigmaTMWS::DrawSongInterface()+0x300>)
    6c7e:	4814      	ldr	r0, [pc, #80]	; (6cd0 <EnigmaTMWS::DrawSongInterface()+0x2fc>)
    6c80:	f012 ff29 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    }
    6c84:	e74c      	b.n	6b20 <EnigmaTMWS::DrawSongInterface()+0x14c>
                DrawSongHelp();
    6c86:	f7fd ff33 	bl	4af0 <EnigmaTMWS::DrawSongHelp() [clone .isra.0]>
    6c8a:	e7a5      	b.n	6bd8 <EnigmaTMWS::DrawSongInterface()+0x204>
                        } else if (!stop) {
    6c8c:	f1bb 0f00 	cmp.w	fp, #0
    6c90:	d1de      	bne.n	6c50 <EnigmaTMWS::DrawSongInterface()+0x27c>
                            gfxPrint(56 + pad(10, edit_index + n + 2), y, edit_index + n + 2); // Step number (1-99)
    6c92:	3102      	adds	r1, #2
    6c94:	200a      	movs	r0, #10
    6c96:	f7fd ff53 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    6c9a:	3038      	adds	r0, #56	; 0x38
  text_x_ = x;
    6c9c:	6068      	str	r0, [r5, #4]
        graphics.print(num);
    6c9e:	4630      	mov	r0, r6
  text_y_ = y;
    6ca0:	60af      	str	r7, [r5, #8]
    6ca2:	f012 ff8c 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    6ca6:	4641      	mov	r1, r8
    6ca8:	4630      	mov	r0, r6
    6caa:	f012 ff14 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                            gfxPrint(track[track_cursor].loop() ? "< Loop >" : "< Stop >");
    6cae:	f994 3f8e 	ldrsb.w	r3, [r4, #3982]	; 0xf8e
    6cb2:	4914      	ldr	r1, [pc, #80]	; (6d04 <EnigmaTMWS::DrawSongInterface()+0x330>)
        set_divide(1);
        set_loop(0);
    }

    byte divide() {return (data & 0x1f) + 1;}
    byte loop() {return ((data >> 5) & 0x01);}
    6cb4:	4423      	add	r3, r4
    6cb6:	4630      	mov	r0, r6
    6cb8:	f893 3f84 	ldrb.w	r3, [r3, #3972]	; 0xf84
    6cbc:	f013 0f20 	tst.w	r3, #32
    6cc0:	4b11      	ldr	r3, [pc, #68]	; (6d08 <EnigmaTMWS::DrawSongInterface()+0x334>)
    6cc2:	bf18      	it	ne
    6cc4:	4619      	movne	r1, r3
    6cc6:	f012 ff06 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                            stop = 1;
    6cca:	f04f 0b01 	mov.w	fp, #1
    }
    6cce:	e7bf      	b.n	6c50 <EnigmaTMWS::DrawSongInterface()+0x27c>
    6cd0:	200065e0 	.word	0x200065e0
    6cd4:	000204fb 	.word	0x000204fb
    6cd8:	00020ff7 	.word	0x00020ff7
    6cdc:	000211d1 	.word	0x000211d1
    6ce0:	000211c7 	.word	0x000211c7
    6ce4:	200036e8 	.word	0x200036e8
    6ce8:	00023d58 	.word	0x00023d58
    6cec:	00020ffe 	.word	0x00020ffe
    6cf0:	000211c6 	.word	0x000211c6
    6cf4:	0001e41c 	.word	0x0001e41c
    6cf8:	000211c8 	.word	0x000211c8
    6cfc:	00020ffd 	.word	0x00020ffd
    6d00:	00021123 	.word	0x00021123
    6d04:	00020fee 	.word	0x00020fee
    6d08:	00020fe5 	.word	0x00020fe5

00006d0c <EnigmaTMWS::DrawPlayInterface()>:
    void DrawPlayInterface() {
    6d0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if (play) gfxIcon(118, 0, PLAY_ICON);
    6d10:	f890 13e4 	ldrb.w	r1, [r0, #996]	; 0x3e4
    void DrawPlayInterface() {
    6d14:	b087      	sub	sp, #28
    6d16:	4605      	mov	r5, r0
        if (play) gfxIcon(118, 0, PLAY_ICON);
    6d18:	b321      	cbz	r1, 6d64 <EnigmaTMWS::DrawPlayInterface()+0x58>
    6d1a:	4a79      	ldr	r2, [pc, #484]	; (6f00 <EnigmaTMWS::DrawPlayInterface()+0x1f4>)
    6d1c:	2100      	movs	r1, #0
        else gfxIcon(118, 0, PAUSE_ICON);
    6d1e:	2076      	movs	r0, #118	; 0x76
    6d20:	f7fd fcc0 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        if (help_countdown) DrawPlayHelp();
    6d24:	f8b5 63e0 	ldrh.w	r6, [r5, #992]	; 0x3e0
    6d28:	4c76      	ldr	r4, [pc, #472]	; (6f04 <EnigmaTMWS::DrawPlayInterface()+0x1f8>)
    6d2a:	b1ee      	cbz	r6, 6d68 <EnigmaTMWS::DrawPlayInterface()+0x5c>
        gfxIcon(56, 15, UP_BTN_ICON);
    6d2c:	4a76      	ldr	r2, [pc, #472]	; (6f08 <EnigmaTMWS::DrawPlayInterface()+0x1fc>)
    6d2e:	210f      	movs	r1, #15
    6d30:	2038      	movs	r0, #56	; 0x38
    6d32:	f7fd fcb7 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
  text_x_ = x;
    6d36:	2542      	movs	r5, #66	; 0x42
  text_y_ = y;
    6d38:	230f      	movs	r3, #15
        graphics.print(str);
    6d3a:	4620      	mov	r0, r4
    6d3c:	4973      	ldr	r1, [pc, #460]	; (6f0c <EnigmaTMWS::DrawPlayInterface()+0x200>)
    6d3e:	60a3      	str	r3, [r4, #8]
  text_x_ = x;
    6d40:	6065      	str	r5, [r4, #4]
    6d42:	f012 fec8 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxIcon(56, 25, DOWN_BTN_ICON);
    6d46:	4a72      	ldr	r2, [pc, #456]	; (6f10 <EnigmaTMWS::DrawPlayInterface()+0x204>)
    6d48:	2119      	movs	r1, #25
    6d4a:	2038      	movs	r0, #56	; 0x38
    6d4c:	f7fd fcaa 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
    6d50:	4970      	ldr	r1, [pc, #448]	; (6f14 <EnigmaTMWS::DrawPlayInterface()+0x208>)
    6d52:	6065      	str	r5, [r4, #4]
  text_y_ = y;
    6d54:	2319      	movs	r3, #25
    6d56:	4620      	mov	r0, r4
    6d58:	60a3      	str	r3, [r4, #8]
    }
    6d5a:	b007      	add	sp, #28
    6d5c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6d60:	f012 beb9 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
        else gfxIcon(118, 0, PAUSE_ICON);
    6d64:	4a6c      	ldr	r2, [pc, #432]	; (6f18 <EnigmaTMWS::DrawPlayInterface()+0x20c>)
    6d66:	e7da      	b.n	6d1e <EnigmaTMWS::DrawPlayInterface()+0x12>
    6d68:	230f      	movs	r3, #15
    6d6a:	496c      	ldr	r1, [pc, #432]	; (6f1c <EnigmaTMWS::DrawPlayInterface()+0x210>)
    6d6c:	60a3      	str	r3, [r4, #8]
    6d6e:	4620      	mov	r0, r4
  text_x_ = x;
    6d70:	6066      	str	r6, [r4, #4]
    6d72:	f012 feb0 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.drawLine(x, y, x2, y2);
    6d76:	2217      	movs	r2, #23
    6d78:	237f      	movs	r3, #127	; 0x7f
    6d7a:	9200      	str	r2, [sp, #0]
    6d7c:	4631      	mov	r1, r6
    6d7e:	4620      	mov	r0, r4
    6d80:	f012 fd36 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
            gfxIcon(80, 14, CLOCK_ICON);
    6d84:	4a66      	ldr	r2, [pc, #408]	; (6f20 <EnigmaTMWS::DrawPlayInterface()+0x214>)
    6d86:	210e      	movs	r1, #14
    6d88:	2050      	movs	r0, #80	; 0x50
    6d8a:	f7fd fc8b 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
            gfxIcon(106, 14, LOOP_ICON);
    6d8e:	4a65      	ldr	r2, [pc, #404]	; (6f24 <EnigmaTMWS::DrawPlayInterface()+0x218>)
    6d90:	210e      	movs	r1, #14
    6d92:	206a      	movs	r0, #106	; 0x6a
    6d94:	f7fd fc86 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
            for (int t = 0; t < 4; t++)
    6d98:	f205 33ea 	addw	r3, r5, #1002	; 0x3ea
    6d9c:	9302      	str	r3, [sp, #8]
    6d9e:	f205 3af3 	addw	sl, r5, #1011	; 0x3f3
            gfxIcon(106, 14, LOOP_ICON);
    6da2:	f04f 0921 	mov.w	r9, #33	; 0x21
                uint16_t ssi = playback_step_index[t]; // playback_step_index is the index of the song_step
    6da6:	9b02      	ldr	r3, [sp, #8]
    6da8:	9603      	str	r6, [sp, #12]
                gfxPrint(0, y, t + 1);
    6daa:	3601      	adds	r6, #1
                uint16_t ssi = playback_step_index[t]; // playback_step_index is the index of the song_step
    6dac:	f833 bf02 	ldrh.w	fp, [r3, #2]!
    6db0:	9302      	str	r3, [sp, #8]
        graphics.print(num);
    6db2:	4631      	mov	r1, r6
    6db4:	f1a9 0708 	sub.w	r7, r9, #8
    6db8:	f04f 0800 	mov.w	r8, #0
    6dbc:	4620      	mov	r0, r4
    6dbe:	f8c4 8004 	str.w	r8, [r4, #4]
  text_y_ = y;
    6dc2:	60a7      	str	r7, [r4, #8]
    6dc4:	f012 fefb 	bl	19bbe <weegfx::Graphics::print(int)>
                if (playback_step_number[t] == 0) {
    6dc8:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
    6dcc:	2900      	cmp	r1, #0
    6dce:	d149      	bne.n	6e64 <EnigmaTMWS::DrawPlayInterface()+0x158>
                    gfxIcon(30, y, RESET_ICON);
    6dd0:	4a55      	ldr	r2, [pc, #340]	; (6f28 <EnigmaTMWS::DrawPlayInterface()+0x21c>)
    6dd2:	4639      	mov	r1, r7
    6dd4:	201e      	movs	r0, #30
    6dd6:	f7fd fc65 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
  text_x_ = x;
    6dda:	234e      	movs	r3, #78	; 0x4e
        graphics.print(str);
    6ddc:	4953      	ldr	r1, [pc, #332]	; (6f2c <EnigmaTMWS::DrawPlayInterface()+0x220>)
    6dde:	6063      	str	r3, [r4, #4]
    6de0:	4620      	mov	r0, r4
  text_y_ = y;
    6de2:	60a7      	str	r7, [r4, #8]
    6de4:	f012 fe77 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    byte divide() {return (data & 0x1f) + 1;}
    6de8:	f89a 1b90 	ldrb.w	r1, [sl, #2960]	; 0xb90
    6dec:	f001 011f 	and.w	r1, r1, #31
        graphics.print(num);
    6df0:	3101      	adds	r1, #1
    6df2:	4620      	mov	r0, r4
    6df4:	f012 fee3 	bl	19bbe <weegfx::Graphics::print(int)>
                if (track[t].loop()) gfxIcon(106, y, LOOP_ICON);
    6df8:	f89a 3b90 	ldrb.w	r3, [sl, #2960]	; 0xb90
    6dfc:	069b      	lsls	r3, r3, #26
    6dfe:	bf4c      	ite	mi
    6e00:	4a48      	ldrmi	r2, [pc, #288]	; (6f24 <EnigmaTMWS::DrawPlayInterface()+0x218>)
                else gfxIcon(106, y, PLAYONCE_ICON);
    6e02:	4a4b      	ldrpl	r2, [pc, #300]	; (6f30 <EnigmaTMWS::DrawPlayInterface()+0x224>)
    6e04:	4639      	mov	r1, r7
    6e06:	206a      	movs	r0, #106	; 0x6a
    6e08:	f7fd fc4c 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
                if (ssi != ENIGMA_NO_STEP_AVAILABLE) {
    6e0c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6e10:	459b      	cmp	fp, r3
    6e12:	d008      	beq.n	6e26 <EnigmaTMWS::DrawPlayInterface()+0x11a>
                    if (playback_end[t]) gfxIcon(118, y, STOP_ICON);
    6e14:	f89a 300c 	ldrb.w	r3, [sl, #12]
    6e18:	2b00      	cmp	r3, #0
    6e1a:	d069      	beq.n	6ef0 <EnigmaTMWS::DrawPlayInterface()+0x1e4>
    6e1c:	4a45      	ldr	r2, [pc, #276]	; (6f34 <EnigmaTMWS::DrawPlayInterface()+0x228>)
                    else if (play || !CursorBlink()) gfxIcon(118, y, PLAY_ICON);
    6e1e:	4639      	mov	r1, r7
    6e20:	2076      	movs	r0, #118	; 0x76
    6e22:	f7fd fc3f 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
                if (t == track_cursor) {
    6e26:	f995 3f8e 	ldrsb.w	r3, [r5, #3982]	; 0xf8e
    6e2a:	9a03      	ldr	r2, [sp, #12]
    6e2c:	4293      	cmp	r3, r2
    6e2e:	d112      	bne.n	6e56 <EnigmaTMWS::DrawPlayInterface()+0x14a>
                    if (track_param == ENIGMA_TRACK_DIVIDE) gfxCursor(84, y + 8, 12);
    6e30:	f995 3f92 	ldrsb.w	r3, [r5, #3986]	; 0xf92
    6e34:	b92b      	cbnz	r3, 6e42 <EnigmaTMWS::DrawPlayInterface()+0x136>
    6e36:	6a68      	ldr	r0, [r5, #36]	; 0x24
    6e38:	230c      	movs	r3, #12
    6e3a:	464a      	mov	r2, r9
    6e3c:	2154      	movs	r1, #84	; 0x54
    6e3e:	f7fd feb3 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
                    if (track_param == ENIGMA_TRACK_LOOP) gfxCursor(106, y + 8, 8);
    6e42:	f995 3f92 	ldrsb.w	r3, [r5, #3986]	; 0xf92
    6e46:	2b01      	cmp	r3, #1
    6e48:	d105      	bne.n	6e56 <EnigmaTMWS::DrawPlayInterface()+0x14a>
    6e4a:	6a68      	ldr	r0, [r5, #36]	; 0x24
    6e4c:	2308      	movs	r3, #8
    6e4e:	464a      	mov	r2, r9
    6e50:	216a      	movs	r1, #106	; 0x6a
    6e52:	f7fd fea9 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            for (int t = 0; t < 4; t++)
    6e56:	2e04      	cmp	r6, #4
    6e58:	f109 090a 	add.w	r9, r9, #10
    6e5c:	d1a3      	bne.n	6da6 <EnigmaTMWS::DrawPlayInterface()+0x9a>
    }
    6e5e:	b007      	add	sp, #28
    6e60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                } else if (ssi != ENIGMA_NO_STEP_AVAILABLE) {
    6e64:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6e68:	459b      	cmp	fp, r3
    6e6a:	d0b6      	beq.n	6dda <EnigmaTMWS::DrawPlayInterface()+0xce>
                    gfxPrint(18 + pad(10, playback_step_number[t]), y, playback_step_number[t]);
    6e6c:	200a      	movs	r0, #10
    6e6e:	f7fd fe67 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    6e72:	3012      	adds	r0, #18
  text_x_ = x;
    6e74:	6060      	str	r0, [r4, #4]
        graphics.print(num);
    6e76:	4620      	mov	r0, r4
  text_y_ = y;
    6e78:	60a7      	str	r7, [r4, #8]
    6e7a:	f012 fea0 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    6e7e:	492e      	ldr	r1, [pc, #184]	; (6f38 <EnigmaTMWS::DrawPlayInterface()+0x22c>)
    6e80:	4620      	mov	r0, r4
    6e82:	f012 fe28 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                    gfxPrint(playback_step_repeat[t] + 1);
    6e86:	f89a 1004 	ldrb.w	r1, [sl, #4]
        graphics.print(num);
    6e8a:	4620      	mov	r0, r4
    6e8c:	3101      	adds	r1, #1
    6e8e:	f012 fe96 	bl	19bbe <weegfx::Graphics::print(int)>
    6e92:	eb05 038b 	add.w	r3, r5, fp, lsl #2
                    HS::TuringMachine::SetName(name, song_step[ssi].tm());
    6e96:	a805      	add	r0, sp, #20
    6e98:	f893 1424 	ldrb.w	r1, [r3, #1060]	; 0x424
    6e9c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    6ea0:	f7fe ffbc 	bl	5e1c <HS::TuringMachine::SetName(char*, unsigned char)>
  text_x_ = x;
    6ea4:	2336      	movs	r3, #54	; 0x36
        graphics.print(str);
    6ea6:	a905      	add	r1, sp, #20
    6ea8:	4620      	mov	r0, r4
    6eaa:	6063      	str	r3, [r4, #4]
  text_y_ = y;
    6eac:	60a7      	str	r7, [r4, #8]
    6eae:	f012 fe12 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  return frame_ + ((y >>3) << 7) + x;
    6eb2:	ea4f 03e9 	mov.w	r3, r9, asr #3
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    6eb6:	f009 0107 	and.w	r1, r9, #7
    6eba:	2201      	movs	r2, #1
  return frame_ + ((y >>3) << 7) + x;
    6ebc:	01db      	lsls	r3, r3, #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    6ebe:	408a      	lsls	r2, r1
    6ec0:	fa5f fe82 	uxtb.w	lr, r2

    void DrawSmallAt(byte x, byte y) {
        for (byte b = 0; b < 16; b++)
            if ((reg >> b) & 0x01) graphics.setPixel(16 - b + x, y);
    6ec4:	f205 3cfe 	addw	ip, r5, #1022	; 0x3fe
  return frame_ + ((y >>3) << 7) + x;
    6ec8:	3346      	adds	r3, #70	; 0x46
    6eca:	f83c 2036 	ldrh.w	r2, [ip, r6, lsl #3]
    6ece:	fa42 f208 	asr.w	r2, r2, r8
    6ed2:	07d2      	lsls	r2, r2, #31
    6ed4:	d506      	bpl.n	6ee4 <EnigmaTMWS::DrawPlayInterface()+0x1d8>
    6ed6:	6820      	ldr	r0, [r4, #0]
    6ed8:	eba3 0208 	sub.w	r2, r3, r8
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    6edc:	5c81      	ldrb	r1, [r0, r2]
    6ede:	ea4e 0101 	orr.w	r1, lr, r1
    6ee2:	5481      	strb	r1, [r0, r2]
        for (byte b = 0; b < 16; b++)
    6ee4:	f108 0801 	add.w	r8, r8, #1
    6ee8:	f1b8 0f10 	cmp.w	r8, #16
    6eec:	d1ed      	bne.n	6eca <EnigmaTMWS::DrawPlayInterface()+0x1be>
    6eee:	e774      	b.n	6dda <EnigmaTMWS::DrawPlayInterface()+0xce>
                    else if (play || !CursorBlink()) gfxIcon(118, y, PLAY_ICON);
    6ef0:	f895 33e4 	ldrb.w	r3, [r5, #996]	; 0x3e4
    6ef4:	b913      	cbnz	r3, 6efc <EnigmaTMWS::DrawPlayInterface()+0x1f0>
    6ef6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    6ef8:	2b00      	cmp	r3, #0
    6efa:	dc94      	bgt.n	6e26 <EnigmaTMWS::DrawPlayInterface()+0x11a>
    6efc:	4a00      	ldr	r2, [pc, #0]	; (6f00 <EnigmaTMWS::DrawPlayInterface()+0x1f4>)
    6efe:	e78e      	b.n	6e1e <EnigmaTMWS::DrawPlayInterface()+0x112>
    6f00:	00024230 	.word	0x00024230
    6f04:	200065e0 	.word	0x200065e0
    6f08:	00023ca0 	.word	0x00023ca0
    6f0c:	00021000 	.word	0x00021000
    6f10:	00023d50 	.word	0x00023d50
    6f14:	0002135a 	.word	0x0002135a
    6f18:	00023c80 	.word	0x00023c80
    6f1c:	0002100b 	.word	0x0002100b
    6f20:	00023c28 	.word	0x00023c28
    6f24:	00024218 	.word	0x00024218
    6f28:	00023c88 	.word	0x00023c88
    6f2c:	00021018 	.word	0x00021018
    6f30:	00023e20 	.word	0x00023e20
    6f34:	00024238 	.word	0x00024238
    6f38:	0002132b 	.word	0x0002132b

00006f3c <EnigmaTMWS::View()>:
    void View() {
    6f3c:	b570      	push	{r4, r5, r6, lr}
    6f3e:	4604      	mov	r4, r0
        gfxHeader("Enigma - ");
    6f40:	4931      	ldr	r1, [pc, #196]	; (7008 <EnigmaTMWS::View()+0xcc>)
    6f42:	f7fe ff1f 	bl	5d84 <HSApplication::gfxHeader(char const*)>
        if (mode == ENIGMA_CONFIRM_RESET) gfxPrint("New Song");
    6f46:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    6f4a:	2b04      	cmp	r3, #4
    6f4c:	d103      	bne.n	6f56 <EnigmaTMWS::View()+0x1a>
        graphics.print(str);
    6f4e:	492f      	ldr	r1, [pc, #188]	; (700c <EnigmaTMWS::View()+0xd0>)
    6f50:	482f      	ldr	r0, [pc, #188]	; (7010 <EnigmaTMWS::View()+0xd4>)
    6f52:	f012 fdc0 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (mode == ENIGMA_MODE_LIBRARY) gfxPrint("Library");
    6f56:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    6f5a:	b91b      	cbnz	r3, 6f64 <EnigmaTMWS::View()+0x28>
    6f5c:	492d      	ldr	r1, [pc, #180]	; (7014 <EnigmaTMWS::View()+0xd8>)
    6f5e:	482c      	ldr	r0, [pc, #176]	; (7010 <EnigmaTMWS::View()+0xd4>)
    6f60:	f012 fdb9 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (mode == ENIGMA_MODE_ASSIGN) gfxPrint("Assign");
    6f64:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    6f68:	2b01      	cmp	r3, #1
    6f6a:	d103      	bne.n	6f74 <EnigmaTMWS::View()+0x38>
    6f6c:	492a      	ldr	r1, [pc, #168]	; (7018 <EnigmaTMWS::View()+0xdc>)
    6f6e:	4828      	ldr	r0, [pc, #160]	; (7010 <EnigmaTMWS::View()+0xd4>)
    6f70:	f012 fdb1 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (mode == ENIGMA_MODE_SONG) gfxPrint("Song");
    6f74:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    6f78:	2b02      	cmp	r3, #2
    6f7a:	d103      	bne.n	6f84 <EnigmaTMWS::View()+0x48>
    6f7c:	4927      	ldr	r1, [pc, #156]	; (701c <EnigmaTMWS::View()+0xe0>)
    6f7e:	4824      	ldr	r0, [pc, #144]	; (7010 <EnigmaTMWS::View()+0xd4>)
    6f80:	f012 fda9 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (mode == ENIGMA_MODE_PLAY) gfxPrint("Play");
    6f84:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    6f88:	2b03      	cmp	r3, #3
    6f8a:	d103      	bne.n	6f94 <EnigmaTMWS::View()+0x58>
    6f8c:	4924      	ldr	r1, [pc, #144]	; (7020 <EnigmaTMWS::View()+0xe4>)
    6f8e:	4820      	ldr	r0, [pc, #128]	; (7010 <EnigmaTMWS::View()+0xd4>)
    6f90:	f012 fda1 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        switch(mode) {
    6f94:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    6f98:	2b04      	cmp	r3, #4
    6f9a:	d830      	bhi.n	6ffe <EnigmaTMWS::View()+0xc2>
    6f9c:	e8df f003 	tbb	[pc, r3]
    6fa0:	2f2b2723 	.word	0x2f2b2723
    6fa4:	03          	.byte	0x03
    6fa5:	00          	.byte	0x00
  text_x_ = x;
    6fa6:	4c1a      	ldr	r4, [pc, #104]	; (7010 <EnigmaTMWS::View()+0xd4>)
        graphics.print(str);
    6fa8:	491e      	ldr	r1, [pc, #120]	; (7024 <EnigmaTMWS::View()+0xe8>)
    6faa:	2500      	movs	r5, #0
  text_y_ = y;
    6fac:	230f      	movs	r3, #15
    6fae:	4620      	mov	r0, r4
    6fb0:	60a3      	str	r3, [r4, #8]
  text_x_ = x;
    6fb2:	6065      	str	r5, [r4, #4]
    6fb4:	f012 fd8f 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_y_ = y;
    6fb8:	2319      	movs	r3, #25
    6fba:	4620      	mov	r0, r4
    6fbc:	491a      	ldr	r1, [pc, #104]	; (7028 <EnigmaTMWS::View()+0xec>)
    6fbe:	60a3      	str	r3, [r4, #8]
    6fc0:	2637      	movs	r6, #55	; 0x37
  text_x_ = x;
    6fc2:	6065      	str	r5, [r4, #4]
    6fc4:	f012 fd87 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    6fc8:	4620      	mov	r0, r4
    6fca:	4918      	ldr	r1, [pc, #96]	; (702c <EnigmaTMWS::View()+0xf0>)
  text_y_ = y;
    6fcc:	60a6      	str	r6, [r4, #8]
  text_x_ = x;
    6fce:	2360      	movs	r3, #96	; 0x60
    6fd0:	6063      	str	r3, [r4, #4]
    6fd2:	f012 fd80 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    6fd6:	6065      	str	r5, [r4, #4]
  text_y_ = y;
    6fd8:	60a6      	str	r6, [r4, #8]
    6fda:	4620      	mov	r0, r4
    6fdc:	4914      	ldr	r1, [pc, #80]	; (7030 <EnigmaTMWS::View()+0xf4>)
    }
    6fde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    6fe2:	f012 bd78 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
            case ENIGMA_MODE_LIBRARY  : DrawLibraryInterface();
    6fe6:	4620      	mov	r0, r4
    6fe8:	f7ff fb18 	bl	661c <EnigmaTMWS::DrawLibraryInterface()>
    }
    6fec:	bd70      	pop	{r4, r5, r6, pc}
            case ENIGMA_MODE_ASSIGN   : DrawAssignInterface();
    6fee:	4620      	mov	r0, r4
    6ff0:	f7ff fbd6 	bl	67a0 <EnigmaTMWS::DrawAssignInterface()>
                                        break;
    6ff4:	e7fa      	b.n	6fec <EnigmaTMWS::View()+0xb0>
            case ENIGMA_MODE_SONG     : DrawSongInterface();
    6ff6:	4620      	mov	r0, r4
    6ff8:	f7ff fcec 	bl	69d4 <EnigmaTMWS::DrawSongInterface()>
                                        break;
    6ffc:	e7f6      	b.n	6fec <EnigmaTMWS::View()+0xb0>
            case ENIGMA_MODE_PLAY     : DrawPlayInterface();
    6ffe:	4620      	mov	r0, r4
    7000:	f7ff fe84 	bl	6d0c <EnigmaTMWS::DrawPlayInterface()>
    }
    7004:	e7f2      	b.n	6fec <EnigmaTMWS::View()+0xb0>
    7006:	bf00      	nop
    7008:	0002101a 	.word	0x0002101a
    700c:	00021024 	.word	0x00021024
    7010:	200065e0 	.word	0x200065e0
    7014:	00020fc8 	.word	0x00020fc8
    7018:	000210e0 	.word	0x000210e0
    701c:	00021028 	.word	0x00021028
    7020:	00020546 	.word	0x00020546
    7024:	0002102d 	.word	0x0002102d
    7028:	00021042 	.word	0x00021042
    702c:	00021051 	.word	0x00021051
    7030:	00021057 	.word	0x00021057

00007034 <EnigmaTMWS::SwitchTuringMachine(unsigned char)>:
    void SwitchTuringMachine(byte ix) {
    7034:	b510      	push	{r4, lr}
    7036:	4604      	mov	r4, r0
        tm_state.Init(ix);
    7038:	f200 20e2 	addw	r0, r0, #738	; 0x2e2
    703c:	f7fe fefa 	bl	5e34 <TuringMachineState::Init(unsigned char)>
    void SetWriteMode(bool write_) {write = write_;}
    7040:	2301      	movs	r3, #1
    7042:	f884 32e8 	strb.w	r3, [r4, #744]	; 0x2e8
        if (tm_state.IsFavorite()) tm_param = ENIGMA_TM_ROTATE;
    7046:	f894 32e7 	ldrb.w	r3, [r4, #743]	; 0x2e7
    704a:	b113      	cbz	r3, 7052 <EnigmaTMWS::SwitchTuringMachine(unsigned char)+0x1e>
    704c:	2302      	movs	r3, #2
    704e:	f884 3f8f 	strb.w	r3, [r4, #3983]	; 0xf8f
    }
    7052:	bd10      	pop	{r4, pc}

00007054 <EnigmaTMWS::DelegateTMParam(int)>:
        if (!tm_state.IsFavorite()) {
    7054:	f890 22e7 	ldrb.w	r2, [r0, #743]	; 0x2e7
            if (tm_param == ENIGMA_TM_LENGTH) tm_state.ChangeLength(direction);
    7058:	f990 3f8f 	ldrsb.w	r3, [r0, #3983]	; 0xf8f
        if (!tm_state.IsFavorite()) {
    705c:	bb32      	cbnz	r2, 70ac <EnigmaTMWS::DelegateTMParam(int)+0x58>
            if (tm_param == ENIGMA_TM_LENGTH) tm_state.ChangeLength(direction);
    705e:	b9ab      	cbnz	r3, 708c <EnigmaTMWS::DelegateTMParam(int)+0x38>
        len = constrain(len + direction, 1, 16);
    7060:	f890 32e6 	ldrb.w	r3, [r0, #742]	; 0x2e6
    7064:	4419      	add	r1, r3
    7066:	2910      	cmp	r1, #16
    7068:	bfa8      	it	ge
    706a:	2110      	movge	r1, #16
    706c:	2901      	cmp	r1, #1
    706e:	bfb8      	it	lt
    7070:	2101      	movlt	r1, #1
        if (write && !fav) HS::user_turing_machines[ix].len = len;
    7072:	f890 32e8 	ldrb.w	r3, [r0, #744]	; 0x2e8
        len = constrain(len + direction, 1, 16);
    7076:	b2c9      	uxtb	r1, r1
    7078:	f880 12e6 	strb.w	r1, [r0, #742]	; 0x2e6
        if (write && !fav) HS::user_turing_machines[ix].len = len;
    707c:	b36b      	cbz	r3, 70da <EnigmaTMWS::DelegateTMParam(int)+0x86>
    707e:	f890 22e2 	ldrb.w	r2, [r0, #738]	; 0x2e2
    7082:	4b19      	ldr	r3, [pc, #100]	; (70e8 <EnigmaTMWS::DelegateTMParam(int)+0x94>)
    7084:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    7088:	7099      	strb	r1, [r3, #2]
    708a:	4770      	bx	lr
            if (tm_param == ENIGMA_TM_PROBABILITY)
    708c:	2b01      	cmp	r3, #1
    708e:	d10d      	bne.n	70ac <EnigmaTMWS::DelegateTMParam(int)+0x58>
                state_prob[tm_cursor] = constrain(state_prob[tm_cursor] + direction, 0, 100);
    7090:	f990 2f8c 	ldrsb.w	r2, [r0, #3980]	; 0xf8c
    7094:	4402      	add	r2, r0
    7096:	f892 32ea 	ldrb.w	r3, [r2, #746]	; 0x2ea
    709a:	4419      	add	r1, r3
    709c:	2964      	cmp	r1, #100	; 0x64
    709e:	bfa8      	it	ge
    70a0:	2164      	movge	r1, #100	; 0x64
    70a2:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
    70a6:	f882 12ea 	strb.w	r1, [r2, #746]	; 0x2ea
    70aa:	4770      	bx	lr
        if (tm_param == ENIGMA_TM_ROTATE) tm_state.Rotate(direction);
    70ac:	2b02      	cmp	r3, #2
    70ae:	d114      	bne.n	70da <EnigmaTMWS::DelegateTMParam(int)+0x86>
        if (write) { // Rotate requires write access, but doesn't care about favorite status
    70b0:	f890 32e8 	ldrb.w	r3, [r0, #744]	; 0x2e8
    70b4:	b18b      	cbz	r3, 70da <EnigmaTMWS::DelegateTMParam(int)+0x86>
            if (direction == 1) { // rotate right
    70b6:	2901      	cmp	r1, #1
                uint16_t bit0 = reg & 0x0001;
    70b8:	f8b0 32e4 	ldrh.w	r3, [r0, #740]	; 0x2e4
            if (direction == 1) { // rotate right
    70bc:	d10e      	bne.n	70dc <EnigmaTMWS::DelegateTMParam(int)+0x88>
                reg = (reg >> 1) | (bit0 << 15);
    70be:	f003 0201 	and.w	r2, r3, #1
    70c2:	085b      	lsrs	r3, r3, #1
    70c4:	ea43 33c2 	orr.w	r3, r3, r2, lsl #15
                reg = (reg << 1) | (bit15 >> 15);
    70c8:	f8a0 32e4 	strh.w	r3, [r0, #740]	; 0x2e4
            HS::user_turing_machines[ix].reg = reg;
    70cc:	f890 22e2 	ldrb.w	r2, [r0, #738]	; 0x2e2
    70d0:	4b05      	ldr	r3, [pc, #20]	; (70e8 <EnigmaTMWS::DelegateTMParam(int)+0x94>)
    70d2:	f8b0 12e4 	ldrh.w	r1, [r0, #740]	; 0x2e4
    70d6:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
    }
    70da:	4770      	bx	lr
            if (direction == -1) { // rotate left
    70dc:	3101      	adds	r1, #1
    70de:	d1f5      	bne.n	70cc <EnigmaTMWS::DelegateTMParam(int)+0x78>
                reg = (reg << 1) | (bit15 >> 15);
    70e0:	005a      	lsls	r2, r3, #1
    70e2:	ea42 33d3 	orr.w	r3, r2, r3, lsr #15
    70e6:	e7ef      	b.n	70c8 <EnigmaTMWS::DelegateTMParam(int)+0x74>
    70e8:	200036e8 	.word	0x200036e8

000070ec <EnigmaTMWS::DelegateOutputParam(int)>:
    void DelegateOutputParam(int direction) {
    70ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (output_param == ENIGMA_OUTPUT_TRACK) {
    70ee:	f990 3f90 	ldrsb.w	r3, [r0, #3984]	; 0xf90
    void DelegateOutputParam(int direction) {
    70f2:	4604      	mov	r4, r0
    70f4:	460d      	mov	r5, r1
        if (output_param == ENIGMA_OUTPUT_TRACK) {
    70f6:	b9a3      	cbnz	r3, 7122 <EnigmaTMWS::DelegateOutputParam(int)+0x36>
            if (output[output_cursor].track() > 0 || direction > 0)
    70f8:	f990 2f8d 	ldrsb.w	r2, [r0, #3981]	; 0xf8d
    byte track() {return tk;}
    70fc:	f44f 71a4 	mov.w	r1, #328	; 0x148
    7100:	fb01 0302 	mla	r3, r1, r2, r0
    7104:	f893 3ba8 	ldrb.w	r3, [r3, #2984]	; 0xba8
    7108:	b90b      	cbnz	r3, 710e <EnigmaTMWS::DelegateOutputParam(int)+0x22>
    710a:	2d00      	cmp	r5, #0
    710c:	dd08      	ble.n	7120 <EnigmaTMWS::DelegateOutputParam(int)+0x34>
                output[output_cursor].set_track(output[output_cursor].track() + direction);
    710e:	442b      	add	r3, r5
    void set_track(byte track_) {tk = constrain(track_, 0, 3);}
    7110:	b2db      	uxtb	r3, r3
    7112:	fb01 4202 	mla	r2, r1, r2, r4
    7116:	2b03      	cmp	r3, #3
    7118:	bfa8      	it	ge
    711a:	2303      	movge	r3, #3
    711c:	f882 3ba8 	strb.w	r3, [r2, #2984]	; 0xba8
    }
    7120:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (output_param == ENIGMA_OUTPUT_TYPE) {
    7122:	2b01      	cmp	r3, #1
    7124:	d01a      	beq.n	715c <EnigmaTMWS::DelegateOutputParam(int)+0x70>
        if (output_param == ENIGMA_OUTPUT_SCALE) {
    7126:	2b02      	cmp	r3, #2
    7128:	d02d      	beq.n	7186 <EnigmaTMWS::DelegateOutputParam(int)+0x9a>
        if (output_param == ENIGMA_OUTPUT_MIDI_CH) {
    712a:	f994 3f90 	ldrsb.w	r3, [r4, #3984]	; 0xf90
    712e:	2b03      	cmp	r3, #3
    7130:	d1f6      	bne.n	7120 <EnigmaTMWS::DelegateOutputParam(int)+0x34>
            if (output[output_cursor].midi_channel() > 0 || direction > 0)
    7132:	f994 2f8d 	ldrsb.w	r2, [r4, #3981]	; 0xf8d
    byte midi_channel() {return mc;}
    7136:	f44f 71a4 	mov.w	r1, #328	; 0x148
    713a:	fb01 4302 	mla	r3, r1, r2, r4
    713e:	f893 3bab 	ldrb.w	r3, [r3, #2987]	; 0xbab
    7142:	b90b      	cbnz	r3, 7148 <EnigmaTMWS::DelegateOutputParam(int)+0x5c>
    7144:	2d00      	cmp	r5, #0
    7146:	ddeb      	ble.n	7120 <EnigmaTMWS::DelegateOutputParam(int)+0x34>
                output[output_cursor].set_midi_channel(output[output_cursor].midi_channel() + direction);
    7148:	442b      	add	r3, r5
    void set_midi_channel(byte midi_channel_) {mc = constrain(midi_channel_, 0, 16);}
    714a:	b2db      	uxtb	r3, r3
    714c:	fb01 4402 	mla	r4, r1, r2, r4
    7150:	2b10      	cmp	r3, #16
    7152:	bfa8      	it	ge
    7154:	2310      	movge	r3, #16
    7156:	f884 3bab 	strb.w	r3, [r4, #2987]	; 0xbab
    }
    715a:	e7e1      	b.n	7120 <EnigmaTMWS::DelegateOutputParam(int)+0x34>
            if (output[output_cursor].type() > 0 || direction > 0)
    715c:	f990 2f8d 	ldrsb.w	r2, [r0, #3981]	; 0xf8d
    byte type() {return ty;}
    7160:	f44f 71a4 	mov.w	r1, #328	; 0x148
    7164:	fb01 0302 	mla	r3, r1, r2, r0
    7168:	f893 3ba9 	ldrb.w	r3, [r3, #2985]	; 0xba9
    716c:	b90b      	cbnz	r3, 7172 <EnigmaTMWS::DelegateOutputParam(int)+0x86>
    716e:	2d00      	cmp	r5, #0
    7170:	ddd6      	ble.n	7120 <EnigmaTMWS::DelegateOutputParam(int)+0x34>
                output[output_cursor].set_type(output[output_cursor].type() + direction);
    7172:	442b      	add	r3, r5
    void set_type(byte type_) {ty = constrain(type_, 0, EnigmaOutputType::GATE);}
    7174:	b2db      	uxtb	r3, r3
    7176:	fb01 4202 	mla	r2, r1, r2, r4
    717a:	2b08      	cmp	r3, #8
    717c:	bf28      	it	cs
    717e:	2308      	movcs	r3, #8
    7180:	f882 3ba9 	strb.w	r3, [r2, #2985]	; 0xba9
    7184:	e7cc      	b.n	7120 <EnigmaTMWS::DelegateOutputParam(int)+0x34>
            if (output[output_cursor].scale() > 0 || direction > 0)
    7186:	f990 6f8d 	ldrsb.w	r6, [r0, #3981]	; 0xf8d
    byte scale() {return sc;}
    718a:	f44f 72a4 	mov.w	r2, #328	; 0x148
    718e:	fb02 0306 	mla	r3, r2, r6, r0
    7192:	f893 3baa 	ldrb.w	r3, [r3, #2986]	; 0xbaa
    7196:	b90b      	cbnz	r3, 719c <EnigmaTMWS::DelegateOutputParam(int)+0xb0>
    7198:	2900      	cmp	r1, #0
    719a:	ddc1      	ble.n	7120 <EnigmaTMWS::DelegateOutputParam(int)+0x34>
        sc = constrain(scale_, 0, OC::Scales::NUM_SCALES - 1);
    719c:	4356      	muls	r6, r2
    719e:	4a0e      	ldr	r2, [pc, #56]	; (71d8 <EnigmaTMWS::DelegateOutputParam(int)+0xec>)
    71a0:	6812      	ldr	r2, [r2, #0]
                output[output_cursor].set_scale(output[output_cursor].scale() + direction);
    71a2:	442b      	add	r3, r5
    71a4:	3a01      	subs	r2, #1
    71a6:	b2db      	uxtb	r3, r3
    71a8:	429a      	cmp	r2, r3
    71aa:	eb04 0706 	add.w	r7, r4, r6
        quantizer.Init();
    71ae:	f606 2668 	addw	r6, r6, #2664	; 0xa68
        sc = constrain(scale_, 0, OC::Scales::NUM_SCALES - 1);
    71b2:	bfa8      	it	ge
    71b4:	461a      	movge	r2, r3
        quantizer.Init();
    71b6:	4426      	add	r6, r4
        sc = constrain(scale_, 0, OC::Scales::NUM_SCALES - 1);
    71b8:	f887 2baa 	strb.w	r2, [r7, #2986]	; 0xbaa
        quantizer.Init();
    71bc:	4630      	mov	r0, r6
    71be:	f7fa f8d1 	bl	1364 <braids::Quantizer::Init()>
        quantizer.Configure(OC::Scales::GetScale(sc), 0xffff);
    71c2:	f897 0baa 	ldrb.w	r0, [r7, #2986]	; 0xbaa
    71c6:	f7f9 fed5 	bl	f74 <OC::Scales::GetScale(int)>
    71ca:	f64f 72ff 	movw	r2, #65535	; 0xffff
    71ce:	4601      	mov	r1, r0
    71d0:	4630      	mov	r0, r6
    71d2:	f7fe ff13 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    }
    71d6:	e7a8      	b.n	712a <EnigmaTMWS::DelegateOutputParam(int)+0x3e>
    71d8:	0001e700 	.word	0x0001e700

000071dc <EnigmaTMWS::DelegateStepParam(int)>:
        if (last_track_step_index > 0) {
    71dc:	f890 33de 	ldrb.w	r3, [r0, #990]	; 0x3de
    71e0:	2b00      	cmp	r3, #0
    71e2:	d078      	beq.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
            if (step_param == ENIGMA_STEP_NUMBER) {
    71e4:	f990 3f91 	ldrsb.w	r3, [r0, #3985]	; 0xf91
    71e8:	2b00      	cmp	r3, #0
    71ea:	d113      	bne.n	7214 <EnigmaTMWS::DelegateStepParam(int)+0x38>
                if (edit_index > 0 || direction > 0) {
    71ec:	f9b0 3f8a 	ldrsh.w	r3, [r0, #3978]	; 0xf8a
    71f0:	2b00      	cmp	r3, #0
    71f2:	dc01      	bgt.n	71f8 <EnigmaTMWS::DelegateStepParam(int)+0x1c>
    71f4:	2900      	cmp	r1, #0
    71f6:	dd6e      	ble.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
                    if (edit_index + direction < 100 && edit_index + direction >= 0)
    71f8:	440b      	add	r3, r1
    71fa:	2b63      	cmp	r3, #99	; 0x63
    71fc:	d86b      	bhi.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
                        if (track_step[edit_index + direction] != ENIGMA_NO_STEP_AVAILABLE) edit_index += direction;
    71fe:	eb00 0243 	add.w	r2, r0, r3, lsl #1
    7202:	f8b2 1314 	ldrh.w	r1, [r2, #788]	; 0x314
    7206:	f64f 72ff 	movw	r2, #65535	; 0xffff
    720a:	4291      	cmp	r1, r2
    720c:	d063      	beq.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
    720e:	f8a0 3f8a 	strh.w	r3, [r0, #3978]	; 0xf8a
    7212:	4770      	bx	lr
            if (step_param > ENIGMA_STEP_NUMBER) {
    7214:	dd5f      	ble.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
                uint16_t ssi = track_step[edit_index]; // song step index
    7216:	f9b0 2f8a 	ldrsh.w	r2, [r0, #3978]	; 0xf8a
    721a:	eb00 0242 	add.w	r2, r0, r2, lsl #1
                if (step_param == ENIGMA_STEP_TM) {
    721e:	2b01      	cmp	r3, #1
                uint16_t ssi = track_step[edit_index]; // song step index
    7220:	f8b2 2314 	ldrh.w	r2, [r2, #788]	; 0x314
                if (step_param == ENIGMA_STEP_TM) {
    7224:	d114      	bne.n	7250 <EnigmaTMWS::DelegateStepParam(int)+0x74>
    7226:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    722a:	f890 3424 	ldrb.w	r3, [r0, #1060]	; 0x424
                    if (song_step[ssi].tm() > 0 || direction > 0)
    722e:	f013 023f 	ands.w	r2, r3, #63	; 0x3f
    7232:	d101      	bne.n	7238 <EnigmaTMWS::DelegateStepParam(int)+0x5c>
    7234:	2900      	cmp	r1, #0
    7236:	dd4e      	ble.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
                        song_step[ssi].set_tm(song_step[ssi].tm() + direction);
    7238:	440a      	add	r2, r1
        tk = (track_ << 6) | (tk & 0x3f);
    }
    void set_tm(byte tm_) {
        if (tm_ > 39) tm_ = 39;
        if (tm_ == 0xff) tm_ = 0;
        tk = (tk & 0xc0) | tm_;
    723a:	b2d2      	uxtb	r2, r2
    723c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    7240:	2a27      	cmp	r2, #39	; 0x27
    7242:	bf94      	ite	ls
    7244:	4313      	orrls	r3, r2
    7246:	f043 0327 	orrhi.w	r3, r3, #39	; 0x27
    724a:	f880 3424 	strb.w	r3, [r0, #1060]	; 0x424
    }
    724e:	4770      	bx	lr
                if (step_param == ENIGMA_STEP_P) {
    7250:	2b02      	cmp	r3, #2
    7252:	d13b      	bne.n	72cc <EnigmaTMWS::DelegateStepParam(int)+0xf0>
    byte p() {return pr;}
    7254:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    7258:	f890 3425 	ldrb.w	r3, [r0, #1061]	; 0x425
                    if (song_step[ssi].p() > 0 || direction > 0)
    725c:	b90b      	cbnz	r3, 7262 <EnigmaTMWS::DelegateStepParam(int)+0x86>
    725e:	2900      	cmp	r1, #0
    7260:	dd39      	ble.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
                        song_step[ssi].set_p(song_step[ssi].p() + direction);
    7262:	440b      	add	r3, r1
    void set_p(byte p_) {
        if (p_ > 100) p_ = 100;
        if (p_ == 0xff) p_ = 0;
        pr = p_;
    7264:	b2db      	uxtb	r3, r3
    7266:	2b64      	cmp	r3, #100	; 0x64
    7268:	bf28      	it	cs
    726a:	2364      	movcs	r3, #100	; 0x64
    726c:	f880 3425 	strb.w	r3, [r0, #1061]	; 0x425
    }
    7270:	4770      	bx	lr
    byte repeats() {return re;}
    7272:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    7276:	f890 3426 	ldrb.w	r3, [r0, #1062]	; 0x426
                    if (song_step[ssi].repeats() > 0 || direction > 0)
    727a:	b90b      	cbnz	r3, 7280 <EnigmaTMWS::DelegateStepParam(int)+0xa4>
    727c:	2900      	cmp	r1, #0
    727e:	dd2a      	ble.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
                        song_step[ssi].set_repeats(song_step[ssi].repeats() + direction);
    7280:	440b      	add	r3, r1
    void set_repeats(byte repeats_) {
        repeats_ = constrain(repeats_, 1, 99);
    7282:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
    7286:	d005      	beq.n	7294 <EnigmaTMWS::DelegateStepParam(int)+0xb8>
    7288:	2b63      	cmp	r3, #99	; 0x63
    728a:	bfa8      	it	ge
    728c:	2363      	movge	r3, #99	; 0x63
    728e:	f880 3426 	strb.w	r3, [r0, #1062]	; 0x426
        re = repeats_;
    }
    7292:	4770      	bx	lr
        repeats_ = constrain(repeats_, 1, 99);
    7294:	2301      	movs	r3, #1
    7296:	e7fa      	b.n	728e <EnigmaTMWS::DelegateStepParam(int)+0xb2>
    int8_t transpose() {return static_cast<int8_t>(tr - 48);}
    7298:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    729c:	f890 2427 	ldrb.w	r2, [r0, #1063]	; 0x427
    72a0:	3a30      	subs	r2, #48	; 0x30
    72a2:	b2d3      	uxtb	r3, r2
                    if (song_step[ssi].transpose() > -48 || direction > 0)
    72a4:	b252      	sxtb	r2, r2
    72a6:	322f      	adds	r2, #47	; 0x2f
    72a8:	da01      	bge.n	72ae <EnigmaTMWS::DelegateStepParam(int)+0xd2>
    72aa:	2900      	cmp	r1, #0
    72ac:	dd13      	ble.n	72d6 <EnigmaTMWS::DelegateStepParam(int)+0xfa>
                        song_step[ssi].set_transpose(song_step[ssi].transpose() + direction);
    72ae:	440b      	add	r3, r1
    72b0:	b25b      	sxtb	r3, r3
    void set_transpose(int8_t transpose_) {
        transpose_ = constrain(transpose_, -48, 48);
    72b2:	f113 0f30 	cmn.w	r3, #48	; 0x30
    72b6:	db06      	blt.n	72c6 <EnigmaTMWS::DelegateStepParam(int)+0xea>
    72b8:	2b30      	cmp	r3, #48	; 0x30
    72ba:	bfa8      	it	ge
    72bc:	2330      	movge	r3, #48	; 0x30
        tr = static_cast<byte>(transpose_ + 48);
    72be:	3330      	adds	r3, #48	; 0x30
    72c0:	f880 3427 	strb.w	r3, [r0, #1063]	; 0x427
    }
    72c4:	4770      	bx	lr
        transpose_ = constrain(transpose_, -48, 48);
    72c6:	f06f 032f 	mvn.w	r3, #47	; 0x2f
    72ca:	e7f8      	b.n	72be <EnigmaTMWS::DelegateStepParam(int)+0xe2>
                if (step_param == ENIGMA_STEP_REPEATS) {
    72cc:	2b03      	cmp	r3, #3
    72ce:	d0d0      	beq.n	7272 <EnigmaTMWS::DelegateStepParam(int)+0x96>
                if (step_param == ENIGMA_STEP_TRANSPOSE) {
    72d0:	2b04      	cmp	r3, #4
    72d2:	d0e1      	beq.n	7298 <EnigmaTMWS::DelegateStepParam(int)+0xbc>
    72d4:	4770      	bx	lr
    }
    72d6:	4770      	bx	lr

000072d8 <EnigmaTMWS::BuildTrackStepList(unsigned char)>:
    void BuildTrackStepList(byte track) {
    72d8:	b4f0      	push	{r4, r5, r6, r7}
        for (uint16_t ix = 0; ix < total_steps; ix++)
    72da:	2400      	movs	r4, #0
    72dc:	f8b0 63dc 	ldrh.w	r6, [r0, #988]	; 0x3dc
        byte ts_ix = 0;
    72e0:	4622      	mov	r2, r4
    byte track() {return (tk >> 6) & 0x03;} // High two bits
    72e2:	f200 4724 	addw	r7, r0, #1060	; 0x424
    72e6:	b2a5      	uxth	r5, r4
        for (uint16_t ix = 0; ix < total_steps; ix++)
    72e8:	42ae      	cmp	r6, r5
    72ea:	d821      	bhi.n	7330 <EnigmaTMWS::BuildTrackStepList(unsigned char)+0x58>
    72ec:	4613      	mov	r3, r2
        if (edit_index >= last_track_step_index) edit_index = last_track_step_index - 1;
    72ee:	f9b0 2f8a 	ldrsh.w	r2, [r0, #3978]	; 0xf8a
        last_track_step_index = ts_ix;
    72f2:	f880 33de 	strb.w	r3, [r0, #990]	; 0x3de
        if (edit_index >= last_track_step_index) edit_index = last_track_step_index - 1;
    72f6:	429a      	cmp	r2, r3
    72f8:	bfa4      	itt	ge
    72fa:	f103 32ff 	addge.w	r2, r3, #4294967295	; 0xffffffff
    72fe:	f8a0 2f8a 	strhge.w	r2, [r0, #3978]	; 0xf8a
        if (edit_index < 0) edit_index = 0;
    7302:	f9b0 2f8a 	ldrsh.w	r2, [r0, #3978]	; 0xf8a
    7306:	2a00      	cmp	r2, #0
    7308:	bfbc      	itt	lt
    730a:	2200      	movlt	r2, #0
    730c:	f8a0 2f8a 	strhlt.w	r2, [r0, #3978]	; 0xf8a
        while (ts_ix < 100) track_step[ts_ix++] = ENIGMA_NO_STEP_AVAILABLE;
    7310:	f1c3 0264 	rsb	r2, r3, #100	; 0x64
    7314:	2b64      	cmp	r3, #100	; 0x64
    7316:	b2d2      	uxtb	r2, r2
    7318:	f503 73c5 	add.w	r3, r3, #394	; 0x18a
    731c:	ea4f 0242 	mov.w	r2, r2, lsl #1
    }
    7320:	bcf0      	pop	{r4, r5, r6, r7}
        while (ts_ix < 100) track_step[ts_ix++] = ENIGMA_NO_STEP_AVAILABLE;
    7322:	bf88      	it	hi
    7324:	2200      	movhi	r2, #0
    7326:	21ff      	movs	r1, #255	; 0xff
    7328:	eb00 0043 	add.w	r0, r0, r3, lsl #1
    732c:	f012 bf34 	b.w	1a198 <memset>
    7330:	f817 3024 	ldrb.w	r3, [r7, r4, lsl #2]
            if (song_step[ix].track() == track) {
    7334:	ebb1 1f93 	cmp.w	r1, r3, lsr #6
    7338:	d108      	bne.n	734c <EnigmaTMWS::BuildTrackStepList(unsigned char)+0x74>
                track_step[ts_ix++] = ix;
    733a:	1c53      	adds	r3, r2, #1
    733c:	b2db      	uxtb	r3, r3
    733e:	eb00 0242 	add.w	r2, r0, r2, lsl #1
                if (ts_ix > 99) break;
    7342:	2b63      	cmp	r3, #99	; 0x63
                track_step[ts_ix++] = ix;
    7344:	f8a2 5314 	strh.w	r5, [r2, #788]	; 0x314
                if (ts_ix > 99) break;
    7348:	d8d1      	bhi.n	72ee <EnigmaTMWS::BuildTrackStepList(unsigned char)+0x16>
    734a:	461a      	mov	r2, r3
        for (uint16_t ix = 0; ix < total_steps; ix++)
    734c:	3401      	adds	r4, #1
    734e:	e7ca      	b.n	72e6 <EnigmaTMWS::BuildTrackStepList(unsigned char)+0xe>

00007350 <EnigmaTMWS::Resume()>:
	void Resume() {
    7350:	b538      	push	{r3, r4, r5, lr}
    7352:	4604      	mov	r4, r0
	    SwitchTuringMachine(tm_cursor);
    7354:	f890 1f8c 	ldrb.w	r1, [r0, #3980]	; 0xf8c
    7358:	f7ff fe6c 	bl	7034 <EnigmaTMWS::SwitchTuringMachine(unsigned char)>
        for (byte o = 0; o < 4; o++)
    735c:	4622      	mov	r2, r4
    735e:	f504 60a4 	add.w	r0, r4, #1312	; 0x520
	    SwitchTuringMachine(tm_cursor);
    7362:	4623      	mov	r3, r4
    7364:	4621      	mov	r1, r4
            output[o].tk = values_[ix++];
    7366:	f8d1 5088 	ldr.w	r5, [r1, #136]	; 0x88
    736a:	f883 5ba8 	strb.w	r5, [r3, #2984]	; 0xba8
            output[o].ty = values_[ix++];
    736e:	f8d1 508c 	ldr.w	r5, [r1, #140]	; 0x8c
    7372:	f883 5ba9 	strb.w	r5, [r3, #2985]	; 0xba9
            output[o].sc = values_[ix++];
    7376:	f8d1 5090 	ldr.w	r5, [r1, #144]	; 0x90
    737a:	f883 5baa 	strb.w	r5, [r3, #2986]	; 0xbaa
            output[o].mc = values_[ix++];
    737e:	f8d1 5094 	ldr.w	r5, [r1, #148]	; 0x94
    7382:	f883 5bab 	strb.w	r5, [r3, #2987]	; 0xbab
        for (byte o = 0; o < 4; o++)
    7386:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    738a:	4283      	cmp	r3, r0
    738c:	f101 0110 	add.w	r1, r1, #16
    7390:	d1e9      	bne.n	7366 <EnigmaTMWS::Resume()+0x16>
        if (song_steps > total_steps) total_steps = song_steps;
    7392:	f8b4 33dc 	ldrh.w	r3, [r4, #988]	; 0x3dc
        byte song_steps = values_[ix++];
    7396:	f894 10c8 	ldrb.w	r1, [r4, #200]	; 0xc8
        if (song_steps > total_steps) total_steps = song_steps;
    739a:	4299      	cmp	r1, r3
    739c:	bfc8      	it	gt
    739e:	f8a4 13dc 	strhgt.w	r1, [r4, #988]	; 0x3dc
    73a2:	f104 0080 	add.w	r0, r4, #128	; 0x80
	    SwitchTuringMachine(tm_cursor);
    73a6:	4623      	mov	r3, r4
            song_step[s].tk = values_[ix++];
    73a8:	f8d2 50cc 	ldr.w	r5, [r2, #204]	; 0xcc
    73ac:	f883 5424 	strb.w	r5, [r3, #1060]	; 0x424
            song_step[s].pr = values_[ix++];
    73b0:	f8d2 50d0 	ldr.w	r5, [r2, #208]	; 0xd0
    73b4:	f883 5425 	strb.w	r5, [r3, #1061]	; 0x425
            song_step[s].re = values_[ix++];
    73b8:	f8d2 50d4 	ldr.w	r5, [r2, #212]	; 0xd4
    73bc:	f883 5426 	strb.w	r5, [r3, #1062]	; 0x426
            song_step[s].tr = values_[ix++];
    73c0:	f8d2 50d8 	ldr.w	r5, [r2, #216]	; 0xd8
    73c4:	f883 5427 	strb.w	r5, [r3, #1063]	; 0x427
        for (byte s = 0; s < 32; s++)
    73c8:	3304      	adds	r3, #4
    73ca:	4283      	cmp	r3, r0
    73cc:	f102 0210 	add.w	r2, r2, #16
    73d0:	d1ea      	bne.n	73a8 <EnigmaTMWS::Resume()+0x58>
    73d2:	f604 7083 	addw	r0, r4, #3971	; 0xf83
            song_step[s].tr = values_[ix++];
    73d6:	2391      	movs	r3, #145	; 0x91
        for (byte t = 0; t < 4; t++) track[t].data = values_[ix++];
    73d8:	461a      	mov	r2, r3
    73da:	3222      	adds	r2, #34	; 0x22
    73dc:	3301      	adds	r3, #1
    73de:	b2db      	uxtb	r3, r3
    73e0:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
    73e4:	f800 2f01 	strb.w	r2, [r0, #1]!
    73e8:	2b95      	cmp	r3, #149	; 0x95
    73ea:	d1f5      	bne.n	73d8 <EnigmaTMWS::Resume()+0x88>
        if (song_steps == 0) Start();
    73ec:	b949      	cbnz	r1, 7402 <EnigmaTMWS::Resume()+0xb2>
    73ee:	6823      	ldr	r3, [r4, #0]
    73f0:	4620      	mov	r0, r4
    73f2:	681b      	ldr	r3, [r3, #0]
    73f4:	4798      	blx	r3
        track_cursor = 0;
    73f6:	2300      	movs	r3, #0
    73f8:	f884 3f8e 	strb.w	r3, [r4, #3982]	; 0xf8e
        edit_index = 0;
    73fc:	f8a4 3f8a 	strh.w	r3, [r4, #3978]	; 0xf8a
	}
    7400:	bd38      	pop	{r3, r4, r5, pc}
        else BuildTrackStepList(0);
    7402:	2100      	movs	r1, #0
    7404:	4620      	mov	r0, r4
    7406:	f7ff ff67 	bl	72d8 <EnigmaTMWS::BuildTrackStepList(unsigned char)>
    740a:	e7f4      	b.n	73f6 <EnigmaTMWS::Resume()+0xa6>

0000740c <EnigmaTMWS::InsertStep()>:
    void InsertStep() {
    740c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (last_track_step_index < 99) {
    740e:	f890 33de 	ldrb.w	r3, [r0, #990]	; 0x3de
    7412:	2b62      	cmp	r3, #98	; 0x62
    void InsertStep() {
    7414:	4604      	mov	r4, r0
        if (last_track_step_index < 99) {
    7416:	d855      	bhi.n	74c4 <EnigmaTMWS::InsertStep()+0xb8>
            uint16_t insert_point = track_step[edit_index] + 1;
    7418:	f9b0 3f8a 	ldrsh.w	r3, [r0, #3978]	; 0xf8a
    741c:	eb00 0343 	add.w	r3, r0, r3, lsl #1
            if (insert_point < total_steps) {
    7420:	f8b0 03dc 	ldrh.w	r0, [r0, #988]	; 0x3dc
            uint16_t insert_point = track_step[edit_index] + 1;
    7424:	f8b3 5314 	ldrh.w	r5, [r3, #788]	; 0x314
    7428:	3501      	adds	r5, #1
    742a:	b2ad      	uxth	r5, r5
            if (insert_point < total_steps) {
    742c:	42a8      	cmp	r0, r5
    742e:	d84a      	bhi.n	74c6 <EnigmaTMWS::InsertStep()+0xba>
        tk = (track_ << 6) | (tk & 0x3f);
    7430:	eb04 0585 	add.w	r5, r4, r5, lsl #2
    7434:	f894 2f8e 	ldrb.w	r2, [r4, #3982]	; 0xf8e
    7438:	f895 3424 	ldrb.w	r3, [r5, #1060]	; 0x424
    byte PickTM() {
        byte tm = 0; // Default of A-1

        // Number of favorites
        byte favorites = 0;
        for (byte i = 0; i < HS::TURING_MACHINE_COUNT; i++) favorites += HS::user_turing_machines[i].favorite;
    743c:	4e2a      	ldr	r6, [pc, #168]	; (74e8 <EnigmaTMWS::InsertStep()+0xdc>)
        tk = (track_ << 6) | (tk & 0x3f);
    743e:	2a03      	cmp	r2, #3
    7440:	bf28      	it	cs
    7442:	2203      	movcs	r2, #3
    7444:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    7448:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    744c:	f885 3424 	strb.w	r3, [r5, #1060]	; 0x424
    7450:	2300      	movs	r3, #0
        byte favorites = 0;
    7452:	4619      	mov	r1, r3
        for (byte i = 0; i < HS::TURING_MACHINE_COUNT; i++) favorites += HS::user_turing_machines[i].favorite;
    7454:	eb06 0283 	add.w	r2, r6, r3, lsl #2
    7458:	3301      	adds	r3, #1
    745a:	78d2      	ldrb	r2, [r2, #3]
    745c:	2b28      	cmp	r3, #40	; 0x28
    745e:	4411      	add	r1, r2
    7460:	b2c9      	uxtb	r1, r1
    7462:	d1f7      	bne.n	7454 <EnigmaTMWS::InsertStep()+0x48>

        if (favorites > 0) {
    7464:	b181      	cbz	r1, 7488 <EnigmaTMWS::InsertStep()+0x7c>
            byte pick = random(0, favorites);
    7466:	2000      	movs	r0, #0
    7468:	f012 fd41 	bl	19eee <random(long, long)>
    746c:	2300      	movs	r3, #0
    746e:	b2c0      	uxtb	r0, r0
            favorites = 0;
    7470:	461a      	mov	r2, r3
            for (byte i = 0; i < HS::TURING_MACHINE_COUNT; i++)
            {
                favorites += HS::user_turing_machines[i].favorite;
    7472:	eb06 0783 	add.w	r7, r6, r3, lsl #2
    7476:	b2d9      	uxtb	r1, r3
    7478:	78ff      	ldrb	r7, [r7, #3]
    747a:	443a      	add	r2, r7
    747c:	b2d2      	uxtb	r2, r2
                if (favorites == pick) {
    747e:	4290      	cmp	r0, r2
    7480:	d003      	beq.n	748a <EnigmaTMWS::InsertStep()+0x7e>
            for (byte i = 0; i < HS::TURING_MACHINE_COUNT; i++)
    7482:	3301      	adds	r3, #1
    7484:	2b28      	cmp	r3, #40	; 0x28
    7486:	d1f4      	bne.n	7472 <EnigmaTMWS::InsertStep()+0x66>
        byte tm = 0; // Default of A-1
    7488:	2100      	movs	r1, #0
        tk = (tk & 0xc0) | tm_;
    748a:	f895 3424 	ldrb.w	r3, [r5, #1060]	; 0x424
    748e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    7492:	4319      	orrs	r1, r3
        pr = p_;
    7494:	2300      	movs	r3, #0
    7496:	f885 3425 	strb.w	r3, [r5, #1061]	; 0x425
        re = repeats_;
    749a:	f243 0301 	movw	r3, #12289	; 0x3001
    749e:	f8a5 3426 	strh.w	r3, [r5, #1062]	; 0x426
            total_steps++;
    74a2:	f8b4 33dc 	ldrh.w	r3, [r4, #988]	; 0x3dc
        tk = (tk & 0xc0) | tm_;
    74a6:	f885 1424 	strb.w	r1, [r5, #1060]	; 0x424
    74aa:	3301      	adds	r3, #1
    74ac:	f8a4 33dc 	strh.w	r3, [r4, #988]	; 0x3dc
            edit_index++;
    74b0:	f8b4 3f8a 	ldrh.w	r3, [r4, #3978]	; 0xf8a
            BuildTrackStepList(track_cursor);
    74b4:	f894 1f8e 	ldrb.w	r1, [r4, #3982]	; 0xf8e
            edit_index++;
    74b8:	3301      	adds	r3, #1
    74ba:	f8a4 3f8a 	strh.w	r3, [r4, #3978]	; 0xf8a
            BuildTrackStepList(track_cursor);
    74be:	4620      	mov	r0, r4
    74c0:	f7ff ff0a 	bl	72d8 <EnigmaTMWS::BuildTrackStepList(unsigned char)>
    }
    74c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                for (int i = total_steps + 1; i > insert_point; i--)
    74c6:	1c46      	adds	r6, r0, #1
    74c8:	f500 7085 	add.w	r0, r0, #266	; 0x10a
    74cc:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    74d0:	42b5      	cmp	r5, r6
    74d2:	f1a0 0704 	sub.w	r7, r0, #4
    74d6:	daab      	bge.n	7430 <EnigmaTMWS::InsertStep()+0x24>
                    memcpy(&song_step[i], &song_step[i - 1], sizeof(song_step[i - 1]));
    74d8:	2204      	movs	r2, #4
    74da:	4639      	mov	r1, r7
    74dc:	f012 fd88 	bl	19ff0 <memcpy>
    74e0:	3e01      	subs	r6, #1
    74e2:	4638      	mov	r0, r7
    74e4:	e7f4      	b.n	74d0 <EnigmaTMWS::InsertStep()+0xc4>
    74e6:	bf00      	nop
    74e8:	200036e8 	.word	0x200036e8

000074ec <EnigmaTMWS::ResetSong()>:
    void ResetSong() {
    74ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        clock_counter = 0;
    74f0:	2300      	movs	r3, #0
    74f2:	f200 38f3 	addw	r8, r0, #1011	; 0x3f3
    void ResetSong() {
    74f6:	4604      	mov	r4, r0
        clock_counter = 0;
    74f8:	f8c0 33e8 	str.w	r3, [r0, #1000]	; 0x3e8
        for (byte t = 0; t < 4; t++)
    74fc:	4605      	mov	r5, r0
    74fe:	f200 37ea 	addw	r7, r0, #1002	; 0x3ea
    7502:	f200 39f2 	addw	r9, r0, #1010	; 0x3f2
        clock_counter = 0;
    7506:	4646      	mov	r6, r8
    byte track() {return (tk >> 6) & 0x03;} // High two bits
    7508:	f200 4a24 	addw	sl, r0, #1060	; 0x424
            if (song_step[s].track() == track) {
    750c:	eba6 0108 	sub.w	r1, r6, r8
        for (uint16_t s = 0; s < total_steps; s++)
    7510:	f8b4 03dc 	ldrh.w	r0, [r4, #988]	; 0x3dc
    7514:	2300      	movs	r3, #0
            if (song_step[s].track() == track) {
    7516:	b2c9      	uxtb	r1, r1
    7518:	b29a      	uxth	r2, r3
        for (uint16_t s = 0; s < total_steps; s++)
    751a:	4290      	cmp	r0, r2
    751c:	d802      	bhi.n	7524 <EnigmaTMWS::ResetSong()+0x38>
        uint16_t step = ENIGMA_NO_STEP_AVAILABLE;
    751e:	f64f 72ff 	movw	r2, #65535	; 0xffff
    7522:	e006      	b.n	7532 <EnigmaTMWS::ResetSong()+0x46>
    7524:	f81a c023 	ldrb.w	ip, [sl, r3, lsl #2]
            if (song_step[s].track() == track) {
    7528:	ebb1 1f9c 	cmp.w	r1, ip, lsr #6
    752c:	f103 0301 	add.w	r3, r3, #1
    7530:	d1f2      	bne.n	7518 <EnigmaTMWS::ResetSong()+0x2c>
            playback_step_number[t] = 0;
    7532:	2300      	movs	r3, #0
            playback_step_index[t] = GetFirstStep(t);
    7534:	f827 2f02 	strh.w	r2, [r7, #2]!
            playback_step_number[t] = 0;
    7538:	f806 3f01 	strb.w	r3, [r6, #1]!
            playback_step_repeat[t] = 0;
    753c:	7133      	strb	r3, [r6, #4]
            playback_step_beat[t] = 0;
    753e:	7233      	strb	r3, [r6, #8]
            playback_end[t] = 0;
    7540:	7333      	strb	r3, [r6, #12]
    byte midi_channel() {return mc;}
    7542:	f895 3bab 	ldrb.w	r3, [r5, #2987]	; 0xbab

    void NoteOff() {
        if (midi_channel()) {
    7546:	b1bb      	cbz	r3, 7578 <EnigmaTMWS::ResetSong()+0x8c>
            if (last_note > -1) usbMIDI.sendNoteOn(last_note, 0, midi_channel());
    7548:	f8d5 2ba0 	ldr.w	r2, [r5, #2976]	; 0xba0
    754c:	2a00      	cmp	r2, #0
    754e:	db0d      	blt.n	756c <EnigmaTMWS::ResetSong()+0x80>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
    7550:	3b01      	subs	r3, #1
    7552:	021b      	lsls	r3, r3, #8
    7554:	0412      	lsls	r2, r2, #16
    7556:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
    755a:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
    755e:	4313      	orrs	r3, r2
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
    7560:	f443 4010 	orr.w	r0, r3, #36864	; 0x9000
    7564:	f040 0009 	orr.w	r0, r0, #9
    7568:	f013 fc20 	bl	1adac <usb_midi_write_packed>
            last_note = -1;
    756c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7570:	f8c5 3ba0 	str.w	r3, [r5, #2976]	; 0xba0
            deferred_note = -1;
    7574:	f8c5 3ba4 	str.w	r3, [r5, #2980]	; 0xba4
        for (byte t = 0; t < 4; t++)
    7578:	454f      	cmp	r7, r9
    757a:	f505 75a4 	add.w	r5, r5, #328	; 0x148
    757e:	d1c5      	bne.n	750c <EnigmaTMWS::ResetSong()+0x20>
    }
    7580:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007584 <EnigmaTMWS::Start()>:
	void Start() {
    7584:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7588:	4604      	mov	r4, r0
	    for (byte ix = 0; ix < HS::TURING_MACHINE_COUNT; ix++) state_prob[ix] = 0;
    758a:	2228      	movs	r2, #40	; 0x28
    758c:	2100      	movs	r1, #0
	    tm_cursor = 0;
    758e:	2500      	movs	r5, #0
	    for (byte ix = 0; ix < HS::TURING_MACHINE_COUNT; ix++) state_prob[ix] = 0;
    7590:	f200 20ea 	addw	r0, r0, #746	; 0x2ea
    7594:	f012 fe00 	bl	1a198 <memset>
	    tm_cursor = 0;
    7598:	f884 5f8c 	strb.w	r5, [r4, #3980]	; 0xf8c
	    SwitchTuringMachine(0);
    759c:	4629      	mov	r1, r5
    759e:	4620      	mov	r0, r4
    75a0:	f7ff fd48 	bl	7034 <EnigmaTMWS::SwitchTuringMachine(unsigned char)>
	    for (byte o = 0; o < 4; o++)
    75a4:	f604 2764 	addw	r7, r4, #2660	; 0xa64
    75a8:	f604 7883 	addw	r8, r4, #3971	; 0xf83
    75ac:	b2ee      	uxtb	r6, r5
	        output[o].InitAs(o);
    75ae:	4631      	mov	r1, r6
    75b0:	4638      	mov	r0, r7
	    for (byte o = 0; o < 4; o++)
    75b2:	3501      	adds	r5, #1
	        output[o].InitAs(o);
    75b4:	f7fe ff56 	bl	6464 <EnigmaOutput::InitAs(unsigned char)>
        data = data & (0xff - 0x1f); // Clear first five bits
        data = data | divide_;
    }
    void set_loop(bool loop_) {
        if (loop_) data = data | 0x20;
        else data = data & (0xff - 0x20); // Clear bit 5
    75b8:	01b6      	lsls	r6, r6, #6
    }
    void set_track(byte track_) {
        track_ = constrain(track_, 0, 3);
        data = data & (0xff - (0x03 << 6));
    75ba:	f818 3f01 	ldrb.w	r3, [r8, #1]!
        else data = data & (0xff - 0x20); // Clear bit 5
    75be:	f888 6000 	strb.w	r6, [r8]
	    for (byte o = 0; o < 4; o++)
    75c2:	2d04      	cmp	r5, #4
    75c4:	f507 77a4 	add.w	r7, r7, #328	; 0x148
    75c8:	d1f0      	bne.n	75ac <EnigmaTMWS::Start()+0x28>
	    ResetSong();
    75ca:	4620      	mov	r0, r4
    75cc:	f7ff ff8e 	bl	74ec <EnigmaTMWS::ResetSong()>
	    BuildTrackStepList(0);
    75d0:	2100      	movs	r1, #0
    75d2:	4620      	mov	r0, r4
    75d4:	f7ff fe80 	bl	72d8 <EnigmaTMWS::BuildTrackStepList(unsigned char)>
	}
    75d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000075dc <EnigmaTMWS::DismissHelp()>:
        uint16_t help_seen_for = help_time - help_countdown;
    75dc:	f8b0 23e0 	ldrh.w	r2, [r0, #992]	; 0x3e0
    75e0:	f8b0 33e2 	ldrh.w	r3, [r0, #994]	; 0x3e2
    75e4:	1a9b      	subs	r3, r3, r2
    75e6:	b29b      	uxth	r3, r3
        if (help_time < 16667) help_time = 0; // If dismissed within 1 second, stop showing help
    75e8:	f244 121a 	movw	r2, #16666	; 0x411a
    75ec:	4293      	cmp	r3, r2
    75ee:	bf98      	it	ls
    75f0:	2300      	movls	r3, #0
    75f2:	f8a0 33e2 	strh.w	r3, [r0, #994]	; 0x3e2
        help_countdown = 0;
    75f6:	2300      	movs	r3, #0
    75f8:	f8a0 33e0 	strh.w	r3, [r0, #992]	; 0x3e0
    }
    75fc:	4770      	bx	lr
    75fe:	Address 0x00000000000075fe is out of bounds.


00007600 <EnigmaTMWS::OnDownButtonPress()>:
        if (help_countdown) DismissHelp();
    7600:	f8b0 33e0 	ldrh.w	r3, [r0, #992]	; 0x3e0
    void OnDownButtonPress() {
    7604:	b570      	push	{r4, r5, r6, lr}
    7606:	4604      	mov	r4, r0
        if (help_countdown) DismissHelp();
    7608:	b113      	cbz	r3, 7610 <EnigmaTMWS::OnDownButtonPress()+0x10>
    760a:	f7ff ffe7 	bl	75dc <EnigmaTMWS::DismissHelp()>
    }
    760e:	bd70      	pop	{r4, r5, r6, pc}
            if (mode == ENIGMA_MODE_LIBRARY) tm_state.Reset();
    7610:	f890 3f88 	ldrb.w	r3, [r0, #3976]	; 0xf88
    7614:	b93b      	cbnz	r3, 7626 <EnigmaTMWS::OnDownButtonPress()+0x26>
        reg = HS::user_turing_machines[ix].reg;
    7616:	f890 22e2 	ldrb.w	r2, [r0, #738]	; 0x2e2
    761a:	4b20      	ldr	r3, [pc, #128]	; (769c <EnigmaTMWS::OnDownButtonPress()+0x9c>)
    761c:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
    7620:	f8a0 32e4 	strh.w	r3, [r0, #740]	; 0x2e4
            if (mode == ENIGMA_MODE_PLAY) ResetSong();
    7624:	e7f3      	b.n	760e <EnigmaTMWS::OnDownButtonPress()+0xe>
            if (mode == ENIGMA_MODE_ASSIGN) assign_audition = 1;
    7626:	2b01      	cmp	r3, #1
    7628:	d009      	beq.n	763e <EnigmaTMWS::OnDownButtonPress()+0x3e>
            if (mode == ENIGMA_MODE_SONG) DeleteStep();
    762a:	2b02      	cmp	r3, #2
    762c:	d00a      	beq.n	7644 <EnigmaTMWS::OnDownButtonPress()+0x44>
            if (mode == ENIGMA_MODE_PLAY) ResetSong();
    762e:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7632:	2b03      	cmp	r3, #3
    7634:	d1eb      	bne.n	760e <EnigmaTMWS::OnDownButtonPress()+0xe>
    7636:	4620      	mov	r0, r4
    7638:	f7ff ff58 	bl	74ec <EnigmaTMWS::ResetSong()>
    }
    763c:	e7e7      	b.n	760e <EnigmaTMWS::OnDownButtonPress()+0xe>
            if (mode == ENIGMA_MODE_ASSIGN) assign_audition = 1;
    763e:	f880 3312 	strb.w	r3, [r0, #786]	; 0x312
            if (mode == ENIGMA_MODE_SONG) DeleteStep();
    7642:	e7e4      	b.n	760e <EnigmaTMWS::OnDownButtonPress()+0xe>
        if (last_track_step_index > 0) { // Can't delete if there are no steps
    7644:	f890 23de 	ldrb.w	r2, [r0, #990]	; 0x3de
    7648:	2a00      	cmp	r2, #0
    764a:	d0e0      	beq.n	760e <EnigmaTMWS::OnDownButtonPress()+0xe>
            if (edit_index == last_track_step_index) edit_index--;
    764c:	f9b0 3f8a 	ldrsh.w	r3, [r0, #3978]	; 0xf8a
    7650:	4293      	cmp	r3, r2
    7652:	bf04      	itt	eq
    7654:	f103 33ff 	addeq.w	r3, r3, #4294967295	; 0xffffffff
    7658:	f8a0 3f8a 	strheq.w	r3, [r0, #3978]	; 0xf8a
            uint16_t mark_to_delete = track_step[edit_index];
    765c:	f9b0 3f8a 	ldrsh.w	r3, [r0, #3978]	; 0xf8a
    7660:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    7664:	f8b3 5314 	ldrh.w	r5, [r3, #788]	; 0x314
            for (int i = mark_to_delete; i < total_steps; i++)
    7668:	f205 1009 	addw	r0, r5, #265	; 0x109
    766c:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    7670:	f8b4 33dc 	ldrh.w	r3, [r4, #988]	; 0x3dc
    7674:	429d      	cmp	r5, r3
    7676:	f100 0604 	add.w	r6, r0, #4
    767a:	db08      	blt.n	768e <EnigmaTMWS::OnDownButtonPress()+0x8e>
            total_steps--;
    767c:	3b01      	subs	r3, #1
            BuildTrackStepList(track_cursor);
    767e:	f894 1f8e 	ldrb.w	r1, [r4, #3982]	; 0xf8e
            total_steps--;
    7682:	f8a4 33dc 	strh.w	r3, [r4, #988]	; 0x3dc
            BuildTrackStepList(track_cursor);
    7686:	4620      	mov	r0, r4
    7688:	f7ff fe26 	bl	72d8 <EnigmaTMWS::BuildTrackStepList(unsigned char)>
    }
    768c:	e7cf      	b.n	762e <EnigmaTMWS::OnDownButtonPress()+0x2e>
                memcpy(&song_step[i], &song_step[i + 1], sizeof(song_step[i + 1]));
    768e:	2204      	movs	r2, #4
    7690:	4631      	mov	r1, r6
    7692:	f012 fcad 	bl	19ff0 <memcpy>
    7696:	3501      	adds	r5, #1
    7698:	4630      	mov	r0, r6
    769a:	e7e9      	b.n	7670 <EnigmaTMWS::OnDownButtonPress()+0x70>
    769c:	200036e8 	.word	0x200036e8

000076a0 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)>:
    }
}

void EnigmaTMWS_handleEncoderEvent(const UI::Event &event) {
    // Left encoder turned
    if (event.control == OC::CONTROL_ENCODER_L) EnigmaTMWS_instance.OnLeftEncoderMove(event.value);
    76a0:	8843      	ldrh	r3, [r0, #2]
    76a2:	2b20      	cmp	r3, #32
void EnigmaTMWS_handleEncoderEvent(const UI::Event &event) {
    76a4:	b570      	push	{r4, r5, r6, lr}
    76a6:	4605      	mov	r5, r0
    if (event.control == OC::CONTROL_ENCODER_L) EnigmaTMWS_instance.OnLeftEncoderMove(event.value);
    76a8:	d108      	bne.n	76bc <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x1c>
        if (help_countdown) DismissHelp();
    76aa:	4c4b      	ldr	r4, [pc, #300]	; (77d8 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x138>)
    if (event.control == OC::CONTROL_ENCODER_L) EnigmaTMWS_instance.OnLeftEncoderMove(event.value);
    76ac:	f9b0 6004 	ldrsh.w	r6, [r0, #4]
        if (help_countdown) DismissHelp();
    76b0:	f8b4 33e0 	ldrh.w	r3, [r4, #992]	; 0x3e0
    76b4:	b183      	cbz	r3, 76d8 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x38>
    76b6:	4620      	mov	r0, r4
    76b8:	f7ff ff90 	bl	75dc <EnigmaTMWS::DismissHelp()>

    // Right encoder turned
    if (event.control == OC::CONTROL_ENCODER_R) EnigmaTMWS_instance.OnRightEncoderMove(event.value);
    76bc:	886b      	ldrh	r3, [r5, #2]
    76be:	2b40      	cmp	r3, #64	; 0x40
    76c0:	d109      	bne.n	76d6 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x36>
        if (help_countdown) DismissHelp();
    76c2:	4c45      	ldr	r4, [pc, #276]	; (77d8 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x138>)
    76c4:	f9b5 1004 	ldrsh.w	r1, [r5, #4]
    76c8:	f8b4 33e0 	ldrh.w	r3, [r4, #992]	; 0x3e0
    76cc:	2b00      	cmp	r3, #0
    76ce:	d03f      	beq.n	7750 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xb0>
    76d0:	4620      	mov	r0, r4
    76d2:	f7ff ff83 	bl	75dc <EnigmaTMWS::DismissHelp()>
}
    76d6:	bd70      	pop	{r4, r5, r6, pc}
            if (mode == ENIGMA_MODE_LIBRARY) {
    76d8:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    76dc:	b973      	cbnz	r3, 76fc <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x5c>
                tm_cursor += direction;
    76de:	f894 1f8c 	ldrb.w	r1, [r4, #3980]	; 0xf8c
    76e2:	4431      	add	r1, r6
    76e4:	b249      	sxtb	r1, r1
                if (tm_cursor < 0) tm_cursor = HS::TURING_MACHINE_COUNT - 1;
    76e6:	2900      	cmp	r1, #0
    76e8:	db18      	blt.n	771c <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x7c>
                if (tm_cursor >= HS::TURING_MACHINE_COUNT) tm_cursor = 0;
    76ea:	2928      	cmp	r1, #40	; 0x28
    76ec:	bfa8      	it	ge
    76ee:	2100      	movge	r1, #0
    76f0:	f884 1f8c 	strb.w	r1, [r4, #3980]	; 0xf8c
                SwitchTuringMachine(tm_cursor);
    76f4:	4838      	ldr	r0, [pc, #224]	; (77d8 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x138>)
    76f6:	b2c9      	uxtb	r1, r1
    76f8:	f7ff fc9c 	bl	7034 <EnigmaTMWS::SwitchTuringMachine(unsigned char)>
            if (mode == ENIGMA_MODE_ASSIGN) {
    76fc:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7700:	2b01      	cmp	r3, #1
    7702:	d10d      	bne.n	7720 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x80>
                output_cursor += direction;
    7704:	f894 3f8d 	ldrb.w	r3, [r4, #3981]	; 0xf8d
    7708:	4433      	add	r3, r6
    770a:	b25b      	sxtb	r3, r3
                if (output_cursor < 0) output_cursor = 3;
    770c:	2b00      	cmp	r3, #0
    770e:	db61      	blt.n	77d4 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x134>
                if (output_cursor > 3) output_cursor = 0;
    7710:	2b03      	cmp	r3, #3
    7712:	dd00      	ble.n	7716 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x76>
    7714:	2300      	movs	r3, #0
    7716:	f884 3f8d 	strb.w	r3, [r4, #3981]	; 0xf8d
            if (mode == ENIGMA_MODE_SONG || mode == ENIGMA_MODE_PLAY) {
    771a:	e013      	b.n	7744 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xa4>
                if (tm_cursor < 0) tm_cursor = HS::TURING_MACHINE_COUNT - 1;
    771c:	2127      	movs	r1, #39	; 0x27
    771e:	e7e7      	b.n	76f0 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x50>
            if (mode == ENIGMA_MODE_SONG || mode == ENIGMA_MODE_PLAY) {
    7720:	3b02      	subs	r3, #2
    7722:	2b01      	cmp	r3, #1
    7724:	d80e      	bhi.n	7744 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xa4>
                track_cursor += direction;
    7726:	f894 1f8e 	ldrb.w	r1, [r4, #3982]	; 0xf8e
    772a:	4431      	add	r1, r6
    772c:	b249      	sxtb	r1, r1
                if (track_cursor < 0) track_cursor = 3;
    772e:	2900      	cmp	r1, #0
    7730:	db0c      	blt.n	774c <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xac>
                if (track_cursor > 3) track_cursor = 0;
    7732:	2904      	cmp	r1, #4
    7734:	bfa8      	it	ge
    7736:	2100      	movge	r1, #0
    7738:	f884 1f8e 	strb.w	r1, [r4, #3982]	; 0xf8e
                BuildTrackStepList(track_cursor);
    773c:	4826      	ldr	r0, [pc, #152]	; (77d8 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x138>)
    773e:	b2c9      	uxtb	r1, r1
    7740:	f7ff fdca 	bl	72d8 <EnigmaTMWS::BuildTrackStepList(unsigned char)>
        cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    7744:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    7748:	6263      	str	r3, [r4, #36]	; 0x24
    }
    774a:	e7b7      	b.n	76bc <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x1c>
                if (track_cursor < 0) track_cursor = 3;
    774c:	2103      	movs	r1, #3
    774e:	e7f3      	b.n	7738 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x98>
            switch(mode) {
    7750:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7754:	2b01      	cmp	r3, #1
    7756:	d009      	beq.n	776c <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xcc>
    7758:	2b02      	cmp	r3, #2
    775a:	d00b      	beq.n	7774 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xd4>
    775c:	b973      	cbnz	r3, 777c <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xdc>
                case ENIGMA_MODE_LIBRARY : DelegateTMParam(direction);
    775e:	4620      	mov	r0, r4
    7760:	f7ff fc78 	bl	7054 <EnigmaTMWS::DelegateTMParam(int)>
        cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    7764:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    7768:	6263      	str	r3, [r4, #36]	; 0x24
}
    776a:	e7b4      	b.n	76d6 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x36>
                case ENIGMA_MODE_ASSIGN  : DelegateOutputParam(direction);
    776c:	4620      	mov	r0, r4
    776e:	f7ff fcbd 	bl	70ec <EnigmaTMWS::DelegateOutputParam(int)>
                                           break;
    7772:	e7f7      	b.n	7764 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xc4>
                case ENIGMA_MODE_SONG    : DelegateStepParam(direction);
    7774:	4620      	mov	r0, r4
    7776:	f7ff fd31 	bl	71dc <EnigmaTMWS::DelegateStepParam(int)>
                                           break;
    777a:	e7f3      	b.n	7764 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xc4>
        if (track_param == ENIGMA_TRACK_DIVIDE) {
    777c:	f994 3f92 	ldrsb.w	r3, [r4, #3986]	; 0xf92
    7780:	b9c3      	cbnz	r3, 77b4 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x114>
            if (track[track_cursor].divide() > 0 || direction > 0)
    7782:	f994 2f8e 	ldrsb.w	r2, [r4, #3982]	; 0xf8e
    byte divide() {return (data & 0x1f) + 1;}
    7786:	18a3      	adds	r3, r4, r2
    7788:	f893 0f84 	ldrb.w	r0, [r3, #3972]	; 0xf84
    778c:	f000 031f 	and.w	r3, r0, #31
    7790:	3301      	adds	r3, #1
                track[track_cursor].set_divide(track[track_cursor].divide() + direction);
    7792:	4419      	add	r1, r3
        divide_ = constrain(divide_, 1, 32) - 1;
    7794:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
    7798:	d00a      	beq.n	77b0 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x110>
    779a:	2920      	cmp	r1, #32
    779c:	bfa8      	it	ge
    779e:	2120      	movge	r1, #32
        data = data | divide_;
    77a0:	4422      	add	r2, r4
        divide_ = constrain(divide_, 1, 32) - 1;
    77a2:	3901      	subs	r1, #1
        data = data & (0xff - 0x1f); // Clear first five bits
    77a4:	f020 001f 	bic.w	r0, r0, #31
        data = data | divide_;
    77a8:	4301      	orrs	r1, r0
    77aa:	f882 1f84 	strb.w	r1, [r2, #3972]	; 0xf84
        if (track_param == ENIGMA_TRACK_LOOP)
    77ae:	e7d9      	b.n	7764 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xc4>
        divide_ = constrain(divide_, 1, 32) - 1;
    77b0:	2101      	movs	r1, #1
    77b2:	e7f5      	b.n	77a0 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x100>
    77b4:	2b01      	cmp	r3, #1
    77b6:	d1d5      	bne.n	7764 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xc4>
            track[track_cursor].set_loop(1 - track[track_cursor].loop());
    77b8:	f994 2f8e 	ldrsb.w	r2, [r4, #3982]	; 0xf8e
    byte loop() {return ((data >> 5) & 0x01);}
    77bc:	4422      	add	r2, r4
    77be:	f892 3f84 	ldrb.w	r3, [r2, #3972]	; 0xf84
        if (loop_) data = data | 0x20;
    77c2:	0699      	lsls	r1, r3, #26
    77c4:	bf54      	ite	pl
    77c6:	f043 0320 	orrpl.w	r3, r3, #32
        else data = data & (0xff - 0x20); // Clear bit 5
    77ca:	f023 0320 	bicmi.w	r3, r3, #32
    77ce:	f882 3f84 	strb.w	r3, [r2, #3972]	; 0xf84
    77d2:	e7c7      	b.n	7764 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0xc4>
                if (output_cursor < 0) output_cursor = 3;
    77d4:	2303      	movs	r3, #3
    77d6:	e79e      	b.n	7716 <EnigmaTMWS_handleEncoderEvent(UI::Event const&)+0x76>
    77d8:	1fffd9ac 	.word	0x1fffd9ac

000077dc <EnigmaTMWS::SendTuringMachineLibrary()>:
    void SendTuringMachineLibrary() {
    77dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    77e0:	4e1b      	ldr	r6, [pc, #108]	; (7850 <EnigmaTMWS::SendTuringMachineLibrary()+0x74>)
    77e2:	b0b0      	sub	sp, #192	; 0xc0
    77e4:	4681      	mov	r9, r0
    77e6:	2700      	movs	r7, #0
            V[ix++] = 'r'; // Indicates a register is being sent
    77e8:	f04f 0a72 	mov.w	sl, #114	; 0x72
            uint16_t reg = HS::user_turing_machines[tm].reg;
    77ec:	8831      	ldrh	r1, [r6, #0]
            byte len = HS::user_turing_machines[tm].len;
    77ee:	78b2      	ldrb	r2, [r6, #2]
            byte favorite = HS::user_turing_machines[tm].favorite;
    77f0:	78f3      	ldrb	r3, [r6, #3]
            V[ix++] = static_cast<byte>(reg & 0xff);  // Low Byte
    77f2:	f8ad 103a 	strh.w	r1, [sp, #58]	; 0x3a
            V[ix++] = len;
    77f6:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
            unpacked.set_data(ix, V);
    77fa:	2106      	movs	r1, #6
    77fc:	aa0e      	add	r2, sp, #56	; 0x38
    77fe:	a810      	add	r0, sp, #64	; 0x40
            PackedData packed = unpacked.pack();
    7800:	f10d 0880 	add.w	r8, sp, #128	; 0x80
            V[ix++] = favorite;
    7804:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
            V[ix++] = tm; // Register index in Library
    7808:	f88d 7039 	strb.w	r7, [sp, #57]	; 0x39
            V[ix++] = 'r'; // Indicates a register is being sent
    780c:	f88d a038 	strb.w	sl, [sp, #56]	; 0x38
            unpacked.set_data(ix, V);
    7810:	f7fd fc9a 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
            PackedData packed = unpacked.pack();
    7814:	a910      	add	r1, sp, #64	; 0x40
    7816:	4640      	mov	r0, r8
    7818:	f7fd fca2 	bl	5160 <_SysExData::pack()>
            SendSysEx(packed, 'T');
    781c:	2354      	movs	r3, #84	; 0x54
    781e:	930d      	str	r3, [sp, #52]	; 0x34
    7820:	ad23      	add	r5, sp, #140	; 0x8c
    7822:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7824:	466c      	mov	r4, sp
    7826:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7828:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    782a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    782c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    782e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7830:	682b      	ldr	r3, [r5, #0]
    7832:	6023      	str	r3, [r4, #0]
    7834:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
    7838:	f109 0080 	add.w	r0, r9, #128	; 0x80
        for (byte tm = 0; tm < HS::TURING_MACHINE_COUNT; tm++)
    783c:	3701      	adds	r7, #1
            SendSysEx(packed, 'T');
    783e:	f7fd fd0b 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
        for (byte tm = 0; tm < HS::TURING_MACHINE_COUNT; tm++)
    7842:	2f28      	cmp	r7, #40	; 0x28
    7844:	f106 0604 	add.w	r6, r6, #4
    7848:	d1d0      	bne.n	77ec <EnigmaTMWS::SendTuringMachineLibrary()+0x10>
    }
    784a:	b030      	add	sp, #192	; 0xc0
    784c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7850:	200036e8 	.word	0x200036e8

00007854 <EnigmaTMWS::SendSingleTuringMachine(unsigned char)>:
    void SendSingleTuringMachine(byte tm) {
    7854:	b5f0      	push	{r4, r5, r6, r7, lr}
    7856:	4b19      	ldr	r3, [pc, #100]	; (78bc <EnigmaTMWS::SendSingleTuringMachine(unsigned char)+0x68>)
    7858:	4607      	mov	r7, r0
    785a:	f833 0021 	ldrh.w	r0, [r3, r1, lsl #2]
        byte len = HS::user_turing_machines[tm].len;
    785e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    void SendSingleTuringMachine(byte tm) {
    7862:	b0b1      	sub	sp, #196	; 0xc4
        byte len = HS::user_turing_machines[tm].len;
    7864:	789a      	ldrb	r2, [r3, #2]
        V[ix++] = tm; // Register index in Library (origin, but unused on receive)
    7866:	f88d 1039 	strb.w	r1, [sp, #57]	; 0x39
        byte favorite = HS::user_turing_machines[tm].favorite;
    786a:	78db      	ldrb	r3, [r3, #3]
        V[ix++] = static_cast<byte>(reg & 0xff);  // Low Byte
    786c:	f8ad 003a 	strh.w	r0, [sp, #58]	; 0x3a
        V[ix++] = len;
    7870:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
        unpacked.set_data(ix, V);
    7874:	a810      	add	r0, sp, #64	; 0x40
    7876:	aa0e      	add	r2, sp, #56	; 0x38
        PackedData packed = unpacked.pack();
    7878:	ae20      	add	r6, sp, #128	; 0x80
        V[ix++] = '1'; // Indicates a single register is being sent
    787a:	2431      	movs	r4, #49	; 0x31
        unpacked.set_data(ix, V);
    787c:	2106      	movs	r1, #6
        V[ix++] = favorite;
    787e:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
        V[ix++] = '1'; // Indicates a single register is being sent
    7882:	f88d 4038 	strb.w	r4, [sp, #56]	; 0x38
        unpacked.set_data(ix, V);
    7886:	f7fd fc5f 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        PackedData packed = unpacked.pack();
    788a:	a910      	add	r1, sp, #64	; 0x40
    788c:	4630      	mov	r0, r6
    788e:	f7fd fc67 	bl	5160 <_SysExData::pack()>
        SendSysEx(packed, 'T');
    7892:	2354      	movs	r3, #84	; 0x54
    7894:	930d      	str	r3, [sp, #52]	; 0x34
    7896:	ad23      	add	r5, sp, #140	; 0x8c
    7898:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    789a:	466c      	mov	r4, sp
    789c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    789e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    78a0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    78a2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    78a4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    78a6:	682b      	ldr	r3, [r5, #0]
    78a8:	6023      	str	r3, [r4, #0]
    78aa:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
    78ae:	f107 0080 	add.w	r0, r7, #128	; 0x80
    78b2:	f7fd fcd1 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
    }
    78b6:	b031      	add	sp, #196	; 0xc4
    78b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    78ba:	bf00      	nop
    78bc:	200036e8 	.word	0x200036e8

000078c0 <EnigmaTMWS::SendSong()>:
    void SendSong() {
    78c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        byte pages = (total_steps / 8) + 1;
    78c4:	f8b0 83dc 	ldrh.w	r8, [r0, #988]	; 0x3dc
    78c8:	ea4f 08d8 	mov.w	r8, r8, lsr #3
    78cc:	f108 0801 	add.w	r8, r8, #1
        for (byte p = 0; p < pages; p++)
    78d0:	f04f 0900 	mov.w	r9, #0
    void SendSong() {
    78d4:	b0bb      	sub	sp, #236	; 0xec
    78d6:	4606      	mov	r6, r0
        byte pages = (total_steps / 8) + 1;
    78d8:	fa5f f888 	uxtb.w	r8, r8
        ix = 0;
    78dc:	464f      	mov	r7, r9
            V[ix++] = 's'; // Indicates a song step page is being sent
    78de:	f04f 0a73 	mov.w	sl, #115	; 0x73
    78e2:	fa5f f289 	uxtb.w	r2, r9
        for (byte p = 0; p < pages; p++)
    78e6:	4590      	cmp	r8, r2
    78e8:	d831      	bhi.n	794e <EnigmaTMWS::SendSong()+0x8e>
        V[ix++] = 't'; // Indicates a set of output assignments
    78ea:	2374      	movs	r3, #116	; 0x74
    78ec:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        for (int t = 0; t < 4; t++) V[ix++] = track[t].data;
    78f0:	f896 3f84 	ldrb.w	r3, [r6, #3972]	; 0xf84
    78f4:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    78f8:	f896 3f85 	ldrb.w	r3, [r6, #3973]	; 0xf85
    78fc:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    7900:	f896 3f86 	ldrb.w	r3, [r6, #3974]	; 0xf86
    7904:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
        unpacked.set_data(ix, V);
    7908:	aa0e      	add	r2, sp, #56	; 0x38
        for (int t = 0; t < 4; t++) V[ix++] = track[t].data;
    790a:	f896 3f87 	ldrb.w	r3, [r6, #3975]	; 0xf87
    790e:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
        unpacked.set_data(ix, V);
    7912:	a81a      	add	r0, sp, #104	; 0x68
        PackedData packed = unpacked.pack();
    7914:	af2a      	add	r7, sp, #168	; 0xa8
        unpacked.set_data(ix, V);
    7916:	2105      	movs	r1, #5
    7918:	f7fd fc16 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        PackedData packed = unpacked.pack();
    791c:	a91a      	add	r1, sp, #104	; 0x68
    791e:	4638      	mov	r0, r7
    7920:	f7fd fc1e 	bl	5160 <_SysExData::pack()>
        SendSysEx(packed, 'T');
    7924:	2354      	movs	r3, #84	; 0x54
    7926:	930d      	str	r3, [sp, #52]	; 0x34
    7928:	ad2d      	add	r5, sp, #180	; 0xb4
    792a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    792c:	466c      	mov	r4, sp
    792e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7930:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7932:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7934:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7936:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7938:	682b      	ldr	r3, [r5, #0]
    793a:	6023      	str	r3, [r4, #0]
    793c:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
    7940:	f106 0080 	add.w	r0, r6, #128	; 0x80
    7944:	f7fd fc88 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
    }
    7948:	b03b      	add	sp, #236	; 0xec
    794a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            V[ix++] = 's'; // Indicates a song step page is being sent
    794e:	f107 03e8 	add.w	r3, r7, #232	; 0xe8
    7952:	446b      	add	r3, sp
            V[ix++] = p; // Page number
    7954:	a93a      	add	r1, sp, #232	; 0xe8
            V[ix++] = 's'; // Indicates a song step page is being sent
    7956:	f803 acb0 	strb.w	sl, [r3, #-176]
    795a:	1c7b      	adds	r3, r7, #1
            V[ix++] = p; // Page number
    795c:	fa51 f383 	uxtab	r3, r1, r3
            V[ix++] = static_cast<byte>(total_steps & 0xff); // Total steps, low byte
    7960:	a83a      	add	r0, sp, #232	; 0xe8
            V[ix++] = p; // Page number
    7962:	f803 2cb0 	strb.w	r2, [r3, #-176]
    7966:	1cbb      	adds	r3, r7, #2
            V[ix++] = static_cast<byte>(total_steps & 0xff); // Total steps, low byte
    7968:	fa50 f383 	uxtab	r3, r0, r3
    796c:	f8b6 13dc 	ldrh.w	r1, [r6, #988]	; 0x3dc
    7970:	f803 1cb0 	strb.w	r1, [r3, #-176]
    7974:	1cf8      	adds	r0, r7, #3
            V[ix++] = static_cast<byte>((total_steps >> 8) & 0xff); // Total steps, high byte
    7976:	ac3a      	add	r4, sp, #232	; 0xe8
    7978:	fa54 f080 	uxtab	r0, r4, r0
    797c:	0a09      	lsrs	r1, r1, #8
    797e:	1d3b      	adds	r3, r7, #4
    7980:	00d2      	lsls	r2, r2, #3
    7982:	f800 1cb0 	strb.w	r1, [r0, #-176]
    7986:	b2db      	uxtb	r3, r3
            for (byte s = 0; s < 10; s++)
    7988:	b2d1      	uxtb	r1, r2
            V[ix++] = static_cast<byte>((total_steps >> 8) & 0xff); // Total steps, high byte
    798a:	2000      	movs	r0, #0
                byte ssi = (p * 8) + s;
    798c:	180a      	adds	r2, r1, r0
    798e:	b2d2      	uxtb	r2, r2
    7990:	eb06 0282 	add.w	r2, r6, r2, lsl #2
                V[ix++] = song_step[ssi].tk;
    7994:	f103 04e8 	add.w	r4, r3, #232	; 0xe8
    7998:	446c      	add	r4, sp
    799a:	f892 5424 	ldrb.w	r5, [r2, #1060]	; 0x424
    799e:	f804 5cb0 	strb.w	r5, [r4, #-176]
    79a2:	1c5c      	adds	r4, r3, #1
                V[ix++] = song_step[ssi].pr;
    79a4:	ad3a      	add	r5, sp, #232	; 0xe8
    79a6:	fa55 f484 	uxtab	r4, r5, r4
    79aa:	f892 5425 	ldrb.w	r5, [r2, #1061]	; 0x425
    79ae:	f804 5cb0 	strb.w	r5, [r4, #-176]
                V[ix++] = song_step[ssi].re;
    79b2:	f10d 0ce8 	add.w	ip, sp, #232	; 0xe8
                V[ix++] = song_step[ssi].pr;
    79b6:	1c9d      	adds	r5, r3, #2
                V[ix++] = song_step[ssi].re;
    79b8:	fa5c f585 	uxtab	r5, ip, r5
    79bc:	f892 c426 	ldrb.w	ip, [r2, #1062]	; 0x426
    79c0:	f805 ccb0 	strb.w	ip, [r5, #-176]
    79c4:	1cdc      	adds	r4, r3, #3
                V[ix++] = song_step[ssi].tr;
    79c6:	ad3a      	add	r5, sp, #232	; 0xe8
    79c8:	fa55 f484 	uxtab	r4, r5, r4
            for (byte s = 0; s < 10; s++)
    79cc:	3001      	adds	r0, #1
                V[ix++] = song_step[ssi].tr;
    79ce:	f892 2427 	ldrb.w	r2, [r2, #1063]	; 0x427
    79d2:	f804 2cb0 	strb.w	r2, [r4, #-176]
    79d6:	3304      	adds	r3, #4
            for (byte s = 0; s < 10; s++)
    79d8:	280a      	cmp	r0, #10
                V[ix++] = song_step[ssi].tr;
    79da:	b2db      	uxtb	r3, r3
            for (byte s = 0; s < 10; s++)
    79dc:	d1d6      	bne.n	798c <EnigmaTMWS::SendSong()+0xcc>
                V[ix++] = song_step[ssi].tr;
    79de:	372c      	adds	r7, #44	; 0x2c
    79e0:	b2ff      	uxtb	r7, r7
            unpacked.set_data(ix, V);
    79e2:	aa0e      	add	r2, sp, #56	; 0x38
    79e4:	4639      	mov	r1, r7
    79e6:	a81a      	add	r0, sp, #104	; 0x68
            PackedData packed = unpacked.pack();
    79e8:	f10d 0ba8 	add.w	fp, sp, #168	; 0xa8
            unpacked.set_data(ix, V);
    79ec:	f7fd fbac 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
            PackedData packed = unpacked.pack();
    79f0:	a91a      	add	r1, sp, #104	; 0x68
    79f2:	4658      	mov	r0, fp
    79f4:	f7fd fbb4 	bl	5160 <_SysExData::pack()>
            SendSysEx(packed, 'T');
    79f8:	2354      	movs	r3, #84	; 0x54
    79fa:	930d      	str	r3, [sp, #52]	; 0x34
    79fc:	ad2d      	add	r5, sp, #180	; 0xb4
    79fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7a00:	466c      	mov	r4, sp
    7a02:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7a04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7a06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7a08:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7a0a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7a0c:	682b      	ldr	r3, [r5, #0]
    7a0e:	6023      	str	r3, [r4, #0]
    7a10:	e89b 000e 	ldmia.w	fp, {r1, r2, r3}
    7a14:	f106 0080 	add.w	r0, r6, #128	; 0x80
    7a18:	f7fd fc1e 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
        for (byte p = 0; p < pages; p++)
    7a1c:	f109 0901 	add.w	r9, r9, #1
    7a20:	e75f      	b.n	78e2 <EnigmaTMWS::SendSong()+0x22>

00007a22 <EnigmaTMWS::SendOutputAssignments()>:
    void SendOutputAssignments() {
    7a22:	b5f0      	push	{r4, r5, r6, r7, lr}
    7a24:	b0bb      	sub	sp, #236	; 0xec
        V[ix++] = 'o'; // Indicates a set of output assignments
    7a26:	236f      	movs	r3, #111	; 0x6f
    7a28:	a90e      	add	r1, sp, #56	; 0x38
    void SendOutputAssignments() {
    7a2a:	4606      	mov	r6, r0
        V[ix++] = 'o'; // Indicates a set of output assignments
    7a2c:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        for (byte o = 0; o < 4; o++)
    7a30:	460a      	mov	r2, r1
    7a32:	4603      	mov	r3, r0
    7a34:	f500 60a4 	add.w	r0, r0, #1312	; 0x520
            V[ix++] = output[o].tk;
    7a38:	f893 4ba8 	ldrb.w	r4, [r3, #2984]	; 0xba8
    7a3c:	704c      	strb	r4, [r1, #1]
            V[ix++] = output[o].ty;
    7a3e:	f893 4ba9 	ldrb.w	r4, [r3, #2985]	; 0xba9
    7a42:	708c      	strb	r4, [r1, #2]
            V[ix++] = output[o].sc;
    7a44:	f893 4baa 	ldrb.w	r4, [r3, #2986]	; 0xbaa
    7a48:	70cc      	strb	r4, [r1, #3]
        for (byte o = 0; o < 4; o++)
    7a4a:	f503 73a4 	add.w	r3, r3, #328	; 0x148
            V[ix++] = output[o].mc;
    7a4e:	f893 4a63 	ldrb.w	r4, [r3, #2659]	; 0xa63
    7a52:	f801 4f04 	strb.w	r4, [r1, #4]!
        for (byte o = 0; o < 4; o++)
    7a56:	4283      	cmp	r3, r0
    7a58:	d1ee      	bne.n	7a38 <EnigmaTMWS::SendOutputAssignments()+0x16>
        unpacked.set_data(ix, V);
    7a5a:	a81a      	add	r0, sp, #104	; 0x68
        PackedData packed = unpacked.pack();
    7a5c:	af2a      	add	r7, sp, #168	; 0xa8
        unpacked.set_data(ix, V);
    7a5e:	2111      	movs	r1, #17
    7a60:	f7fd fb72 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        PackedData packed = unpacked.pack();
    7a64:	a91a      	add	r1, sp, #104	; 0x68
    7a66:	4638      	mov	r0, r7
    7a68:	f7fd fb7a 	bl	5160 <_SysExData::pack()>
        SendSysEx(packed, 'T');
    7a6c:	2354      	movs	r3, #84	; 0x54
    7a6e:	930d      	str	r3, [sp, #52]	; 0x34
    7a70:	ad2d      	add	r5, sp, #180	; 0xb4
    7a72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7a74:	466c      	mov	r4, sp
    7a76:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7a78:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7a7a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7a7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    7a7e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7a80:	682b      	ldr	r3, [r5, #0]
    7a82:	6023      	str	r3, [r4, #0]
    7a84:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
    7a88:	f106 0080 	add.w	r0, r6, #128	; 0x80
    7a8c:	f7fd fbe4 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
    }
    7a90:	b03b      	add	sp, #236	; 0xec
    7a92:	bdf0      	pop	{r4, r5, r6, r7, pc}

00007a94 <EnigmaTMWS::OnSendSysEx()>:
    void OnSendSysEx() {
    7a94:	b510      	push	{r4, lr}
    7a96:	4604      	mov	r4, r0
        SendTuringMachineLibrary();
    7a98:	f7ff fea0 	bl	77dc <EnigmaTMWS::SendTuringMachineLibrary()>
        SendOutputAssignments();
    7a9c:	4620      	mov	r0, r4
    7a9e:	f7ff ffc0 	bl	7a22 <EnigmaTMWS::SendOutputAssignments()>
        SendSong();
    7aa2:	4620      	mov	r0, r4
    7aa4:	f7ff ff0c 	bl	78c0 <EnigmaTMWS::SendSong()>
    }
    7aa8:	bd10      	pop	{r4, pc}

00007aaa <non-virtual thunk to EnigmaTMWS::OnSendSysEx()>:
    void OnSendSysEx() {
    7aaa:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    7aae:	e7f1      	b.n	7a94 <EnigmaTMWS::OnSendSysEx()>

00007ab0 <EnigmaTMWS_handleAppEvent(OC::AppEvent)>:
    if (event ==  OC::APP_EVENT_RESUME) {
    7ab0:	2801      	cmp	r0, #1
void EnigmaTMWS_handleAppEvent(OC::AppEvent event) {
    7ab2:	b538      	push	{r3, r4, r5, lr}
    if (event ==  OC::APP_EVENT_RESUME) {
    7ab4:	d103      	bne.n	7abe <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0xe>
        EnigmaTMWS_instance.Resume();
    7ab6:	4828      	ldr	r0, [pc, #160]	; (7b58 <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0xa8>)
    7ab8:	f7ff fc4a 	bl	7350 <EnigmaTMWS::Resume()>
}
    7abc:	bd38      	pop	{r3, r4, r5, pc}
    if (event == OC::APP_EVENT_SUSPEND) {
    7abe:	2800      	cmp	r0, #0
    7ac0:	d1fc      	bne.n	7abc <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0xc>
    7ac2:	4b25      	ldr	r3, [pc, #148]	; (7b58 <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0xa8>)
    7ac4:	461a      	mov	r2, r3
    7ac6:	4619      	mov	r1, r3
    7ac8:	461c      	mov	r4, r3
            values_[ix++] = output[o].tk;
    7aca:	f891 5ba8 	ldrb.w	r5, [r1, #2984]	; 0xba8
    7ace:	f8c2 5088 	str.w	r5, [r2, #136]	; 0x88
            values_[ix++] = output[o].ty;
    7ad2:	f891 5ba9 	ldrb.w	r5, [r1, #2985]	; 0xba9
    7ad6:	f8c2 508c 	str.w	r5, [r2, #140]	; 0x8c
            values_[ix++] = output[o].sc;
    7ada:	f891 5baa 	ldrb.w	r5, [r1, #2986]	; 0xbaa
    7ade:	f8c2 5090 	str.w	r5, [r2, #144]	; 0x90
        for (byte o = 0; o < 4; o++)
    7ae2:	3001      	adds	r0, #1
            values_[ix++] = output[o].mc;
    7ae4:	f891 5bab 	ldrb.w	r5, [r1, #2987]	; 0xbab
    7ae8:	f8c2 5094 	str.w	r5, [r2, #148]	; 0x94
        for (byte o = 0; o < 4; o++)
    7aec:	2804      	cmp	r0, #4
    7aee:	f501 71a4 	add.w	r1, r1, #328	; 0x148
    7af2:	f102 0210 	add.w	r2, r2, #16
    7af6:	d1e8      	bne.n	7aca <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0x1a>
        int song_steps = constrain(total_steps, 0, 32);
    7af8:	f8b4 23dc 	ldrh.w	r2, [r4, #988]	; 0x3dc
    7afc:	2a20      	cmp	r2, #32
    7afe:	bfa8      	it	ge
    7b00:	2220      	movge	r2, #32
        values_[ix++] = static_cast<byte>(song_steps);
    7b02:	f8c4 20c8 	str.w	r2, [r4, #200]	; 0xc8
    7b06:	4a14      	ldr	r2, [pc, #80]	; (7b58 <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0xa8>)
    7b08:	2100      	movs	r1, #0
            values_[ix++] = song_step[s].tk;
    7b0a:	f893 0424 	ldrb.w	r0, [r3, #1060]	; 0x424
    7b0e:	f8c2 00cc 	str.w	r0, [r2, #204]	; 0xcc
            values_[ix++] = song_step[s].pr;
    7b12:	f893 0425 	ldrb.w	r0, [r3, #1061]	; 0x425
    7b16:	f8c2 00d0 	str.w	r0, [r2, #208]	; 0xd0
            values_[ix++] = song_step[s].re;
    7b1a:	f893 0426 	ldrb.w	r0, [r3, #1062]	; 0x426
    7b1e:	f8c2 00d4 	str.w	r0, [r2, #212]	; 0xd4
        for (byte s = 0; s < 32; s++)
    7b22:	3101      	adds	r1, #1
            values_[ix++] = song_step[s].tr;
    7b24:	f893 0427 	ldrb.w	r0, [r3, #1063]	; 0x427
    7b28:	f8c2 00d8 	str.w	r0, [r2, #216]	; 0xd8
        for (byte s = 0; s < 32; s++)
    7b2c:	2920      	cmp	r1, #32
    7b2e:	f103 0304 	add.w	r3, r3, #4
    7b32:	f102 0210 	add.w	r2, r2, #16
    7b36:	d1e8      	bne.n	7b0a <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0x5a>
    7b38:	4908      	ldr	r1, [pc, #32]	; (7b5c <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0xac>)
            values_[ix++] = song_step[s].tr;
    7b3a:	2391      	movs	r3, #145	; 0x91
        for (byte t = 0; t < 4; t++) values_[ix++] = track[t].data;
    7b3c:	461a      	mov	r2, r3
    7b3e:	3301      	adds	r3, #1
    7b40:	b2db      	uxtb	r3, r3
    7b42:	3222      	adds	r2, #34	; 0x22
    7b44:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    7b48:	f844 0022 	str.w	r0, [r4, r2, lsl #2]
    7b4c:	2b95      	cmp	r3, #149	; 0x95
    7b4e:	d1f5      	bne.n	7b3c <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0x8c>
        EnigmaTMWS_instance.OnSendSysEx();
    7b50:	4801      	ldr	r0, [pc, #4]	; (7b58 <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0xa8>)
    7b52:	f7ff ff9f 	bl	7a94 <EnigmaTMWS::OnSendSysEx()>
}
    7b56:	e7b1      	b.n	7abc <EnigmaTMWS_handleAppEvent(OC::AppEvent)+0xc>
    7b58:	1fffd9ac 	.word	0x1fffd9ac
    7b5c:	1fffe92f 	.word	0x1fffe92f

00007b60 <EnigmaTMWS_handleButtonEvent(UI::Event const&)>:
void EnigmaTMWS_handleButtonEvent(const UI::Event &event) {
    7b60:	b538      	push	{r3, r4, r5, lr}
    if (event.control == OC::CONTROL_BUTTON_L) {
    7b62:	8843      	ldrh	r3, [r0, #2]
    7b64:	2b04      	cmp	r3, #4
void EnigmaTMWS_handleButtonEvent(const UI::Event &event) {
    7b66:	4605      	mov	r5, r0
    if (event.control == OC::CONTROL_BUTTON_L) {
    7b68:	d117      	bne.n	7b9a <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x3a>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) EnigmaTMWS_instance.OnLeftButtonLongPress();
    7b6a:	7802      	ldrb	r2, [r0, #0]
        if (mode == ENIGMA_MODE_LIBRARY) SendTuringMachineLibrary();
    7b6c:	4c7f      	ldr	r4, [pc, #508]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) EnigmaTMWS_instance.OnLeftButtonLongPress();
    7b6e:	2a02      	cmp	r2, #2
        if (mode == ENIGMA_MODE_LIBRARY) SendTuringMachineLibrary();
    7b70:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) EnigmaTMWS_instance.OnLeftButtonLongPress();
    7b74:	d140      	bne.n	7bf8 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x98>
        if (mode == ENIGMA_MODE_LIBRARY) SendTuringMachineLibrary();
    7b76:	b913      	cbnz	r3, 7b7e <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x1e>
    7b78:	4620      	mov	r0, r4
    7b7a:	f7ff fe2f 	bl	77dc <EnigmaTMWS::SendTuringMachineLibrary()>
        if (mode == ENIGMA_MODE_ASSIGN) SendOutputAssignments();
    7b7e:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7b82:	2b01      	cmp	r3, #1
    7b84:	d102      	bne.n	7b8c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x2c>
    7b86:	4879      	ldr	r0, [pc, #484]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
    7b88:	f7ff ff4b 	bl	7a22 <EnigmaTMWS::SendOutputAssignments()>
        if (mode >= ENIGMA_MODE_SONG) SendSong();
    7b8c:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7b90:	2b01      	cmp	r3, #1
    7b92:	d902      	bls.n	7b9a <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x3a>
    7b94:	4875      	ldr	r0, [pc, #468]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
    7b96:	f7ff fe93 	bl	78c0 <EnigmaTMWS::SendSong()>
    if (event.control == OC::CONTROL_BUTTON_R && event.type == UI::EVENT_BUTTON_PRESS) EnigmaTMWS_instance.OnRightButtonPress();
    7b9a:	886b      	ldrh	r3, [r5, #2]
    7b9c:	2b08      	cmp	r3, #8
    7b9e:	d10a      	bne.n	7bb6 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x56>
    7ba0:	782b      	ldrb	r3, [r5, #0]
    7ba2:	2b01      	cmp	r3, #1
    7ba4:	d127      	bne.n	7bf6 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x96>
        if (help_countdown) DismissHelp();
    7ba6:	4c71      	ldr	r4, [pc, #452]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
    7ba8:	f8b4 33e0 	ldrh.w	r3, [r4, #992]	; 0x3e0
    7bac:	2b00      	cmp	r3, #0
    7bae:	d043      	beq.n	7c38 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0xd8>
    7bb0:	4620      	mov	r0, r4
    7bb2:	f7ff fd13 	bl	75dc <EnigmaTMWS::DismissHelp()>
    if (event.control == OC::CONTROL_BUTTON_UP) EnigmaTMWS_instance.OnUpButtonPress();
    7bb6:	886b      	ldrh	r3, [r5, #2]
    7bb8:	2b01      	cmp	r3, #1
    7bba:	d108      	bne.n	7bce <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x6e>
        if (help_countdown) DismissHelp();
    7bbc:	4c6b      	ldr	r4, [pc, #428]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
    7bbe:	f8b4 33e0 	ldrh.w	r3, [r4, #992]	; 0x3e0
    7bc2:	2b00      	cmp	r3, #0
    7bc4:	f000 808c 	beq.w	7ce0 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x180>
    7bc8:	4620      	mov	r0, r4
    7bca:	f7ff fd07 	bl	75dc <EnigmaTMWS::DismissHelp()>
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
    7bce:	886b      	ldrh	r3, [r5, #2]
    7bd0:	2b02      	cmp	r3, #2
    7bd2:	d110      	bne.n	7bf6 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x96>
        if (event.type == UI::EVENT_BUTTON_PRESS) EnigmaTMWS_instance.OnDownButtonPress();
    7bd4:	782b      	ldrb	r3, [r5, #0]
    7bd6:	2b01      	cmp	r3, #1
    7bd8:	d102      	bne.n	7be0 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x80>
    7bda:	4864      	ldr	r0, [pc, #400]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
    7bdc:	f7ff fd10 	bl	7600 <EnigmaTMWS::OnDownButtonPress()>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) EnigmaTMWS_instance.OnDownButtonLongPress();
    7be0:	782b      	ldrb	r3, [r5, #0]
    7be2:	2b02      	cmp	r3, #2
    7be4:	d107      	bne.n	7bf6 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x96>
        last_mode = mode;
    7be6:	4b61      	ldr	r3, [pc, #388]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
    7be8:	f893 2f88 	ldrb.w	r2, [r3, #3976]	; 0xf88
    7bec:	f883 2f89 	strb.w	r2, [r3, #3977]	; 0xf89
        mode = ENIGMA_CONFIRM_RESET;
    7bf0:	2204      	movs	r2, #4
    7bf2:	f883 2f88 	strb.w	r2, [r3, #3976]	; 0xf88
}
    7bf6:	bd38      	pop	{r3, r4, r5, pc}
        if (mode == ENIGMA_CONFIRM_RESET) mode = last_mode; // Cancel erase
    7bf8:	2b04      	cmp	r3, #4
    7bfa:	d10e      	bne.n	7c1a <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0xba>
    7bfc:	f894 3f89 	ldrb.w	r3, [r4, #3977]	; 0xf89
        else if (++mode > ENIGMA_MODE_PLAY) mode = ENIGMA_MODE_LIBRARY;
    7c00:	f884 3f88 	strb.w	r3, [r4, #3976]	; 0xf88
        if (mode == ENIGMA_MODE_LIBRARY && play) ++mode;
    7c04:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7c08:	b173      	cbz	r3, 7c28 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0xc8>
    7c0a:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    7c0e:	6263      	str	r3, [r4, #36]	; 0x24
        help_countdown = help_time;
    7c10:	f8b4 33e2 	ldrh.w	r3, [r4, #994]	; 0x3e2
    7c14:	f8a4 33e0 	strh.w	r3, [r4, #992]	; 0x3e0
    }
    7c18:	e7bf      	b.n	7b9a <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x3a>
        else if (++mode > ENIGMA_MODE_PLAY) mode = ENIGMA_MODE_LIBRARY;
    7c1a:	3301      	adds	r3, #1
    7c1c:	b2db      	uxtb	r3, r3
    7c1e:	2b03      	cmp	r3, #3
    7c20:	d9ee      	bls.n	7c00 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0xa0>
    7c22:	2300      	movs	r3, #0
    7c24:	f884 3f88 	strb.w	r3, [r4, #3976]	; 0xf88
        if (mode == ENIGMA_MODE_LIBRARY && play) ++mode;
    7c28:	f894 33e4 	ldrb.w	r3, [r4, #996]	; 0x3e4
    7c2c:	2b00      	cmp	r3, #0
    7c2e:	d0ec      	beq.n	7c0a <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0xaa>
    7c30:	2301      	movs	r3, #1
    7c32:	f884 3f88 	strb.w	r3, [r4, #3976]	; 0xf88
    7c36:	e7e8      	b.n	7c0a <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0xaa>
            if (mode == ENIGMA_CONFIRM_RESET) {
    7c38:	f894 2f88 	ldrb.w	r2, [r4, #3976]	; 0xf88
    7c3c:	2a04      	cmp	r2, #4
    7c3e:	d108      	bne.n	7c52 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0xf2>
                Start();
    7c40:	4620      	mov	r0, r4
                total_steps = 0;
    7c42:	f8a4 33dc 	strh.w	r3, [r4, #988]	; 0x3dc
                Start();
    7c46:	f7ff fc9d 	bl	7584 <EnigmaTMWS::Start()>
                mode = last_mode;
    7c4a:	f894 3f89 	ldrb.w	r3, [r4, #3977]	; 0xf89
    7c4e:	f884 3f88 	strb.w	r3, [r4, #3976]	; 0xf88
            if (mode == ENIGMA_MODE_LIBRARY && !tm_state.IsFavorite()) {
    7c52:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7c56:	b983      	cbnz	r3, 7c7a <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x11a>
    7c58:	f894 22e7 	ldrb.w	r2, [r4, #743]	; 0x2e7
    7c5c:	b94a      	cbnz	r2, 7c72 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x112>
                if (++tm_param > ENIGMA_TM_ROTATE) tm_param = 0;
    7c5e:	f894 3f8f 	ldrb.w	r3, [r4, #3983]	; 0xf8f
    7c62:	3301      	adds	r3, #1
    7c64:	b25b      	sxtb	r3, r3
    7c66:	2b02      	cmp	r3, #2
    7c68:	bfd4      	ite	le
    7c6a:	f884 3f8f 	strble.w	r3, [r4, #3983]	; 0xf8f
    7c6e:	f884 2f8f 	strbgt.w	r2, [r4, #3983]	; 0xf8f
    7c72:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    7c76:	6263      	str	r3, [r4, #36]	; 0x24
    }
    7c78:	e79d      	b.n	7bb6 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x56>
            if (mode == ENIGMA_MODE_ASSIGN) {
    7c7a:	2b01      	cmp	r3, #1
    7c7c:	d00d      	beq.n	7c9a <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x13a>
            if (mode == ENIGMA_MODE_SONG) {
    7c7e:	2b02      	cmp	r3, #2
    7c80:	d024      	beq.n	7ccc <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x16c>
            if (mode == ENIGMA_MODE_PLAY) {
    7c82:	2b03      	cmp	r3, #3
    7c84:	d1f5      	bne.n	7c72 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x112>
                if (++track_param > ENIGMA_TRACK_LOOP) track_param = ENIGMA_TRACK_DIVIDE;
    7c86:	f894 3f92 	ldrb.w	r3, [r4, #3986]	; 0xf92
    7c8a:	3301      	adds	r3, #1
    7c8c:	b25b      	sxtb	r3, r3
    7c8e:	2b01      	cmp	r3, #1
    7c90:	bfc8      	it	gt
    7c92:	2300      	movgt	r3, #0
    7c94:	f884 3f92 	strb.w	r3, [r4, #3986]	; 0xf92
    7c98:	e7eb      	b.n	7c72 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x112>
                if (output[output_cursor].type() > EnigmaOutputType::NOTE7) {
    7c9a:	f994 2f8d 	ldrsb.w	r2, [r4, #3981]	; 0xf8d
                if (++output_param > ENIGMA_OUTPUT_MIDI_CH) output_param = 0;
    7c9e:	f894 3f90 	ldrb.w	r3, [r4, #3984]	; 0xf90
    byte type() {return ty;}
    7ca2:	f44f 71a4 	mov.w	r1, #328	; 0x148
    7ca6:	fb01 4202 	mla	r2, r1, r2, r4
    7caa:	3301      	adds	r3, #1
    7cac:	b25b      	sxtb	r3, r3
                if (output[output_cursor].type() > EnigmaOutputType::NOTE7) {
    7cae:	f892 2ba9 	ldrb.w	r2, [r2, #2985]	; 0xba9
                if (++output_param > ENIGMA_OUTPUT_MIDI_CH) output_param = 0;
    7cb2:	2b04      	cmp	r3, #4
    7cb4:	bfa8      	it	ge
    7cb6:	2300      	movge	r3, #0
                if (output[output_cursor].type() > EnigmaOutputType::NOTE7) {
    7cb8:	2a04      	cmp	r2, #4
    7cba:	f884 3f90 	strb.w	r3, [r4, #3984]	; 0xf90
    7cbe:	d9d8      	bls.n	7c72 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x112>
                    if (output_param == ENIGMA_OUTPUT_SCALE) output_param = ENIGMA_OUTPUT_MIDI_CH;
    7cc0:	2b02      	cmp	r3, #2
    7cc2:	d1d6      	bne.n	7c72 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x112>
    7cc4:	2303      	movs	r3, #3
    7cc6:	f884 3f90 	strb.w	r3, [r4, #3984]	; 0xf90
    7cca:	e7d2      	b.n	7c72 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x112>
                if (++step_param > ENIGMA_STEP_TRANSPOSE) step_param = ENIGMA_STEP_NUMBER;
    7ccc:	f894 3f91 	ldrb.w	r3, [r4, #3985]	; 0xf91
    7cd0:	3301      	adds	r3, #1
    7cd2:	b25b      	sxtb	r3, r3
    7cd4:	2b05      	cmp	r3, #5
    7cd6:	bfa8      	it	ge
    7cd8:	2300      	movge	r3, #0
    7cda:	f884 3f91 	strb.w	r3, [r4, #3985]	; 0xf91
            if (mode == ENIGMA_MODE_PLAY) {
    7cde:	e7c8      	b.n	7c72 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x112>
            if (mode == ENIGMA_MODE_LIBRARY) {
    7ce0:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7ce4:	b9e3      	cbnz	r3, 7d20 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x1c0>
                tm_state.SetFavorite(1 - tm_state.IsFavorite());
    7ce6:	f894 32e7 	ldrb.w	r3, [r4, #743]	; 0x2e7
        if (write) HS::user_turing_machines[ix].favorite = favorite;
    7cea:	f894 22e8 	ldrb.w	r2, [r4, #744]	; 0x2e8
    7cee:	f083 0301 	eor.w	r3, r3, #1
        fav = favorite;
    7cf2:	f884 32e7 	strb.w	r3, [r4, #743]	; 0x2e7
        if (write) HS::user_turing_machines[ix].favorite = favorite;
    7cf6:	b12a      	cbz	r2, 7d04 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x1a4>
    7cf8:	f894 12e2 	ldrb.w	r1, [r4, #738]	; 0x2e2
    7cfc:	4a1c      	ldr	r2, [pc, #112]	; (7d70 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x210>)
    7cfe:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    7d02:	70d3      	strb	r3, [r2, #3]
                state_prob[tm_cursor] = 0;
    7d04:	f994 1f8c 	ldrsb.w	r1, [r4, #3980]	; 0xf8c
    7d08:	1862      	adds	r2, r4, r1
    7d0a:	2000      	movs	r0, #0
    7d0c:	f882 02ea 	strb.w	r0, [r2, #746]	; 0x2ea
                if (tm_state.IsFavorite()) {
    7d10:	b133      	cbz	r3, 7d20 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x1c0>
                    tm_param = ENIGMA_TM_ROTATE;
    7d12:	2302      	movs	r3, #2
                    SendSingleTuringMachine(tm_cursor);
    7d14:	4815      	ldr	r0, [pc, #84]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
                    tm_param = ENIGMA_TM_ROTATE;
    7d16:	f884 3f8f 	strb.w	r3, [r4, #3983]	; 0xf8f
                    SendSingleTuringMachine(tm_cursor);
    7d1a:	b2c9      	uxtb	r1, r1
    7d1c:	f7ff fd9a 	bl	7854 <EnigmaTMWS::SendSingleTuringMachine(unsigned char)>
            if (mode == ENIGMA_MODE_ASSIGN && !play) assign_audition = 0;
    7d20:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7d24:	2b01      	cmp	r3, #1
    7d26:	d107      	bne.n	7d38 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x1d8>
    7d28:	f894 33e4 	ldrb.w	r3, [r4, #996]	; 0x3e4
    7d2c:	2b00      	cmp	r3, #0
    7d2e:	f47f af4e 	bne.w	7bce <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x6e>
                else assign_audition = last_assign_audition;
    7d32:	f884 3312 	strb.w	r3, [r4, #786]	; 0x312
    7d36:	e74a      	b.n	7bce <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x6e>
            if (mode == ENIGMA_MODE_SONG) InsertStep();
    7d38:	2b02      	cmp	r3, #2
    7d3a:	d102      	bne.n	7d42 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x1e2>
    7d3c:	480b      	ldr	r0, [pc, #44]	; (7d6c <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x20c>)
    7d3e:	f7ff fb65 	bl	740c <EnigmaTMWS::InsertStep()>
            if (mode == ENIGMA_MODE_PLAY) {
    7d42:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7d46:	2b03      	cmp	r3, #3
    7d48:	f47f af41 	bne.w	7bce <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x6e>
                play = 1 - play;
    7d4c:	f894 33e4 	ldrb.w	r3, [r4, #996]	; 0x3e4
    7d50:	f083 0301 	eor.w	r3, r3, #1
    7d54:	f884 33e4 	strb.w	r3, [r4, #996]	; 0x3e4
                if (play) {
    7d58:	b12b      	cbz	r3, 7d66 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x206>
                    last_assign_audition = assign_audition;
    7d5a:	f894 3312 	ldrb.w	r3, [r4, #786]	; 0x312
    7d5e:	f884 3313 	strb.w	r3, [r4, #787]	; 0x313
                    assign_audition = 1;
    7d62:	2301      	movs	r3, #1
    7d64:	e7e5      	b.n	7d32 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x1d2>
                else assign_audition = last_assign_audition;
    7d66:	f894 3313 	ldrb.w	r3, [r4, #787]	; 0x313
    7d6a:	e7e2      	b.n	7d32 <EnigmaTMWS_handleButtonEvent(UI::Event const&)+0x1d2>
    7d6c:	1fffd9ac 	.word	0x1fffd9ac
    7d70:	200036e8 	.word	0x200036e8

00007d74 <EnigmaTMWS::ReceiveTuringMachine(unsigned char*)>:
        byte tm = V[ix++];
    7d74:	7848      	ldrb	r0, [r1, #1]
        if (tm < HS::TURING_MACHINE_COUNT) {
    7d76:	2827      	cmp	r0, #39	; 0x27
    void ReceiveTuringMachine(uint8_t *V) {
    7d78:	b530      	push	{r4, r5, lr}
        if (tm < HS::TURING_MACHINE_COUNT) {
    7d7a:	d80f      	bhi.n	7d9c <EnigmaTMWS::ReceiveTuringMachine(unsigned char*)+0x28>
            uint8_t high = V[ix++];
    7d7c:	78cb      	ldrb	r3, [r1, #3]
    7d7e:	788c      	ldrb	r4, [r1, #2]
            byte favorite = V[ix++];
    7d80:	794a      	ldrb	r2, [r1, #5]
            byte len = V[ix++];
    7d82:	790d      	ldrb	r5, [r1, #4]
    7d84:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
            HS::user_turing_machines[tm].reg = reg;
    7d88:	4b05      	ldr	r3, [pc, #20]	; (7da0 <EnigmaTMWS::ReceiveTuringMachine(unsigned char*)+0x2c>)
            HS::user_turing_machines[tm].favorite = favorite;
    7d8a:	3a00      	subs	r2, #0
            HS::user_turing_machines[tm].reg = reg;
    7d8c:	f823 4020 	strh.w	r4, [r3, r0, lsl #2]
            HS::user_turing_machines[tm].len  = len;
    7d90:	eb03 0380 	add.w	r3, r3, r0, lsl #2
            HS::user_turing_machines[tm].favorite = favorite;
    7d94:	bf18      	it	ne
    7d96:	2201      	movne	r2, #1
            HS::user_turing_machines[tm].len  = len;
    7d98:	709d      	strb	r5, [r3, #2]
            HS::user_turing_machines[tm].favorite = favorite;
    7d9a:	70da      	strb	r2, [r3, #3]
    }
    7d9c:	bd30      	pop	{r4, r5, pc}
    7d9e:	bf00      	nop
    7da0:	200036e8 	.word	0x200036e8

00007da4 <EnigmaTMWS::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    7da4:	b570      	push	{r4, r5, r6, lr}
    7da6:	b08c      	sub	sp, #48	; 0x30
    7da8:	4604      	mov	r4, r0
        if (ExtractSysExData(V, 'T')) {
    7daa:	2254      	movs	r2, #84	; 0x54
    7dac:	4669      	mov	r1, sp
    7dae:	3080      	adds	r0, #128	; 0x80
    7db0:	f7fd fca6 	bl	5700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>
    7db4:	b138      	cbz	r0, 7dc6 <EnigmaTMWS::OnReceiveSysEx()+0x22>
            char type = V[0]; // Type of Enigma data:r=Register, s=Song step, c=Song Config, 1=single TM
    7db6:	f89d 3000 	ldrb.w	r3, [sp]
            if (type == 'r') ReceiveTuringMachine(V);
    7dba:	2b72      	cmp	r3, #114	; 0x72
    7dbc:	d105      	bne.n	7dca <EnigmaTMWS::OnReceiveSysEx()+0x26>
    7dbe:	4669      	mov	r1, sp
    7dc0:	4620      	mov	r0, r4
    7dc2:	f7ff ffd7 	bl	7d74 <EnigmaTMWS::ReceiveTuringMachine(unsigned char*)>
    }
    7dc6:	b00c      	add	sp, #48	; 0x30
    7dc8:	bd70      	pop	{r4, r5, r6, pc}
            if (type == 's') ReceiveSongSteps(V);
    7dca:	2b73      	cmp	r3, #115	; 0x73
    7dcc:	d009      	beq.n	7de2 <EnigmaTMWS::OnReceiveSysEx()+0x3e>
            if (type == 't') ReceiveTrackSettings(V);
    7dce:	2b74      	cmp	r3, #116	; 0x74
    7dd0:	d130      	bne.n	7e34 <EnigmaTMWS::OnReceiveSysEx()+0x90>
        for (byte t = 0; t < 4; t++) track[t].data = V[ix++];
    7dd2:	2204      	movs	r2, #4
    7dd4:	f10d 0101 	add.w	r1, sp, #1
    7dd8:	f604 7084 	addw	r0, r4, #3972	; 0xf84
    7ddc:	f012 f908 	bl	19ff0 <memcpy>
    7de0:	e7f1      	b.n	7dc6 <EnigmaTMWS::OnReceiveSysEx()+0x22>
        byte page = V[ix++];
    7de2:	f89d 1001 	ldrb.w	r1, [sp, #1]
        total_steps = static_cast<uint16_t>((high << 8) | low);
    7de6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    7dea:	f8a4 33dc 	strh.w	r3, [r4, #988]	; 0x3dc
            byte ssi = (page * 8) + s;
    7dee:	00c9      	lsls	r1, r1, #3
    7df0:	b2c9      	uxtb	r1, r1
    7df2:	466a      	mov	r2, sp
    7df4:	2000      	movs	r0, #0
    7df6:	180b      	adds	r3, r1, r0
    7df8:	b2db      	uxtb	r3, r3
    7dfa:	eb04 0383 	add.w	r3, r4, r3, lsl #2
            song_step[ssi].tk = V[ix++];
    7dfe:	7915      	ldrb	r5, [r2, #4]
    7e00:	f883 5424 	strb.w	r5, [r3, #1060]	; 0x424
            song_step[ssi].pr = V[ix++];
    7e04:	7955      	ldrb	r5, [r2, #5]
    7e06:	f883 5425 	strb.w	r5, [r3, #1061]	; 0x425
        for (byte s = 0; s < 8; s++)
    7e0a:	3001      	adds	r0, #1
            song_step[ssi].re = V[ix++];
    7e0c:	7995      	ldrb	r5, [r2, #6]
    7e0e:	f883 5426 	strb.w	r5, [r3, #1062]	; 0x426
        for (byte s = 0; s < 8; s++)
    7e12:	2808      	cmp	r0, #8
            song_step[ssi].tr = V[ix++];
    7e14:	79d5      	ldrb	r5, [r2, #7]
    7e16:	f883 5427 	strb.w	r5, [r3, #1063]	; 0x427
        for (byte s = 0; s < 8; s++)
    7e1a:	f102 0204 	add.w	r2, r2, #4
    7e1e:	d1ea      	bne.n	7df6 <EnigmaTMWS::OnReceiveSysEx()+0x52>
        BuildTrackStepList(0);
    7e20:	2100      	movs	r1, #0
    7e22:	4620      	mov	r0, r4
    7e24:	f7ff fa58 	bl	72d8 <EnigmaTMWS::BuildTrackStepList(unsigned char)>
        track_cursor = 0;
    7e28:	2300      	movs	r3, #0
    7e2a:	f884 3f8e 	strb.w	r3, [r4, #3982]	; 0xf8e
        edit_index = 0;
    7e2e:	f8a4 3f8a 	strh.w	r3, [r4, #3978]	; 0xf8a
            if (type == '1') {
    7e32:	e7c8      	b.n	7dc6 <EnigmaTMWS::OnReceiveSysEx()+0x22>
            if (type == 'o') ReceiveOutputAssignments(V);
    7e34:	2b6f      	cmp	r3, #111	; 0x6f
    7e36:	d01d      	beq.n	7e74 <EnigmaTMWS::OnReceiveSysEx()+0xd0>
            if (type == '1') {
    7e38:	2b31      	cmp	r3, #49	; 0x31
    7e3a:	d1c4      	bne.n	7dc6 <EnigmaTMWS::OnReceiveSysEx()+0x22>
                if (mode == ENIGMA_MODE_LIBRARY) V[1] = tm_cursor;
    7e3c:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
    7e40:	b91b      	cbnz	r3, 7e4a <EnigmaTMWS::OnReceiveSysEx()+0xa6>
    7e42:	f894 3f8c 	ldrb.w	r3, [r4, #3980]	; 0xf8c
    7e46:	f88d 3001 	strb.w	r3, [sp, #1]
                if (!HS::user_turing_machines[V[1]].favorite) {
    7e4a:	4d15      	ldr	r5, [pc, #84]	; (7ea0 <EnigmaTMWS::OnReceiveSysEx()+0xfc>)
    7e4c:	f89d 3001 	ldrb.w	r3, [sp, #1]
    7e50:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    7e54:	78de      	ldrb	r6, [r3, #3]
    7e56:	2e00      	cmp	r6, #0
    7e58:	d1b5      	bne.n	7dc6 <EnigmaTMWS::OnReceiveSysEx()+0x22>
                    ReceiveTuringMachine(V);
    7e5a:	4669      	mov	r1, sp
    7e5c:	4620      	mov	r0, r4
    7e5e:	f7ff ff89 	bl	7d74 <EnigmaTMWS::ReceiveTuringMachine(unsigned char*)>
                    HS::user_turing_machines[V[1]].favorite = 0; // Favorite off, so that update may be automated in performance
    7e62:	f89d 1001 	ldrb.w	r1, [sp, #1]
    7e66:	eb05 0581 	add.w	r5, r5, r1, lsl #2
                    SwitchTuringMachine(V[1]);
    7e6a:	4620      	mov	r0, r4
                    HS::user_turing_machines[V[1]].favorite = 0; // Favorite off, so that update may be automated in performance
    7e6c:	70ee      	strb	r6, [r5, #3]
                    SwitchTuringMachine(V[1]);
    7e6e:	f7ff f8e1 	bl	7034 <EnigmaTMWS::SwitchTuringMachine(unsigned char)>
    }
    7e72:	e7a8      	b.n	7dc6 <EnigmaTMWS::OnReceiveSysEx()+0x22>
    7e74:	466b      	mov	r3, sp
    7e76:	f504 62a4 	add.w	r2, r4, #1312	; 0x520
            output[o].tk = V[ix++];
    7e7a:	7859      	ldrb	r1, [r3, #1]
    7e7c:	f884 1ba8 	strb.w	r1, [r4, #2984]	; 0xba8
            output[o].ty = V[ix++];
    7e80:	7899      	ldrb	r1, [r3, #2]
    7e82:	f884 1ba9 	strb.w	r1, [r4, #2985]	; 0xba9
            output[o].sc = V[ix++];
    7e86:	78d9      	ldrb	r1, [r3, #3]
    7e88:	f884 1baa 	strb.w	r1, [r4, #2986]	; 0xbaa
            output[o].mc = V[ix++];
    7e8c:	f813 1f04 	ldrb.w	r1, [r3, #4]!
    7e90:	f884 1bab 	strb.w	r1, [r4, #2987]	; 0xbab
        for (byte o = 0; o < 4; o++)
    7e94:	f504 74a4 	add.w	r4, r4, #328	; 0x148
    7e98:	4294      	cmp	r4, r2
    7e9a:	d1ee      	bne.n	7e7a <EnigmaTMWS::OnReceiveSysEx()+0xd6>
    7e9c:	e793      	b.n	7dc6 <EnigmaTMWS::OnReceiveSysEx()+0x22>
    7e9e:	bf00      	nop
    7ea0:	200036e8 	.word	0x200036e8

00007ea4 <non-virtual thunk to EnigmaTMWS::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    7ea4:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    7ea8:	e77c      	b.n	7da4 <EnigmaTMWS::OnReceiveSysEx()>
    7eaa:	bf00      	nop

00007eac <ClockManager::get()>:
    static ClockManager *get() {
    7eac:	b538      	push	{r3, r4, r5, lr}
        if (!instance) instance = new ClockManager;
    7eae:	4d0a      	ldr	r5, [pc, #40]	; (7ed8 <ClockManager::get()+0x2c>)
    7eb0:	682c      	ldr	r4, [r5, #0]
    7eb2:	b97c      	cbnz	r4, 7ed4 <ClockManager::get()+0x28>
    7eb4:	2018      	movs	r0, #24
    7eb6:	f012 f9cd 	bl	1a254 <operator new(unsigned int)>
        ticks_per_tock = 1000000 / bpm;
    7eba:	f242 038d 	movw	r3, #8333	; 0x208d
        last_tock_tick = 0;
    7ebe:	e9c0 3400 	strd	r3, r4, [r0]
        tempo = bpm;
    7ec2:	2378      	movs	r3, #120	; 0x78
    7ec4:	81c3      	strh	r3, [r0, #14]
        running = 0;
    7ec6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
        last_tock_check = 0;
    7eca:	6084      	str	r4, [r0, #8]
        tock = 0;
    7ecc:	7304      	strb	r4, [r0, #12]
        running = 0;
    7ece:	6103      	str	r3, [r0, #16]
        count = 0;
    7ed0:	8284      	strh	r4, [r0, #20]
        if (!instance) instance = new ClockManager;
    7ed2:	6028      	str	r0, [r5, #0]
    }
    7ed4:	6828      	ldr	r0, [r5, #0]
    7ed6:	bd38      	pop	{r3, r4, r5, pc}
    7ed8:	2000365c 	.word	0x2000365c

00007edc <ClockManager::IsRunning()>:

    void Unpause() {paused = 0;}

    void ToggleForwarding() {forwarded = 1 - forwarded;}

    bool IsRunning() {return (running && !paused);}
    7edc:	4603      	mov	r3, r0
    7ede:	7c00      	ldrb	r0, [r0, #16]
    7ee0:	b110      	cbz	r0, 7ee8 <ClockManager::IsRunning()+0xc>
    7ee2:	7c58      	ldrb	r0, [r3, #17]
    7ee4:	f080 0001 	eor.w	r0, r0, #1
    7ee8:	4770      	bx	lr
    7eea:	Address 0x0000000000007eea is out of bounds.


00007eec <ClockSetup_OnEncoderMove(bool, int)>:
        if (cursor == 0) { // Source
    7eec:	4b1b      	ldr	r3, [pc, #108]	; (7f5c <ClockSetup_OnEncoderMove(bool, int)+0x70>)
    7eee:	2274      	movs	r2, #116	; 0x74
    7ef0:	fb02 3000 	mla	r0, r2, r0, r3
void ClockSetup_OnEncoderMove(bool hemisphere, int direction) {ClockSetup_instance[hemisphere].OnEncoderMove(direction);}
    7ef4:	b510      	push	{r4, lr}
        if (cursor == 0) { // Source
    7ef6:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    7ef8:	b96b      	cbnz	r3, 7f16 <ClockSetup_OnEncoderMove(bool, int)+0x2a>
            if (clock_m->IsRunning() || clock_m->IsPaused()) clock_m->Stop();
    7efa:	6f04      	ldr	r4, [r0, #112]	; 0x70
    7efc:	4620      	mov	r0, r4
    7efe:	f7ff ffed 	bl	7edc <ClockManager::IsRunning()>
    7f02:	b908      	cbnz	r0, 7f08 <ClockSetup_OnEncoderMove(bool, int)+0x1c>
    7f04:	7c63      	ldrb	r3, [r4, #17]
    7f06:	b113      	cbz	r3, 7f0e <ClockSetup_OnEncoderMove(bool, int)+0x22>
        running = 0;
    7f08:	2300      	movs	r3, #0
        running = 1;
    7f0a:	8223      	strh	r3, [r4, #16]
void ClockSetup_OnEncoderMove(bool hemisphere, int direction) {ClockSetup_instance[hemisphere].OnEncoderMove(direction);}
    7f0c:	bd10      	pop	{r4, pc}
        forwarded = 0;
    7f0e:	7563      	strb	r3, [r4, #21]
        running = 1;
    7f10:	f240 1301 	movw	r3, #257	; 0x101
    7f14:	e7f9      	b.n	7f0a <ClockSetup_OnEncoderMove(bool, int)+0x1e>
        if (cursor == 1) { // Set tempo
    7f16:	2b01      	cmp	r3, #1
    7f18:	d00c      	beq.n	7f34 <ClockSetup_OnEncoderMove(bool, int)+0x48>
        if (cursor == 2) { // Set multiplier
    7f1a:	2b02      	cmp	r3, #2
    7f1c:	d1f6      	bne.n	7f0c <ClockSetup_OnEncoderMove(bool, int)+0x20>
    7f1e:	6f02      	ldr	r2, [r0, #112]	; 0x70
            mult += direction;
    7f20:	7c93      	ldrb	r3, [r2, #18]
    7f22:	440b      	add	r3, r1
    7f24:	b25b      	sxtb	r3, r3
        multiply = constrain(multiply, 1, 24);
    7f26:	2b00      	cmp	r3, #0
    7f28:	dd16      	ble.n	7f58 <ClockSetup_OnEncoderMove(bool, int)+0x6c>
    7f2a:	2b18      	cmp	r3, #24
    7f2c:	bfa8      	it	ge
    7f2e:	2318      	movge	r3, #24
    7f30:	7493      	strb	r3, [r2, #18]
void ClockSetup_OnEncoderMove(bool hemisphere, int direction) {ClockSetup_instance[hemisphere].OnEncoderMove(direction);}
    7f32:	e7eb      	b.n	7f0c <ClockSetup_OnEncoderMove(bool, int)+0x20>
            uint16_t bpm = clock_m->GetTempo();
    7f34:	6f03      	ldr	r3, [r0, #112]	; 0x70
            bpm += direction;
    7f36:	89da      	ldrh	r2, [r3, #14]
    7f38:	4411      	add	r1, r2
    7f3a:	b289      	uxth	r1, r1
    7f3c:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
    7f40:	bf28      	it	cs
    7f42:	f44f 7196 	movcs.w	r1, #300	; 0x12c
    7f46:	290a      	cmp	r1, #10
    7f48:	bf38      	it	cc
    7f4a:	210a      	movcc	r1, #10
        ticks_per_tock = 1000000 / bpm;
    7f4c:	4a04      	ldr	r2, [pc, #16]	; (7f60 <ClockSetup_OnEncoderMove(bool, int)+0x74>)
        tempo = bpm;
    7f4e:	81d9      	strh	r1, [r3, #14]
        ticks_per_tock = 1000000 / bpm;
    7f50:	fbb2 f2f1 	udiv	r2, r2, r1
    7f54:	601a      	str	r2, [r3, #0]
        if (cursor == 2) { // Set multiplier
    7f56:	e7d9      	b.n	7f0c <ClockSetup_OnEncoderMove(bool, int)+0x20>
        multiply = constrain(multiply, 1, 24);
    7f58:	2301      	movs	r3, #1
    7f5a:	e7e9      	b.n	7f30 <ClockSetup_OnEncoderMove(bool, int)+0x44>
    7f5c:	1fffca50 	.word	0x1fffca50
    7f60:	000f4240 	.word	0x000f4240

00007f64 <ClockManager::Tock()>:

    bool IsForwarded() {return forwarded;}

    /* Returns true if the clock should fire on this tick, based on the current tempo */
    bool Tock() {
        uint32_t now = OC::CORE::ticks;
    7f64:	4912      	ldr	r1, [pc, #72]	; (7fb0 <ClockManager::Tock()+0x4c>)
        if (now != last_tock_check) {
    7f66:	6883      	ldr	r3, [r0, #8]
        uint32_t now = OC::CORE::ticks;
    7f68:	680a      	ldr	r2, [r1, #0]
        if (now != last_tock_check) {
    7f6a:	4293      	cmp	r3, r2
    bool Tock() {
    7f6c:	b530      	push	{r4, r5, lr}
        if (now != last_tock_check) {
    7f6e:	d01a      	beq.n	7fa6 <ClockManager::Tock()+0x42>
            last_tock_check = now;
            if (now >= (last_tock_tick + (ticks_per_tock / static_cast<uint32_t>(tocks_per_beat)))) {
    7f70:	6845      	ldr	r5, [r0, #4]
    7f72:	f990 4012 	ldrsb.w	r4, [r0, #18]
    7f76:	6803      	ldr	r3, [r0, #0]
    7f78:	fbb3 f3f4 	udiv	r3, r3, r4
    7f7c:	442b      	add	r3, r5
    7f7e:	4293      	cmp	r3, r2
            last_tock_check = now;
    7f80:	6082      	str	r2, [r0, #8]
            if (now >= (last_tock_tick + (ticks_per_tock / static_cast<uint32_t>(tocks_per_beat)))) {
    7f82:	d812      	bhi.n	7faa <ClockManager::Tock()+0x46>
                tock = 1;
    7f84:	2301      	movs	r3, #1
    7f86:	7303      	strb	r3, [r0, #12]
                last_tock_tick = now;
                if (++count >= tocks_per_beat) Reset();
    7f88:	7d03      	ldrb	r3, [r0, #20]
                last_tock_tick = now;
    7f8a:	6042      	str	r2, [r0, #4]
                if (++count >= tocks_per_beat) Reset();
    7f8c:	3301      	adds	r3, #1
    7f8e:	b2db      	uxtb	r3, r3
    7f90:	42a3      	cmp	r3, r4
    7f92:	7503      	strb	r3, [r0, #20]
    7f94:	db07      	blt.n	7fa6 <ClockManager::Tock()+0x42>
        last_tock_tick = OC::CORE::ticks;
    7f96:	680b      	ldr	r3, [r1, #0]
    7f98:	6043      	str	r3, [r0, #4]
        count = 0;
    7f9a:	2300      	movs	r3, #0
    7f9c:	7503      	strb	r3, [r0, #20]
        cycle = 1 - cycle;
    7f9e:	7cc3      	ldrb	r3, [r0, #19]
    7fa0:	f083 0301 	eor.w	r3, r3, #1
    7fa4:	74c3      	strb	r3, [r0, #19]
            } else tock = 0;
        }
        return tock;
    }
    7fa6:	7b00      	ldrb	r0, [r0, #12]
    7fa8:	bd30      	pop	{r4, r5, pc}
            } else tock = 0;
    7faa:	2300      	movs	r3, #0
    7fac:	7303      	strb	r3, [r0, #12]
    7fae:	e7fa      	b.n	7fa6 <ClockManager::Tock()+0x42>
    7fb0:	200046cc 	.word	0x200046cc

00007fb4 <HemisphereApplet::BaseStart(bool)>:
        gfx_offset = hemisphere * 64;
    7fb4:	018b      	lsls	r3, r1, #6
    void BaseStart(bool hemisphere_) {
    7fb6:	b510      	push	{r4, lr}
        gfx_offset = hemisphere * 64;
    7fb8:	6183      	str	r3, [r0, #24]
        io_offset = hemisphere * 2;
    7fba:	004b      	lsls	r3, r1, #1
    7fbc:	61c3      	str	r3, [r0, #28]
            clock_countdown[ch]  = 0;
    7fbe:	2300      	movs	r3, #0
    7fc0:	6403      	str	r3, [r0, #64]	; 0x40
            inputs[ch] = 0;
    7fc2:	6203      	str	r3, [r0, #32]
            outputs[ch] = 0;
    7fc4:	6283      	str	r3, [r0, #40]	; 0x28
            adc_lag_countdown[ch] = 0;
    7fc6:	64c3      	str	r3, [r0, #76]	; 0x4c
            clock_countdown[ch]  = 0;
    7fc8:	6443      	str	r3, [r0, #68]	; 0x44
            inputs[ch] = 0;
    7fca:	6243      	str	r3, [r0, #36]	; 0x24
            outputs[ch] = 0;
    7fcc:	62c3      	str	r3, [r0, #44]	; 0x2c
            adc_lag_countdown[ch] = 0;
    7fce:	6503      	str	r3, [r0, #80]	; 0x50
        help_active = 0;
    7fd0:	65c3      	str	r3, [r0, #92]	; 0x5c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    7fd2:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    void BaseStart(bool hemisphere_) {
    7fd6:	4604      	mov	r4, r0
        hemisphere = hemisphere_;
    7fd8:	7101      	strb	r1, [r0, #4]
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    7fda:	6483      	str	r3, [r0, #72]	; 0x48
        if (hemisphere == 0)
    7fdc:	b919      	cbnz	r1, 7fe6 <HemisphereApplet::BaseStart(bool)+0x32>
            FreqMeasure.end();
    7fde:	f010 ff63 	bl	18ea8 <FreqMeasureClass::end()>
            OC::DigitalInputs::reInit();
    7fe2:	f7f8 ff47 	bl	e74 <OC::DigitalInputs::reInit()>
        if (!applet_started) {
    7fe6:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
    7fea:	b943      	cbnz	r3, 7ffe <HemisphereApplet::BaseStart(bool)+0x4a>
            applet_started = true;
    7fec:	2301      	movs	r3, #1
    7fee:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
            Start();
    7ff2:	6823      	ldr	r3, [r4, #0]
    7ff4:	4620      	mov	r0, r4
    7ff6:	685b      	ldr	r3, [r3, #4]
    }
    7ff8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            Start();
    7ffc:	4718      	bx	r3
    }
    7ffe:	bd10      	pop	{r4, pc}

00008000 <ADEG_Start(bool)>:
void ADEG_Start(bool hemisphere) {ADEG_instance[hemisphere].BaseStart(hemisphere);}
    8000:	b508      	push	{r3, lr}
    8002:	4b04      	ldr	r3, [pc, #16]	; (8014 <ADEG_Start(bool)+0x14>)
    8004:	4601      	mov	r1, r0
    8006:	2090      	movs	r0, #144	; 0x90
    8008:	fb00 3001 	mla	r0, r0, r1, r3
    800c:	f7ff ffd2 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    8010:	bd08      	pop	{r3, pc}
    8012:	bf00      	nop
    8014:	1fffa8c8 	.word	0x1fffa8c8

00008018 <ADSREG_Start(bool)>:
void ADSREG_Start(bool hemisphere) {
    8018:	b508      	push	{r3, lr}
    ADSREG_instance[hemisphere].BaseStart(hemisphere);
    801a:	4b04      	ldr	r3, [pc, #16]	; (802c <ADSREG_Start(bool)+0x14>)
void ADSREG_Start(bool hemisphere) {
    801c:	4601      	mov	r1, r0
    ADSREG_instance[hemisphere].BaseStart(hemisphere);
    801e:	20a4      	movs	r0, #164	; 0xa4
    8020:	fb00 3001 	mla	r0, r0, r1, r3
    8024:	f7ff ffc6 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8028:	bd08      	pop	{r3, pc}
    802a:	bf00      	nop
    802c:	1fffa9e8 	.word	0x1fffa9e8

00008030 <ASR_Start(bool)>:
void ASR_Start(bool hemisphere) {ASR_instance[hemisphere].BaseStart(hemisphere);}
    8030:	b508      	push	{r3, lr}
    8032:	4b04      	ldr	r3, [pc, #16]	; (8044 <ASR_Start(bool)+0x14>)
    8034:	4601      	mov	r1, r0
    8036:	f44f 70da 	mov.w	r0, #436	; 0x1b4
    803a:	fb00 3001 	mla	r0, r0, r1, r3
    803e:	f7ff ffb9 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    8042:	bd08      	pop	{r3, pc}
    8044:	1fffab30 	.word	0x1fffab30

00008048 <AnnularFusion_Start(bool)>:
void AnnularFusion_Start(bool hemisphere) {
    8048:	b508      	push	{r3, lr}
    AnnularFusion_instance[hemisphere].BaseStart(hemisphere);
    804a:	4b04      	ldr	r3, [pc, #16]	; (805c <AnnularFusion_Start(bool)+0x14>)
void AnnularFusion_Start(bool hemisphere) {
    804c:	4601      	mov	r1, r0
    AnnularFusion_instance[hemisphere].BaseStart(hemisphere);
    804e:	f44f 708a 	mov.w	r0, #276	; 0x114
    8052:	fb00 3001 	mla	r0, r0, r1, r3
    8056:	f7ff ffad 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    805a:	bd08      	pop	{r3, pc}
    805c:	1fffae98 	.word	0x1fffae98

00008060 <AttenuateOffset_Start(bool)>:
void AttenuateOffset_Start(bool hemisphere) {AttenuateOffset_instance[hemisphere].BaseStart(hemisphere);}
    8060:	b508      	push	{r3, lr}
    8062:	4601      	mov	r1, r0
    8064:	4802      	ldr	r0, [pc, #8]	; (8070 <AttenuateOffset_Start(bool)+0x10>)
    8066:	eb00 10c1 	add.w	r0, r0, r1, lsl #7
    806a:	f7ff ffa3 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    806e:	bd08      	pop	{r3, pc}
    8070:	1fffb0c0 	.word	0x1fffb0c0

00008074 <Binary_Start(bool)>:
void Binary_Start(bool hemisphere) {
    8074:	b508      	push	{r3, lr}
    Binary_instance[hemisphere].BaseStart(hemisphere);
    8076:	4b04      	ldr	r3, [pc, #16]	; (8088 <Binary_Start(bool)+0x14>)
void Binary_Start(bool hemisphere) {
    8078:	4601      	mov	r1, r0
    Binary_instance[hemisphere].BaseStart(hemisphere);
    807a:	20e4      	movs	r0, #228	; 0xe4
    807c:	fb00 3001 	mla	r0, r0, r1, r3
    8080:	f7ff ff98 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8084:	bd08      	pop	{r3, pc}
    8086:	bf00      	nop
    8088:	1fffb1c8 	.word	0x1fffb1c8

0000808c <BootsNCat_Start(bool)>:
void BootsNCat_Start(bool hemisphere) {BootsNCat_instance[hemisphere].BaseStart(hemisphere);}
    808c:	b508      	push	{r3, lr}
    808e:	4b04      	ldr	r3, [pc, #16]	; (80a0 <BootsNCat_Start(bool)+0x14>)
    8090:	4601      	mov	r1, r0
    8092:	f44f 70b6 	mov.w	r0, #364	; 0x16c
    8096:	fb00 3001 	mla	r0, r0, r1, r3
    809a:	f7ff ff8b 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    809e:	bd08      	pop	{r3, pc}
    80a0:	1fffb390 	.word	0x1fffb390

000080a4 <Brancher_Start(bool)>:
void Brancher_Start(bool hemisphere) {
    80a4:	b508      	push	{r3, lr}
    Brancher_instance[hemisphere].BaseStart(hemisphere);
    80a6:	4b04      	ldr	r3, [pc, #16]	; (80b8 <Brancher_Start(bool)+0x14>)
void Brancher_Start(bool hemisphere) {
    80a8:	4601      	mov	r1, r0
    Brancher_instance[hemisphere].BaseStart(hemisphere);
    80aa:	2074      	movs	r0, #116	; 0x74
    80ac:	fb00 3001 	mla	r0, r0, r1, r3
    80b0:	f7ff ff80 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    80b4:	bd08      	pop	{r3, pc}
    80b6:	bf00      	nop
    80b8:	1fffb668 	.word	0x1fffb668

000080bc <Burst_Start(bool)>:
void Burst_Start(bool hemisphere) {
    80bc:	b508      	push	{r3, lr}
    Burst_instance[hemisphere].BaseStart(hemisphere);
    80be:	4b04      	ldr	r3, [pc, #16]	; (80d0 <Burst_Start(bool)+0x14>)
void Burst_Start(bool hemisphere) {
    80c0:	4601      	mov	r1, r0
    Burst_instance[hemisphere].BaseStart(hemisphere);
    80c2:	2090      	movs	r0, #144	; 0x90
    80c4:	fb00 3001 	mla	r0, r0, r1, r3
    80c8:	f7ff ff74 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    80cc:	bd08      	pop	{r3, pc}
    80ce:	bf00      	nop
    80d0:	1fffb750 	.word	0x1fffb750

000080d4 <CVRecV2_Start(bool)>:
void CVRecV2_Start(bool hemisphere) {CVRecV2_instance[hemisphere].BaseStart(hemisphere);}
    80d4:	b508      	push	{r3, lr}
    80d6:	4b04      	ldr	r3, [pc, #16]	; (80e8 <CVRecV2_Start(bool)+0x14>)
    80d8:	4601      	mov	r1, r0
    80da:	f240 60fc 	movw	r0, #1788	; 0x6fc
    80de:	fb00 3001 	mla	r0, r0, r1, r3
    80e2:	f7ff ff67 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    80e6:	bd08      	pop	{r3, pc}
    80e8:	1fffb878 	.word	0x1fffb878

000080ec <Calculate_Start(bool)>:
void Calculate_Start(bool hemisphere) {
    80ec:	b508      	push	{r3, lr}
    Calculate_instance[hemisphere].BaseStart(hemisphere);
    80ee:	4b04      	ldr	r3, [pc, #16]	; (8100 <Calculate_Start(bool)+0x14>)
void Calculate_Start(bool hemisphere) {
    80f0:	4601      	mov	r1, r0
    Calculate_instance[hemisphere].BaseStart(hemisphere);
    80f2:	20bc      	movs	r0, #188	; 0xbc
    80f4:	fb00 3001 	mla	r0, r0, r1, r3
    80f8:	f7ff ff5c 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    80fc:	bd08      	pop	{r3, pc}
    80fe:	bf00      	nop
    8100:	1fffc670 	.word	0x1fffc670

00008104 <Carpeggio_Start(bool)>:
void Carpeggio_Start(bool hemisphere) {
    8104:	b508      	push	{r3, lr}
    Carpeggio_instance[hemisphere].BaseStart(hemisphere);
    8106:	4b04      	ldr	r3, [pc, #16]	; (8118 <Carpeggio_Start(bool)+0x14>)
void Carpeggio_Start(bool hemisphere) {
    8108:	4601      	mov	r1, r0
    Carpeggio_instance[hemisphere].BaseStart(hemisphere);
    810a:	20a8      	movs	r0, #168	; 0xa8
    810c:	fb00 3001 	mla	r0, r0, r1, r3
    8110:	f7ff ff50 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8114:	bd08      	pop	{r3, pc}
    8116:	bf00      	nop
    8118:	1fffc7e8 	.word	0x1fffc7e8

0000811c <ClockDivider_Start(bool)>:
void ClockDivider_Start(bool hemisphere) {
    811c:	b508      	push	{r3, lr}
    ClockDivider_instance[hemisphere].BaseStart(hemisphere);
    811e:	4b04      	ldr	r3, [pc, #16]	; (8130 <ClockDivider_Start(bool)+0x14>)
void ClockDivider_Start(bool hemisphere) {
    8120:	4601      	mov	r1, r0
    ClockDivider_instance[hemisphere].BaseStart(hemisphere);
    8122:	208c      	movs	r0, #140	; 0x8c
    8124:	fb00 3001 	mla	r0, r0, r1, r3
    8128:	f7ff ff44 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    812c:	bd08      	pop	{r3, pc}
    812e:	bf00      	nop
    8130:	1fffc938 	.word	0x1fffc938

00008134 <ClockSetup_Start(bool)>:
void ClockSetup_Start(bool hemisphere) {ClockSetup_instance[hemisphere].BaseStart(hemisphere);}
    8134:	b508      	push	{r3, lr}
    8136:	4b04      	ldr	r3, [pc, #16]	; (8148 <ClockSetup_Start(bool)+0x14>)
    8138:	4601      	mov	r1, r0
    813a:	2074      	movs	r0, #116	; 0x74
    813c:	fb00 3001 	mla	r0, r0, r1, r3
    8140:	f7ff ff38 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    8144:	bd08      	pop	{r3, pc}
    8146:	bf00      	nop
    8148:	1fffca50 	.word	0x1fffca50

0000814c <ClockSkip_Start(bool)>:
void ClockSkip_Start(bool hemisphere) {
    814c:	b508      	push	{r3, lr}
    ClockSkip_instance[hemisphere].BaseStart(hemisphere);
    814e:	4b04      	ldr	r3, [pc, #16]	; (8160 <ClockSkip_Start(bool)+0x14>)
void ClockSkip_Start(bool hemisphere) {
    8150:	4601      	mov	r1, r0
    ClockSkip_instance[hemisphere].BaseStart(hemisphere);
    8152:	207c      	movs	r0, #124	; 0x7c
    8154:	fb00 3001 	mla	r0, r0, r1, r3
    8158:	f7ff ff2c 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    815c:	bd08      	pop	{r3, pc}
    815e:	bf00      	nop
    8160:	1fffcac4 	.word	0x1fffcac4

00008164 <Compare_Start(bool)>:
void Compare_Start(bool hemisphere) {
    8164:	b508      	push	{r3, lr}
    Compare_instance[hemisphere].BaseStart(hemisphere);
    8166:	4b04      	ldr	r3, [pc, #16]	; (8178 <Compare_Start(bool)+0x14>)
void Compare_Start(bool hemisphere) {
    8168:	4601      	mov	r1, r0
    Compare_instance[hemisphere].BaseStart(hemisphere);
    816a:	2078      	movs	r0, #120	; 0x78
    816c:	fb00 3001 	mla	r0, r0, r1, r3
    8170:	f7ff ff20 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8174:	bd08      	pop	{r3, pc}
    8176:	bf00      	nop
    8178:	1fffcbbc 	.word	0x1fffcbbc

0000817c <DrCrusher_Start(bool)>:
void DrCrusher_Start(bool hemisphere) {DrCrusher_instance[hemisphere].BaseStart(hemisphere);}
    817c:	b508      	push	{r3, lr}
    817e:	4b04      	ldr	r3, [pc, #16]	; (8190 <DrCrusher_Start(bool)+0x14>)
    8180:	4601      	mov	r1, r0
    8182:	207c      	movs	r0, #124	; 0x7c
    8184:	fb00 3001 	mla	r0, r0, r1, r3
    8188:	f7ff ff14 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    818c:	bd08      	pop	{r3, pc}
    818e:	bf00      	nop
    8190:	1fffccac 	.word	0x1fffccac

00008194 <DualQuant_Start(bool)>:
void DualQuant_Start(bool hemisphere) {
    8194:	b508      	push	{r3, lr}
    DualQuant_instance[hemisphere].BaseStart(hemisphere);
    8196:	4b04      	ldr	r3, [pc, #16]	; (81a8 <DualQuant_Start(bool)+0x14>)
void DualQuant_Start(bool hemisphere) {
    8198:	4601      	mov	r1, r0
    DualQuant_instance[hemisphere].BaseStart(hemisphere);
    819a:	f44f 703e 	mov.w	r0, #760	; 0x2f8
    819e:	fb00 3001 	mla	r0, r0, r1, r3
    81a2:	f7ff ff07 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    81a6:	bd08      	pop	{r3, pc}
    81a8:	1fffcda4 	.word	0x1fffcda4

000081ac <EnigmaJr_Start(bool)>:
void EnigmaJr_Start(bool hemisphere) {EnigmaJr_instance[hemisphere].BaseStart(hemisphere);}
    81ac:	b508      	push	{r3, lr}
    81ae:	4b04      	ldr	r3, [pc, #16]	; (81c0 <EnigmaJr_Start(bool)+0x14>)
    81b0:	4601      	mov	r1, r0
    81b2:	f44f 7043 	mov.w	r0, #780	; 0x30c
    81b6:	fb00 3001 	mla	r0, r0, r1, r3
    81ba:	f7ff fefb 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    81be:	bd08      	pop	{r3, pc}
    81c0:	1fffd394 	.word	0x1fffd394

000081c4 <EnvFollow_Start(bool)>:
void EnvFollow_Start(bool hemisphere) {EnvFollow_instance[hemisphere].BaseStart(hemisphere);}
    81c4:	b508      	push	{r3, lr}
    81c6:	4b04      	ldr	r3, [pc, #16]	; (81d8 <EnvFollow_Start(bool)+0x14>)
    81c8:	4601      	mov	r1, r0
    81ca:	2090      	movs	r0, #144	; 0x90
    81cc:	fb00 3001 	mla	r0, r0, r1, r3
    81d0:	f7ff fef0 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    81d4:	bd08      	pop	{r3, pc}
    81d6:	bf00      	nop
    81d8:	1fffe940 	.word	0x1fffe940

000081dc <GateDelay_Start(bool)>:
void GateDelay_Start(bool hemisphere) {
    81dc:	b508      	push	{r3, lr}
    GateDelay_instance[hemisphere].BaseStart(hemisphere);
    81de:	4b04      	ldr	r3, [pc, #16]	; (81f0 <GateDelay_Start(bool)+0x14>)
void GateDelay_Start(bool hemisphere) {
    81e0:	4601      	mov	r1, r0
    GateDelay_instance[hemisphere].BaseStart(hemisphere);
    81e2:	f44f 7021 	mov.w	r0, #644	; 0x284
    81e6:	fb00 3001 	mla	r0, r0, r1, r3
    81ea:	f7ff fee3 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    81ee:	bd08      	pop	{r3, pc}
    81f0:	1fffea60 	.word	0x1fffea60

000081f4 <GatedVCA_Start(bool)>:
void GatedVCA_Start(bool hemisphere) {
    81f4:	b508      	push	{r3, lr}
    GatedVCA_instance[hemisphere].BaseStart(hemisphere);
    81f6:	4b04      	ldr	r3, [pc, #16]	; (8208 <GatedVCA_Start(bool)+0x14>)
void GatedVCA_Start(bool hemisphere) {
    81f8:	4601      	mov	r1, r0
    GatedVCA_instance[hemisphere].BaseStart(hemisphere);
    81fa:	2074      	movs	r0, #116	; 0x74
    81fc:	fb00 3001 	mla	r0, r0, r1, r3
    8200:	f7ff fed8 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8204:	bd08      	pop	{r3, pc}
    8206:	bf00      	nop
    8208:	1fffef68 	.word	0x1fffef68

0000820c <LoFiPCM_Start(bool)>:
void LoFiPCM_Start(bool hemisphere) {
    820c:	b508      	push	{r3, lr}
    LoFiPCM_instance[hemisphere].BaseStart(hemisphere);
    820e:	4b04      	ldr	r3, [pc, #16]	; (8220 <LoFiPCM_Start(bool)+0x14>)
void LoFiPCM_Start(bool hemisphere) {
    8210:	4601      	mov	r1, r0
    LoFiPCM_instance[hemisphere].BaseStart(hemisphere);
    8212:	f640 007c 	movw	r0, #2172	; 0x87c
    8216:	fb00 3001 	mla	r0, r0, r1, r3
    821a:	f7ff fecb 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    821e:	bd08      	pop	{r3, pc}
    8220:	1ffff054 	.word	0x1ffff054

00008224 <Logic_Start(bool)>:
void Logic_Start(bool hemisphere) {
    8224:	b508      	push	{r3, lr}
    Logic_instance[hemisphere].BaseStart(hemisphere);
    8226:	4b04      	ldr	r3, [pc, #16]	; (8238 <Logic_Start(bool)+0x14>)
void Logic_Start(bool hemisphere) {
    8228:	4601      	mov	r1, r0
    Logic_instance[hemisphere].BaseStart(hemisphere);
    822a:	20bc      	movs	r0, #188	; 0xbc
    822c:	fb00 3001 	mla	r0, r0, r1, r3
    8230:	f7ff fec0 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8234:	bd08      	pop	{r3, pc}
    8236:	bf00      	nop
    8238:	2000014c 	.word	0x2000014c

0000823c <LowerRenz_Start(bool)>:
void LowerRenz_Start(bool hemisphere) {
    823c:	b508      	push	{r3, lr}
    LowerRenz_instance[hemisphere].BaseStart(hemisphere);
    823e:	4b04      	ldr	r3, [pc, #16]	; (8250 <LowerRenz_Start(bool)+0x14>)
void LowerRenz_Start(bool hemisphere) {
    8240:	4601      	mov	r1, r0
    LowerRenz_instance[hemisphere].BaseStart(hemisphere);
    8242:	207c      	movs	r0, #124	; 0x7c
    8244:	fb00 3001 	mla	r0, r0, r1, r3
    8248:	f7ff feb4 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    824c:	bd08      	pop	{r3, pc}
    824e:	bf00      	nop
    8250:	200002c4 	.word	0x200002c4

00008254 <Metronome_Start(bool)>:
void Metronome_Start(bool hemisphere) {Metronome_instance[hemisphere].BaseStart(hemisphere);}
    8254:	b508      	push	{r3, lr}
    8256:	4b04      	ldr	r3, [pc, #16]	; (8268 <Metronome_Start(bool)+0x14>)
    8258:	4601      	mov	r1, r0
    825a:	2074      	movs	r0, #116	; 0x74
    825c:	fb00 3001 	mla	r0, r0, r1, r3
    8260:	f7ff fea8 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    8264:	bd08      	pop	{r3, pc}
    8266:	bf00      	nop
    8268:	200003bc 	.word	0x200003bc

0000826c <MixerBal_Start(bool)>:
void MixerBal_Start(bool hemisphere) {
    826c:	b508      	push	{r3, lr}
    MixerBal_instance[hemisphere].BaseStart(hemisphere);
    826e:	4b04      	ldr	r3, [pc, #16]	; (8280 <MixerBal_Start(bool)+0x14>)
void MixerBal_Start(bool hemisphere) {
    8270:	4601      	mov	r1, r0
    MixerBal_instance[hemisphere].BaseStart(hemisphere);
    8272:	2074      	movs	r0, #116	; 0x74
    8274:	fb00 3001 	mla	r0, r0, r1, r3
    8278:	f7ff fe9c 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    827c:	bd08      	pop	{r3, pc}
    827e:	bf00      	nop
    8280:	200004a4 	.word	0x200004a4

00008284 <Palimpsest_Start(bool)>:
void Palimpsest_Start(bool hemisphere) {
    8284:	b508      	push	{r3, lr}
    Palimpsest_instance[hemisphere].BaseStart(hemisphere);
    8286:	4b04      	ldr	r3, [pc, #16]	; (8298 <Palimpsest_Start(bool)+0x14>)
void Palimpsest_Start(bool hemisphere) {
    8288:	4601      	mov	r1, r0
    Palimpsest_instance[hemisphere].BaseStart(hemisphere);
    828a:	20cc      	movs	r0, #204	; 0xcc
    828c:	fb00 3001 	mla	r0, r0, r1, r3
    8290:	f7ff fe90 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8294:	bd08      	pop	{r3, pc}
    8296:	bf00      	nop
    8298:	20000d34 	.word	0x20000d34

0000829c <RunglBook_Start(bool)>:
void RunglBook_Start(bool hemisphere) {RunglBook_instance[hemisphere].BaseStart(hemisphere);}
    829c:	b508      	push	{r3, lr}
    829e:	4b04      	ldr	r3, [pc, #16]	; (82b0 <RunglBook_Start(bool)+0x14>)
    82a0:	4601      	mov	r1, r0
    82a2:	2070      	movs	r0, #112	; 0x70
    82a4:	fb00 3001 	mla	r0, r0, r1, r3
    82a8:	f7ff fe84 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    82ac:	bd08      	pop	{r3, pc}
    82ae:	bf00      	nop
    82b0:	20000ecc 	.word	0x20000ecc

000082b4 <ScaleDuet_Start(bool)>:
void ScaleDuet_Start(bool hemisphere) {
    82b4:	b508      	push	{r3, lr}
    ScaleDuet_instance[hemisphere].BaseStart(hemisphere);
    82b6:	4b04      	ldr	r3, [pc, #16]	; (82c8 <ScaleDuet_Start(bool)+0x14>)
void ScaleDuet_Start(bool hemisphere) {
    82b8:	4601      	mov	r1, r0
    ScaleDuet_instance[hemisphere].BaseStart(hemisphere);
    82ba:	f44f 70d8 	mov.w	r0, #432	; 0x1b0
    82be:	fb00 3001 	mla	r0, r0, r1, r3
    82c2:	f7ff fe77 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    82c6:	bd08      	pop	{r3, pc}
    82c8:	20000fac 	.word	0x20000fac

000082cc <Schmitt_Start(bool)>:
void Schmitt_Start(bool hemisphere) {
    82cc:	b508      	push	{r3, lr}
    Schmitt_instance[hemisphere].BaseStart(hemisphere);
    82ce:	4b04      	ldr	r3, [pc, #16]	; (82e0 <Schmitt_Start(bool)+0x14>)
void Schmitt_Start(bool hemisphere) {
    82d0:	4601      	mov	r1, r0
    Schmitt_instance[hemisphere].BaseStart(hemisphere);
    82d2:	207c      	movs	r0, #124	; 0x7c
    82d4:	fb00 3001 	mla	r0, r0, r1, r3
    82d8:	f7ff fe6c 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    82dc:	bd08      	pop	{r3, pc}
    82de:	bf00      	nop
    82e0:	2000130c 	.word	0x2000130c

000082e4 <Scope_Start(bool)>:
void Scope_Start(bool hemisphere) {
    82e4:	b508      	push	{r3, lr}
    Scope_instance[hemisphere].BaseStart(hemisphere);
    82e6:	4b04      	ldr	r3, [pc, #16]	; (82f8 <Scope_Start(bool)+0x14>)
void Scope_Start(bool hemisphere) {
    82e8:	4601      	mov	r1, r0
    Scope_instance[hemisphere].BaseStart(hemisphere);
    82ea:	20d0      	movs	r0, #208	; 0xd0
    82ec:	fb00 3001 	mla	r0, r0, r1, r3
    82f0:	f7ff fe60 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    82f4:	bd08      	pop	{r3, pc}
    82f6:	bf00      	nop
    82f8:	20001404 	.word	0x20001404

000082fc <Sequence5_Start(bool)>:
void Sequence5_Start(bool hemisphere) {
    82fc:	b508      	push	{r3, lr}
    Sequence5_instance[hemisphere].BaseStart(hemisphere);
    82fe:	4b04      	ldr	r3, [pc, #16]	; (8310 <Sequence5_Start(bool)+0x14>)
void Sequence5_Start(bool hemisphere) {
    8300:	4601      	mov	r1, r0
    Sequence5_instance[hemisphere].BaseStart(hemisphere);
    8302:	2090      	movs	r0, #144	; 0x90
    8304:	fb00 3001 	mla	r0, r0, r1, r3
    8308:	f7ff fe54 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    830c:	bd08      	pop	{r3, pc}
    830e:	bf00      	nop
    8310:	200015a4 	.word	0x200015a4

00008314 <ShiftGate_Start(bool)>:
void ShiftGate_Start(bool hemisphere) {ShiftGate_instance[hemisphere].BaseStart(hemisphere);}
    8314:	b508      	push	{r3, lr}
    8316:	4b04      	ldr	r3, [pc, #16]	; (8328 <ShiftGate_Start(bool)+0x14>)
    8318:	4601      	mov	r1, r0
    831a:	2078      	movs	r0, #120	; 0x78
    831c:	fb00 3001 	mla	r0, r0, r1, r3
    8320:	f7ff fe48 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    8324:	bd08      	pop	{r3, pc}
    8326:	bf00      	nop
    8328:	20001744 	.word	0x20001744

0000832c <Shuffle_Start(bool)>:
void Shuffle_Start(bool hemisphere) {
    832c:	b508      	push	{r3, lr}
    Shuffle_instance[hemisphere].BaseStart(hemisphere);
    832e:	4b04      	ldr	r3, [pc, #16]	; (8340 <Shuffle_Start(bool)+0x14>)
void Shuffle_Start(bool hemisphere) {
    8330:	4601      	mov	r1, r0
    Shuffle_instance[hemisphere].BaseStart(hemisphere);
    8332:	2084      	movs	r0, #132	; 0x84
    8334:	fb00 3001 	mla	r0, r0, r1, r3
    8338:	f7ff fe3c 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    833c:	bd08      	pop	{r3, pc}
    833e:	bf00      	nop
    8340:	20001834 	.word	0x20001834

00008344 <SkewedLFO_Start(bool)>:
void SkewedLFO_Start(bool hemisphere) {
    8344:	b508      	push	{r3, lr}
    SkewedLFO_instance[hemisphere].BaseStart(hemisphere);
    8346:	4b04      	ldr	r3, [pc, #16]	; (8358 <SkewedLFO_Start(bool)+0x14>)
void SkewedLFO_Start(bool hemisphere) {
    8348:	4601      	mov	r1, r0
    SkewedLFO_instance[hemisphere].BaseStart(hemisphere);
    834a:	2084      	movs	r0, #132	; 0x84
    834c:	fb00 3001 	mla	r0, r0, r1, r3
    8350:	f7ff fe30 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8354:	bd08      	pop	{r3, pc}
    8356:	bf00      	nop
    8358:	2000193c 	.word	0x2000193c

0000835c <Slew_Start(bool)>:
void Slew_Start(bool hemisphere) {
    835c:	b508      	push	{r3, lr}
    Slew_instance[hemisphere].BaseStart(hemisphere);
    835e:	4b04      	ldr	r3, [pc, #16]	; (8370 <Slew_Start(bool)+0x14>)
void Slew_Start(bool hemisphere) {
    8360:	4601      	mov	r1, r0
    Slew_instance[hemisphere].BaseStart(hemisphere);
    8362:	2088      	movs	r0, #136	; 0x88
    8364:	fb00 3001 	mla	r0, r0, r1, r3
    8368:	f7ff fe24 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    836c:	bd08      	pop	{r3, pc}
    836e:	bf00      	nop
    8370:	20001a44 	.word	0x20001a44

00008374 <Squanch_Start(bool)>:
void Squanch_Start(bool hemisphere) {Squanch_instance[hemisphere].BaseStart(hemisphere);}
    8374:	b508      	push	{r3, lr}
    8376:	4b04      	ldr	r3, [pc, #16]	; (8388 <Squanch_Start(bool)+0x14>)
    8378:	4601      	mov	r1, r0
    837a:	f44f 70de 	mov.w	r0, #444	; 0x1bc
    837e:	fb00 3001 	mla	r0, r0, r1, r3
    8382:	f7ff fe17 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    8386:	bd08      	pop	{r3, pc}
    8388:	20001b54 	.word	0x20001b54

0000838c <Switch_Start(bool)>:
void Switch_Start(bool hemisphere) {
    838c:	b508      	push	{r3, lr}
    Switch_instance[hemisphere].BaseStart(hemisphere);
    838e:	4b04      	ldr	r3, [pc, #16]	; (83a0 <Switch_Start(bool)+0x14>)
void Switch_Start(bool hemisphere) {
    8390:	4601      	mov	r1, r0
    Switch_instance[hemisphere].BaseStart(hemisphere);
    8392:	2078      	movs	r0, #120	; 0x78
    8394:	fb00 3001 	mla	r0, r0, r1, r3
    8398:	f7ff fe0c 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    839c:	bd08      	pop	{r3, pc}
    839e:	bf00      	nop
    83a0:	20001ecc 	.word	0x20001ecc

000083a4 <TLNeuron_Start(bool)>:
void TLNeuron_Start(bool hemisphere) {
    83a4:	b508      	push	{r3, lr}
    TLNeuron_instance[hemisphere].BaseStart(hemisphere);
    83a6:	4b04      	ldr	r3, [pc, #16]	; (83b8 <TLNeuron_Start(bool)+0x14>)
void TLNeuron_Start(bool hemisphere) {
    83a8:	4601      	mov	r1, r0
    TLNeuron_instance[hemisphere].BaseStart(hemisphere);
    83aa:	208c      	movs	r0, #140	; 0x8c
    83ac:	fb00 3001 	mla	r0, r0, r1, r3
    83b0:	f7ff fe00 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    83b4:	bd08      	pop	{r3, pc}
    83b6:	bf00      	nop
    83b8:	20001fbc 	.word	0x20001fbc

000083bc <TM_Start(bool)>:
void TM_Start(bool hemisphere) {
    83bc:	b508      	push	{r3, lr}
    TM_instance[hemisphere].BaseStart(hemisphere);
    83be:	4b04      	ldr	r3, [pc, #16]	; (83d0 <TM_Start(bool)+0x14>)
void TM_Start(bool hemisphere) {
    83c0:	4601      	mov	r1, r0
    TM_instance[hemisphere].BaseStart(hemisphere);
    83c2:	f44f 70dc 	mov.w	r0, #440	; 0x1b8
    83c6:	fb00 3001 	mla	r0, r0, r1, r3
    83ca:	f7ff fdf3 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    83ce:	bd08      	pop	{r3, pc}
    83d0:	200020d4 	.word	0x200020d4

000083d4 <Trending_Start(bool)>:
void Trending_Start(bool hemisphere) {Trending_instance[hemisphere].BaseStart(hemisphere);}
    83d4:	b508      	push	{r3, lr}
    83d6:	4b04      	ldr	r3, [pc, #16]	; (83e8 <Trending_Start(bool)+0x14>)
    83d8:	4601      	mov	r1, r0
    83da:	20a0      	movs	r0, #160	; 0xa0
    83dc:	fb00 3001 	mla	r0, r0, r1, r3
    83e0:	f7ff fde8 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    83e4:	bd08      	pop	{r3, pc}
    83e6:	bf00      	nop
    83e8:	20002654 	.word	0x20002654

000083ec <TrigSeq_Start(bool)>:
void TrigSeq_Start(bool hemisphere) {
    83ec:	b508      	push	{r3, lr}
    TrigSeq_instance[hemisphere].BaseStart(hemisphere);
    83ee:	4b04      	ldr	r3, [pc, #16]	; (8400 <TrigSeq_Start(bool)+0x14>)
void TrigSeq_Start(bool hemisphere) {
    83f0:	4601      	mov	r1, r0
    TrigSeq_instance[hemisphere].BaseStart(hemisphere);
    83f2:	2084      	movs	r0, #132	; 0x84
    83f4:	fb00 3001 	mla	r0, r0, r1, r3
    83f8:	f7ff fddc 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    83fc:	bd08      	pop	{r3, pc}
    83fe:	bf00      	nop
    8400:	2000288c 	.word	0x2000288c

00008404 <TrigSeq16_Start(bool)>:
void TrigSeq16_Start(bool hemisphere) {
    8404:	b508      	push	{r3, lr}
    TrigSeq16_instance[hemisphere].BaseStart(hemisphere);
    8406:	4b04      	ldr	r3, [pc, #16]	; (8418 <TrigSeq16_Start(bool)+0x14>)
void TrigSeq16_Start(bool hemisphere) {
    8408:	4601      	mov	r1, r0
    TrigSeq16_instance[hemisphere].BaseStart(hemisphere);
    840a:	207c      	movs	r0, #124	; 0x7c
    840c:	fb00 3001 	mla	r0, r0, r1, r3
    8410:	f7ff fdd0 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    8414:	bd08      	pop	{r3, pc}
    8416:	bf00      	nop
    8418:	20002794 	.word	0x20002794

0000841c <Tuner_Start(bool)>:
void Tuner_Start(bool hemisphere) {
    841c:	b508      	push	{r3, lr}
    Tuner_instance[hemisphere].BaseStart(hemisphere);
    841e:	4b04      	ldr	r3, [pc, #16]	; (8430 <Tuner_Start(bool)+0x14>)
void Tuner_Start(bool hemisphere) {
    8420:	4601      	mov	r1, r0
    Tuner_instance[hemisphere].BaseStart(hemisphere);
    8422:	2088      	movs	r0, #136	; 0x88
    8424:	fb00 3001 	mla	r0, r0, r1, r3
    8428:	f7ff fdc4 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    842c:	bd08      	pop	{r3, pc}
    842e:	bf00      	nop
    8430:	20002998 	.word	0x20002998

00008434 <VectorEG_Start(bool)>:
void VectorEG_Start(bool hemisphere) {VectorEG_instance[hemisphere].BaseStart(hemisphere);}
    8434:	b508      	push	{r3, lr}
    8436:	4b04      	ldr	r3, [pc, #16]	; (8448 <VectorEG_Start(bool)+0x14>)
    8438:	4601      	mov	r1, r0
    843a:	f44f 708a 	mov.w	r0, #276	; 0x114
    843e:	fb00 3001 	mla	r0, r0, r1, r3
    8442:	f7ff fdb7 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    8446:	bd08      	pop	{r3, pc}
    8448:	20002ab0 	.word	0x20002ab0

0000844c <VectorLFO_Start(bool)>:
void VectorLFO_Start(bool hemisphere) {VectorLFO_instance[hemisphere].BaseStart(hemisphere);}
    844c:	b508      	push	{r3, lr}
    844e:	4b04      	ldr	r3, [pc, #16]	; (8460 <VectorLFO_Start(bool)+0x14>)
    8450:	4601      	mov	r1, r0
    8452:	f44f 7088 	mov.w	r0, #272	; 0x110
    8456:	fb00 3001 	mla	r0, r0, r1, r3
    845a:	f7ff fdab 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    845e:	bd08      	pop	{r3, pc}
    8460:	20002cd8 	.word	0x20002cd8

00008464 <VectorMod_Start(bool)>:
void VectorMod_Start(bool hemisphere) {VectorMod_instance[hemisphere].BaseStart(hemisphere);}
    8464:	b508      	push	{r3, lr}
    8466:	4b04      	ldr	r3, [pc, #16]	; (8478 <VectorMod_Start(bool)+0x14>)
    8468:	4601      	mov	r1, r0
    846a:	f44f 7088 	mov.w	r0, #272	; 0x110
    846e:	fb00 3001 	mla	r0, r0, r1, r3
    8472:	f7ff fd9f 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    8476:	bd08      	pop	{r3, pc}
    8478:	20002ef8 	.word	0x20002ef8

0000847c <VectorMorph_Start(bool)>:
void VectorMorph_Start(bool hemisphere) {VectorMorph_instance[hemisphere].BaseStart(hemisphere);}
    847c:	b508      	push	{r3, lr}
    847e:	4b04      	ldr	r3, [pc, #16]	; (8490 <VectorMorph_Start(bool)+0x14>)
    8480:	4601      	mov	r1, r0
    8482:	f44f 708e 	mov.w	r0, #284	; 0x11c
    8486:	fb00 3001 	mla	r0, r0, r1, r3
    848a:	f7ff fd93 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    848e:	bd08      	pop	{r3, pc}
    8490:	20003118 	.word	0x20003118

00008494 <Voltage_Start(bool)>:
void Voltage_Start(bool hemisphere) {Voltage_instance[hemisphere].BaseStart(hemisphere);}
    8494:	b508      	push	{r3, lr}
    8496:	4601      	mov	r1, r0
    8498:	4802      	ldr	r0, [pc, #8]	; (84a4 <Voltage_Start(bool)+0x10>)
    849a:	eb00 10c1 	add.w	r0, r0, r1, lsl #7
    849e:	f7ff fd89 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
    84a2:	bd08      	pop	{r3, pc}
    84a4:	20003350 	.word	0x20003350

000084a8 <hMIDIIn_Start(bool)>:
void hMIDIIn_Start(bool hemisphere) {
    84a8:	b508      	push	{r3, lr}
    84aa:	4601      	mov	r1, r0
    hMIDIIn_instance[hemisphere].BaseStart(hemisphere);
    84ac:	4802      	ldr	r0, [pc, #8]	; (84b8 <hMIDIIn_Start(bool)+0x10>)
    84ae:	eb00 2001 	add.w	r0, r0, r1, lsl #8
    84b2:	f7ff fd7f 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    84b6:	bd08      	pop	{r3, pc}
    84b8:	20004db8 	.word	0x20004db8

000084bc <hMIDIOut_Start(bool)>:
void hMIDIOut_Start(bool hemisphere) {
    84bc:	b508      	push	{r3, lr}
    84be:	4601      	mov	r1, r0
    hMIDIOut_instance[hemisphere].BaseStart(hemisphere);
    84c0:	4802      	ldr	r0, [pc, #8]	; (84cc <hMIDIOut_Start(bool)+0x10>)
    84c2:	eb00 2001 	add.w	r0, r0, r1, lsl #8
    84c6:	f7ff fd75 	bl	7fb4 <HemisphereApplet::BaseStart(bool)>
}
    84ca:	bd08      	pop	{r3, pc}
    84cc:	20004fb8 	.word	0x20004fb8

000084d0 <HemisphereApplet::gfxCursor(int, int, int)>:
    void gfxCursor(int x, int y, int w) {
    84d0:	b573      	push	{r0, r1, r4, r5, r6, lr}
        if (CursorBlink()) gfxLine(x, y, x + w - 1, y);
    84d2:	6c86      	ldr	r6, [r0, #72]	; 0x48
    84d4:	2e00      	cmp	r6, #0
    84d6:	dd05      	ble.n	84e4 <HemisphereApplet::gfxCursor(int, int, int)+0x14>
    84d8:	440b      	add	r3, r1
    84da:	9200      	str	r2, [sp, #0]
    84dc:	6980      	ldr	r0, [r0, #24]
    84de:	3b01      	subs	r3, #1
    84e0:	f7fc fa86 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
    }
    84e4:	b002      	add	sp, #8
    84e6:	bd70      	pop	{r4, r5, r6, pc}

000084e8 <HemisphereApplet::gfxPrint(int, int, char const*)>:
    void gfxPrint(int x, int y, const char *str) {
    84e8:	b410      	push	{r4}
    84ea:	4604      	mov	r4, r0
  text_x_ = x;
    84ec:	4804      	ldr	r0, [pc, #16]	; (8500 <HemisphereApplet::gfxPrint(int, int, char const*)+0x18>)
        graphics.setPrintPos(x + gfx_offset, y);
    84ee:	69a4      	ldr	r4, [r4, #24]
  text_y_ = y;
    84f0:	6082      	str	r2, [r0, #8]
    84f2:	440c      	add	r4, r1
  text_x_ = x;
    84f4:	6044      	str	r4, [r0, #4]
        graphics.print(str);
    84f6:	4619      	mov	r1, r3
    }
    84f8:	bc10      	pop	{r4}
        graphics.print(str);
    84fa:	f011 baec 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    84fe:	bf00      	nop
    8500:	200065e0 	.word	0x200065e0

00008504 <HemisphereApplet::gfxPrintVoltage(int)>:
    void gfxPrintVoltage(int cv) {
    8504:	b538      	push	{r3, r4, r5, lr}
        if (v < 0) v = -v;
    8506:	4818      	ldr	r0, [pc, #96]	; (8568 <HemisphereApplet::gfxPrintVoltage(int)+0x64>)
        int v = (cv * 100) / (12 << 7);
    8508:	2564      	movs	r5, #100	; 0x64
    850a:	fb05 f201 	mul.w	r2, r5, r1
        if (v < 0) v = -v;
    850e:	4282      	cmp	r2, r0
        int dv = v - (wv * 100); // decimal
    8510:	f06f 0163 	mvn.w	r1, #99	; 0x63
        int v = (cv * 100) / (12 << 7);
    8514:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    8518:	fb92 f3f3 	sdiv	r3, r2, r3
        if (v < 0) v = -v;
    851c:	bfb8      	it	lt
    851e:	425b      	neglt	r3, r3
        int wv = v / 100; // whole volts
    8520:	fb93 f5f5 	sdiv	r5, r3, r5
        int dv = v - (wv * 100); // decimal
    8524:	fb01 3405 	mla	r4, r1, r5, r3
        graphics.print(str);
    8528:	4b10      	ldr	r3, [pc, #64]	; (856c <HemisphereApplet::gfxPrintVoltage(int)+0x68>)
    852a:	4911      	ldr	r1, [pc, #68]	; (8570 <HemisphereApplet::gfxPrintVoltage(int)+0x6c>)
    852c:	4282      	cmp	r2, r0
    852e:	bfa8      	it	ge
    8530:	4619      	movge	r1, r3
    8532:	4810      	ldr	r0, [pc, #64]	; (8574 <HemisphereApplet::gfxPrintVoltage(int)+0x70>)
    8534:	f011 facf 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
    8538:	480e      	ldr	r0, [pc, #56]	; (8574 <HemisphereApplet::gfxPrintVoltage(int)+0x70>)
    853a:	4629      	mov	r1, r5
    853c:	f011 fb3f 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    8540:	490d      	ldr	r1, [pc, #52]	; (8578 <HemisphereApplet::gfxPrintVoltage(int)+0x74>)
    8542:	480c      	ldr	r0, [pc, #48]	; (8574 <HemisphereApplet::gfxPrintVoltage(int)+0x70>)
    8544:	f011 fac7 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (dv < 10) gfxPrint("0");
    8548:	2c09      	cmp	r4, #9
    854a:	dc03      	bgt.n	8554 <HemisphereApplet::gfxPrintVoltage(int)+0x50>
        graphics.print(str);
    854c:	490b      	ldr	r1, [pc, #44]	; (857c <HemisphereApplet::gfxPrintVoltage(int)+0x78>)
    854e:	4809      	ldr	r0, [pc, #36]	; (8574 <HemisphereApplet::gfxPrintVoltage(int)+0x70>)
    8550:	f011 fac1 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
    8554:	4621      	mov	r1, r4
    8556:	4807      	ldr	r0, [pc, #28]	; (8574 <HemisphereApplet::gfxPrintVoltage(int)+0x70>)
    8558:	f011 fb31 	bl	19bbe <weegfx::Graphics::print(int)>
    }
    855c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        graphics.print(str);
    8560:	4907      	ldr	r1, [pc, #28]	; (8580 <HemisphereApplet::gfxPrintVoltage(int)+0x7c>)
    8562:	4804      	ldr	r0, [pc, #16]	; (8574 <HemisphereApplet::gfxPrintVoltage(int)+0x70>)
    8564:	f011 bab7 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    8568:	fffffa01 	.word	0xfffffa01
    856c:	0001e41c 	.word	0x0001e41c
    8570:	0001f2ef 	.word	0x0001f2ef
    8574:	200065e0 	.word	0x200065e0
    8578:	00020f2c 	.word	0x00020f2c
    857c:	00020525 	.word	0x00020525
    8580:	000217de 	.word	0x000217de

00008584 <HemisphereApplet::gfxInvert(int, int, int, int)>:
        graphics.invertRect(x + gfx_offset, y, w, h);
    8584:	6980      	ldr	r0, [r0, #24]
    8586:	4401      	add	r1, r0
    8588:	4801      	ldr	r0, [pc, #4]	; (8590 <HemisphereApplet::gfxInvert(int, int, int, int)+0xc>)
    858a:	f010 bf48 	b.w	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
    858e:	bf00      	nop
    8590:	200065e0 	.word	0x200065e0

00008594 <HemisphereApplet::gfxSkyline()>:
    void gfxSkyline() {
    8594:	b537      	push	{r0, r1, r2, r4, r5, lr}
    8596:	4604      	mov	r4, r0
            int height = ProportionCV(ViewIn(ch), 32);
    8598:	2120      	movs	r1, #32
    859a:	6a00      	ldr	r0, [r0, #32]
    859c:	f7fc f862 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
            gfxFrame(23 + (10 * ch), BottomAlign(height), 6, 63);
    85a0:	253f      	movs	r5, #63	; 0x3f
    85a2:	f1c0 023e 	rsb	r2, r0, #62	; 0x3e
    85a6:	2306      	movs	r3, #6
    85a8:	69a0      	ldr	r0, [r4, #24]
    85aa:	9500      	str	r5, [sp, #0]
    85ac:	2117      	movs	r1, #23
    85ae:	f7fc fa2d 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
            height = ProportionCV(ViewOut(ch), 32);
    85b2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    85b4:	2120      	movs	r1, #32
    85b6:	f7fc f855 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
            gfxInvert(3 + (46 * ch), BottomAlign(height), 12, 63);
    85ba:	230c      	movs	r3, #12
    85bc:	f1c0 023e 	rsb	r2, r0, #62	; 0x3e
    85c0:	9500      	str	r5, [sp, #0]
    85c2:	4620      	mov	r0, r4
    85c4:	2103      	movs	r1, #3
    85c6:	f7ff ffdd 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
            int height = ProportionCV(ViewIn(ch), 32);
    85ca:	6a60      	ldr	r0, [r4, #36]	; 0x24
    85cc:	2120      	movs	r1, #32
    85ce:	f7fc f849 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
            gfxFrame(23 + (10 * ch), BottomAlign(height), 6, 63);
    85d2:	2306      	movs	r3, #6
    85d4:	f1c0 023e 	rsb	r2, r0, #62	; 0x3e
    85d8:	9500      	str	r5, [sp, #0]
    85da:	69a0      	ldr	r0, [r4, #24]
    85dc:	2121      	movs	r1, #33	; 0x21
    85de:	f7fc fa15 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
            height = ProportionCV(ViewOut(ch), 32);
    85e2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    85e4:	2120      	movs	r1, #32
    85e6:	f7fc f83d 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
            gfxInvert(3 + (46 * ch), BottomAlign(height), 12, 63);
    85ea:	9500      	str	r5, [sp, #0]
    85ec:	f1c0 023e 	rsb	r2, r0, #62	; 0x3e
    85f0:	230c      	movs	r3, #12
    85f2:	2131      	movs	r1, #49	; 0x31
    85f4:	4620      	mov	r0, r4
    85f6:	f7ff ffc5 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
    }
    85fa:	b003      	add	sp, #12
    85fc:	bd30      	pop	{r4, r5, pc}

000085fe <HemisphereApplet::gfxHeader(char const*)>:
    void gfxHeader(const char *str) {
    85fe:	b513      	push	{r0, r1, r4, lr}
    8600:	460b      	mov	r3, r1
    8602:	4604      	mov	r4, r0
        gfxPrint(1, 2, str);
    8604:	2202      	movs	r2, #2
    8606:	2101      	movs	r1, #1
    8608:	f7ff ff6e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxLine(0, 10, 62, 10);
    860c:	220a      	movs	r2, #10
    860e:	69a0      	ldr	r0, [r4, #24]
    8610:	9200      	str	r2, [sp, #0]
    8612:	233e      	movs	r3, #62	; 0x3e
    8614:	2100      	movs	r1, #0
    8616:	f7fc f9eb 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(0, 12, 62, 12);
    861a:	220c      	movs	r2, #12
    861c:	69a0      	ldr	r0, [r4, #24]
    861e:	9200      	str	r2, [sp, #0]
    8620:	233e      	movs	r3, #62	; 0x3e
    8622:	2100      	movs	r1, #0
    8624:	f7fc f9e4 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
    }
    8628:	b002      	add	sp, #8
    862a:	bd10      	pop	{r4, pc}

0000862c <HemisphereApplet::DrawHelpScreen()>:
        gfxHeader(applet_name());
    862c:	6803      	ldr	r3, [r0, #0]
    void DrawHelpScreen() {
    862e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
        gfxHeader(applet_name());
    8632:	681b      	ldr	r3, [r3, #0]
    8634:	4c1e      	ldr	r4, [pc, #120]	; (86b0 <HemisphereApplet::DrawHelpScreen()+0x84>)
            if (section == HEMISPHERE_HELP_ENCODER) graphics.print("Enc");
    8636:	f8df 907c 	ldr.w	r9, [pc, #124]	; 86b4 <HemisphereApplet::DrawHelpScreen()+0x88>
    void DrawHelpScreen() {
    863a:	4605      	mov	r5, r0
        gfxHeader(applet_name());
    863c:	4798      	blx	r3
    863e:	4601      	mov	r1, r0
    8640:	4628      	mov	r0, r5
    8642:	f7ff ffdc 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        SetHelp();
    8646:	682b      	ldr	r3, [r5, #0]
    8648:	4628      	mov	r0, r5
    864a:	691b      	ldr	r3, [r3, #16]
    864c:	4798      	blx	r3
        for (int section = 0; section < 4; section++)
    864e:	2600      	movs	r6, #0
    8650:	3504      	adds	r5, #4
        SetHelp();
    8652:	2710      	movs	r7, #16
    8654:	46b0      	mov	r8, r6
    8656:	f8c4 8004 	str.w	r8, [r4, #4]
  text_y_ = y;
    865a:	60a7      	str	r7, [r4, #8]
            if (section == HEMISPHERE_HELP_DIGITALS) graphics.print("Dig");
    865c:	b9de      	cbnz	r6, 8696 <HemisphereApplet::DrawHelpScreen()+0x6a>
    865e:	4916      	ldr	r1, [pc, #88]	; (86b8 <HemisphereApplet::DrawHelpScreen()+0x8c>)
            if (section == HEMISPHERE_HELP_ENCODER) graphics.print("Enc");
    8660:	4620      	mov	r0, r4
    8662:	f011 fa38 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.invertRect(0, y - 1, 19, 9);
    8666:	2309      	movs	r3, #9
    8668:	1e7a      	subs	r2, r7, #1
    866a:	9300      	str	r3, [sp, #0]
    866c:	2100      	movs	r1, #0
    866e:	2313      	movs	r3, #19
    8670:	4620      	mov	r0, r4
    8672:	f010 fed4 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
        for (int section = 0; section < 4; section++)
    8676:	3601      	adds	r6, #1
  text_x_ = x;
    8678:	2314      	movs	r3, #20
            graphics.print(help[section]);
    867a:	f855 1f04 	ldr.w	r1, [r5, #4]!
  text_y_ = y;
    867e:	60a7      	str	r7, [r4, #8]
    8680:	4620      	mov	r0, r4
  text_x_ = x;
    8682:	6063      	str	r3, [r4, #4]
    8684:	f011 fa27 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        for (int section = 0; section < 4; section++)
    8688:	2e04      	cmp	r6, #4
    868a:	f107 070c 	add.w	r7, r7, #12
    868e:	d1e2      	bne.n	8656 <HemisphereApplet::DrawHelpScreen()+0x2a>
    }
    8690:	b003      	add	sp, #12
    8692:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            if (section == HEMISPHERE_HELP_CVS) graphics.print("CV");
    8696:	2e01      	cmp	r6, #1
    8698:	d101      	bne.n	869e <HemisphereApplet::DrawHelpScreen()+0x72>
    869a:	4908      	ldr	r1, [pc, #32]	; (86bc <HemisphereApplet::DrawHelpScreen()+0x90>)
    869c:	e7e0      	b.n	8660 <HemisphereApplet::DrawHelpScreen()+0x34>
            if (section == HEMISPHERE_HELP_OUTS) graphics.print("Out");
    869e:	2e02      	cmp	r6, #2
    86a0:	d101      	bne.n	86a6 <HemisphereApplet::DrawHelpScreen()+0x7a>
    86a2:	4907      	ldr	r1, [pc, #28]	; (86c0 <HemisphereApplet::DrawHelpScreen()+0x94>)
    86a4:	e7dc      	b.n	8660 <HemisphereApplet::DrawHelpScreen()+0x34>
            if (section == HEMISPHERE_HELP_ENCODER) graphics.print("Enc");
    86a6:	2e03      	cmp	r6, #3
    86a8:	d1dd      	bne.n	8666 <HemisphereApplet::DrawHelpScreen()+0x3a>
    86aa:	4649      	mov	r1, r9
    86ac:	e7d8      	b.n	8660 <HemisphereApplet::DrawHelpScreen()+0x34>
    86ae:	bf00      	nop
    86b0:	200065e0 	.word	0x200065e0
    86b4:	00021060 	.word	0x00021060
    86b8:	0002105c 	.word	0x0002105c
    86bc:	00020a2c 	.word	0x00020a2c
    86c0:	00020c31 	.word	0x00020c31

000086c4 <HemisphereApplet::BaseView()>:
        if (help_active) DrawHelpScreen();
    86c4:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    void BaseView() {
    86c6:	b510      	push	{r4, lr}
    86c8:	4604      	mov	r4, r0
        if (help_active) DrawHelpScreen();
    86ca:	b12b      	cbz	r3, 86d8 <HemisphereApplet::BaseView()+0x14>
    86cc:	f7ff ffae 	bl	862c <HemisphereApplet::DrawHelpScreen()>
        last_view_tick = OC::CORE::ticks;
    86d0:	4b03      	ldr	r3, [pc, #12]	; (86e0 <HemisphereApplet::BaseView()+0x1c>)
    86d2:	681b      	ldr	r3, [r3, #0]
    86d4:	65a3      	str	r3, [r4, #88]	; 0x58
    }
    86d6:	bd10      	pop	{r4, pc}
        else View();
    86d8:	6803      	ldr	r3, [r0, #0]
    86da:	68db      	ldr	r3, [r3, #12]
    86dc:	4798      	blx	r3
    86de:	e7f7      	b.n	86d0 <HemisphereApplet::BaseView()+0xc>
    86e0:	200046cc 	.word	0x200046cc

000086e4 <ADEG_View(bool)>:
void ADEG_View(bool hemisphere) {ADEG_instance[hemisphere].BaseView();}
    86e4:	b508      	push	{r3, lr}
    86e6:	4b03      	ldr	r3, [pc, #12]	; (86f4 <ADEG_View(bool)+0x10>)
    86e8:	2290      	movs	r2, #144	; 0x90
    86ea:	fb02 3000 	mla	r0, r2, r0, r3
    86ee:	f7ff ffe9 	bl	86c4 <HemisphereApplet::BaseView()>
    86f2:	bd08      	pop	{r3, pc}
    86f4:	1fffa8c8 	.word	0x1fffa8c8

000086f8 <ADSREG_View(bool)>:
void ADSREG_View(bool hemisphere) {
    86f8:	b508      	push	{r3, lr}
    ADSREG_instance[hemisphere].BaseView();
    86fa:	4b03      	ldr	r3, [pc, #12]	; (8708 <ADSREG_View(bool)+0x10>)
    86fc:	22a4      	movs	r2, #164	; 0xa4
    86fe:	fb02 3000 	mla	r0, r2, r0, r3
    8702:	f7ff ffdf 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8706:	bd08      	pop	{r3, pc}
    8708:	1fffa9e8 	.word	0x1fffa9e8

0000870c <ASR_View(bool)>:
void ASR_View(bool hemisphere) {ASR_instance[hemisphere].BaseView();}
    870c:	b508      	push	{r3, lr}
    870e:	4b04      	ldr	r3, [pc, #16]	; (8720 <ASR_View(bool)+0x14>)
    8710:	f44f 72da 	mov.w	r2, #436	; 0x1b4
    8714:	fb02 3000 	mla	r0, r2, r0, r3
    8718:	f7ff ffd4 	bl	86c4 <HemisphereApplet::BaseView()>
    871c:	bd08      	pop	{r3, pc}
    871e:	bf00      	nop
    8720:	1fffab30 	.word	0x1fffab30

00008724 <AnnularFusion_View(bool)>:
void AnnularFusion_View(bool hemisphere) {
    8724:	b508      	push	{r3, lr}
    AnnularFusion_instance[hemisphere].BaseView();
    8726:	4b04      	ldr	r3, [pc, #16]	; (8738 <AnnularFusion_View(bool)+0x14>)
    8728:	f44f 728a 	mov.w	r2, #276	; 0x114
    872c:	fb02 3000 	mla	r0, r2, r0, r3
    8730:	f7ff ffc8 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8734:	bd08      	pop	{r3, pc}
    8736:	bf00      	nop
    8738:	1fffae98 	.word	0x1fffae98

0000873c <AttenuateOffset_View(bool)>:
void AttenuateOffset_View(bool hemisphere) {AttenuateOffset_instance[hemisphere].BaseView();}
    873c:	b508      	push	{r3, lr}
    873e:	4b03      	ldr	r3, [pc, #12]	; (874c <AttenuateOffset_View(bool)+0x10>)
    8740:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    8744:	f7ff ffbe 	bl	86c4 <HemisphereApplet::BaseView()>
    8748:	bd08      	pop	{r3, pc}
    874a:	bf00      	nop
    874c:	1fffb0c0 	.word	0x1fffb0c0

00008750 <Binary_View(bool)>:
void Binary_View(bool hemisphere) {
    8750:	b508      	push	{r3, lr}
    Binary_instance[hemisphere].BaseView();
    8752:	4b03      	ldr	r3, [pc, #12]	; (8760 <Binary_View(bool)+0x10>)
    8754:	22e4      	movs	r2, #228	; 0xe4
    8756:	fb02 3000 	mla	r0, r2, r0, r3
    875a:	f7ff ffb3 	bl	86c4 <HemisphereApplet::BaseView()>
}
    875e:	bd08      	pop	{r3, pc}
    8760:	1fffb1c8 	.word	0x1fffb1c8

00008764 <BootsNCat_View(bool)>:
void BootsNCat_View(bool hemisphere) {BootsNCat_instance[hemisphere].BaseView();}
    8764:	b508      	push	{r3, lr}
    8766:	4b04      	ldr	r3, [pc, #16]	; (8778 <BootsNCat_View(bool)+0x14>)
    8768:	f44f 72b6 	mov.w	r2, #364	; 0x16c
    876c:	fb02 3000 	mla	r0, r2, r0, r3
    8770:	f7ff ffa8 	bl	86c4 <HemisphereApplet::BaseView()>
    8774:	bd08      	pop	{r3, pc}
    8776:	bf00      	nop
    8778:	1fffb390 	.word	0x1fffb390

0000877c <Brancher_View(bool)>:
void Brancher_View(bool hemisphere) {
    877c:	b508      	push	{r3, lr}
    Brancher_instance[hemisphere].BaseView();
    877e:	4b03      	ldr	r3, [pc, #12]	; (878c <Brancher_View(bool)+0x10>)
    8780:	2274      	movs	r2, #116	; 0x74
    8782:	fb02 3000 	mla	r0, r2, r0, r3
    8786:	f7ff ff9d 	bl	86c4 <HemisphereApplet::BaseView()>
}
    878a:	bd08      	pop	{r3, pc}
    878c:	1fffb668 	.word	0x1fffb668

00008790 <Burst_View(bool)>:
void Burst_View(bool hemisphere) {
    8790:	b508      	push	{r3, lr}
    Burst_instance[hemisphere].BaseView();
    8792:	4b03      	ldr	r3, [pc, #12]	; (87a0 <Burst_View(bool)+0x10>)
    8794:	2290      	movs	r2, #144	; 0x90
    8796:	fb02 3000 	mla	r0, r2, r0, r3
    879a:	f7ff ff93 	bl	86c4 <HemisphereApplet::BaseView()>
}
    879e:	bd08      	pop	{r3, pc}
    87a0:	1fffb750 	.word	0x1fffb750

000087a4 <CVRecV2_View(bool)>:
void CVRecV2_View(bool hemisphere) {CVRecV2_instance[hemisphere].BaseView();}
    87a4:	b508      	push	{r3, lr}
    87a6:	4b04      	ldr	r3, [pc, #16]	; (87b8 <CVRecV2_View(bool)+0x14>)
    87a8:	f240 62fc 	movw	r2, #1788	; 0x6fc
    87ac:	fb02 3000 	mla	r0, r2, r0, r3
    87b0:	f7ff ff88 	bl	86c4 <HemisphereApplet::BaseView()>
    87b4:	bd08      	pop	{r3, pc}
    87b6:	bf00      	nop
    87b8:	1fffb878 	.word	0x1fffb878

000087bc <Calculate_View(bool)>:
void Calculate_View(bool hemisphere) {
    87bc:	b508      	push	{r3, lr}
    Calculate_instance[hemisphere].BaseView();
    87be:	4b03      	ldr	r3, [pc, #12]	; (87cc <Calculate_View(bool)+0x10>)
    87c0:	22bc      	movs	r2, #188	; 0xbc
    87c2:	fb02 3000 	mla	r0, r2, r0, r3
    87c6:	f7ff ff7d 	bl	86c4 <HemisphereApplet::BaseView()>
}
    87ca:	bd08      	pop	{r3, pc}
    87cc:	1fffc670 	.word	0x1fffc670

000087d0 <Carpeggio_View(bool)>:
void Carpeggio_View(bool hemisphere) {
    87d0:	b508      	push	{r3, lr}
    Carpeggio_instance[hemisphere].BaseView();
    87d2:	4b03      	ldr	r3, [pc, #12]	; (87e0 <Carpeggio_View(bool)+0x10>)
    87d4:	22a8      	movs	r2, #168	; 0xa8
    87d6:	fb02 3000 	mla	r0, r2, r0, r3
    87da:	f7ff ff73 	bl	86c4 <HemisphereApplet::BaseView()>
}
    87de:	bd08      	pop	{r3, pc}
    87e0:	1fffc7e8 	.word	0x1fffc7e8

000087e4 <ClockDivider_View(bool)>:
void ClockDivider_View(bool hemisphere) {
    87e4:	b508      	push	{r3, lr}
    ClockDivider_instance[hemisphere].BaseView();
    87e6:	4b03      	ldr	r3, [pc, #12]	; (87f4 <ClockDivider_View(bool)+0x10>)
    87e8:	228c      	movs	r2, #140	; 0x8c
    87ea:	fb02 3000 	mla	r0, r2, r0, r3
    87ee:	f7ff ff69 	bl	86c4 <HemisphereApplet::BaseView()>
}
    87f2:	bd08      	pop	{r3, pc}
    87f4:	1fffc938 	.word	0x1fffc938

000087f8 <ClockSetup_View(bool)>:
void ClockSetup_View(bool hemisphere) {ClockSetup_instance[hemisphere].BaseView();}
    87f8:	b508      	push	{r3, lr}
    87fa:	4b03      	ldr	r3, [pc, #12]	; (8808 <ClockSetup_View(bool)+0x10>)
    87fc:	2274      	movs	r2, #116	; 0x74
    87fe:	fb02 3000 	mla	r0, r2, r0, r3
    8802:	f7ff ff5f 	bl	86c4 <HemisphereApplet::BaseView()>
    8806:	bd08      	pop	{r3, pc}
    8808:	1fffca50 	.word	0x1fffca50

0000880c <ClockSkip_View(bool)>:
void ClockSkip_View(bool hemisphere) {
    880c:	b508      	push	{r3, lr}
    ClockSkip_instance[hemisphere].BaseView();
    880e:	4b03      	ldr	r3, [pc, #12]	; (881c <ClockSkip_View(bool)+0x10>)
    8810:	227c      	movs	r2, #124	; 0x7c
    8812:	fb02 3000 	mla	r0, r2, r0, r3
    8816:	f7ff ff55 	bl	86c4 <HemisphereApplet::BaseView()>
}
    881a:	bd08      	pop	{r3, pc}
    881c:	1fffcac4 	.word	0x1fffcac4

00008820 <Compare_View(bool)>:
void Compare_View(bool hemisphere) {
    8820:	b508      	push	{r3, lr}
    Compare_instance[hemisphere].BaseView();
    8822:	4b03      	ldr	r3, [pc, #12]	; (8830 <Compare_View(bool)+0x10>)
    8824:	2278      	movs	r2, #120	; 0x78
    8826:	fb02 3000 	mla	r0, r2, r0, r3
    882a:	f7ff ff4b 	bl	86c4 <HemisphereApplet::BaseView()>
}
    882e:	bd08      	pop	{r3, pc}
    8830:	1fffcbbc 	.word	0x1fffcbbc

00008834 <DrCrusher_View(bool)>:
void DrCrusher_View(bool hemisphere) {DrCrusher_instance[hemisphere].BaseView();}
    8834:	b508      	push	{r3, lr}
    8836:	4b03      	ldr	r3, [pc, #12]	; (8844 <DrCrusher_View(bool)+0x10>)
    8838:	227c      	movs	r2, #124	; 0x7c
    883a:	fb02 3000 	mla	r0, r2, r0, r3
    883e:	f7ff ff41 	bl	86c4 <HemisphereApplet::BaseView()>
    8842:	bd08      	pop	{r3, pc}
    8844:	1fffccac 	.word	0x1fffccac

00008848 <DualQuant_View(bool)>:
void DualQuant_View(bool hemisphere) {
    8848:	b508      	push	{r3, lr}
    DualQuant_instance[hemisphere].BaseView();
    884a:	4b04      	ldr	r3, [pc, #16]	; (885c <DualQuant_View(bool)+0x14>)
    884c:	f44f 723e 	mov.w	r2, #760	; 0x2f8
    8850:	fb02 3000 	mla	r0, r2, r0, r3
    8854:	f7ff ff36 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8858:	bd08      	pop	{r3, pc}
    885a:	bf00      	nop
    885c:	1fffcda4 	.word	0x1fffcda4

00008860 <EnigmaJr_View(bool)>:
void EnigmaJr_View(bool hemisphere) {EnigmaJr_instance[hemisphere].BaseView();}
    8860:	b508      	push	{r3, lr}
    8862:	4b04      	ldr	r3, [pc, #16]	; (8874 <EnigmaJr_View(bool)+0x14>)
    8864:	f44f 7243 	mov.w	r2, #780	; 0x30c
    8868:	fb02 3000 	mla	r0, r2, r0, r3
    886c:	f7ff ff2a 	bl	86c4 <HemisphereApplet::BaseView()>
    8870:	bd08      	pop	{r3, pc}
    8872:	bf00      	nop
    8874:	1fffd394 	.word	0x1fffd394

00008878 <EnvFollow_View(bool)>:
void EnvFollow_View(bool hemisphere) {EnvFollow_instance[hemisphere].BaseView();}
    8878:	b508      	push	{r3, lr}
    887a:	4b03      	ldr	r3, [pc, #12]	; (8888 <EnvFollow_View(bool)+0x10>)
    887c:	2290      	movs	r2, #144	; 0x90
    887e:	fb02 3000 	mla	r0, r2, r0, r3
    8882:	f7ff ff1f 	bl	86c4 <HemisphereApplet::BaseView()>
    8886:	bd08      	pop	{r3, pc}
    8888:	1fffe940 	.word	0x1fffe940

0000888c <GateDelay_View(bool)>:
void GateDelay_View(bool hemisphere) {
    888c:	b508      	push	{r3, lr}
    GateDelay_instance[hemisphere].BaseView();
    888e:	4b04      	ldr	r3, [pc, #16]	; (88a0 <GateDelay_View(bool)+0x14>)
    8890:	f44f 7221 	mov.w	r2, #644	; 0x284
    8894:	fb02 3000 	mla	r0, r2, r0, r3
    8898:	f7ff ff14 	bl	86c4 <HemisphereApplet::BaseView()>
}
    889c:	bd08      	pop	{r3, pc}
    889e:	bf00      	nop
    88a0:	1fffea60 	.word	0x1fffea60

000088a4 <GatedVCA_View(bool)>:
void GatedVCA_View(bool hemisphere) {
    88a4:	b508      	push	{r3, lr}
    GatedVCA_instance[hemisphere].BaseView();
    88a6:	4b03      	ldr	r3, [pc, #12]	; (88b4 <GatedVCA_View(bool)+0x10>)
    88a8:	2274      	movs	r2, #116	; 0x74
    88aa:	fb02 3000 	mla	r0, r2, r0, r3
    88ae:	f7ff ff09 	bl	86c4 <HemisphereApplet::BaseView()>
}
    88b2:	bd08      	pop	{r3, pc}
    88b4:	1fffef68 	.word	0x1fffef68

000088b8 <LoFiPCM_View(bool)>:
void LoFiPCM_View(bool hemisphere) {
    88b8:	b508      	push	{r3, lr}
    LoFiPCM_instance[hemisphere].BaseView();
    88ba:	4b04      	ldr	r3, [pc, #16]	; (88cc <LoFiPCM_View(bool)+0x14>)
    88bc:	f640 027c 	movw	r2, #2172	; 0x87c
    88c0:	fb02 3000 	mla	r0, r2, r0, r3
    88c4:	f7ff fefe 	bl	86c4 <HemisphereApplet::BaseView()>
}
    88c8:	bd08      	pop	{r3, pc}
    88ca:	bf00      	nop
    88cc:	1ffff054 	.word	0x1ffff054

000088d0 <Logic_View(bool)>:
void Logic_View(bool hemisphere) {
    88d0:	b508      	push	{r3, lr}
    Logic_instance[hemisphere].BaseView();
    88d2:	4b03      	ldr	r3, [pc, #12]	; (88e0 <Logic_View(bool)+0x10>)
    88d4:	22bc      	movs	r2, #188	; 0xbc
    88d6:	fb02 3000 	mla	r0, r2, r0, r3
    88da:	f7ff fef3 	bl	86c4 <HemisphereApplet::BaseView()>
}
    88de:	bd08      	pop	{r3, pc}
    88e0:	2000014c 	.word	0x2000014c

000088e4 <LowerRenz_View(bool)>:
void LowerRenz_View(bool hemisphere) {
    88e4:	b508      	push	{r3, lr}
    LowerRenz_instance[hemisphere].BaseView();
    88e6:	4b03      	ldr	r3, [pc, #12]	; (88f4 <LowerRenz_View(bool)+0x10>)
    88e8:	227c      	movs	r2, #124	; 0x7c
    88ea:	fb02 3000 	mla	r0, r2, r0, r3
    88ee:	f7ff fee9 	bl	86c4 <HemisphereApplet::BaseView()>
}
    88f2:	bd08      	pop	{r3, pc}
    88f4:	200002c4 	.word	0x200002c4

000088f8 <Metronome_View(bool)>:
void Metronome_View(bool hemisphere) {Metronome_instance[hemisphere].BaseView();}
    88f8:	b508      	push	{r3, lr}
    88fa:	4b03      	ldr	r3, [pc, #12]	; (8908 <Metronome_View(bool)+0x10>)
    88fc:	2274      	movs	r2, #116	; 0x74
    88fe:	fb02 3000 	mla	r0, r2, r0, r3
    8902:	f7ff fedf 	bl	86c4 <HemisphereApplet::BaseView()>
    8906:	bd08      	pop	{r3, pc}
    8908:	200003bc 	.word	0x200003bc

0000890c <MixerBal_View(bool)>:
void MixerBal_View(bool hemisphere) {
    890c:	b508      	push	{r3, lr}
    MixerBal_instance[hemisphere].BaseView();
    890e:	4b03      	ldr	r3, [pc, #12]	; (891c <MixerBal_View(bool)+0x10>)
    8910:	2274      	movs	r2, #116	; 0x74
    8912:	fb02 3000 	mla	r0, r2, r0, r3
    8916:	f7ff fed5 	bl	86c4 <HemisphereApplet::BaseView()>
}
    891a:	bd08      	pop	{r3, pc}
    891c:	200004a4 	.word	0x200004a4

00008920 <Palimpsest_View(bool)>:
void Palimpsest_View(bool hemisphere) {
    8920:	b508      	push	{r3, lr}
    Palimpsest_instance[hemisphere].BaseView();
    8922:	4b03      	ldr	r3, [pc, #12]	; (8930 <Palimpsest_View(bool)+0x10>)
    8924:	22cc      	movs	r2, #204	; 0xcc
    8926:	fb02 3000 	mla	r0, r2, r0, r3
    892a:	f7ff fecb 	bl	86c4 <HemisphereApplet::BaseView()>
}
    892e:	bd08      	pop	{r3, pc}
    8930:	20000d34 	.word	0x20000d34

00008934 <RunglBook_View(bool)>:
void RunglBook_View(bool hemisphere) {RunglBook_instance[hemisphere].BaseView();}
    8934:	b508      	push	{r3, lr}
    8936:	4b03      	ldr	r3, [pc, #12]	; (8944 <RunglBook_View(bool)+0x10>)
    8938:	2270      	movs	r2, #112	; 0x70
    893a:	fb02 3000 	mla	r0, r2, r0, r3
    893e:	f7ff fec1 	bl	86c4 <HemisphereApplet::BaseView()>
    8942:	bd08      	pop	{r3, pc}
    8944:	20000ecc 	.word	0x20000ecc

00008948 <ScaleDuet_View(bool)>:
void ScaleDuet_View(bool hemisphere) {
    8948:	b508      	push	{r3, lr}
    ScaleDuet_instance[hemisphere].BaseView();
    894a:	4b04      	ldr	r3, [pc, #16]	; (895c <ScaleDuet_View(bool)+0x14>)
    894c:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
    8950:	fb02 3000 	mla	r0, r2, r0, r3
    8954:	f7ff feb6 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8958:	bd08      	pop	{r3, pc}
    895a:	bf00      	nop
    895c:	20000fac 	.word	0x20000fac

00008960 <Schmitt_View(bool)>:
void Schmitt_View(bool hemisphere) {
    8960:	b508      	push	{r3, lr}
    Schmitt_instance[hemisphere].BaseView();
    8962:	4b03      	ldr	r3, [pc, #12]	; (8970 <Schmitt_View(bool)+0x10>)
    8964:	227c      	movs	r2, #124	; 0x7c
    8966:	fb02 3000 	mla	r0, r2, r0, r3
    896a:	f7ff feab 	bl	86c4 <HemisphereApplet::BaseView()>
}
    896e:	bd08      	pop	{r3, pc}
    8970:	2000130c 	.word	0x2000130c

00008974 <Scope_View(bool)>:
void Scope_View(bool hemisphere) {
    8974:	b508      	push	{r3, lr}
    Scope_instance[hemisphere].BaseView();
    8976:	4b03      	ldr	r3, [pc, #12]	; (8984 <Scope_View(bool)+0x10>)
    8978:	22d0      	movs	r2, #208	; 0xd0
    897a:	fb02 3000 	mla	r0, r2, r0, r3
    897e:	f7ff fea1 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8982:	bd08      	pop	{r3, pc}
    8984:	20001404 	.word	0x20001404

00008988 <Sequence5_View(bool)>:
void Sequence5_View(bool hemisphere) {
    8988:	b508      	push	{r3, lr}
    Sequence5_instance[hemisphere].BaseView();
    898a:	4b03      	ldr	r3, [pc, #12]	; (8998 <Sequence5_View(bool)+0x10>)
    898c:	2290      	movs	r2, #144	; 0x90
    898e:	fb02 3000 	mla	r0, r2, r0, r3
    8992:	f7ff fe97 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8996:	bd08      	pop	{r3, pc}
    8998:	200015a4 	.word	0x200015a4

0000899c <ShiftGate_View(bool)>:
void ShiftGate_View(bool hemisphere) {ShiftGate_instance[hemisphere].BaseView();}
    899c:	b508      	push	{r3, lr}
    899e:	4b03      	ldr	r3, [pc, #12]	; (89ac <ShiftGate_View(bool)+0x10>)
    89a0:	2278      	movs	r2, #120	; 0x78
    89a2:	fb02 3000 	mla	r0, r2, r0, r3
    89a6:	f7ff fe8d 	bl	86c4 <HemisphereApplet::BaseView()>
    89aa:	bd08      	pop	{r3, pc}
    89ac:	20001744 	.word	0x20001744

000089b0 <Shuffle_View(bool)>:
void Shuffle_View(bool hemisphere) {
    89b0:	b508      	push	{r3, lr}
    Shuffle_instance[hemisphere].BaseView();
    89b2:	4b03      	ldr	r3, [pc, #12]	; (89c0 <Shuffle_View(bool)+0x10>)
    89b4:	2284      	movs	r2, #132	; 0x84
    89b6:	fb02 3000 	mla	r0, r2, r0, r3
    89ba:	f7ff fe83 	bl	86c4 <HemisphereApplet::BaseView()>
}
    89be:	bd08      	pop	{r3, pc}
    89c0:	20001834 	.word	0x20001834

000089c4 <SkewedLFO_View(bool)>:
void SkewedLFO_View(bool hemisphere) {
    89c4:	b508      	push	{r3, lr}
    SkewedLFO_instance[hemisphere].BaseView();
    89c6:	4b03      	ldr	r3, [pc, #12]	; (89d4 <SkewedLFO_View(bool)+0x10>)
    89c8:	2284      	movs	r2, #132	; 0x84
    89ca:	fb02 3000 	mla	r0, r2, r0, r3
    89ce:	f7ff fe79 	bl	86c4 <HemisphereApplet::BaseView()>
}
    89d2:	bd08      	pop	{r3, pc}
    89d4:	2000193c 	.word	0x2000193c

000089d8 <Slew_View(bool)>:
void Slew_View(bool hemisphere) {
    89d8:	b508      	push	{r3, lr}
    Slew_instance[hemisphere].BaseView();
    89da:	4b03      	ldr	r3, [pc, #12]	; (89e8 <Slew_View(bool)+0x10>)
    89dc:	2288      	movs	r2, #136	; 0x88
    89de:	fb02 3000 	mla	r0, r2, r0, r3
    89e2:	f7ff fe6f 	bl	86c4 <HemisphereApplet::BaseView()>
}
    89e6:	bd08      	pop	{r3, pc}
    89e8:	20001a44 	.word	0x20001a44

000089ec <Squanch_View(bool)>:
void Squanch_View(bool hemisphere) {Squanch_instance[hemisphere].BaseView();}
    89ec:	b508      	push	{r3, lr}
    89ee:	4b04      	ldr	r3, [pc, #16]	; (8a00 <Squanch_View(bool)+0x14>)
    89f0:	f44f 72de 	mov.w	r2, #444	; 0x1bc
    89f4:	fb02 3000 	mla	r0, r2, r0, r3
    89f8:	f7ff fe64 	bl	86c4 <HemisphereApplet::BaseView()>
    89fc:	bd08      	pop	{r3, pc}
    89fe:	bf00      	nop
    8a00:	20001b54 	.word	0x20001b54

00008a04 <Switch_View(bool)>:
void Switch_View(bool hemisphere) {
    8a04:	b508      	push	{r3, lr}
    Switch_instance[hemisphere].BaseView();
    8a06:	4b03      	ldr	r3, [pc, #12]	; (8a14 <Switch_View(bool)+0x10>)
    8a08:	2278      	movs	r2, #120	; 0x78
    8a0a:	fb02 3000 	mla	r0, r2, r0, r3
    8a0e:	f7ff fe59 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8a12:	bd08      	pop	{r3, pc}
    8a14:	20001ecc 	.word	0x20001ecc

00008a18 <TLNeuron_View(bool)>:
void TLNeuron_View(bool hemisphere) {
    8a18:	b508      	push	{r3, lr}
    TLNeuron_instance[hemisphere].BaseView();
    8a1a:	4b03      	ldr	r3, [pc, #12]	; (8a28 <TLNeuron_View(bool)+0x10>)
    8a1c:	228c      	movs	r2, #140	; 0x8c
    8a1e:	fb02 3000 	mla	r0, r2, r0, r3
    8a22:	f7ff fe4f 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8a26:	bd08      	pop	{r3, pc}
    8a28:	20001fbc 	.word	0x20001fbc

00008a2c <TM_View(bool)>:
void TM_View(bool hemisphere) {
    8a2c:	b508      	push	{r3, lr}
    TM_instance[hemisphere].BaseView();
    8a2e:	4b04      	ldr	r3, [pc, #16]	; (8a40 <TM_View(bool)+0x14>)
    8a30:	f44f 72dc 	mov.w	r2, #440	; 0x1b8
    8a34:	fb02 3000 	mla	r0, r2, r0, r3
    8a38:	f7ff fe44 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8a3c:	bd08      	pop	{r3, pc}
    8a3e:	bf00      	nop
    8a40:	200020d4 	.word	0x200020d4

00008a44 <Trending_View(bool)>:
void Trending_View(bool hemisphere) {Trending_instance[hemisphere].BaseView();}
    8a44:	b508      	push	{r3, lr}
    8a46:	4b03      	ldr	r3, [pc, #12]	; (8a54 <Trending_View(bool)+0x10>)
    8a48:	22a0      	movs	r2, #160	; 0xa0
    8a4a:	fb02 3000 	mla	r0, r2, r0, r3
    8a4e:	f7ff fe39 	bl	86c4 <HemisphereApplet::BaseView()>
    8a52:	bd08      	pop	{r3, pc}
    8a54:	20002654 	.word	0x20002654

00008a58 <TrigSeq_View(bool)>:
void TrigSeq_View(bool hemisphere) {
    8a58:	b508      	push	{r3, lr}
    TrigSeq_instance[hemisphere].BaseView();
    8a5a:	4b03      	ldr	r3, [pc, #12]	; (8a68 <TrigSeq_View(bool)+0x10>)
    8a5c:	2284      	movs	r2, #132	; 0x84
    8a5e:	fb02 3000 	mla	r0, r2, r0, r3
    8a62:	f7ff fe2f 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8a66:	bd08      	pop	{r3, pc}
    8a68:	2000288c 	.word	0x2000288c

00008a6c <TrigSeq16_View(bool)>:
void TrigSeq16_View(bool hemisphere) {
    8a6c:	b508      	push	{r3, lr}
    TrigSeq16_instance[hemisphere].BaseView();
    8a6e:	4b03      	ldr	r3, [pc, #12]	; (8a7c <TrigSeq16_View(bool)+0x10>)
    8a70:	227c      	movs	r2, #124	; 0x7c
    8a72:	fb02 3000 	mla	r0, r2, r0, r3
    8a76:	f7ff fe25 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8a7a:	bd08      	pop	{r3, pc}
    8a7c:	20002794 	.word	0x20002794

00008a80 <Tuner_View(bool)>:
void Tuner_View(bool hemisphere) {
    8a80:	b508      	push	{r3, lr}
    Tuner_instance[hemisphere].BaseView();
    8a82:	4b03      	ldr	r3, [pc, #12]	; (8a90 <Tuner_View(bool)+0x10>)
    8a84:	2288      	movs	r2, #136	; 0x88
    8a86:	fb02 3000 	mla	r0, r2, r0, r3
    8a8a:	f7ff fe1b 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8a8e:	bd08      	pop	{r3, pc}
    8a90:	20002998 	.word	0x20002998

00008a94 <VectorEG_View(bool)>:
void VectorEG_View(bool hemisphere) {VectorEG_instance[hemisphere].BaseView();}
    8a94:	b508      	push	{r3, lr}
    8a96:	4b04      	ldr	r3, [pc, #16]	; (8aa8 <VectorEG_View(bool)+0x14>)
    8a98:	f44f 728a 	mov.w	r2, #276	; 0x114
    8a9c:	fb02 3000 	mla	r0, r2, r0, r3
    8aa0:	f7ff fe10 	bl	86c4 <HemisphereApplet::BaseView()>
    8aa4:	bd08      	pop	{r3, pc}
    8aa6:	bf00      	nop
    8aa8:	20002ab0 	.word	0x20002ab0

00008aac <VectorLFO_View(bool)>:
void VectorLFO_View(bool hemisphere) {VectorLFO_instance[hemisphere].BaseView();}
    8aac:	b508      	push	{r3, lr}
    8aae:	4b04      	ldr	r3, [pc, #16]	; (8ac0 <VectorLFO_View(bool)+0x14>)
    8ab0:	f44f 7288 	mov.w	r2, #272	; 0x110
    8ab4:	fb02 3000 	mla	r0, r2, r0, r3
    8ab8:	f7ff fe04 	bl	86c4 <HemisphereApplet::BaseView()>
    8abc:	bd08      	pop	{r3, pc}
    8abe:	bf00      	nop
    8ac0:	20002cd8 	.word	0x20002cd8

00008ac4 <VectorMod_View(bool)>:
void VectorMod_View(bool hemisphere) {VectorMod_instance[hemisphere].BaseView();}
    8ac4:	b508      	push	{r3, lr}
    8ac6:	4b04      	ldr	r3, [pc, #16]	; (8ad8 <VectorMod_View(bool)+0x14>)
    8ac8:	f44f 7288 	mov.w	r2, #272	; 0x110
    8acc:	fb02 3000 	mla	r0, r2, r0, r3
    8ad0:	f7ff fdf8 	bl	86c4 <HemisphereApplet::BaseView()>
    8ad4:	bd08      	pop	{r3, pc}
    8ad6:	bf00      	nop
    8ad8:	20002ef8 	.word	0x20002ef8

00008adc <VectorMorph_View(bool)>:
void VectorMorph_View(bool hemisphere) {VectorMorph_instance[hemisphere].BaseView();}
    8adc:	b508      	push	{r3, lr}
    8ade:	4b04      	ldr	r3, [pc, #16]	; (8af0 <VectorMorph_View(bool)+0x14>)
    8ae0:	f44f 728e 	mov.w	r2, #284	; 0x11c
    8ae4:	fb02 3000 	mla	r0, r2, r0, r3
    8ae8:	f7ff fdec 	bl	86c4 <HemisphereApplet::BaseView()>
    8aec:	bd08      	pop	{r3, pc}
    8aee:	bf00      	nop
    8af0:	20003118 	.word	0x20003118

00008af4 <Voltage_View(bool)>:
void Voltage_View(bool hemisphere) {Voltage_instance[hemisphere].BaseView();}
    8af4:	b508      	push	{r3, lr}
    8af6:	4b03      	ldr	r3, [pc, #12]	; (8b04 <Voltage_View(bool)+0x10>)
    8af8:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    8afc:	f7ff fde2 	bl	86c4 <HemisphereApplet::BaseView()>
    8b00:	bd08      	pop	{r3, pc}
    8b02:	bf00      	nop
    8b04:	20003350 	.word	0x20003350

00008b08 <hMIDIIn_View(bool)>:
void hMIDIIn_View(bool hemisphere) {
    8b08:	b508      	push	{r3, lr}
    hMIDIIn_instance[hemisphere].BaseView();
    8b0a:	4b03      	ldr	r3, [pc, #12]	; (8b18 <hMIDIIn_View(bool)+0x10>)
    8b0c:	eb03 2000 	add.w	r0, r3, r0, lsl #8
    8b10:	f7ff fdd8 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8b14:	bd08      	pop	{r3, pc}
    8b16:	bf00      	nop
    8b18:	20004db8 	.word	0x20004db8

00008b1c <hMIDIOut_View(bool)>:
void hMIDIOut_View(bool hemisphere) {
    8b1c:	b508      	push	{r3, lr}
    hMIDIOut_instance[hemisphere].BaseView();
    8b1e:	4b03      	ldr	r3, [pc, #12]	; (8b2c <hMIDIOut_View(bool)+0x10>)
    8b20:	eb03 2000 	add.w	r0, r3, r0, lsl #8
    8b24:	f7ff fdce 	bl	86c4 <HemisphereApplet::BaseView()>
}
    8b28:	bd08      	pop	{r3, pc}
    8b2a:	bf00      	nop
    8b2c:	20004fb8 	.word	0x20004fb8

00008b30 <RunglBook::View()>:
        gfxHeader(applet_name());
    8b30:	6803      	ldr	r3, [r0, #0]
    void View() {
    8b32:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    8b34:	681b      	ldr	r3, [r3, #0]
    void View() {
    8b36:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    8b38:	4798      	blx	r3
    8b3a:	4601      	mov	r1, r0
    8b3c:	4620      	mov	r0, r4
    8b3e:	f7ff fd5e 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        gfxPrint(1, 15, "Thr:");
    8b42:	4b07      	ldr	r3, [pc, #28]	; (8b60 <RunglBook::View()+0x30>)
    8b44:	220f      	movs	r2, #15
    8b46:	4620      	mov	r0, r4
    8b48:	2101      	movs	r1, #1
    8b4a:	f7ff fccd 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrintVoltage(threshold);
    8b4e:	4620      	mov	r0, r4
    8b50:	f8b4 106e 	ldrh.w	r1, [r4, #110]	; 0x6e
    8b54:	f7ff fcd6 	bl	8504 <HemisphereApplet::gfxPrintVoltage(int)>
        gfxSkyline();
    8b58:	4620      	mov	r0, r4
    8b5a:	f7ff fd1b 	bl	8594 <HemisphereApplet::gfxSkyline()>
    }
    8b5e:	bd10      	pop	{r4, pc}
    8b60:	00021064 	.word	0x00021064

00008b64 <ClockSkip::View()>:
        gfxHeader(applet_name());
    8b64:	6803      	ldr	r3, [r0, #0]
    void View() {
    8b66:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
        gfxHeader(applet_name());
    8b6a:	681b      	ldr	r3, [r3, #0]
        graphics.print(str);
    8b6c:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8c08 <ClockSkip::View()+0xa4>
    8b70:	f8df 9098 	ldr.w	r9, [pc, #152]	; 8c0c <ClockSkip::View()+0xa8>
    void View() {
    8b74:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    8b76:	4798      	blx	r3
    8b78:	4601      	mov	r1, r0
    8b7a:	4620      	mov	r0, r4
    8b7c:	f7ff fd3f 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        ForEachChannel(ch)
    8b80:	f104 066a 	add.w	r6, r4, #106	; 0x6a
    8b84:	2500      	movs	r5, #0
            gfxPrint(0 + (31 * ch), 15, p[ch]);
    8b86:	ebc5 1745 	rsb	r7, r5, r5, lsl #5
    8b8a:	f936 3f02 	ldrsh.w	r3, [r6, #2]!
    8b8e:	69a0      	ldr	r0, [r4, #24]
    8b90:	220f      	movs	r2, #15
    8b92:	4639      	mov	r1, r7
    8b94:	f7fb ff6c 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
    8b98:	4641      	mov	r1, r8
    8b9a:	4648      	mov	r0, r9
    8b9c:	f010 ff9b 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (ch == cursor) gfxCursor(0 + (31 * ch), 23, 30);
    8ba0:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    8ba4:	42ab      	cmp	r3, r5
    8ba6:	d105      	bne.n	8bb4 <ClockSkip::View()+0x50>
    8ba8:	231e      	movs	r3, #30
    8baa:	2217      	movs	r2, #23
    8bac:	4639      	mov	r1, r7
    8bae:	4620      	mov	r0, r4
    8bb0:	f7ff fc8e 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        ForEachChannel(ch)
    8bb4:	b32d      	cbz	r5, 8c02 <ClockSkip::View()+0x9e>
            gfxBitmap(12 + (32 * ch), 45, 8, CLOCK_ICON);
    8bb6:	4d16      	ldr	r5, [pc, #88]	; (8c10 <ClockSkip::View()+0xac>)
    8bb8:	69a0      	ldr	r0, [r4, #24]
    8bba:	9500      	str	r5, [sp, #0]
    8bbc:	2308      	movs	r3, #8
    8bbe:	222d      	movs	r2, #45	; 0x2d
    8bc0:	210c      	movs	r1, #12
    8bc2:	f7fb fee7 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            if (trigger_countdown[ch] > 0) gfxFrame(9 + (32 * ch), 42, 13, 13);
    8bc6:	6f23      	ldr	r3, [r4, #112]	; 0x70
    8bc8:	2b00      	cmp	r3, #0
    8bca:	dd06      	ble.n	8bda <ClockSkip::View()+0x76>
    8bcc:	230d      	movs	r3, #13
    8bce:	69a0      	ldr	r0, [r4, #24]
    8bd0:	9300      	str	r3, [sp, #0]
    8bd2:	222a      	movs	r2, #42	; 0x2a
    8bd4:	2109      	movs	r1, #9
    8bd6:	f7fb ff19 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
            gfxBitmap(12 + (32 * ch), 45, 8, CLOCK_ICON);
    8bda:	2308      	movs	r3, #8
    8bdc:	69a0      	ldr	r0, [r4, #24]
    8bde:	9500      	str	r5, [sp, #0]
    8be0:	222d      	movs	r2, #45	; 0x2d
    8be2:	212c      	movs	r1, #44	; 0x2c
    8be4:	f7fb fed6 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            if (trigger_countdown[ch] > 0) gfxFrame(9 + (32 * ch), 42, 13, 13);
    8be8:	6f63      	ldr	r3, [r4, #116]	; 0x74
    8bea:	2b00      	cmp	r3, #0
    8bec:	dd06      	ble.n	8bfc <ClockSkip::View()+0x98>
    8bee:	230d      	movs	r3, #13
    8bf0:	69a0      	ldr	r0, [r4, #24]
    8bf2:	9300      	str	r3, [sp, #0]
    8bf4:	222a      	movs	r2, #42	; 0x2a
    8bf6:	2129      	movs	r1, #41	; 0x29
    8bf8:	f7fb ff08 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    }
    8bfc:	b003      	add	sp, #12
    8bfe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    8c02:	2501      	movs	r5, #1
    8c04:	e7bf      	b.n	8b86 <ClockSkip::View()+0x22>
    8c06:	bf00      	nop
    8c08:	000204fb 	.word	0x000204fb
    8c0c:	200065e0 	.word	0x200065e0
    8c10:	00023c28 	.word	0x00023c28

00008c14 <GatedVCA::View()>:
    void View() {
    8c14:	b538      	push	{r3, r4, r5, lr}
        gfxHeader(applet_name());
    8c16:	6803      	ldr	r3, [r0, #0]
    8c18:	681b      	ldr	r3, [r3, #0]
    void View() {
    8c1a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    8c1c:	4798      	blx	r3
    8c1e:	4601      	mov	r1, r0
    8c20:	4620      	mov	r0, r4
    8c22:	f7ff fcec 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        gfxPrint(0, 15, "Offset:");
    8c26:	4b09      	ldr	r3, [pc, #36]	; (8c4c <GatedVCA::View()+0x38>)
    8c28:	220f      	movs	r2, #15
    8c2a:	4620      	mov	r0, r4
    8c2c:	2100      	movs	r1, #0
    8c2e:	f7ff fc5b 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(pad(100, amp_offset_pct), amp_offset_pct);
    8c32:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    8c34:	2064      	movs	r0, #100	; 0x64
    8c36:	4629      	mov	r1, r5
    8c38:	f7fb fd23 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    8c3c:	4629      	mov	r1, r5
    8c3e:	f7fb fefb 	bl	4a38 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]>
        gfxSkyline();
    8c42:	4620      	mov	r0, r4
    8c44:	f7ff fca6 	bl	8594 <HemisphereApplet::gfxSkyline()>
    }
    8c48:	bd38      	pop	{r3, r4, r5, pc}
    8c4a:	bf00      	nop
    8c4c:	00021069 	.word	0x00021069

00008c50 <Logic::View()>:
        gfxHeader(applet_name());
    8c50:	6803      	ldr	r3, [r0, #0]
    void View() {
    8c52:	b537      	push	{r0, r1, r2, r4, r5, lr}
        gfxHeader(applet_name());
    8c54:	681b      	ldr	r3, [r3, #0]
    void View() {
    8c56:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    8c58:	4798      	blx	r3
    8c5a:	4601      	mov	r1, r0
    8c5c:	4620      	mov	r0, r4
    8c5e:	f7ff fcce 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
            gfxPrint(0 + (31 * ch), 15, op_name[operation[ch]]);
    8c62:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
    8c66:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    8c6a:	2100      	movs	r1, #0
    8c6c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    8c6e:	220f      	movs	r2, #15
    8c70:	4620      	mov	r0, r4
    8c72:	f7ff fc39 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            if (ch == selected) gfxCursor(0 + (31 * ch), 23, 30);
    8c76:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
    8c7a:	b921      	cbnz	r1, 8c86 <Logic::View()+0x36>
    8c7c:	231e      	movs	r3, #30
    8c7e:	2217      	movs	r2, #23
    8c80:	4620      	mov	r0, r4
    8c82:	f7ff fc25 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            gfxPrint(0 + (31 * ch), 15, op_name[operation[ch]]);
    8c86:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    8c8a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    8c8e:	220f      	movs	r2, #15
    8c90:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    8c92:	211f      	movs	r1, #31
    8c94:	4620      	mov	r0, r4
    8c96:	f7ff fc27 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            if (ch == selected) gfxCursor(0 + (31 * ch), 23, 30);
    8c9a:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
    8c9e:	2b01      	cmp	r3, #1
    8ca0:	d105      	bne.n	8cae <Logic::View()+0x5e>
    8ca2:	231e      	movs	r3, #30
    8ca4:	2217      	movs	r2, #23
    8ca6:	211f      	movs	r1, #31
    8ca8:	4620      	mov	r0, r4
    8caa:	f7ff fc11 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            gfxBitmap(8 + (36 * ch), 45, 12, LOGIC_ICON[source[ch]]);
    8cae:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
    8cb2:	4d16      	ldr	r5, [pc, #88]	; (8d0c <Logic::View()+0xbc>)
    8cb4:	69a0      	ldr	r0, [r4, #24]
    8cb6:	230c      	movs	r3, #12
    8cb8:	fb03 5202 	mla	r2, r3, r2, r5
    8cbc:	9200      	str	r2, [sp, #0]
    8cbe:	2108      	movs	r1, #8
    8cc0:	222d      	movs	r2, #45	; 0x2d
    8cc2:	f7fb fe67 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            if (result[ch]) gfxFrame(5 + (36 * ch), 42, 17, 13);
    8cc6:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
    8cca:	b13b      	cbz	r3, 8cdc <Logic::View()+0x8c>
    8ccc:	230d      	movs	r3, #13
    8cce:	9300      	str	r3, [sp, #0]
    8cd0:	69a0      	ldr	r0, [r4, #24]
    8cd2:	2311      	movs	r3, #17
    8cd4:	222a      	movs	r2, #42	; 0x2a
    8cd6:	2105      	movs	r1, #5
    8cd8:	f7fb fe98 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
            gfxBitmap(8 + (36 * ch), 45, 12, LOGIC_ICON[source[ch]]);
    8cdc:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
    8ce0:	69a0      	ldr	r0, [r4, #24]
    8ce2:	230c      	movs	r3, #12
    8ce4:	fb03 5502 	mla	r5, r3, r2, r5
    8ce8:	9500      	str	r5, [sp, #0]
    8cea:	222d      	movs	r2, #45	; 0x2d
    8cec:	212c      	movs	r1, #44	; 0x2c
    8cee:	f7fb fe51 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            if (result[ch]) gfxFrame(5 + (36 * ch), 42, 17, 13);
    8cf2:	f894 30ad 	ldrb.w	r3, [r4, #173]	; 0xad
    8cf6:	b13b      	cbz	r3, 8d08 <Logic::View()+0xb8>
    8cf8:	230d      	movs	r3, #13
    8cfa:	9300      	str	r3, [sp, #0]
    8cfc:	69a0      	ldr	r0, [r4, #24]
    8cfe:	2311      	movs	r3, #17
    8d00:	222a      	movs	r2, #42	; 0x2a
    8d02:	2129      	movs	r1, #41	; 0x29
    8d04:	f7fb fe82 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    }
    8d08:	b003      	add	sp, #12
    8d0a:	bd30      	pop	{r4, r5, pc}
    8d0c:	00023c30 	.word	0x00023c30

00008d10 <MixerBal::View()>:
        gfxHeader(applet_name());
    8d10:	6803      	ldr	r3, [r0, #0]
    void View() {
    8d12:	b513      	push	{r0, r1, r4, lr}
        gfxHeader(applet_name());
    8d14:	681b      	ldr	r3, [r3, #0]
    void View() {
    8d16:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    8d18:	4798      	blx	r3
    8d1a:	4601      	mov	r1, r0
    8d1c:	4620      	mov	r0, r4
    8d1e:	f7ff fc6e 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        gfxFrame(1, 15, 62, 6);
    8d22:	2306      	movs	r3, #6
    8d24:	69a0      	ldr	r0, [r4, #24]
    8d26:	9300      	str	r3, [sp, #0]
    8d28:	220f      	movs	r2, #15
    8d2a:	233e      	movs	r3, #62	; 0x3e
    8d2c:	2101      	movs	r1, #1
    8d2e:	f7fb fe6d 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    8d32:	6f23      	ldr	r3, [r4, #112]	; 0x70
        gfxLine(x, 15, x, 20);
    8d34:	69a0      	ldr	r0, [r4, #24]
    8d36:	22ff      	movs	r2, #255	; 0xff
    8d38:	039b      	lsls	r3, r3, #14
    8d3a:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    8d3e:	223e      	movs	r2, #62	; 0x3e
    8d40:	4353      	muls	r3, r2
    8d42:	139b      	asrs	r3, r3, #14
    8d44:	2214      	movs	r2, #20
    8d46:	9200      	str	r2, [sp, #0]
    8d48:	4619      	mov	r1, r3
    8d4a:	220f      	movs	r2, #15
    8d4c:	f7fb fe50 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxSkyline();
    8d50:	4620      	mov	r0, r4
    8d52:	f7ff fc1f 	bl	8594 <HemisphereApplet::gfxSkyline()>
    }
    8d56:	b002      	add	sp, #8
    8d58:	bd10      	pop	{r4, pc}
    8d5a:	Address 0x0000000000008d5a is out of bounds.


00008d5c <Scope::View()>:
        gfxHeader(applet_name());
    8d5c:	6803      	ldr	r3, [r0, #0]
    void View() {
    8d5e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        gfxHeader(applet_name());
    8d62:	681b      	ldr	r3, [r3, #0]
        if (OC::CORE::ticks - last_bpm_tick < 1666) gfxBitmap(1, 15, 8, CLOCK_ICON);
    8d64:	4e3d      	ldr	r6, [pc, #244]	; (8e5c <Scope::View()+0x100>)
    void View() {
    8d66:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    8d68:	4798      	blx	r3
    8d6a:	4601      	mov	r1, r0
    8d6c:	4620      	mov	r0, r4
    8d6e:	f7ff fc46 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        gfxPrint(9, 15, "BPM ");
    8d72:	4b3b      	ldr	r3, [pc, #236]	; (8e60 <Scope::View()+0x104>)
    8d74:	220f      	movs	r2, #15
    8d76:	2109      	movs	r1, #9
    8d78:	4620      	mov	r0, r4
    8d7a:	f7ff fbb5 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(bpm / 4);
    8d7e:	6f21      	ldr	r1, [r4, #112]	; 0x70
        graphics.print(num);
    8d80:	4838      	ldr	r0, [pc, #224]	; (8e64 <Scope::View()+0x108>)
    8d82:	2900      	cmp	r1, #0
    8d84:	bfb8      	it	lt
    8d86:	3103      	addlt	r1, #3
    8d88:	1089      	asrs	r1, r1, #2
    8d8a:	f010 ff18 	bl	19bbe <weegfx::Graphics::print(int)>
        gfxLine(0, 24, 63, 24);
    8d8e:	2218      	movs	r2, #24
    8d90:	9200      	str	r2, [sp, #0]
    8d92:	233f      	movs	r3, #63	; 0x3f
    8d94:	69a0      	ldr	r0, [r4, #24]
    8d96:	2100      	movs	r1, #0
    8d98:	f7fb fe2a 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        if (OC::CORE::ticks - last_bpm_tick < 1666) gfxBitmap(1, 15, 8, CLOCK_ICON);
    8d9c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    8d9e:	6833      	ldr	r3, [r6, #0]
    8da0:	1a9b      	subs	r3, r3, r2
    8da2:	f240 6281 	movw	r2, #1665	; 0x681
    8da6:	4293      	cmp	r3, r2
    8da8:	d807      	bhi.n	8dba <Scope::View()+0x5e>
    8daa:	4b2f      	ldr	r3, [pc, #188]	; (8e68 <Scope::View()+0x10c>)
    8dac:	9300      	str	r3, [sp, #0]
    8dae:	69a0      	ldr	r0, [r4, #24]
    8db0:	2308      	movs	r3, #8
    8db2:	220f      	movs	r2, #15
    8db4:	2101      	movs	r1, #1
    8db6:	f7fb fded 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
    void View() {
    8dba:	2500      	movs	r5, #0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    8dbc:	f04f 08ff 	mov.w	r8, #255	; 0xff
        int scaled = simfloat2int(proportion * max_value);
    8dc0:	271c      	movs	r7, #28
            int x = s + sample_num;
    8dc2:	f8d4 10c4 	ldr.w	r1, [r4, #196]	; 0xc4
            gfxPixel(x, (28 - l) + 24);
    8dc6:	69a0      	ldr	r0, [r4, #24]
            int x = s + sample_num;
    8dc8:	4429      	add	r1, r5
            if (x > 63) x -= 64;
    8dca:	293f      	cmp	r1, #63	; 0x3f
    8dcc:	bfc8      	it	gt
    8dce:	3940      	subgt	r1, #64	; 0x40
            int l = Proportion(snapshot[x], 255, 28);
    8dd0:	1863      	adds	r3, r4, r1
        for (int s = 0; s < 64; s++)
    8dd2:	3501      	adds	r5, #1
            int l = Proportion(snapshot[x], 255, 28);
    8dd4:	f893 2079 	ldrb.w	r2, [r3, #121]	; 0x79
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    8dd8:	0392      	lsls	r2, r2, #14
    8dda:	fbb2 f2f8 	udiv	r2, r2, r8
        int scaled = simfloat2int(proportion * max_value);
    8dde:	437a      	muls	r2, r7
    8de0:	1392      	asrs	r2, r2, #14
            gfxPixel(x, (28 - l) + 24);
    8de2:	f1c2 0234 	rsb	r2, r2, #52	; 0x34
    8de6:	f7fb fe17 	bl	4a18 <HemisphereApplet::gfxPixel(int, int) [clone .isra.0]>
        for (int s = 0; s < 64; s++)
    8dea:	2d40      	cmp	r5, #64	; 0x40
    8dec:	d1e9      	bne.n	8dc2 <Scope::View()+0x66>
        if (OC::CORE::ticks - last_encoder_move < 16667) {
    8dee:	f8d4 20c8 	ldr.w	r2, [r4, #200]	; 0xc8
    8df2:	6833      	ldr	r3, [r6, #0]
    8df4:	1a9b      	subs	r3, r3, r2
    8df6:	f244 121a 	movw	r2, #16666	; 0x411a
    8dfa:	4293      	cmp	r3, r2
    8dfc:	d806      	bhi.n	8e0c <Scope::View()+0xb0>
            gfxPrint(1, 26, sample_ticks);
    8dfe:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
    8e02:	69a0      	ldr	r0, [r4, #24]
    8e04:	221a      	movs	r2, #26
    8e06:	2101      	movs	r1, #1
    8e08:	f7fb fe32 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxLine(0, 53, 63, 53);
    8e0c:	2235      	movs	r2, #53	; 0x35
    8e0e:	69a0      	ldr	r0, [r4, #24]
    8e10:	9200      	str	r2, [sp, #0]
    8e12:	233f      	movs	r3, #63	; 0x3f
    8e14:	2100      	movs	r1, #0
    8e16:	f7fb fdeb 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxBitmap(1, 55, 8, CV_ICON);
    8e1a:	4b14      	ldr	r3, [pc, #80]	; (8e6c <Scope::View()+0x110>)
    8e1c:	69a0      	ldr	r0, [r4, #24]
    8e1e:	9300      	str	r3, [sp, #0]
    8e20:	2237      	movs	r2, #55	; 0x37
    8e22:	2308      	movs	r3, #8
    8e24:	2101      	movs	r1, #1
    8e26:	f7fb fdb5 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        graphics.setPrintPos(x + gfx_offset, y);
    8e2a:	69a3      	ldr	r3, [r4, #24]
    8e2c:	4a0d      	ldr	r2, [pc, #52]	; (8e64 <Scope::View()+0x108>)
        gfxPrintVoltage(last_cv);
    8e2e:	6f61      	ldr	r1, [r4, #116]	; 0x74
    8e30:	330c      	adds	r3, #12
    8e32:	6053      	str	r3, [r2, #4]
    8e34:	4620      	mov	r0, r4
  text_y_ = y;
    8e36:	2337      	movs	r3, #55	; 0x37
    8e38:	6093      	str	r3, [r2, #8]
    8e3a:	f7ff fb63 	bl	8504 <HemisphereApplet::gfxPrintVoltage(int)>
        if (freeze) {
    8e3e:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    8e42:	b13b      	cbz	r3, 8e54 <Scope::View()+0xf8>
            gfxInvert(0, 24, 64, 40);
    8e44:	2328      	movs	r3, #40	; 0x28
    8e46:	9300      	str	r3, [sp, #0]
    8e48:	2218      	movs	r2, #24
    8e4a:	2340      	movs	r3, #64	; 0x40
    8e4c:	2100      	movs	r1, #0
    8e4e:	4620      	mov	r0, r4
    8e50:	f7ff fb98 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
    }
    8e54:	b002      	add	sp, #8
    8e56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8e5a:	bf00      	nop
    8e5c:	200046cc 	.word	0x200046cc
    8e60:	00021071 	.word	0x00021071
    8e64:	200065e0 	.word	0x200065e0
    8e68:	00023c28 	.word	0x00023c28
    8e6c:	000241f0 	.word	0x000241f0

00008e70 <Switch::View()>:
        gfxHeader(applet_name());
    8e70:	6803      	ldr	r3, [r0, #0]
    void View() {
    8e72:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    8e74:	681b      	ldr	r3, [r3, #0]
    void View() {
    8e76:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    8e78:	4798      	blx	r3
    8e7a:	4601      	mov	r1, r0
    8e7c:	4620      	mov	r0, r4
    8e7e:	f7ff fbbe 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        gfxPrint(1, 15, "Seq");
    8e82:	4620      	mov	r0, r4
    8e84:	4b0d      	ldr	r3, [pc, #52]	; (8ebc <Switch::View()+0x4c>)
    8e86:	220f      	movs	r2, #15
    8e88:	2101      	movs	r1, #1
    8e8a:	f7ff fb2d 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(36, 15, "Gate");
    8e8e:	4620      	mov	r0, r4
    8e90:	4b0b      	ldr	r3, [pc, #44]	; (8ec0 <Switch::View()+0x50>)
    8e92:	220f      	movs	r2, #15
    8e94:	2124      	movs	r1, #36	; 0x24
    8e96:	f7ff fb27 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(5 + (46 * ch), 40, active[ch]);
    8e9a:	6f23      	ldr	r3, [r4, #112]	; 0x70
    8e9c:	69a0      	ldr	r0, [r4, #24]
    8e9e:	2228      	movs	r2, #40	; 0x28
    8ea0:	2105      	movs	r1, #5
    8ea2:	f7fb fde5 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
    8ea6:	69a0      	ldr	r0, [r4, #24]
    8ea8:	6f63      	ldr	r3, [r4, #116]	; 0x74
    8eaa:	2228      	movs	r2, #40	; 0x28
    8eac:	2133      	movs	r1, #51	; 0x33
    8eae:	f7fb fddf 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxSkyline();
    8eb2:	4620      	mov	r0, r4
    8eb4:	f7ff fb6e 	bl	8594 <HemisphereApplet::gfxSkyline()>
    }
    8eb8:	bd10      	pop	{r4, pc}
    8eba:	bf00      	nop
    8ebc:	00020d06 	.word	0x00020d06
    8ec0:	00020c91 	.word	0x00020c91

00008ec4 <HemisphereApplet::DetentedIn(int)>:
        return inputs[ch];
    8ec4:	3108      	adds	r1, #8
    8ec6:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
        return (In(ch) > (HEMISPHERE_CENTER_CV + 64) || In(ch) < (HEMISPHERE_CENTER_CV - 64)) ? In(ch) : HEMISPHERE_CENTER_CV;
    8eca:	f100 0340 	add.w	r3, r0, #64	; 0x40
    8ece:	2b80      	cmp	r3, #128	; 0x80
    }
    8ed0:	bf98      	it	ls
    8ed2:	2000      	movls	r0, #0
    8ed4:	4770      	bx	lr

00008ed6 <HemisphereApplet::Out(int, int, int)>:
    void Out(int ch, int value, int octave = 0) {
    8ed6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8ed8:	4606      	mov	r6, r0
        DAC_CHANNEL channel = (DAC_CHANNEL)(ch + io_offset);
    8eda:	69c0      	ldr	r0, [r0, #28]
    void Out(int ch, int value, int octave = 0) {
    8edc:	4615      	mov	r5, r2
        DAC_CHANNEL channel = (DAC_CHANNEL)(ch + io_offset);
    8ede:	4408      	add	r0, r1
    void Out(int ch, int value, int octave = 0) {
    8ee0:	460c      	mov	r4, r1
        OC::DAC::set_pitch(channel, value, octave);
    8ee2:	461a      	mov	r2, r3
    8ee4:	4629      	mov	r1, r5
    8ee6:	b2c0      	uxtb	r0, r0
    void Out(int ch, int value, int octave = 0) {
    8ee8:	461f      	mov	r7, r3
        outputs[ch] = value + (octave * (12 << 7));
    8eea:	340a      	adds	r4, #10
        OC::DAC::set_pitch(channel, value, octave);
    8eec:	f7fb ffe0 	bl	4eb0 <OC::DAC::set_pitch(DAC_CHANNEL, long, long)>
        outputs[ch] = value + (octave * (12 << 7));
    8ef0:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    8ef4:	fb03 5507 	mla	r5, r3, r7, r5
    8ef8:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
    }
    8efc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8efe:	Address 0x0000000000008efe is out of bounds.


00008f00 <hMIDIIn::Start()>:
    void Start() {
    8f00:	b5f0      	push	{r4, r5, r6, r7, lr}
        const char * fn_name_list[] = {"Note#", "Trig", "Gate", "Veloc", "Mod", "Aft", "Bend", "Clock"};
    8f02:	4e15      	ldr	r6, [pc, #84]	; (8f58 <hMIDIIn::Start()+0x58>)
        channel = 0; // Default channel 1
    8f04:	2700      	movs	r7, #0
        first_note = -1;
    8f06:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    void Start() {
    8f0a:	4604      	mov	r4, r0
        channel = 0; // Default channel 1
    8f0c:	66c7      	str	r7, [r0, #108]	; 0x6c
        first_note = -1;
    8f0e:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
        const char * fn_name_list[] = {"Note#", "Trig", "Gate", "Veloc", "Mod", "Aft", "Bend", "Clock"};
    8f12:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    void Start() {
    8f14:	b089      	sub	sp, #36	; 0x24
        const char * fn_name_list[] = {"Note#", "Trig", "Gate", "Veloc", "Mod", "Aft", "Bend", "Clock"};
    8f16:	466d      	mov	r5, sp
    8f18:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    8f1a:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
    8f1e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
        for (int i = 0; i < 8; i++) fn_name[i] = fn_name_list[i];
    8f22:	4669      	mov	r1, sp
    8f24:	2220      	movs	r2, #32
    8f26:	f104 0084 	add.w	r0, r4, #132	; 0x84
    8f2a:	f011 f861 	bl	19ff0 <memcpy>
            Out(ch, 0);
    8f2e:	463b      	mov	r3, r7
    8f30:	463a      	mov	r2, r7
    8f32:	4639      	mov	r1, r7
    8f34:	4620      	mov	r0, r4
            function[ch] = ch * 2;
    8f36:	6727      	str	r7, [r4, #112]	; 0x70
            Out(ch, 0);
    8f38:	f7ff ffcd 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            function[ch] = ch * 2;
    8f3c:	2302      	movs	r3, #2
    8f3e:	6763      	str	r3, [r4, #116]	; 0x74
            Out(ch, 0);
    8f40:	463a      	mov	r2, r7
    8f42:	463b      	mov	r3, r7
    8f44:	2101      	movs	r1, #1
    8f46:	4620      	mov	r0, r4
    8f48:	f7ff ffc5 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        log_index = 0;
    8f4c:	f8c4 70fc 	str.w	r7, [r4, #252]	; 0xfc
        clock_count = 0;
    8f50:	f884 70a4 	strb.w	r7, [r4, #164]	; 0xa4
    }
    8f54:	b009      	add	sp, #36	; 0x24
    8f56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8f58:	000225dc 	.word	0x000225dc

00008f5c <HemisphereApplet::BaseController(bool)>:
    void BaseController(bool master_clock_on) {
    8f5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8f60:	4604      	mov	r4, r0
        master_clock_bus = (master_clock_on && hemisphere == RIGHT_HEMISPHERE);
    8f62:	b101      	cbz	r1, 8f66 <HemisphereApplet::BaseController(bool)+0xa>
    8f64:	7901      	ldrb	r1, [r0, #4]
    8f66:	f884 1054 	strb.w	r1, [r4, #84]	; 0x54
        ForEachChannel(ch)
    8f6a:	2600      	movs	r6, #0
    8f6c:	f104 051c 	add.w	r5, r4, #28
    8f70:	f104 0760 	add.w	r7, r4, #96	; 0x60
            } else changed_cv[ch] = 0;
    8f74:	46b0      	mov	r8, r6
                changed_cv[ch] = 1;
    8f76:	f04f 0901 	mov.w	r9, #1
            ADC_CHANNEL channel = (ADC_CHANNEL)(ch + io_offset);
    8f7a:	69e0      	ldr	r0, [r4, #28]
    8f7c:	4430      	add	r0, r6
            inputs[ch] = OC::ADC::raw_pitch_value(channel);
    8f7e:	b2c0      	uxtb	r0, r0
    8f80:	f7fc f812 	bl	4fa8 <OC::ADC::raw_pitch_value(ADC_CHANNEL)>
    8f84:	f845 0f04 	str.w	r0, [r5, #4]!
            if (abs(inputs[ch] - last_cv[ch]) > HEMISPHERE_CHANGE_THRESHOLD) {
    8f88:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    8f8a:	1ac3      	subs	r3, r0, r3
    8f8c:	2b00      	cmp	r3, #0
    8f8e:	bfb8      	it	lt
    8f90:	425b      	neglt	r3, r3
    8f92:	2b20      	cmp	r3, #32
            if (clock_countdown[ch] > 0) {
    8f94:	6a2b      	ldr	r3, [r5, #32]
                changed_cv[ch] = 1;
    8f96:	bfca      	itet	gt
    8f98:	f887 9000 	strbgt.w	r9, [r7]
            } else changed_cv[ch] = 0;
    8f9c:	f887 8000 	strble.w	r8, [r7]
                last_cv[ch] = inputs[ch];
    8fa0:	6468      	strgt	r0, [r5, #68]	; 0x44
            if (clock_countdown[ch] > 0) {
    8fa2:	2b00      	cmp	r3, #0
    8fa4:	dd07      	ble.n	8fb6 <HemisphereApplet::BaseController(bool)+0x5a>
                if (--clock_countdown[ch] == 0) Out(ch, 0);
    8fa6:	3b01      	subs	r3, #1
    8fa8:	622b      	str	r3, [r5, #32]
    8faa:	b923      	cbnz	r3, 8fb6 <HemisphereApplet::BaseController(bool)+0x5a>
    8fac:	461a      	mov	r2, r3
    8fae:	4631      	mov	r1, r6
    8fb0:	4620      	mov	r0, r4
    8fb2:	f7ff ff90 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
    8fb6:	3701      	adds	r7, #1
    8fb8:	b176      	cbz	r6, 8fd8 <HemisphereApplet::BaseController(bool)+0x7c>
        if (--cursor_countdown < -HEMISPHERE_CURSOR_TICKS) cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    8fba:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    8fbc:	4907      	ldr	r1, [pc, #28]	; (8fdc <HemisphereApplet::BaseController(bool)+0x80>)
    8fbe:	3b01      	subs	r3, #1
    8fc0:	f642 62e0 	movw	r2, #12000	; 0x2ee0
    8fc4:	428b      	cmp	r3, r1
    8fc6:	bfb8      	it	lt
    8fc8:	4613      	movlt	r3, r2
    8fca:	64a3      	str	r3, [r4, #72]	; 0x48
        Controller();
    8fcc:	6823      	ldr	r3, [r4, #0]
    8fce:	4620      	mov	r0, r4
    8fd0:	689b      	ldr	r3, [r3, #8]
    }
    8fd2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        Controller();
    8fd6:	4718      	bx	r3
    8fd8:	2601      	movs	r6, #1
    8fda:	e7ce      	b.n	8f7a <HemisphereApplet::BaseController(bool)+0x1e>
    8fdc:	ffffd120 	.word	0xffffd120

00008fe0 <ADEG_Controller(bool, bool)>:
void ADEG_Controller(bool hemisphere, bool forwarding) {ADEG_instance[hemisphere].BaseController(forwarding);}
    8fe0:	b508      	push	{r3, lr}
    8fe2:	4b03      	ldr	r3, [pc, #12]	; (8ff0 <ADEG_Controller(bool, bool)+0x10>)
    8fe4:	2290      	movs	r2, #144	; 0x90
    8fe6:	fb02 3000 	mla	r0, r2, r0, r3
    8fea:	f7ff ffb7 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    8fee:	bd08      	pop	{r3, pc}
    8ff0:	1fffa8c8 	.word	0x1fffa8c8

00008ff4 <ADSREG_Controller(bool, bool)>:
void ADSREG_Controller(bool hemisphere, bool forwarding) {
    8ff4:	b508      	push	{r3, lr}
    ADSREG_instance[hemisphere].BaseController(forwarding);
    8ff6:	4b03      	ldr	r3, [pc, #12]	; (9004 <ADSREG_Controller(bool, bool)+0x10>)
    8ff8:	22a4      	movs	r2, #164	; 0xa4
    8ffa:	fb02 3000 	mla	r0, r2, r0, r3
    8ffe:	f7ff ffad 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9002:	bd08      	pop	{r3, pc}
    9004:	1fffa9e8 	.word	0x1fffa9e8

00009008 <ASR_Controller(bool, bool)>:
void ASR_Controller(bool hemisphere, bool forwarding) {ASR_instance[hemisphere].BaseController(forwarding);}
    9008:	b508      	push	{r3, lr}
    900a:	4b04      	ldr	r3, [pc, #16]	; (901c <ASR_Controller(bool, bool)+0x14>)
    900c:	f44f 72da 	mov.w	r2, #436	; 0x1b4
    9010:	fb02 3000 	mla	r0, r2, r0, r3
    9014:	f7ff ffa2 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    9018:	bd08      	pop	{r3, pc}
    901a:	bf00      	nop
    901c:	1fffab30 	.word	0x1fffab30

00009020 <AnnularFusion_Controller(bool, bool)>:
void AnnularFusion_Controller(bool hemisphere, bool forwarding) {
    9020:	b508      	push	{r3, lr}
    AnnularFusion_instance[hemisphere].BaseController(forwarding);
    9022:	4b04      	ldr	r3, [pc, #16]	; (9034 <AnnularFusion_Controller(bool, bool)+0x14>)
    9024:	f44f 728a 	mov.w	r2, #276	; 0x114
    9028:	fb02 3000 	mla	r0, r2, r0, r3
    902c:	f7ff ff96 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9030:	bd08      	pop	{r3, pc}
    9032:	bf00      	nop
    9034:	1fffae98 	.word	0x1fffae98

00009038 <AttenuateOffset_Controller(bool, bool)>:
void AttenuateOffset_Controller(bool hemisphere, bool forwarding) {AttenuateOffset_instance[hemisphere].BaseController(forwarding);}
    9038:	b508      	push	{r3, lr}
    903a:	4b03      	ldr	r3, [pc, #12]	; (9048 <AttenuateOffset_Controller(bool, bool)+0x10>)
    903c:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    9040:	f7ff ff8c 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    9044:	bd08      	pop	{r3, pc}
    9046:	bf00      	nop
    9048:	1fffb0c0 	.word	0x1fffb0c0

0000904c <Binary_Controller(bool, bool)>:
void Binary_Controller(bool hemisphere, bool forwarding) {
    904c:	b508      	push	{r3, lr}
    Binary_instance[hemisphere].BaseController(forwarding);
    904e:	4b03      	ldr	r3, [pc, #12]	; (905c <Binary_Controller(bool, bool)+0x10>)
    9050:	22e4      	movs	r2, #228	; 0xe4
    9052:	fb02 3000 	mla	r0, r2, r0, r3
    9056:	f7ff ff81 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    905a:	bd08      	pop	{r3, pc}
    905c:	1fffb1c8 	.word	0x1fffb1c8

00009060 <BootsNCat_Controller(bool, bool)>:
void BootsNCat_Controller(bool hemisphere, bool forwarding) {BootsNCat_instance[hemisphere].BaseController(forwarding);}
    9060:	b508      	push	{r3, lr}
    9062:	4b04      	ldr	r3, [pc, #16]	; (9074 <BootsNCat_Controller(bool, bool)+0x14>)
    9064:	f44f 72b6 	mov.w	r2, #364	; 0x16c
    9068:	fb02 3000 	mla	r0, r2, r0, r3
    906c:	f7ff ff76 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    9070:	bd08      	pop	{r3, pc}
    9072:	bf00      	nop
    9074:	1fffb390 	.word	0x1fffb390

00009078 <Brancher_Controller(bool, bool)>:
void Brancher_Controller(bool hemisphere, bool forwarding) {
    9078:	b508      	push	{r3, lr}
	Brancher_instance[hemisphere].BaseController(forwarding);
    907a:	4b03      	ldr	r3, [pc, #12]	; (9088 <Brancher_Controller(bool, bool)+0x10>)
    907c:	2274      	movs	r2, #116	; 0x74
    907e:	fb02 3000 	mla	r0, r2, r0, r3
    9082:	f7ff ff6b 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9086:	bd08      	pop	{r3, pc}
    9088:	1fffb668 	.word	0x1fffb668

0000908c <Burst_Controller(bool, bool)>:
void Burst_Controller(bool hemisphere, bool forwarding) {
    908c:	b508      	push	{r3, lr}
    Burst_instance[hemisphere].BaseController(forwarding);
    908e:	4b03      	ldr	r3, [pc, #12]	; (909c <Burst_Controller(bool, bool)+0x10>)
    9090:	2290      	movs	r2, #144	; 0x90
    9092:	fb02 3000 	mla	r0, r2, r0, r3
    9096:	f7ff ff61 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    909a:	bd08      	pop	{r3, pc}
    909c:	1fffb750 	.word	0x1fffb750

000090a0 <CVRecV2_Controller(bool, bool)>:
void CVRecV2_Controller(bool hemisphere, bool forwarding) {CVRecV2_instance[hemisphere].BaseController(forwarding);}
    90a0:	b508      	push	{r3, lr}
    90a2:	4b04      	ldr	r3, [pc, #16]	; (90b4 <CVRecV2_Controller(bool, bool)+0x14>)
    90a4:	f240 62fc 	movw	r2, #1788	; 0x6fc
    90a8:	fb02 3000 	mla	r0, r2, r0, r3
    90ac:	f7ff ff56 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    90b0:	bd08      	pop	{r3, pc}
    90b2:	bf00      	nop
    90b4:	1fffb878 	.word	0x1fffb878

000090b8 <Calculate_Controller(bool, bool)>:
void Calculate_Controller(bool hemisphere, bool forwarding) {
    90b8:	b508      	push	{r3, lr}
    Calculate_instance[hemisphere].BaseController(forwarding);
    90ba:	4b03      	ldr	r3, [pc, #12]	; (90c8 <Calculate_Controller(bool, bool)+0x10>)
    90bc:	22bc      	movs	r2, #188	; 0xbc
    90be:	fb02 3000 	mla	r0, r2, r0, r3
    90c2:	f7ff ff4b 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    90c6:	bd08      	pop	{r3, pc}
    90c8:	1fffc670 	.word	0x1fffc670

000090cc <Carpeggio_Controller(bool, bool)>:
void Carpeggio_Controller(bool hemisphere, bool forwarding) {
    90cc:	b508      	push	{r3, lr}
    Carpeggio_instance[hemisphere].BaseController(forwarding);
    90ce:	4b03      	ldr	r3, [pc, #12]	; (90dc <Carpeggio_Controller(bool, bool)+0x10>)
    90d0:	22a8      	movs	r2, #168	; 0xa8
    90d2:	fb02 3000 	mla	r0, r2, r0, r3
    90d6:	f7ff ff41 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    90da:	bd08      	pop	{r3, pc}
    90dc:	1fffc7e8 	.word	0x1fffc7e8

000090e0 <ClockDivider_Controller(bool, bool)>:
void ClockDivider_Controller(bool hemisphere, bool forwarding) {
    90e0:	b508      	push	{r3, lr}
    ClockDivider_instance[hemisphere].BaseController(forwarding);
    90e2:	4b03      	ldr	r3, [pc, #12]	; (90f0 <ClockDivider_Controller(bool, bool)+0x10>)
    90e4:	228c      	movs	r2, #140	; 0x8c
    90e6:	fb02 3000 	mla	r0, r2, r0, r3
    90ea:	f7ff ff37 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    90ee:	bd08      	pop	{r3, pc}
    90f0:	1fffc938 	.word	0x1fffc938

000090f4 <ClockSetup_Controller(bool, bool)>:
void ClockSetup_Controller(bool hemisphere, bool forwarding) {ClockSetup_instance[hemisphere].BaseController(forwarding);}
    90f4:	b508      	push	{r3, lr}
    90f6:	4b03      	ldr	r3, [pc, #12]	; (9104 <ClockSetup_Controller(bool, bool)+0x10>)
    90f8:	2274      	movs	r2, #116	; 0x74
    90fa:	fb02 3000 	mla	r0, r2, r0, r3
    90fe:	f7ff ff2d 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    9102:	bd08      	pop	{r3, pc}
    9104:	1fffca50 	.word	0x1fffca50

00009108 <ClockSkip_Controller(bool, bool)>:
void ClockSkip_Controller(bool hemisphere, bool forwarding) {
    9108:	b508      	push	{r3, lr}
    ClockSkip_instance[hemisphere].BaseController(forwarding);
    910a:	4b03      	ldr	r3, [pc, #12]	; (9118 <ClockSkip_Controller(bool, bool)+0x10>)
    910c:	227c      	movs	r2, #124	; 0x7c
    910e:	fb02 3000 	mla	r0, r2, r0, r3
    9112:	f7ff ff23 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9116:	bd08      	pop	{r3, pc}
    9118:	1fffcac4 	.word	0x1fffcac4

0000911c <Compare_Controller(bool, bool)>:
void Compare_Controller(bool hemisphere, bool forwarding) {
    911c:	b508      	push	{r3, lr}
    Compare_instance[hemisphere].BaseController(forwarding);
    911e:	4b03      	ldr	r3, [pc, #12]	; (912c <Compare_Controller(bool, bool)+0x10>)
    9120:	2278      	movs	r2, #120	; 0x78
    9122:	fb02 3000 	mla	r0, r2, r0, r3
    9126:	f7ff ff19 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    912a:	bd08      	pop	{r3, pc}
    912c:	1fffcbbc 	.word	0x1fffcbbc

00009130 <DrCrusher_Controller(bool, bool)>:
void DrCrusher_Controller(bool hemisphere, bool forwarding) {DrCrusher_instance[hemisphere].BaseController(forwarding);}
    9130:	b508      	push	{r3, lr}
    9132:	4b03      	ldr	r3, [pc, #12]	; (9140 <DrCrusher_Controller(bool, bool)+0x10>)
    9134:	227c      	movs	r2, #124	; 0x7c
    9136:	fb02 3000 	mla	r0, r2, r0, r3
    913a:	f7ff ff0f 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    913e:	bd08      	pop	{r3, pc}
    9140:	1fffccac 	.word	0x1fffccac

00009144 <DualQuant_Controller(bool, bool)>:
void DualQuant_Controller(bool hemisphere, bool forwarding) {
    9144:	b508      	push	{r3, lr}
    DualQuant_instance[hemisphere].BaseController(forwarding);
    9146:	4b04      	ldr	r3, [pc, #16]	; (9158 <DualQuant_Controller(bool, bool)+0x14>)
    9148:	f44f 723e 	mov.w	r2, #760	; 0x2f8
    914c:	fb02 3000 	mla	r0, r2, r0, r3
    9150:	f7ff ff04 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9154:	bd08      	pop	{r3, pc}
    9156:	bf00      	nop
    9158:	1fffcda4 	.word	0x1fffcda4

0000915c <EnigmaJr_Controller(bool, bool)>:
void EnigmaJr_Controller(bool hemisphere, bool forwarding) {EnigmaJr_instance[hemisphere].BaseController(forwarding);}
    915c:	b508      	push	{r3, lr}
    915e:	4b04      	ldr	r3, [pc, #16]	; (9170 <EnigmaJr_Controller(bool, bool)+0x14>)
    9160:	f44f 7243 	mov.w	r2, #780	; 0x30c
    9164:	fb02 3000 	mla	r0, r2, r0, r3
    9168:	f7ff fef8 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    916c:	bd08      	pop	{r3, pc}
    916e:	bf00      	nop
    9170:	1fffd394 	.word	0x1fffd394

00009174 <EnvFollow_Controller(bool, bool)>:
void EnvFollow_Controller(bool hemisphere, bool forwarding) {EnvFollow_instance[hemisphere].BaseController(forwarding);}
    9174:	b508      	push	{r3, lr}
    9176:	4b03      	ldr	r3, [pc, #12]	; (9184 <EnvFollow_Controller(bool, bool)+0x10>)
    9178:	2290      	movs	r2, #144	; 0x90
    917a:	fb02 3000 	mla	r0, r2, r0, r3
    917e:	f7ff feed 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    9182:	bd08      	pop	{r3, pc}
    9184:	1fffe940 	.word	0x1fffe940

00009188 <GateDelay_Controller(bool, bool)>:
void GateDelay_Controller(bool hemisphere, bool forwarding) {
    9188:	b508      	push	{r3, lr}
    GateDelay_instance[hemisphere].BaseController(forwarding);
    918a:	4b04      	ldr	r3, [pc, #16]	; (919c <GateDelay_Controller(bool, bool)+0x14>)
    918c:	f44f 7221 	mov.w	r2, #644	; 0x284
    9190:	fb02 3000 	mla	r0, r2, r0, r3
    9194:	f7ff fee2 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9198:	bd08      	pop	{r3, pc}
    919a:	bf00      	nop
    919c:	1fffea60 	.word	0x1fffea60

000091a0 <GatedVCA_Controller(bool, bool)>:
void GatedVCA_Controller(bool hemisphere, bool forwarding) {
    91a0:	b508      	push	{r3, lr}
    GatedVCA_instance[hemisphere].BaseController(forwarding);
    91a2:	4b03      	ldr	r3, [pc, #12]	; (91b0 <GatedVCA_Controller(bool, bool)+0x10>)
    91a4:	2274      	movs	r2, #116	; 0x74
    91a6:	fb02 3000 	mla	r0, r2, r0, r3
    91aa:	f7ff fed7 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    91ae:	bd08      	pop	{r3, pc}
    91b0:	1fffef68 	.word	0x1fffef68

000091b4 <LoFiPCM_Controller(bool, bool)>:
void LoFiPCM_Controller(bool hemisphere, bool forwarding) {
    91b4:	b508      	push	{r3, lr}
    LoFiPCM_instance[hemisphere].BaseController(forwarding);
    91b6:	4b04      	ldr	r3, [pc, #16]	; (91c8 <LoFiPCM_Controller(bool, bool)+0x14>)
    91b8:	f640 027c 	movw	r2, #2172	; 0x87c
    91bc:	fb02 3000 	mla	r0, r2, r0, r3
    91c0:	f7ff fecc 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    91c4:	bd08      	pop	{r3, pc}
    91c6:	bf00      	nop
    91c8:	1ffff054 	.word	0x1ffff054

000091cc <Logic_Controller(bool, bool)>:
void Logic_Controller(bool hemisphere, bool forwarding) {
    91cc:	b508      	push	{r3, lr}
    Logic_instance[hemisphere].BaseController(forwarding);
    91ce:	4b03      	ldr	r3, [pc, #12]	; (91dc <Logic_Controller(bool, bool)+0x10>)
    91d0:	22bc      	movs	r2, #188	; 0xbc
    91d2:	fb02 3000 	mla	r0, r2, r0, r3
    91d6:	f7ff fec1 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    91da:	bd08      	pop	{r3, pc}
    91dc:	2000014c 	.word	0x2000014c

000091e0 <LowerRenz_Controller(bool, bool)>:
void LowerRenz_Controller(bool hemisphere, bool forwarding) {
    91e0:	b508      	push	{r3, lr}
    LowerRenz_instance[hemisphere].BaseController(forwarding);
    91e2:	4b03      	ldr	r3, [pc, #12]	; (91f0 <LowerRenz_Controller(bool, bool)+0x10>)
    91e4:	227c      	movs	r2, #124	; 0x7c
    91e6:	fb02 3000 	mla	r0, r2, r0, r3
    91ea:	f7ff feb7 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    91ee:	bd08      	pop	{r3, pc}
    91f0:	200002c4 	.word	0x200002c4

000091f4 <Metronome_Controller(bool, bool)>:
void Metronome_Controller(bool hemisphere, bool forwarding) {Metronome_instance[hemisphere].BaseController(forwarding);}
    91f4:	b508      	push	{r3, lr}
    91f6:	4b03      	ldr	r3, [pc, #12]	; (9204 <Metronome_Controller(bool, bool)+0x10>)
    91f8:	2274      	movs	r2, #116	; 0x74
    91fa:	fb02 3000 	mla	r0, r2, r0, r3
    91fe:	f7ff fead 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    9202:	bd08      	pop	{r3, pc}
    9204:	200003bc 	.word	0x200003bc

00009208 <MixerBal_Controller(bool, bool)>:
void MixerBal_Controller(bool hemisphere, bool forwarding) {
    9208:	b508      	push	{r3, lr}
    MixerBal_instance[hemisphere].BaseController(forwarding);
    920a:	4b03      	ldr	r3, [pc, #12]	; (9218 <MixerBal_Controller(bool, bool)+0x10>)
    920c:	2274      	movs	r2, #116	; 0x74
    920e:	fb02 3000 	mla	r0, r2, r0, r3
    9212:	f7ff fea3 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9216:	bd08      	pop	{r3, pc}
    9218:	200004a4 	.word	0x200004a4

0000921c <Palimpsest_Controller(bool, bool)>:
void Palimpsest_Controller(bool hemisphere, bool forwarding) {
    921c:	b508      	push	{r3, lr}
    Palimpsest_instance[hemisphere].BaseController(forwarding);
    921e:	4b03      	ldr	r3, [pc, #12]	; (922c <Palimpsest_Controller(bool, bool)+0x10>)
    9220:	22cc      	movs	r2, #204	; 0xcc
    9222:	fb02 3000 	mla	r0, r2, r0, r3
    9226:	f7ff fe99 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    922a:	bd08      	pop	{r3, pc}
    922c:	20000d34 	.word	0x20000d34

00009230 <RunglBook_Controller(bool, bool)>:
void RunglBook_Controller(bool hemisphere, bool forwarding) {RunglBook_instance[hemisphere].BaseController(forwarding);}
    9230:	b508      	push	{r3, lr}
    9232:	4b03      	ldr	r3, [pc, #12]	; (9240 <RunglBook_Controller(bool, bool)+0x10>)
    9234:	2270      	movs	r2, #112	; 0x70
    9236:	fb02 3000 	mla	r0, r2, r0, r3
    923a:	f7ff fe8f 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    923e:	bd08      	pop	{r3, pc}
    9240:	20000ecc 	.word	0x20000ecc

00009244 <ScaleDuet_Controller(bool, bool)>:
void ScaleDuet_Controller(bool hemisphere, bool forwarding) {
    9244:	b508      	push	{r3, lr}
    ScaleDuet_instance[hemisphere].BaseController(forwarding);
    9246:	4b04      	ldr	r3, [pc, #16]	; (9258 <ScaleDuet_Controller(bool, bool)+0x14>)
    9248:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
    924c:	fb02 3000 	mla	r0, r2, r0, r3
    9250:	f7ff fe84 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9254:	bd08      	pop	{r3, pc}
    9256:	bf00      	nop
    9258:	20000fac 	.word	0x20000fac

0000925c <Schmitt_Controller(bool, bool)>:
void Schmitt_Controller(bool hemisphere, bool forwarding) {
    925c:	b508      	push	{r3, lr}
    Schmitt_instance[hemisphere].BaseController(forwarding);
    925e:	4b03      	ldr	r3, [pc, #12]	; (926c <Schmitt_Controller(bool, bool)+0x10>)
    9260:	227c      	movs	r2, #124	; 0x7c
    9262:	fb02 3000 	mla	r0, r2, r0, r3
    9266:	f7ff fe79 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    926a:	bd08      	pop	{r3, pc}
    926c:	2000130c 	.word	0x2000130c

00009270 <Scope_Controller(bool, bool)>:
void Scope_Controller(bool hemisphere, bool forwarding) {
    9270:	b508      	push	{r3, lr}
    Scope_instance[hemisphere].BaseController(forwarding);
    9272:	4b03      	ldr	r3, [pc, #12]	; (9280 <Scope_Controller(bool, bool)+0x10>)
    9274:	22d0      	movs	r2, #208	; 0xd0
    9276:	fb02 3000 	mla	r0, r2, r0, r3
    927a:	f7ff fe6f 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    927e:	bd08      	pop	{r3, pc}
    9280:	20001404 	.word	0x20001404

00009284 <Sequence5_Controller(bool, bool)>:
void Sequence5_Controller(bool hemisphere, bool forwarding) {
    9284:	b508      	push	{r3, lr}
    Sequence5_instance[hemisphere].BaseController(forwarding);
    9286:	4b03      	ldr	r3, [pc, #12]	; (9294 <Sequence5_Controller(bool, bool)+0x10>)
    9288:	2290      	movs	r2, #144	; 0x90
    928a:	fb02 3000 	mla	r0, r2, r0, r3
    928e:	f7ff fe65 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9292:	bd08      	pop	{r3, pc}
    9294:	200015a4 	.word	0x200015a4

00009298 <ShiftGate_Controller(bool, bool)>:
void ShiftGate_Controller(bool hemisphere, bool forwarding) {ShiftGate_instance[hemisphere].BaseController(forwarding);}
    9298:	b508      	push	{r3, lr}
    929a:	4b03      	ldr	r3, [pc, #12]	; (92a8 <ShiftGate_Controller(bool, bool)+0x10>)
    929c:	2278      	movs	r2, #120	; 0x78
    929e:	fb02 3000 	mla	r0, r2, r0, r3
    92a2:	f7ff fe5b 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    92a6:	bd08      	pop	{r3, pc}
    92a8:	20001744 	.word	0x20001744

000092ac <Shuffle_Controller(bool, bool)>:
void Shuffle_Controller(bool hemisphere, bool forwarding) {
    92ac:	b508      	push	{r3, lr}
    Shuffle_instance[hemisphere].BaseController(forwarding);
    92ae:	4b03      	ldr	r3, [pc, #12]	; (92bc <Shuffle_Controller(bool, bool)+0x10>)
    92b0:	2284      	movs	r2, #132	; 0x84
    92b2:	fb02 3000 	mla	r0, r2, r0, r3
    92b6:	f7ff fe51 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    92ba:	bd08      	pop	{r3, pc}
    92bc:	20001834 	.word	0x20001834

000092c0 <SkewedLFO_Controller(bool, bool)>:
void SkewedLFO_Controller(bool hemisphere, bool forwarding) {
    92c0:	b508      	push	{r3, lr}
    SkewedLFO_instance[hemisphere].BaseController(forwarding);
    92c2:	4b03      	ldr	r3, [pc, #12]	; (92d0 <SkewedLFO_Controller(bool, bool)+0x10>)
    92c4:	2284      	movs	r2, #132	; 0x84
    92c6:	fb02 3000 	mla	r0, r2, r0, r3
    92ca:	f7ff fe47 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    92ce:	bd08      	pop	{r3, pc}
    92d0:	2000193c 	.word	0x2000193c

000092d4 <Slew_Controller(bool, bool)>:
void Slew_Controller(bool hemisphere, bool forwarding) {
    92d4:	b508      	push	{r3, lr}
    Slew_instance[hemisphere].BaseController(forwarding);
    92d6:	4b03      	ldr	r3, [pc, #12]	; (92e4 <Slew_Controller(bool, bool)+0x10>)
    92d8:	2288      	movs	r2, #136	; 0x88
    92da:	fb02 3000 	mla	r0, r2, r0, r3
    92de:	f7ff fe3d 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    92e2:	bd08      	pop	{r3, pc}
    92e4:	20001a44 	.word	0x20001a44

000092e8 <Squanch_Controller(bool, bool)>:
void Squanch_Controller(bool hemisphere, bool forwarding) {Squanch_instance[hemisphere].BaseController(forwarding);}
    92e8:	b508      	push	{r3, lr}
    92ea:	4b04      	ldr	r3, [pc, #16]	; (92fc <Squanch_Controller(bool, bool)+0x14>)
    92ec:	f44f 72de 	mov.w	r2, #444	; 0x1bc
    92f0:	fb02 3000 	mla	r0, r2, r0, r3
    92f4:	f7ff fe32 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    92f8:	bd08      	pop	{r3, pc}
    92fa:	bf00      	nop
    92fc:	20001b54 	.word	0x20001b54

00009300 <Switch_Controller(bool, bool)>:
void Switch_Controller(bool hemisphere, bool forwarding) {
    9300:	b508      	push	{r3, lr}
    Switch_instance[hemisphere].BaseController(forwarding);
    9302:	4b03      	ldr	r3, [pc, #12]	; (9310 <Switch_Controller(bool, bool)+0x10>)
    9304:	2278      	movs	r2, #120	; 0x78
    9306:	fb02 3000 	mla	r0, r2, r0, r3
    930a:	f7ff fe27 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    930e:	bd08      	pop	{r3, pc}
    9310:	20001ecc 	.word	0x20001ecc

00009314 <TLNeuron_Controller(bool, bool)>:
void TLNeuron_Controller(bool hemisphere, bool forwarding) {
    9314:	b508      	push	{r3, lr}
    TLNeuron_instance[hemisphere].BaseController(forwarding);
    9316:	4b03      	ldr	r3, [pc, #12]	; (9324 <TLNeuron_Controller(bool, bool)+0x10>)
    9318:	228c      	movs	r2, #140	; 0x8c
    931a:	fb02 3000 	mla	r0, r2, r0, r3
    931e:	f7ff fe1d 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9322:	bd08      	pop	{r3, pc}
    9324:	20001fbc 	.word	0x20001fbc

00009328 <TM_Controller(bool, bool)>:
void TM_Controller(bool hemisphere, bool forwarding) {
    9328:	b508      	push	{r3, lr}
    TM_instance[hemisphere].BaseController(forwarding);
    932a:	4b04      	ldr	r3, [pc, #16]	; (933c <TM_Controller(bool, bool)+0x14>)
    932c:	f44f 72dc 	mov.w	r2, #440	; 0x1b8
    9330:	fb02 3000 	mla	r0, r2, r0, r3
    9334:	f7ff fe12 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9338:	bd08      	pop	{r3, pc}
    933a:	bf00      	nop
    933c:	200020d4 	.word	0x200020d4

00009340 <Trending_Controller(bool, bool)>:
void Trending_Controller(bool hemisphere, bool forwarding) {Trending_instance[hemisphere].BaseController(forwarding);}
    9340:	b508      	push	{r3, lr}
    9342:	4b03      	ldr	r3, [pc, #12]	; (9350 <Trending_Controller(bool, bool)+0x10>)
    9344:	22a0      	movs	r2, #160	; 0xa0
    9346:	fb02 3000 	mla	r0, r2, r0, r3
    934a:	f7ff fe07 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    934e:	bd08      	pop	{r3, pc}
    9350:	20002654 	.word	0x20002654

00009354 <TrigSeq_Controller(bool, bool)>:
void TrigSeq_Controller(bool hemisphere, bool forwarding) {
    9354:	b508      	push	{r3, lr}
    TrigSeq_instance[hemisphere].BaseController(forwarding);
    9356:	4b03      	ldr	r3, [pc, #12]	; (9364 <TrigSeq_Controller(bool, bool)+0x10>)
    9358:	2284      	movs	r2, #132	; 0x84
    935a:	fb02 3000 	mla	r0, r2, r0, r3
    935e:	f7ff fdfd 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9362:	bd08      	pop	{r3, pc}
    9364:	2000288c 	.word	0x2000288c

00009368 <TrigSeq16_Controller(bool, bool)>:
void TrigSeq16_Controller(bool hemisphere, bool forwarding) {
    9368:	b508      	push	{r3, lr}
    TrigSeq16_instance[hemisphere].BaseController(forwarding);
    936a:	4b03      	ldr	r3, [pc, #12]	; (9378 <TrigSeq16_Controller(bool, bool)+0x10>)
    936c:	227c      	movs	r2, #124	; 0x7c
    936e:	fb02 3000 	mla	r0, r2, r0, r3
    9372:	f7ff fdf3 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9376:	bd08      	pop	{r3, pc}
    9378:	20002794 	.word	0x20002794

0000937c <Tuner_Controller(bool, bool)>:
void Tuner_Controller(bool hemisphere, bool forwarding) {
    937c:	b508      	push	{r3, lr}
    Tuner_instance[hemisphere].BaseController(forwarding);
    937e:	4b03      	ldr	r3, [pc, #12]	; (938c <Tuner_Controller(bool, bool)+0x10>)
    9380:	2288      	movs	r2, #136	; 0x88
    9382:	fb02 3000 	mla	r0, r2, r0, r3
    9386:	f7ff fde9 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    938a:	bd08      	pop	{r3, pc}
    938c:	20002998 	.word	0x20002998

00009390 <VectorEG_Controller(bool, bool)>:
void VectorEG_Controller(bool hemisphere, bool forwarding) {VectorEG_instance[hemisphere].BaseController(forwarding);}
    9390:	b508      	push	{r3, lr}
    9392:	4b04      	ldr	r3, [pc, #16]	; (93a4 <VectorEG_Controller(bool, bool)+0x14>)
    9394:	f44f 728a 	mov.w	r2, #276	; 0x114
    9398:	fb02 3000 	mla	r0, r2, r0, r3
    939c:	f7ff fdde 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    93a0:	bd08      	pop	{r3, pc}
    93a2:	bf00      	nop
    93a4:	20002ab0 	.word	0x20002ab0

000093a8 <VectorLFO_Controller(bool, bool)>:
void VectorLFO_Controller(bool hemisphere, bool forwarding) {VectorLFO_instance[hemisphere].BaseController(forwarding);}
    93a8:	b508      	push	{r3, lr}
    93aa:	4b04      	ldr	r3, [pc, #16]	; (93bc <VectorLFO_Controller(bool, bool)+0x14>)
    93ac:	f44f 7288 	mov.w	r2, #272	; 0x110
    93b0:	fb02 3000 	mla	r0, r2, r0, r3
    93b4:	f7ff fdd2 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    93b8:	bd08      	pop	{r3, pc}
    93ba:	bf00      	nop
    93bc:	20002cd8 	.word	0x20002cd8

000093c0 <VectorMod_Controller(bool, bool)>:
void VectorMod_Controller(bool hemisphere, bool forwarding) {VectorMod_instance[hemisphere].BaseController(forwarding);}
    93c0:	b508      	push	{r3, lr}
    93c2:	4b04      	ldr	r3, [pc, #16]	; (93d4 <VectorMod_Controller(bool, bool)+0x14>)
    93c4:	f44f 7288 	mov.w	r2, #272	; 0x110
    93c8:	fb02 3000 	mla	r0, r2, r0, r3
    93cc:	f7ff fdc6 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    93d0:	bd08      	pop	{r3, pc}
    93d2:	bf00      	nop
    93d4:	20002ef8 	.word	0x20002ef8

000093d8 <VectorMorph_Controller(bool, bool)>:
void VectorMorph_Controller(bool hemisphere, bool forwarding) {VectorMorph_instance[hemisphere].BaseController(forwarding);}
    93d8:	b508      	push	{r3, lr}
    93da:	4b04      	ldr	r3, [pc, #16]	; (93ec <VectorMorph_Controller(bool, bool)+0x14>)
    93dc:	f44f 728e 	mov.w	r2, #284	; 0x11c
    93e0:	fb02 3000 	mla	r0, r2, r0, r3
    93e4:	f7ff fdba 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    93e8:	bd08      	pop	{r3, pc}
    93ea:	bf00      	nop
    93ec:	20003118 	.word	0x20003118

000093f0 <Voltage_Controller(bool, bool)>:
void Voltage_Controller(bool hemisphere, bool forwarding) {Voltage_instance[hemisphere].BaseController(forwarding);}
    93f0:	b508      	push	{r3, lr}
    93f2:	4b03      	ldr	r3, [pc, #12]	; (9400 <Voltage_Controller(bool, bool)+0x10>)
    93f4:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    93f8:	f7ff fdb0 	bl	8f5c <HemisphereApplet::BaseController(bool)>
    93fc:	bd08      	pop	{r3, pc}
    93fe:	bf00      	nop
    9400:	20003350 	.word	0x20003350

00009404 <hMIDIIn_Controller(bool, bool)>:
void hMIDIIn_Controller(bool hemisphere, bool forwarding) {
    9404:	b508      	push	{r3, lr}
    hMIDIIn_instance[hemisphere].BaseController(forwarding);
    9406:	4b03      	ldr	r3, [pc, #12]	; (9414 <hMIDIIn_Controller(bool, bool)+0x10>)
    9408:	eb03 2000 	add.w	r0, r3, r0, lsl #8
    940c:	f7ff fda6 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9410:	bd08      	pop	{r3, pc}
    9412:	bf00      	nop
    9414:	20004db8 	.word	0x20004db8

00009418 <hMIDIOut_Controller(bool, bool)>:
void hMIDIOut_Controller(bool hemisphere, bool forwarding) {
    9418:	b508      	push	{r3, lr}
    hMIDIOut_instance[hemisphere].BaseController(forwarding);
    941a:	4b03      	ldr	r3, [pc, #12]	; (9428 <hMIDIOut_Controller(bool, bool)+0x10>)
    941c:	eb03 2000 	add.w	r0, r3, r0, lsl #8
    9420:	f7ff fd9c 	bl	8f5c <HemisphereApplet::BaseController(bool)>
}
    9424:	bd08      	pop	{r3, pc}
    9426:	bf00      	nop
    9428:	20004fb8 	.word	0x20004fb8

0000942c <EnvFollow::Controller()>:
    void Controller() {
    942c:	b570      	push	{r4, r5, r6, lr}
        if (--countdown == 0) {
    942e:	f890 3078 	ldrb.w	r3, [r0, #120]	; 0x78
    9432:	3b01      	subs	r3, #1
    9434:	b2db      	uxtb	r3, r3
    void Controller() {
    9436:	4604      	mov	r4, r0
        if (--countdown == 0) {
    9438:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
    943c:	bbb3      	cbnz	r3, 94ac <EnvFollow::Controller()+0x80>
                target[ch] = max[ch] * gain[ch];
    943e:	6f02      	ldr	r2, [r0, #112]	; 0x70
    9440:	f890 308c 	ldrb.w	r3, [r0, #140]	; 0x8c
    9444:	4353      	muls	r3, r2
                if (duck[ch]) target[ch] = HEMISPHERE_MAX_CV - target[ch]; // Handle ducking channel(s)
    9446:	f890 208e 	ldrb.w	r2, [r0, #142]	; 0x8e
                target[ch] = max[ch] * gain[ch];
    944a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
                if (duck[ch]) target[ch] = HEMISPHERE_MAX_CV - target[ch]; // Handle ducking channel(s)
    944e:	b11a      	cbz	r2, 9458 <EnvFollow::Controller()+0x2c>
    9450:	f5c3 53f0 	rsb	r3, r3, #7680	; 0x1e00
    9454:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
                target[ch] = constrain(target[ch], 0, HEMISPHERE_MAX_CV);
    9458:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
                target[ch] = max[ch] * gain[ch];
    945c:	6f62      	ldr	r2, [r4, #116]	; 0x74
                target[ch] = constrain(target[ch], 0, HEMISPHERE_MAX_CV);
    945e:	f5b3 5ff0 	cmp.w	r3, #7680	; 0x1e00
    9462:	bfa8      	it	ge
    9464:	f44f 53f0 	movge.w	r3, #7680	; 0x1e00
    9468:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    946c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
                max[ch] = 0;
    9470:	2300      	movs	r3, #0
    9472:	6723      	str	r3, [r4, #112]	; 0x70
                target[ch] = max[ch] * gain[ch];
    9474:	f894 308d 	ldrb.w	r3, [r4, #141]	; 0x8d
    9478:	4353      	muls	r3, r2
                if (duck[ch]) target[ch] = HEMISPHERE_MAX_CV - target[ch]; // Handle ducking channel(s)
    947a:	f894 208f 	ldrb.w	r2, [r4, #143]	; 0x8f
                target[ch] = max[ch] * gain[ch];
    947e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
                if (duck[ch]) target[ch] = HEMISPHERE_MAX_CV - target[ch]; // Handle ducking channel(s)
    9482:	b11a      	cbz	r2, 948c <EnvFollow::Controller()+0x60>
    9484:	f5c3 53f0 	rsb	r3, r3, #7680	; 0x1e00
    9488:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
                target[ch] = constrain(target[ch], 0, HEMISPHERE_MAX_CV);
    948c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    9490:	f5b3 5ff0 	cmp.w	r3, #7680	; 0x1e00
    9494:	bfa8      	it	ge
    9496:	f44f 53f0 	movge.w	r3, #7680	; 0x1e00
    949a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    949e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
                max[ch] = 0;
    94a2:	2300      	movs	r3, #0
    94a4:	6763      	str	r3, [r4, #116]	; 0x74
            countdown = HEM_ENV_FOLLOWER_SAMPLES;
    94a6:	23a6      	movs	r3, #166	; 0xa6
    94a8:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    94ac:	f104 051c 	add.w	r5, r4, #28
    void Controller() {
    94b0:	2600      	movs	r6, #0
        return inputs[ch];
    94b2:	f855 3f04 	ldr.w	r3, [r5, #4]!
            if (In(ch) > max[ch]) max[ch] = In(ch);
    94b6:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    94b8:	429a      	cmp	r2, r3
    94ba:	bfb8      	it	lt
    94bc:	652b      	strlt	r3, [r5, #80]	; 0x50
            if (target[ch] > signal[ch]) signal[ch]++;
    94be:	6e6a      	ldr	r2, [r5, #100]	; 0x64
    94c0:	6deb      	ldr	r3, [r5, #92]	; 0x5c
    94c2:	429a      	cmp	r2, r3
    94c4:	dd0b      	ble.n	94de <EnvFollow::Controller()+0xb2>
    94c6:	3301      	adds	r3, #1
            else if (target[ch] < signal[ch]) signal[ch]--;
    94c8:	65eb      	str	r3, [r5, #92]	; 0x5c
            Out(ch, signal[ch]);
    94ca:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    94cc:	2300      	movs	r3, #0
    94ce:	4631      	mov	r1, r6
    94d0:	4620      	mov	r0, r4
    94d2:	f7ff fd00 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
    94d6:	b106      	cbz	r6, 94da <EnvFollow::Controller()+0xae>
    }
    94d8:	bd70      	pop	{r4, r5, r6, pc}
    94da:	2601      	movs	r6, #1
    94dc:	e7e9      	b.n	94b2 <EnvFollow::Controller()+0x86>
            else if (target[ch] < signal[ch]) signal[ch]--;
    94de:	daf4      	bge.n	94ca <EnvFollow::Controller()+0x9e>
    94e0:	3b01      	subs	r3, #1
    94e2:	e7f1      	b.n	94c8 <EnvFollow::Controller()+0x9c>

000094e4 <MixerBal::Controller()>:
    void Controller() {
    94e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        int mix1 = Proportion(balance, MIXER_MAX_VALUE, signal2)
    94e6:	6f03      	ldr	r3, [r0, #112]	; 0x70
    94e8:	6a01      	ldr	r1, [r0, #32]
    94ea:	6a47      	ldr	r7, [r0, #36]	; 0x24
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    94ec:	26ff      	movs	r6, #255	; 0xff
    94ee:	039c      	lsls	r4, r3, #14
                 + Proportion(MIXER_MAX_VALUE - balance, MIXER_MAX_VALUE, signal1);
    94f0:	1af3      	subs	r3, r6, r3
    94f2:	fb94 f4f6 	sdiv	r4, r4, r6
    94f6:	039b      	lsls	r3, r3, #14
    94f8:	fb93 f3f6 	sdiv	r3, r3, r6
        int scaled = simfloat2int(proportion * max_value);
    94fc:	fb01 f604 	mul.w	r6, r1, r4
    9500:	fb07 f203 	mul.w	r2, r7, r3
    9504:	437c      	muls	r4, r7
    9506:	13b6      	asrs	r6, r6, #14
                 + Proportion(MIXER_MAX_VALUE - balance, MIXER_MAX_VALUE, signal2);
    9508:	eb06 36a2 	add.w	r6, r6, r2, asr #14
    950c:	4359      	muls	r1, r3
    950e:	13a2      	asrs	r2, r4, #14
        Out(0, mix1);
    9510:	2300      	movs	r3, #0
    void Controller() {
    9512:	4605      	mov	r5, r0
        Out(0, mix1);
    9514:	eb02 32a1 	add.w	r2, r2, r1, asr #14
    9518:	4619      	mov	r1, r3
    951a:	f7ff fcdc 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        Out(1, mix2);
    951e:	2300      	movs	r3, #0
    9520:	4632      	mov	r2, r6
    9522:	2101      	movs	r1, #1
    9524:	4628      	mov	r0, r5
    9526:	f7ff fcd6 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    952a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000952c <AttenuateOffset::Controller()>:
    void Controller() {
    952c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            Out(ch, signal);
    9530:	4e13      	ldr	r6, [pc, #76]	; (9580 <AttenuateOffset::Controller()+0x54>)
    void Controller() {
    9532:	4604      	mov	r4, r0
    9534:	f100 051c 	add.w	r5, r0, #28
        ForEachChannel(ch)
    9538:	f04f 0800 	mov.w	r8, #0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    953c:	273f      	movs	r7, #63	; 0x3f
            int signal = Proportion(level[ch], 63, In(ch)) + (offset[ch] * ATTENOFF_INCREMENTS);
    953e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
        int scaled = simfloat2int(proportion * max_value);
    9540:	f855 2f04 	ldr.w	r2, [r5, #4]!
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9544:	039b      	lsls	r3, r3, #14
    9546:	fb93 f3f7 	sdiv	r3, r3, r7
        int scaled = simfloat2int(proportion * max_value);
    954a:	4353      	muls	r3, r2
    954c:	6daa      	ldr	r2, [r5, #88]	; 0x58
    954e:	01d2      	lsls	r2, r2, #7
    9550:	eb02 32a3 	add.w	r2, r2, r3, asr #14
            Out(ch, signal);
    9554:	f5b2 5ff0 	cmp.w	r2, #7680	; 0x1e00
    9558:	bfa8      	it	ge
    955a:	f44f 52f0 	movge.w	r2, #7680	; 0x1e00
    955e:	42b2      	cmp	r2, r6
    9560:	bfb8      	it	lt
    9562:	4632      	movlt	r2, r6
    9564:	2300      	movs	r3, #0
    9566:	4641      	mov	r1, r8
    9568:	4620      	mov	r0, r4
    956a:	f7ff fcb4 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
    956e:	f1b8 0f00 	cmp.w	r8, #0
    9572:	d001      	beq.n	9578 <AttenuateOffset::Controller()+0x4c>
    }
    9574:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9578:	f04f 0801 	mov.w	r8, #1
    957c:	e7df      	b.n	953e <AttenuateOffset::Controller()+0x12>
    957e:	bf00      	nop
    9580:	ffffee00 	.word	0xffffee00

00009584 <HemisphereApplet::Clock(int, bool)>:
    bool Clock(int ch, bool physical = 0) {
    9584:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (hemisphere == 0) {
    9586:	7904      	ldrb	r4, [r0, #4]
    bool Clock(int ch, bool physical = 0) {
    9588:	4606      	mov	r6, r0
    958a:	460d      	mov	r5, r1
        if (hemisphere == 0) {
    958c:	bb24      	cbnz	r4, 95d8 <HemisphereApplet::Clock(int, bool)+0x54>
            if (ch == 0) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_1>();
    958e:	b9d1      	cbnz	r1, 95c6 <HemisphereApplet::Clock(int, bool)+0x42>
    9590:	4b1d      	ldr	r3, [pc, #116]	; (9608 <HemisphereApplet::Clock(int, bool)+0x84>)
    9592:	681c      	ldr	r4, [r3, #0]
    9594:	f004 0401 	and.w	r4, r4, #1
        if (ch == 0 && !physical) {
    9598:	b94a      	cbnz	r2, 95ae <HemisphereApplet::Clock(int, bool)+0x2a>
            ClockManager *clock_m = clock_m->get();
    959a:	f7fe fc87 	bl	7eac <ClockManager::get()>
    959e:	4607      	mov	r7, r0
            if (clock_m->IsRunning()) clocked = clock_m->Tock();
    95a0:	f7fe fc9c 	bl	7edc <ClockManager::IsRunning()>
    95a4:	b328      	cbz	r0, 95f2 <HemisphereApplet::Clock(int, bool)+0x6e>
    95a6:	4638      	mov	r0, r7
    95a8:	f7fe fcdc 	bl	7f64 <ClockManager::Tock()>
    95ac:	4604      	mov	r4, r0
        if (clocked) {
    95ae:	b18c      	cbz	r4, 95d4 <HemisphereApplet::Clock(int, bool)+0x50>
        		cycle_ticks[ch] = OC::CORE::ticks - last_clock[ch];
    95b0:	eb06 0585 	add.w	r5, r6, r5, lsl #2
    95b4:	4a15      	ldr	r2, [pc, #84]	; (960c <HemisphereApplet::Clock(int, bool)+0x88>)
    95b6:	6b29      	ldr	r1, [r5, #48]	; 0x30
    95b8:	6813      	ldr	r3, [r2, #0]
    95ba:	1a5b      	subs	r3, r3, r1
    95bc:	63ab      	str	r3, [r5, #56]	; 0x38
        		last_clock[ch] = OC::CORE::ticks;
    95be:	6813      	ldr	r3, [r2, #0]
    95c0:	632b      	str	r3, [r5, #48]	; 0x30
    95c2:	2401      	movs	r4, #1
    95c4:	e006      	b.n	95d4 <HemisphereApplet::Clock(int, bool)+0x50>
            if (ch == 1) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_2>();
    95c6:	2901      	cmp	r1, #1
    95c8:	d104      	bne.n	95d4 <HemisphereApplet::Clock(int, bool)+0x50>
    95ca:	4b0f      	ldr	r3, [pc, #60]	; (9608 <HemisphereApplet::Clock(int, bool)+0x84>)
    95cc:	681b      	ldr	r3, [r3, #0]
        if (clocked) {
    95ce:	f013 0f02 	tst.w	r3, #2
    95d2:	d1ed      	bne.n	95b0 <HemisphereApplet::Clock(int, bool)+0x2c>
    }
    95d4:	4620      	mov	r0, r4
    95d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if (ch == 0) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_3>();
    95d8:	b921      	cbnz	r1, 95e4 <HemisphereApplet::Clock(int, bool)+0x60>
    95da:	4b0b      	ldr	r3, [pc, #44]	; (9608 <HemisphereApplet::Clock(int, bool)+0x84>)
    95dc:	681c      	ldr	r4, [r3, #0]
    95de:	f3c4 0480 	ubfx	r4, r4, #2, #1
            if (ch == 1) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_4>();
    95e2:	e7d9      	b.n	9598 <HemisphereApplet::Clock(int, bool)+0x14>
    95e4:	2901      	cmp	r1, #1
    95e6:	d10d      	bne.n	9604 <HemisphereApplet::Clock(int, bool)+0x80>
    95e8:	4b07      	ldr	r3, [pc, #28]	; (9608 <HemisphereApplet::Clock(int, bool)+0x84>)
    95ea:	681c      	ldr	r4, [r3, #0]
        if (clocked) {
    95ec:	f014 0408 	ands.w	r4, r4, #8
    95f0:	e7ef      	b.n	95d2 <HemisphereApplet::Clock(int, bool)+0x4e>
            else if (master_clock_bus) clocked = OC::DigitalInputs::clocked<OC::DIGITAL_INPUT_1>();
    95f2:	f896 3054 	ldrb.w	r3, [r6, #84]	; 0x54
    95f6:	2b00      	cmp	r3, #0
    95f8:	d0d9      	beq.n	95ae <HemisphereApplet::Clock(int, bool)+0x2a>
    95fa:	4b03      	ldr	r3, [pc, #12]	; (9608 <HemisphereApplet::Clock(int, bool)+0x84>)
    95fc:	681c      	ldr	r4, [r3, #0]
    95fe:	f004 0401 	and.w	r4, r4, #1
    9602:	e7d4      	b.n	95ae <HemisphereApplet::Clock(int, bool)+0x2a>
    9604:	2400      	movs	r4, #0
        return clocked;
    9606:	e7e5      	b.n	95d4 <HemisphereApplet::Clock(int, bool)+0x50>
    9608:	1fffa5b4 	.word	0x1fffa5b4
    960c:	200046cc 	.word	0x200046cc

00009610 <Scope::Controller()>:
        if (Clock(0)) {
    9610:	2200      	movs	r2, #0
    void Controller() {
    9612:	b538      	push	{r3, r4, r5, lr}
        if (Clock(0)) {
    9614:	4611      	mov	r1, r2
    void Controller() {
    9616:	4604      	mov	r4, r0
        if (Clock(0)) {
    9618:	f7ff ffb4 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    961c:	b168      	cbz	r0, 963a <Scope::Controller()+0x2a>
            int this_tick = OC::CORE::ticks;
    961e:	4b2e      	ldr	r3, [pc, #184]	; (96d8 <Scope::Controller()+0xc8>)
    9620:	6819      	ldr	r1, [r3, #0]
            int time = this_tick - last_bpm_tick;
    9622:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
            last_bpm_tick = this_tick;
    9624:	66e1      	str	r1, [r4, #108]	; 0x6c
            int time = this_tick - last_bpm_tick;
    9626:	1aca      	subs	r2, r1, r3
            bpm = 1000000 / time;
    9628:	4b2c      	ldr	r3, [pc, #176]	; (96dc <Scope::Controller()+0xcc>)
    962a:	fb93 f3f2 	sdiv	r3, r3, r2
    962e:	f242 720f 	movw	r2, #9999	; 0x270f
    9632:	4293      	cmp	r3, r2
    9634:	bfd4      	ite	le
    9636:	6723      	strle	r3, [r4, #112]	; 0x70
    9638:	6722      	strgt	r2, [r4, #112]	; 0x70
        if (Clock(1)) {
    963a:	2200      	movs	r2, #0
    963c:	2101      	movs	r1, #1
    963e:	4620      	mov	r0, r4
    9640:	f7ff ffa0 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9644:	b1a8      	cbz	r0, 9672 <Scope::Controller()+0x62>
            if (last_scope_tick) {
    9646:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
    964a:	4923      	ldr	r1, [pc, #140]	; (96d8 <Scope::Controller()+0xc8>)
    964c:	b172      	cbz	r2, 966c <Scope::Controller()+0x5c>
                int cycle_ticks = OC::CORE::ticks - last_scope_tick;
    964e:	680b      	ldr	r3, [r1, #0]
                sample_ticks = cycle_ticks / 64;
    9650:	1a9b      	subs	r3, r3, r2
    9652:	bf48      	it	mi
    9654:	333f      	addmi	r3, #63	; 0x3f
    9656:	119b      	asrs	r3, r3, #6
                sample_ticks = constrain(sample_ticks, 2, 64000);
    9658:	f5b3 4f7a 	cmp.w	r3, #64000	; 0xfa00
    965c:	bfa8      	it	ge
    965e:	f44f 437a 	movge.w	r3, #64000	; 0xfa00
    9662:	2b02      	cmp	r3, #2
    9664:	bfb8      	it	lt
    9666:	2302      	movlt	r3, #2
    9668:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
            last_scope_tick = OC::CORE::ticks;
    966c:	680b      	ldr	r3, [r1, #0]
    966e:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
        if (!freeze) {
    9672:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    9676:	bb73      	cbnz	r3, 96d6 <Scope::Controller()+0xc6>
            if (--sample_countdown < 1) {
    9678:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
        return inputs[ch];
    967c:	6a65      	ldr	r5, [r4, #36]	; 0x24
            last_cv = In(1);
    967e:	6765      	str	r5, [r4, #116]	; 0x74
            if (--sample_countdown < 1) {
    9680:	3b01      	subs	r3, #1
    9682:	2b00      	cmp	r3, #0
    9684:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
    9688:	dc19      	bgt.n	96be <Scope::Controller()+0xae>
                sample_countdown = sample_ticks;
    968a:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
    968e:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
                if (++sample_num > 63) sample_num = 0;
    9692:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    9696:	3301      	adds	r3, #1
    9698:	2b40      	cmp	r3, #64	; 0x40
    969a:	bfa8      	it	ge
    969c:	2300      	movge	r3, #0
    969e:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
                snapshot[sample_num] = (uint8_t)sample;
    96a2:	18e2      	adds	r2, r4, r3
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    96a4:	6a23      	ldr	r3, [r4, #32]
    96a6:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
    96aa:	039b      	lsls	r3, r3, #14
    96ac:	fb93 f3f1 	sdiv	r3, r3, r1
        int scaled = simfloat2int(proportion * max_value);
    96b0:	f343 13d1 	sbfx	r3, r3, #7, #18
                sample = constrain(sample, -128, 127) + 127;
    96b4:	f303 0307 	ssat	r3, #8, r3
    96b8:	337f      	adds	r3, #127	; 0x7f
                snapshot[sample_num] = (uint8_t)sample;
    96ba:	f882 3079 	strb.w	r3, [r2, #121]	; 0x79
            ForEachChannel(ch) Out(ch, In(ch));
    96be:	2300      	movs	r3, #0
    96c0:	4619      	mov	r1, r3
    96c2:	6a22      	ldr	r2, [r4, #32]
    96c4:	4620      	mov	r0, r4
    96c6:	f7ff fc06 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    96ca:	2300      	movs	r3, #0
    96cc:	462a      	mov	r2, r5
    96ce:	2101      	movs	r1, #1
    96d0:	4620      	mov	r0, r4
    96d2:	f7ff fc00 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    96d6:	bd38      	pop	{r3, r4, r5, pc}
    96d8:	200046cc 	.word	0x200046cc
    96dc:	000f4240 	.word	0x000f4240

000096e0 <DualQuant::Controller()>:
    void Controller() {
    96e0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    96e4:	4604      	mov	r4, r0
    96e6:	f100 0620 	add.w	r6, r0, #32
    96ea:	f100 076c 	add.w	r7, r0, #108	; 0x6c
    96ee:	f100 0902 	add.w	r9, r0, #2
    96f2:	4605      	mov	r5, r0
            if (Clock(ch)) {
    96f4:	f04f 0a00 	mov.w	sl, #0
     *     int cv = In(ch);
     *     // etc...
     * }
     */
    void StartADCLag(int ch = 0) {
        adc_lag_countdown[ch] = HEMISPHERE_ADC_LAG;
    96f8:	f04f 0b21 	mov.w	fp, #33	; 0x21
    96fc:	eba5 0804 	sub.w	r8, r5, r4
    9700:	2200      	movs	r2, #0
    9702:	4641      	mov	r1, r8
    9704:	4620      	mov	r0, r4
    9706:	f7ff ff3d 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    970a:	b140      	cbz	r0, 971e <DualQuant::Controller()+0x3e>
                continuous[ch] = 0; // Turn off continuous mode if there's a clock
    970c:	f885 a2e4 	strb.w	sl, [r5, #740]	; 0x2e4
    9710:	f8c6 b02c 	str.w	fp, [r6, #44]	; 0x2c
    }

    bool EndOfADCLag(int ch = 0) {
        return (--adc_lag_countdown[ch] == 0);
    9714:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    9716:	3b01      	subs	r3, #1
    9718:	62f3      	str	r3, [r6, #44]	; 0x2c
            if (continuous[ch] || EndOfADCLag(ch)) {
    971a:	b123      	cbz	r3, 9726 <DualQuant::Controller()+0x46>
    971c:	e015      	b.n	974a <DualQuant::Controller()+0x6a>
    971e:	f895 32e4 	ldrb.w	r3, [r5, #740]	; 0x2e4
    9722:	2b00      	cmp	r3, #0
    9724:	d0f6      	beq.n	9714 <DualQuant::Controller()+0x34>
                int32_t quantized = quantizer[ch].Process(pitch, root[ch] << 7, 0);
    9726:	f895 22f4 	ldrb.w	r2, [r5, #756]	; 0x2f4
    972a:	6831      	ldr	r1, [r6, #0]
    972c:	2300      	movs	r3, #0
    972e:	01d2      	lsls	r2, r2, #7
    9730:	4638      	mov	r0, r7
    9732:	f7f7 fe2d 	bl	1390 <braids::Quantizer::Process(long, long, long)>
                Out(ch, quantized);
    9736:	2300      	movs	r3, #0
                int32_t quantized = quantizer[ch].Process(pitch, root[ch] << 7, 0);
    9738:	4602      	mov	r2, r0
                Out(ch, quantized);
    973a:	9001      	str	r0, [sp, #4]
    973c:	4641      	mov	r1, r8
    973e:	4620      	mov	r0, r4
    9740:	f7ff fbc9 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                last_note[ch] = quantized;
    9744:	9a01      	ldr	r2, [sp, #4]
    9746:	f8c6 22bc 	str.w	r2, [r6, #700]	; 0x2bc
        ForEachChannel(ch)
    974a:	3501      	adds	r5, #1
    974c:	454d      	cmp	r5, r9
    974e:	f106 0604 	add.w	r6, r6, #4
    9752:	f507 779c 	add.w	r7, r7, #312	; 0x138
    9756:	d1d1      	bne.n	96fc <DualQuant::Controller()+0x1c>
    }
    9758:	b003      	add	sp, #12
    975a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000975e <Calculate::Controller()>:
    void Controller() {
    975e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    9762:	4604      	mov	r4, r0
    9764:	f100 06b8 	add.w	r6, r0, #184	; 0xb8
    9768:	f100 07a8 	add.w	r7, r0, #168	; 0xa8
        ForEachChannel(ch)
    976c:	2500      	movs	r5, #0
                    rand_clocked[ch] = 1;
    976e:	f04f 0901 	mov.w	r9, #1
            int idx = operation[ch];
    9772:	f857 3f04 	ldr.w	r3, [r7, #4]!
            if (idx == 5) { // S&H
    9776:	2b05      	cmp	r3, #5
    9778:	d10f      	bne.n	979a <Calculate::Controller()+0x3c>
                if (Clock(ch)) Out(ch, In(ch));
    977a:	2200      	movs	r2, #0
    977c:	4629      	mov	r1, r5
    977e:	4620      	mov	r0, r4
    9780:	f7ff ff00 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9784:	b1f0      	cbz	r0, 97c4 <Calculate::Controller()+0x66>
    9786:	f857 2c8c 	ldr.w	r2, [r7, #-140]
    978a:	2300      	movs	r3, #0
                Out(ch, result);
    978c:	4629      	mov	r1, r5
    978e:	4620      	mov	r0, r4
    9790:	f7ff fba1 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    9794:	e016      	b.n	97c4 <Calculate::Controller()+0x66>
    9796:	2501      	movs	r5, #1
    9798:	e7eb      	b.n	9772 <Calculate::Controller()+0x14>
            } else if (idx == 6) { // Rand
    979a:	2b06      	cmp	r3, #6
    979c:	d123      	bne.n	97e6 <Calculate::Controller()+0x88>
                if (Clock(ch)) {
    979e:	2200      	movs	r2, #0
    97a0:	4629      	mov	r1, r5
    97a2:	4620      	mov	r0, r4
    97a4:	f7ff feee 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    97a8:	b188      	cbz	r0, 97ce <Calculate::Controller()+0x70>
                    Out(ch, random(0, HEMISPHERE_MAX_CV));
    97aa:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
    97ae:	2000      	movs	r0, #0
    97b0:	f010 fb9d 	bl	19eee <random(long, long)>
    97b4:	2300      	movs	r3, #0
    97b6:	4602      	mov	r2, r0
    97b8:	4629      	mov	r1, r5
    97ba:	4620      	mov	r0, r4
    97bc:	f7ff fb8b 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                    rand_clocked[ch] = 1;
    97c0:	f886 9000 	strb.w	r9, [r6]
        ForEachChannel(ch)
    97c4:	3601      	adds	r6, #1
    97c6:	2d00      	cmp	r5, #0
    97c8:	d0e5      	beq.n	9796 <Calculate::Controller()+0x38>
    }
    97ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                else if (!rand_clocked[ch]) Out(ch, random(0, HEMISPHERE_MAX_CV));
    97ce:	f896 8000 	ldrb.w	r8, [r6]
    97d2:	f1b8 0f00 	cmp.w	r8, #0
    97d6:	d1f5      	bne.n	97c4 <Calculate::Controller()+0x66>
    97d8:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
    97dc:	f010 fb87 	bl	19eee <random(long, long)>
                int result = calc_fn[idx](In(0), In(1));
    97e0:	4602      	mov	r2, r0
                Out(ch, result);
    97e2:	2300      	movs	r3, #0
    97e4:	e7d2      	b.n	978c <Calculate::Controller()+0x2e>
            } else if (idx < 5) {
    97e6:	2b04      	cmp	r3, #4
    97e8:	dcec      	bgt.n	97c4 <Calculate::Controller()+0x66>
                int result = calc_fn[idx](In(0), In(1));
    97ea:	3322      	adds	r3, #34	; 0x22
    97ec:	6a61      	ldr	r1, [r4, #36]	; 0x24
    97ee:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    97f2:	6a20      	ldr	r0, [r4, #32]
    97f4:	4798      	blx	r3
    97f6:	e7f3      	b.n	97e0 <Calculate::Controller()+0x82>

000097f8 <CVRecV2::Controller()>:
    void Controller() {
    97f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        bool reset = Clock(1);
    97fc:	2200      	movs	r2, #0
    97fe:	2101      	movs	r1, #1
    void Controller() {
    9800:	4604      	mov	r4, r0
        bool reset = Clock(1);
    9802:	f7ff febf 	bl	9584 <HemisphereApplet::Clock(int, bool)>
        if (Clock(0) || reset) {
    9806:	2200      	movs	r2, #0
        bool reset = Clock(1);
    9808:	4605      	mov	r5, r0
        if (Clock(0) || reset) {
    980a:	4611      	mov	r1, r2
    980c:	4620      	mov	r0, r4
    980e:	f7ff feb9 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9812:	f104 0320 	add.w	r3, r4, #32
    9816:	b908      	cbnz	r0, 981c <CVRecV2::Controller()+0x24>
    9818:	2d00      	cmp	r5, #0
    981a:	d05d      	beq.n	98d8 <CVRecV2::Controller()+0xe0>
            step++;
    981c:	f8b4 16f8 	ldrh.w	r1, [r4, #1784]	; 0x6f8
            if (step > end || step < start) step = start;
    9820:	f9b4 76f6 	ldrsh.w	r7, [r4, #1782]	; 0x6f6
    9824:	f9b4 26f4 	ldrsh.w	r2, [r4, #1780]	; 0x6f4
            step++;
    9828:	3101      	adds	r1, #1
    982a:	b209      	sxth	r1, r1
            if (step > end || step < start) step = start;
    982c:	42b9      	cmp	r1, r7
            step++;
    982e:	f8a4 16f8 	strh.w	r1, [r4, #1784]	; 0x6f8
            if (step > end || step < start) step = start;
    9832:	dc01      	bgt.n	9838 <CVRecV2::Controller()+0x40>
    9834:	4291      	cmp	r1, r2
    9836:	da01      	bge.n	983c <CVRecV2::Controller()+0x44>
    9838:	f8a4 26f8 	strh.w	r2, [r4, #1784]	; 0x6f8
            if (reset) {
    983c:	b13d      	cbz	r5, 984e <CVRecV2::Controller()+0x56>
                if (punch_out) punch_out = end - start;
    983e:	f9b4 16fa 	ldrsh.w	r1, [r4, #1786]	; 0x6fa
                step = start;
    9842:	f8a4 26f8 	strh.w	r2, [r4, #1784]	; 0x6f8
                if (punch_out) punch_out = end - start;
    9846:	b111      	cbz	r1, 984e <CVRecV2::Controller()+0x56>
    9848:	1ab9      	subs	r1, r7, r2
    984a:	f8a4 16fa 	strh.w	r1, [r4, #1786]	; 0x6fa
                signal[ch] = int2simfloat(cv[ch][step]);
    984e:	f9b4 06f8 	ldrsh.w	r0, [r4, #1784]	; 0x6f8
                if (smooth) rise[ch] = (int2simfloat(cv[ch][next_step]) - int2simfloat(cv[ch][step])) / ClockCycleTicks(0);
    9852:	f894 c6ec 	ldrb.w	ip, [r4, #1772]	; 0x6ec
                if (mode & (0x01 << ch)) { // Record this channel
    9856:	f8d4 e6f0 	ldr.w	lr, [r4, #1776]	; 0x6f0
                byte next_step = step + 1;
    985a:	1c41      	adds	r1, r0, #1
    985c:	b2c9      	uxtb	r1, r1
                if (next_step > end) next_step = start;
    985e:	b2d2      	uxtb	r2, r2
                if (smooth) rise[ch] = (int2simfloat(cv[ch][next_step]) - int2simfloat(cv[ch][step])) / ClockCycleTicks(0);
    9860:	2500      	movs	r5, #0
    9862:	eb04 0040 	add.w	r0, r4, r0, lsl #1
    9866:	461e      	mov	r6, r3
    9868:	42b9      	cmp	r1, r7
    986a:	bfd8      	it	le
    986c:	460a      	movle	r2, r1
    986e:	46a9      	mov	r9, r5
    9870:	f44f 78c0 	mov.w	r8, #384	; 0x180
                signal[ch] = int2simfloat(cv[ch][step]);
    9874:	f9b0 10dc 	ldrsh.w	r1, [r0, #220]	; 0xdc
    9878:	0389      	lsls	r1, r1, #14
    987a:	f8c6 16c4 	str.w	r1, [r6, #1732]	; 0x6c4
                if (smooth) rise[ch] = (int2simfloat(cv[ch][next_step]) - int2simfloat(cv[ch][step])) / ClockCycleTicks(0);
    987e:	f1bc 0f00 	cmp.w	ip, #0
    9882:	d045      	beq.n	9910 <CVRecV2::Controller()+0x118>
    9884:	fb08 2705 	mla	r7, r8, r5, r2
    9888:	eb04 0747 	add.w	r7, r4, r7, lsl #1
    988c:	f9b7 70dc 	ldrsh.w	r7, [r7, #220]	; 0xdc
    9890:	ebc1 3187 	rsb	r1, r1, r7, lsl #14
    9894:	6ba7      	ldr	r7, [r4, #56]	; 0x38
    9896:	fb91 f1f7 	sdiv	r1, r1, r7
    989a:	f8c6 16bc 	str.w	r1, [r6, #1724]	; 0x6bc
                if (mode & (0x01 << ch)) { // Record this channel
    989e:	fa4e f105 	asr.w	r1, lr, r5
    98a2:	07c9      	lsls	r1, r1, #31
    98a4:	d508      	bpl.n	98b8 <CVRecV2::Controller()+0xc0>
                    if (punch_out > 0) {
    98a6:	f9b4 16fa 	ldrsh.w	r1, [r4, #1786]	; 0x6fa
    98aa:	2900      	cmp	r1, #0
                        cv[ch][step] = In(ch);
    98ac:	bfc2      	ittt	gt
    98ae:	6831      	ldrgt	r1, [r6, #0]
    98b0:	f8a0 10dc 	strhgt.w	r1, [r0, #220]	; 0xdc
                        rec = 1;
    98b4:	f04f 0901 	movgt.w	r9, #1
            ForEachChannel(ch)
    98b8:	f500 7040 	add.w	r0, r0, #768	; 0x300
    98bc:	3604      	adds	r6, #4
    98be:	b32d      	cbz	r5, 990c <CVRecV2::Controller()+0x114>
            if (rec) {
    98c0:	f1b9 0f00 	cmp.w	r9, #0
    98c4:	d008      	beq.n	98d8 <CVRecV2::Controller()+0xe0>
                if (--punch_out == 0) mode = 0;
    98c6:	f8b4 26fa 	ldrh.w	r2, [r4, #1786]	; 0x6fa
    98ca:	3a01      	subs	r2, #1
    98cc:	b212      	sxth	r2, r2
    98ce:	f8a4 26fa 	strh.w	r2, [r4, #1786]	; 0x6fa
    98d2:	b90a      	cbnz	r2, 98d8 <CVRecV2::Controller()+0xe0>
    98d4:	f8c4 26f0 	str.w	r2, [r4, #1776]	; 0x6f0
    98d8:	461d      	mov	r5, r3
                        rec = 1;
    98da:	2600      	movs	r6, #0
            if (!(mode & (0x01 << ch))) { // If not recording this channel, play it
    98dc:	f8d4 36f0 	ldr.w	r3, [r4, #1776]	; 0x6f0
    98e0:	4133      	asrs	r3, r6
    98e2:	f013 0301 	ands.w	r3, r3, #1
    98e6:	d117      	bne.n	9918 <CVRecV2::Controller()+0x120>
                Out(ch, simfloat2int(signal[ch]));
    98e8:	f8d5 26c4 	ldr.w	r2, [r5, #1732]	; 0x6c4
    98ec:	4631      	mov	r1, r6
    98ee:	1392      	asrs	r2, r2, #14
    98f0:	4620      	mov	r0, r4
    98f2:	f7ff faf0 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                signal[ch] += rise[ch];
    98f6:	f8d5 36c4 	ldr.w	r3, [r5, #1732]	; 0x6c4
    98fa:	f8d5 26bc 	ldr.w	r2, [r5, #1724]	; 0x6bc
    98fe:	4413      	add	r3, r2
    9900:	f8c5 36c4 	str.w	r3, [r5, #1732]	; 0x6c4
        ForEachChannel(ch)
    9904:	3504      	adds	r5, #4
    9906:	b12e      	cbz	r6, 9914 <CVRecV2::Controller()+0x11c>
    }
    9908:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    990c:	2501      	movs	r5, #1
    990e:	e7b1      	b.n	9874 <CVRecV2::Controller()+0x7c>
                else rise[ch] = 0;
    9910:	4661      	mov	r1, ip
    9912:	e7c2      	b.n	989a <CVRecV2::Controller()+0xa2>
    9914:	2601      	movs	r6, #1
    9916:	e7e1      	b.n	98dc <CVRecV2::Controller()+0xe4>
                Out(ch, In(ch));
    9918:	682a      	ldr	r2, [r5, #0]
    991a:	2300      	movs	r3, #0
    991c:	4631      	mov	r1, r6
    991e:	4620      	mov	r0, r4
    9920:	f7ff fad9 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    9924:	e7ee      	b.n	9904 <CVRecV2::Controller()+0x10c>

00009926 <HemisphereApplet::ClockOut(int, int)>:
    void ClockOut(int ch, int ticks = HEMISPHERE_CLOCK_TICKS) {
    9926:	b508      	push	{r3, lr}
        clock_countdown[ch] = ticks;
    9928:	f101 0310 	add.w	r3, r1, #16
    992c:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
        Out(ch, 0, PULSE_VOLTAGE);
    9930:	2305      	movs	r3, #5
    9932:	2200      	movs	r2, #0
    9934:	f7ff facf 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    9938:	bd08      	pop	{r3, pc}

0000993a <TrigSeq16::Controller()>:
        if (Clock(0) || Clock(1)) {
    993a:	2200      	movs	r2, #0
    void Controller() {
    993c:	b510      	push	{r4, lr}
        if (Clock(0) || Clock(1)) {
    993e:	4611      	mov	r1, r2
    void Controller() {
    9940:	4604      	mov	r4, r0
        if (Clock(0) || Clock(1)) {
    9942:	f7ff fe1f 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9946:	4602      	mov	r2, r0
    9948:	b350      	cbz	r0, 99a0 <TrigSeq16::Controller()+0x66>
            if (Clock(1) || step >= end_step) step = -1;
    994a:	2200      	movs	r2, #0
    994c:	2101      	movs	r1, #1
    994e:	4620      	mov	r0, r4
    9950:	f7ff fe18 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9954:	b918      	cbnz	r0, 995e <TrigSeq16::Controller()+0x24>
    9956:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    9958:	6f63      	ldr	r3, [r4, #116]	; 0x74
    995a:	429a      	cmp	r2, r3
    995c:	db02      	blt.n	9964 <TrigSeq16::Controller()+0x2a>
    995e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9962:	66e3      	str	r3, [r4, #108]	; 0x6c
            step++;
    9964:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        return inputs[ch];
    9966:	6a23      	ldr	r3, [r4, #32]
    9968:	1c51      	adds	r1, r2, #1
            if (step < 8) {
    996a:	2907      	cmp	r1, #7
                if ((pattern[0] >> step) & 0x01) ClockOut(swap ? 1 : 0);
    996c:	bfd8      	it	le
    996e:	f894 2070 	ldrble.w	r2, [r4, #112]	; 0x70
            step++;
    9972:	66e1      	str	r1, [r4, #108]	; 0x6c
                if ((pattern[1] >> (step - 8)) & 0x01) ClockOut(swap ? 1 : 0);
    9974:	bfc5      	ittet	gt
    9976:	f894 1071 	ldrbgt.w	r1, [r4, #113]	; 0x71
    997a:	3a07      	subgt	r2, #7
                if ((pattern[0] >> step) & 0x01) ClockOut(swap ? 1 : 0);
    997c:	410a      	asrle	r2, r1
                if ((pattern[1] >> (step - 8)) & 0x01) ClockOut(swap ? 1 : 0);
    997e:	fa41 f202 	asrgt.w	r2, r1, r2
    9982:	f012 0f01 	tst.w	r2, #1
    9986:	f241 11ff 	movw	r1, #4607	; 0x11ff
    998a:	f04f 0264 	mov.w	r2, #100	; 0x64
    998e:	d00e      	beq.n	99ae <TrigSeq16::Controller()+0x74>
    9990:	428b      	cmp	r3, r1
    9992:	bfd4      	ite	le
    9994:	2100      	movle	r1, #0
    9996:	2101      	movgt	r1, #1
                else ClockOut(swap ? 0 : 1);
    9998:	4620      	mov	r0, r4
    999a:	f7ff ffc4 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
    }
    999e:	e005      	b.n	99ac <TrigSeq16::Controller()+0x72>
        if (Clock(0) || Clock(1)) {
    99a0:	2101      	movs	r1, #1
    99a2:	4620      	mov	r0, r4
    99a4:	f7ff fdee 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    99a8:	2800      	cmp	r0, #0
    99aa:	d1ce      	bne.n	994a <TrigSeq16::Controller()+0x10>
    }
    99ac:	bd10      	pop	{r4, pc}
                else ClockOut(swap ? 0 : 1);
    99ae:	428b      	cmp	r3, r1
    99b0:	bfcc      	ite	gt
    99b2:	2100      	movgt	r1, #0
    99b4:	2101      	movle	r1, #1
    99b6:	e7ef      	b.n	9998 <TrigSeq16::Controller()+0x5e>

000099b8 <TrigSeq::Controller()>:
        if (Clock(0) || Clock(1)) {
    99b8:	2200      	movs	r2, #0
    void Controller() {
    99ba:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        if (Clock(0) || Clock(1)) {
    99be:	4611      	mov	r1, r2
    void Controller() {
    99c0:	4604      	mov	r4, r0
        if (Clock(0) || Clock(1)) {
    99c2:	f7ff fddf 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    99c6:	4602      	mov	r2, r0
    99c8:	b358      	cbz	r0, 9a22 <TrigSeq::Controller()+0x6a>
    99ca:	f8d4 8020 	ldr.w	r8, [r4, #32]
            ForEachChannel(ch)
    99ce:	f104 0568 	add.w	r5, r4, #104	; 0x68
    99d2:	f104 0773 	add.w	r7, r4, #115	; 0x73
    99d6:	2600      	movs	r6, #0
                if (Clock(1) || step[ch] >= end_step[ch]) step[ch] = -1;
    99d8:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
    99dc:	2200      	movs	r2, #0
    99de:	2101      	movs	r1, #1
    99e0:	4620      	mov	r0, r4
    99e2:	f7ff fdcf 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    99e6:	b918      	cbnz	r0, 99f0 <TrigSeq::Controller()+0x38>
    99e8:	686a      	ldr	r2, [r5, #4]
    99ea:	692b      	ldr	r3, [r5, #16]
    99ec:	429a      	cmp	r2, r3
    99ee:	db01      	blt.n	99f4 <TrigSeq::Controller()+0x3c>
    99f0:	f8c5 9004 	str.w	r9, [r5, #4]
                step[ch]++;
    99f4:	f855 3f04 	ldr.w	r3, [r5, #4]!
    99f8:	3301      	adds	r3, #1
    99fa:	602b      	str	r3, [r5, #0]
                if ((pattern[ch] >> step[ch]) & 0x01) ClockOut(swap ? (1 - ch) : ch);
    99fc:	f817 2f01 	ldrb.w	r2, [r7, #1]!
    9a00:	fa42 f303 	asr.w	r3, r2, r3
    9a04:	07db      	lsls	r3, r3, #31
    9a06:	d509      	bpl.n	9a1c <TrigSeq::Controller()+0x64>
    9a08:	f5b8 5f90 	cmp.w	r8, #4608	; 0x1200
    9a0c:	bfac      	ite	ge
    9a0e:	f1c6 0101 	rsbge	r1, r6, #1
    9a12:	4631      	movlt	r1, r6
    9a14:	2264      	movs	r2, #100	; 0x64
    9a16:	4620      	mov	r0, r4
    9a18:	f7ff ff85 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
            ForEachChannel(ch)
    9a1c:	b93e      	cbnz	r6, 9a2e <TrigSeq::Controller()+0x76>
    9a1e:	2601      	movs	r6, #1
    9a20:	e7dc      	b.n	99dc <TrigSeq::Controller()+0x24>
        if (Clock(0) || Clock(1)) {
    9a22:	2101      	movs	r1, #1
    9a24:	4620      	mov	r0, r4
    9a26:	f7ff fdad 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9a2a:	2800      	cmp	r0, #0
    9a2c:	d1cd      	bne.n	99ca <TrigSeq::Controller()+0x12>
    }
    9a2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9a32:	Address 0x0000000000009a32 is out of bounds.


00009a34 <Shuffle::Controller()>:
    void Controller() {
    9a34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        uint32_t tick = OC::CORE::ticks;
    9a36:	4b22      	ldr	r3, [pc, #136]	; (9ac0 <Shuffle::Controller()+0x8c>)
        if (Clock(1)) {
    9a38:	2200      	movs	r2, #0
    9a3a:	2101      	movs	r1, #1
        uint32_t tick = OC::CORE::ticks;
    9a3c:	681d      	ldr	r5, [r3, #0]
    void Controller() {
    9a3e:	4604      	mov	r4, r0
        if (Clock(1)) {
    9a40:	f7ff fda0 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9a44:	b118      	cbz	r0, 9a4e <Shuffle::Controller()+0x1a>
            which = 0; // Reset (next trigger will be even clock)
    9a46:	2300      	movs	r3, #0
    9a48:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
            last_tick = tick;
    9a4c:	6765      	str	r5, [r4, #116]	; 0x74
        if (Clock(0)) {
    9a4e:	2200      	movs	r2, #0
    9a50:	4611      	mov	r1, r2
    9a52:	4620      	mov	r0, r4
    9a54:	f7ff fd96 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9a58:	b338      	cbz	r0, 9aaa <Shuffle::Controller()+0x76>
            which = 1 - which;
    9a5a:	f894 7070 	ldrb.w	r7, [r4, #112]	; 0x70
            if (last_tick) {
    9a5e:	6f66      	ldr	r6, [r4, #116]	; 0x74
            which = 1 - which;
    9a60:	f087 0701 	eor.w	r7, r7, #1
    9a64:	f884 7070 	strb.w	r7, [r4, #112]	; 0x70
            if (last_tick) {
    9a68:	b1f6      	cbz	r6, 9aa8 <Shuffle::Controller()+0x74>
                tempo = tick - last_tick;
    9a6a:	1bae      	subs	r6, r5, r6
                int16_t d = delay[which] + Proportion(DetentedIn(which), HEMISPHERE_MAX_CV, 100);
    9a6c:	4639      	mov	r1, r7
                tempo = tick - last_tick;
    9a6e:	67e6      	str	r6, [r4, #124]	; 0x7c
                int16_t d = delay[which] + Proportion(DetentedIn(which), HEMISPHERE_MAX_CV, 100);
    9a70:	4620      	mov	r0, r4
    9a72:	f7ff fa27 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
    9a76:	3740      	adds	r7, #64	; 0x40
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9a78:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    9a7c:	0380      	lsls	r0, r0, #14
        int scaled = simfloat2int(proportion * max_value);
    9a7e:	2264      	movs	r2, #100	; 0x64
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9a80:	fb90 f0f3 	sdiv	r0, r0, r3
    9a84:	f834 3017 	ldrh.w	r3, [r4, r7, lsl #1]
        int scaled = simfloat2int(proportion * max_value);
    9a88:	4350      	muls	r0, r2
    9a8a:	eb03 33a0 	add.w	r3, r3, r0, asr #14
    9a8e:	b21b      	sxth	r3, r3
                d = constrain(d, 0, 100);
    9a90:	2b00      	cmp	r3, #0
    9a92:	db13      	blt.n	9abc <Shuffle::Controller()+0x88>
    9a94:	4293      	cmp	r3, r2
    9a96:	bfa8      	it	ge
    9a98:	4613      	movge	r3, r2
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9a9a:	039b      	lsls	r3, r3, #14
    9a9c:	fbb3 f3f2 	udiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    9aa0:	4373      	muls	r3, r6
                next_trigger = tick + delay_ticks;
    9aa2:	eb05 33a3 	add.w	r3, r5, r3, asr #14
    9aa6:	67a3      	str	r3, [r4, #120]	; 0x78
            last_tick = tick;
    9aa8:	6765      	str	r5, [r4, #116]	; 0x74
        if (tick == next_trigger) ClockOut(0);
    9aaa:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    9aac:	42ab      	cmp	r3, r5
    9aae:	d104      	bne.n	9aba <Shuffle::Controller()+0x86>
    9ab0:	2264      	movs	r2, #100	; 0x64
    9ab2:	2100      	movs	r1, #0
    9ab4:	4620      	mov	r0, r4
    9ab6:	f7ff ff36 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
    }
    9aba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                d = constrain(d, 0, 100);
    9abc:	2300      	movs	r3, #0
    9abe:	e7ec      	b.n	9a9a <Shuffle::Controller()+0x66>
    9ac0:	200046cc 	.word	0x200046cc

00009ac4 <Sequence5::Controller()>:
    void Controller() {
    9ac4:	b570      	push	{r4, r5, r6, lr}
        if (Clock(1)) {
    9ac6:	2200      	movs	r2, #0
    9ac8:	2101      	movs	r1, #1
    void Controller() {
    9aca:	4604      	mov	r4, r0
        if (Clock(1)) {
    9acc:	f7ff fd5a 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9ad0:	b138      	cbz	r0, 9ae2 <Sequence5::Controller()+0x1e>
            step = 0;
    9ad2:	2300      	movs	r3, #0
    9ad4:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
            ClockOut(1);
    9ad8:	2264      	movs	r2, #100	; 0x64
    9ada:	2101      	movs	r1, #1
    9adc:	4620      	mov	r0, r4
    9ade:	f7ff ff22 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
        if (DetentedIn(0)) {
    9ae2:	2100      	movs	r1, #0
    9ae4:	4620      	mov	r0, r4
    9ae6:	f7ff f9ed 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
    9aea:	4606      	mov	r6, r0
    9aec:	b120      	cbz	r0, 9af8 <Sequence5::Controller()+0x34>
            transpose = In(0) / 128; // 128 ADC steps per semitone
    9aee:	6a26      	ldr	r6, [r4, #32]
    9af0:	2e00      	cmp	r6, #0
    9af2:	bfb8      	it	lt
    9af4:	367f      	addlt	r6, #127	; 0x7f
    9af6:	11f6      	asrs	r6, r6, #7
        int play_note = note[step] + 60 + transpose;
    9af8:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
        if (Clock(0)) StartADCLag();
    9afc:	2200      	movs	r2, #0
        int play_note = note[step] + 60 + transpose;
    9afe:	eb04 0383 	add.w	r3, r4, r3, lsl #2
        if (Clock(0)) StartADCLag();
    9b02:	4611      	mov	r1, r2
    9b04:	4620      	mov	r0, r4
        int play_note = note[step] + 60 + transpose;
    9b06:	6f5d      	ldr	r5, [r3, #116]	; 0x74
        if (Clock(0)) StartADCLag();
    9b08:	f7ff fd3c 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9b0c:	b108      	cbz	r0, 9b12 <Sequence5::Controller()+0x4e>
        adc_lag_countdown[ch] = HEMISPHERE_ADC_LAG;
    9b0e:	2321      	movs	r3, #33	; 0x21
    9b10:	64e3      	str	r3, [r4, #76]	; 0x4c
        return (--adc_lag_countdown[ch] == 0);
    9b12:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    9b14:	3b01      	subs	r3, #1
    9b16:	64e3      	str	r3, [r4, #76]	; 0x4c
        if (EndOfADCLag()) {
    9b18:	bb53      	cbnz	r3, 9b70 <Sequence5::Controller()+0xac>
            Advance(step);
    9b1a:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
        return (muted & (0x01 << step));
    9b1e:	f894 0070 	ldrb.w	r0, [r4, #112]	; 0x70
        if (++step == 5) step = 0;
    9b22:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
    9b26:	2a04      	cmp	r2, #4
    9b28:	f102 0301 	add.w	r3, r2, #1
    9b2c:	bf08      	it	eq
    9b2e:	2300      	moveq	r3, #0
        return (muted & (0x01 << step));
    9b30:	fa40 f203 	asr.w	r2, r0, r3
        if (step_is_muted(step) && step != starting_point) Advance(starting_point);
    9b34:	07d2      	lsls	r2, r2, #31
    9b36:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    9b3a:	d501      	bpl.n	9b40 <Sequence5::Controller()+0x7c>
    9b3c:	4299      	cmp	r1, r3
    9b3e:	d1f0      	bne.n	9b22 <Sequence5::Controller()+0x5e>
            if (step == 0) ClockOut(1);
    9b40:	b923      	cbnz	r3, 9b4c <Sequence5::Controller()+0x88>
    9b42:	2264      	movs	r2, #100	; 0x64
    9b44:	2101      	movs	r1, #1
    9b46:	4620      	mov	r0, r4
    9b48:	f7ff feed 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
            play = 1;
    9b4c:	2301      	movs	r3, #1
    9b4e:	f884 308c 	strb.w	r3, [r4, #140]	; 0x8c
        int play_note = note[step] + 60 + transpose;
    9b52:	353c      	adds	r5, #60	; 0x3c
    9b54:	19a8      	adds	r0, r5, r6
            int cv = MIDIQuantizer::CV(play_note);
    9b56:	f380 0007 	usat	r0, #7, r0
    9b5a:	2100      	movs	r1, #0
    9b5c:	b2c0      	uxtb	r0, r0
    9b5e:	f7fb ff22 	bl	59a6 <MIDIQuantizer::CV(unsigned char, int)>
            Out(0, cv);
    9b62:	2300      	movs	r3, #0
            int cv = MIDIQuantizer::CV(play_note);
    9b64:	4602      	mov	r2, r0
            Out(0, cv);
    9b66:	4619      	mov	r1, r3
    9b68:	4620      	mov	r0, r4
    9b6a:	f7ff f9b4 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    9b6e:	e003      	b.n	9b78 <Sequence5::Controller()+0xb4>
        if (play) {
    9b70:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
    9b74:	2b00      	cmp	r3, #0
    9b76:	d1ec      	bne.n	9b52 <Sequence5::Controller()+0x8e>
    }
    9b78:	bd70      	pop	{r4, r5, r6, pc}

00009b7a <Metronome::Controller()>:
    void Controller() {
    9b7a:	b538      	push	{r3, r4, r5, lr}
        Clock(0);
    9b7c:	2200      	movs	r2, #0
    void Controller() {
    9b7e:	4604      	mov	r4, r0
        Clock(0);
    9b80:	4611      	mov	r1, r2
    9b82:	f7ff fcff 	bl	9584 <HemisphereApplet::Clock(int, bool)>
        if (clock_m->IsRunning()) {
    9b86:	6f25      	ldr	r5, [r4, #112]	; 0x70
    9b88:	4628      	mov	r0, r5
    9b8a:	f7fe f9a7 	bl	7edc <ClockManager::IsRunning()>
    9b8e:	b178      	cbz	r0, 9bb0 <Metronome::Controller()+0x36>
            if (clock_m->Tock()) {
    9b90:	4628      	mov	r0, r5
    9b92:	f7fe f9e7 	bl	7f64 <ClockManager::Tock()>
    9b96:	b158      	cbz	r0, 9bb0 <Metronome::Controller()+0x36>
                ClockOut(0);
    9b98:	2264      	movs	r2, #100	; 0x64
    9b9a:	2100      	movs	r1, #0
    9b9c:	4620      	mov	r0, r4
    9b9e:	f7ff fec2 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
                if (clock_m->EndOfBeat()) ClockOut(1);
    9ba2:	7d2b      	ldrb	r3, [r5, #20]
    9ba4:	b923      	cbnz	r3, 9bb0 <Metronome::Controller()+0x36>
    9ba6:	2264      	movs	r2, #100	; 0x64
    9ba8:	2101      	movs	r1, #1
    9baa:	4620      	mov	r0, r4
    9bac:	f7ff febb 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
    }
    9bb0:	bd38      	pop	{r3, r4, r5, pc}

00009bb2 <ClockSkip::Controller()>:
    void Controller() {
    9bb2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    9bb6:	4604      	mov	r4, r0
    9bb8:	f100 0870 	add.w	r8, r0, #112	; 0x70
        ForEachChannel(ch)
    9bbc:	2500      	movs	r5, #0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9bbe:	f44f 56f0 	mov.w	r6, #7680	; 0x1e00
        int scaled = simfloat2int(proportion * max_value);
    9bc2:	2764      	movs	r7, #100	; 0x64
            if (Clock(ch)) {
    9bc4:	2200      	movs	r2, #0
    9bc6:	4629      	mov	r1, r5
    9bc8:	4620      	mov	r0, r4
    9bca:	f7ff fcdb 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9bce:	b1e0      	cbz	r0, 9c0a <ClockSkip::Controller()+0x58>
                int prob = p[ch] + Proportion(DetentedIn(ch), HEMISPHERE_MAX_CV, 100);
    9bd0:	4629      	mov	r1, r5
    9bd2:	4620      	mov	r0, r4
    9bd4:	f7ff f976 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
    9bd8:	f104 036c 	add.w	r3, r4, #108	; 0x6c
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9bdc:	0380      	lsls	r0, r0, #14
    9bde:	f933 9015 	ldrsh.w	r9, [r3, r5, lsl #1]
    9be2:	fb90 f0f6 	sdiv	r0, r0, r6
        int scaled = simfloat2int(proportion * max_value);
    9be6:	4378      	muls	r0, r7
    9be8:	eb09 39a0 	add.w	r9, r9, r0, asr #14
                if (random(1, 100) <= prob) {
    9bec:	2164      	movs	r1, #100	; 0x64
    9bee:	2001      	movs	r0, #1
    9bf0:	f010 f97d 	bl	19eee <random(long, long)>
    9bf4:	4548      	cmp	r0, r9
    9bf6:	dc08      	bgt.n	9c0a <ClockSkip::Controller()+0x58>
                    ClockOut(ch);
    9bf8:	2264      	movs	r2, #100	; 0x64
    9bfa:	4629      	mov	r1, r5
    9bfc:	4620      	mov	r0, r4
    9bfe:	f7ff fe92 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
                    trigger_countdown[ch] = 1667;
    9c02:	f240 6383 	movw	r3, #1667	; 0x683
    9c06:	f8c8 3000 	str.w	r3, [r8]
            if (trigger_countdown[ch]) trigger_countdown[ch]--;
    9c0a:	f8d8 3000 	ldr.w	r3, [r8]
    9c0e:	b113      	cbz	r3, 9c16 <ClockSkip::Controller()+0x64>
    9c10:	3b01      	subs	r3, #1
    9c12:	f8c8 3000 	str.w	r3, [r8]
        ForEachChannel(ch)
    9c16:	f108 0804 	add.w	r8, r8, #4
    9c1a:	b10d      	cbz	r5, 9c20 <ClockSkip::Controller()+0x6e>
    }
    9c1c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9c20:	2501      	movs	r5, #1
    9c22:	e7cf      	b.n	9bc4 <ClockSkip::Controller()+0x12>

00009c24 <ClockDivider::Controller()>:
        int this_tick = OC::CORE::ticks;
    9c24:	4b3b      	ldr	r3, [pc, #236]	; (9d14 <ClockDivider::Controller()+0xf0>)
    void Controller() {
    9c26:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        int this_tick = OC::CORE::ticks;
    9c2a:	681f      	ldr	r7, [r3, #0]
    void Controller() {
    9c2c:	4604      	mov	r4, r0
    9c2e:	f100 066c 	add.w	r6, r0, #108	; 0x6c
        ForEachChannel(ch)
    9c32:	2500      	movs	r5, #0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9c34:	f44f 6870 	mov.w	r8, #3840	; 0xf00
    9c38:	f06f 0907 	mvn.w	r9, #7
                if (div[ch] == 0 || div[ch] == -1) div[ch] = 1;
    9c3c:	f04f 0a01 	mov.w	sl, #1
            int input = DetentedIn(ch) - HEMISPHERE_CENTER_CV;
    9c40:	4629      	mov	r1, r5
    9c42:	4620      	mov	r0, r4
    9c44:	f7ff f93e 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
            if (input) {
    9c48:	b180      	cbz	r0, 9c6c <ClockDivider::Controller()+0x48>
    9c4a:	0383      	lsls	r3, r0, #14
    9c4c:	fb93 f3f8 	sdiv	r3, r3, r8
        int scaled = simfloat2int(proportion * max_value);
    9c50:	f343 23d1 	sbfx	r3, r3, #11, #18
    9c54:	2b08      	cmp	r3, #8
    9c56:	bfa8      	it	ge
    9c58:	2308      	movge	r3, #8
    9c5a:	454b      	cmp	r3, r9
    9c5c:	bfb8      	it	lt
    9c5e:	464b      	movlt	r3, r9
                if (div[ch] == 0 || div[ch] == -1) div[ch] = 1;
    9c60:	1c5a      	adds	r2, r3, #1
    9c62:	2a01      	cmp	r2, #1
                div[ch] = constrain(div[ch], -HEM_CLOCKDIV_MAX, HEM_CLOCKDIV_MAX);
    9c64:	bf8c      	ite	hi
    9c66:	6033      	strhi	r3, [r6, #0]
                if (div[ch] == 0 || div[ch] == -1) div[ch] = 1;
    9c68:	f8c6 a000 	strls.w	sl, [r6]
        ForEachChannel(ch)
    9c6c:	3604      	adds	r6, #4
    9c6e:	b33d      	cbz	r5, 9cc0 <ClockDivider::Controller()+0x9c>
        if (Clock(1)) { // Reset
    9c70:	2200      	movs	r2, #0
    9c72:	4629      	mov	r1, r5
    9c74:	4620      	mov	r0, r4
    9c76:	f7ff fc85 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9c7a:	b110      	cbz	r0, 9c82 <ClockDivider::Controller()+0x5e>
            ForEachChannel(ch) count[ch] = 0;
    9c7c:	2300      	movs	r3, #0
    9c7e:	6763      	str	r3, [r4, #116]	; 0x74
    9c80:	67a3      	str	r3, [r4, #120]	; 0x78
        if (Clock(0)) {
    9c82:	2200      	movs	r2, #0
    9c84:	4611      	mov	r1, r2
    9c86:	4620      	mov	r0, r4
    9c88:	f7ff fc7c 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9c8c:	f104 0568 	add.w	r5, r4, #104	; 0x68
    9c90:	b9c0      	cbnz	r0, 9cc4 <ClockDivider::Controller()+0xa0>
            ForEachChannel(ch)
    9c92:	2600      	movs	r6, #0
            if (div[ch] < 0) { // Negative value indicates clock multiplication
    9c94:	f855 2f04 	ldr.w	r2, [r5, #4]!
    9c98:	2a00      	cmp	r2, #0
    9c9a:	da0e      	bge.n	9cba <ClockDivider::Controller()+0x96>
                if (this_tick >= next_clock[ch]) {
    9c9c:	6929      	ldr	r1, [r5, #16]
    9c9e:	42b9      	cmp	r1, r7
    9ca0:	dc0b      	bgt.n	9cba <ClockDivider::Controller()+0x96>
                    int clock_every = (cycle_time / -div[ch]);
    9ca2:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    9ca6:	4252      	negs	r2, r2
    9ca8:	fb93 f3f2 	sdiv	r3, r3, r2
                    next_clock[ch] += clock_every;
    9cac:	440b      	add	r3, r1
    9cae:	612b      	str	r3, [r5, #16]
                    ClockOut(ch);
    9cb0:	2264      	movs	r2, #100	; 0x64
    9cb2:	4631      	mov	r1, r6
    9cb4:	4620      	mov	r0, r4
    9cb6:	f7ff fe36 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
        ForEachChannel(ch)
    9cba:	b34e      	cbz	r6, 9d10 <ClockDivider::Controller()+0xec>
    }
    9cbc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9cc0:	2501      	movs	r5, #1
    9cc2:	e7bd      	b.n	9c40 <ClockDivider::Controller()+0x1c>
    int ClockCycleTicks(int ch) {return cycle_ticks[ch];}
    9cc4:	6ba6      	ldr	r6, [r4, #56]	; 0x38
        		cycle_time = ClockCycleTicks(0);
    9cc6:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
            ForEachChannel(ch)
    9cca:	f04f 0a00 	mov.w	sl, #0
    9cce:	46a9      	mov	r9, r5
                        count[ch] = 0; // Reset
    9cd0:	46d0      	mov	r8, sl
                count[ch]++;
    9cd2:	f8d9 200c 	ldr.w	r2, [r9, #12]
    9cd6:	3201      	adds	r2, #1
    9cd8:	f8c9 200c 	str.w	r2, [r9, #12]
                if (div[ch] > 0) { // Positive value indicates clock division
    9cdc:	f859 3f04 	ldr.w	r3, [r9, #4]!
    9ce0:	2b00      	cmp	r3, #0
    9ce2:	dd0e      	ble.n	9d02 <ClockDivider::Controller()+0xde>
                    if (count[ch] >= div[ch]) {
    9ce4:	429a      	cmp	r2, r3
    9ce6:	db06      	blt.n	9cf6 <ClockDivider::Controller()+0xd2>
                        count[ch] = 0; // Reset
    9ce8:	f8c9 8008 	str.w	r8, [r9, #8]
                    ClockOut(ch); // Sync
    9cec:	2264      	movs	r2, #100	; 0x64
    9cee:	4651      	mov	r1, sl
    9cf0:	4620      	mov	r0, r4
    9cf2:	f7ff fe18 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
            ForEachChannel(ch)
    9cf6:	f1ba 0f00 	cmp.w	sl, #0
    9cfa:	d1ca      	bne.n	9c92 <ClockDivider::Controller()+0x6e>
    9cfc:	f04f 0a01 	mov.w	sl, #1
    9d00:	e7e7      	b.n	9cd2 <ClockDivider::Controller()+0xae>
                    int clock_every = (cycle_time / -div[ch]);
    9d02:	425b      	negs	r3, r3
    9d04:	fb96 f3f3 	sdiv	r3, r6, r3
                    next_clock[ch] = this_tick + clock_every;
    9d08:	443b      	add	r3, r7
    9d0a:	f8c9 3010 	str.w	r3, [r9, #16]
    9d0e:	e7ed      	b.n	9cec <ClockDivider::Controller()+0xc8>
    9d10:	2601      	movs	r6, #1
    9d12:	e7bf      	b.n	9c94 <ClockDivider::Controller()+0x70>
    9d14:	200046cc 	.word	0x200046cc

00009d18 <AnnularFusion::Controller()>:
    void Controller() {
    9d18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        if (Clock(1)) step = 0; // Reset
    9d1c:	2200      	movs	r2, #0
    9d1e:	2101      	movs	r1, #1
    void Controller() {
    9d20:	4604      	mov	r4, r0
        if (Clock(1)) step = 0; // Reset
    9d22:	f7ff fc2f 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9d26:	b108      	cbz	r0, 9d2c <AnnularFusion::Controller()+0x14>
    9d28:	2300      	movs	r3, #0
    9d2a:	66e3      	str	r3, [r4, #108]	; 0x6c
        if (Clock(0)) {
    9d2c:	2200      	movs	r2, #0
    9d2e:	4611      	mov	r1, r2
    9d30:	4620      	mov	r0, r4
    9d32:	f7ff fc27 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9d36:	2800      	cmp	r0, #0
    9d38:	d038      	beq.n	9dac <AnnularFusion::Controller()+0x94>
            last_clock = OC::CORE::ticks;
    9d3a:	4b22      	ldr	r3, [pc, #136]	; (9dc4 <AnnularFusion::Controller()+0xac>)
    9d3c:	681b      	ldr	r3, [r3, #0]
    9d3e:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
            ForEachChannel(ch)
    9d42:	f104 06f0 	add.w	r6, r4, #240	; 0xf0
    9d46:	f04f 0800 	mov.w	r8, #0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9d4a:	f44f 57f0 	mov.w	r7, #7680	; 0x1e00
                int rotation = Proportion(DetentedIn(ch), HEMISPHERE_MAX_CV, length[ch]);
    9d4e:	4641      	mov	r1, r8
    9d50:	4620      	mov	r0, r4
    9d52:	f7ff f8b7 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
    9d56:	6973      	ldr	r3, [r6, #20]
                pattern[ch] = EuclideanPattern(length[ch] - 1, beats[ch], rotation);
    9d58:	7f31      	ldrb	r1, [r6, #28]
    9d5a:	0382      	lsls	r2, r0, #14
    9d5c:	1e58      	subs	r0, r3, #1
    9d5e:	fb92 f2f7 	sdiv	r2, r2, r7
        int scaled = simfloat2int(proportion * max_value);
    9d62:	435a      	muls	r2, r3
    9d64:	f3c2 3287 	ubfx	r2, r2, #14, #8
    9d68:	b2c0      	uxtb	r0, r0
    9d6a:	f7f7 fadb 	bl	1324 <EuclideanPattern(unsigned char, unsigned char, unsigned char)>
    9d6e:	f846 0f04 	str.w	r0, [r6, #4]!
                int sb = step % length[ch];
    9d72:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    9d74:	6932      	ldr	r2, [r6, #16]
    9d76:	fb95 f3f2 	sdiv	r3, r5, r2
    9d7a:	fb02 5313 	mls	r3, r2, r3, r5
                if ((pattern[ch] >> sb) & 0x01) {
    9d7e:	40d8      	lsrs	r0, r3
    9d80:	07c3      	lsls	r3, r0, #31
    9d82:	d504      	bpl.n	9d8e <AnnularFusion::Controller()+0x76>
                    ClockOut(ch);
    9d84:	2264      	movs	r2, #100	; 0x64
    9d86:	4641      	mov	r1, r8
    9d88:	4620      	mov	r0, r4
    9d8a:	f7ff fdcc 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
            ForEachChannel(ch)
    9d8e:	f1b8 0f00 	cmp.w	r8, #0
    9d92:	d013      	beq.n	9dbc <AnnularFusion::Controller()+0xa4>
            if (++step >= length[0] * length[1]) step = 0;
    9d94:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    9d98:	f8d4 2108 	ldr.w	r2, [r4, #264]	; 0x108
    9d9c:	3501      	adds	r5, #1
    9d9e:	4353      	muls	r3, r2
    9da0:	429d      	cmp	r5, r3
    9da2:	bfa8      	it	ge
    9da4:	2300      	movge	r3, #0
    9da6:	66e5      	str	r5, [r4, #108]	; 0x6c
    9da8:	bfa8      	it	ge
    9daa:	66e3      	strge	r3, [r4, #108]	; 0x6c
        if (display_timeout > 0) --display_timeout;
    9dac:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    9db0:	b113      	cbz	r3, 9db8 <AnnularFusion::Controller()+0xa0>
    9db2:	3b01      	subs	r3, #1
    9db4:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
    }
    9db8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9dbc:	f04f 0801 	mov.w	r8, #1
    9dc0:	e7c5      	b.n	9d4e <AnnularFusion::Controller()+0x36>
    9dc2:	bf00      	nop
    9dc4:	200046cc 	.word	0x200046cc

00009dc8 <ADEG::Controller()>:
        if (Clock(0)) {
    9dc8:	2200      	movs	r2, #0
    void Controller() {
    9dca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (Clock(0)) {
    9dcc:	4611      	mov	r1, r2
    void Controller() {
    9dce:	4604      	mov	r4, r0
        if (Clock(0)) {
    9dd0:	f7ff fbd8 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9dd4:	4602      	mov	r2, r0
    9dd6:	2800      	cmp	r0, #0
    9dd8:	d053      	beq.n	9e82 <ADEG::Controller()+0xba>
            phase = 1; // Return to attack phase
    9dda:	2301      	movs	r3, #1
    9ddc:	6723      	str	r3, [r4, #112]	; 0x70
            effective_attack = attack;
    9dde:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    9de2:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
            effective_decay = decay;
    9de6:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
            effective_decay = attack;
    9dea:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        if (phase > 0) {
    9dee:	6f26      	ldr	r6, [r4, #112]	; 0x70
    9df0:	2e00      	cmp	r6, #0
    9df2:	dd45      	ble.n	9e80 <ADEG::Controller()+0xb8>
            if (phase == 2) target = 0; // Fall to zero for decay
    9df4:	2e02      	cmp	r6, #2
            if (signal != target) {
    9df6:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
            if (phase == 2) target = 0; // Fall to zero for decay
    9df8:	bf14      	ite	ne
    9dfa:	f04f 67f0 	movne.w	r7, #125829120	; 0x7800000
    9dfe:	2700      	moveq	r7, #0
            if (signal != target) {
    9e00:	42bd      	cmp	r5, r7
    9e02:	d036      	beq.n	9e72 <ADEG::Controller()+0xaa>
                    ? effective_attack + Proportion(DetentedIn(0), HEMISPHERE_MAX_CV, HEM_ADEG_MAX_VALUE)
    9e04:	2e01      	cmp	r6, #1
    9e06:	d14b      	bne.n	9ea0 <ADEG::Controller()+0xd8>
    9e08:	2100      	movs	r1, #0
    9e0a:	4620      	mov	r0, r4
    9e0c:	f7ff f85a 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9e10:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    9e14:	0380      	lsls	r0, r0, #14
    9e16:	fb90 f0f3 	sdiv	r0, r0, r3
    9e1a:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
        int scaled = simfloat2int(proportion * max_value);
    9e1e:	ebc0 2000 	rsb	r0, r0, r0, lsl #8
    9e22:	eb03 33a0 	add.w	r3, r3, r0, asr #14
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9e26:	f383 0308 	usat	r3, #8, r3
    9e2a:	22ff      	movs	r2, #255	; 0xff
    9e2c:	039b      	lsls	r3, r3, #14
    9e2e:	fbb3 f3f2 	udiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    9e32:	f248 2235 	movw	r2, #33333	; 0x8235
    9e36:	4353      	muls	r3, r2
                simfloat remaining = target - signal;
    9e38:	1b7f      	subs	r7, r7, r5
    9e3a:	139b      	asrs	r3, r3, #14
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9e3c:	f427 527f 	bic.w	r2, r7, #16320	; 0x3fc0
    9e40:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
    9e44:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
    9e48:	fb92 f2f1 	sdiv	r2, r2, r1
        int scaled = simfloat2int(proportion * max_value);
    9e4c:	4353      	muls	r3, r2
                if (ticks_to_remaining <= 0) {
    9e4e:	139b      	asrs	r3, r3, #14
    9e50:	d004      	beq.n	9e5c <ADEG::Controller()+0x94>
                    delta = remaining / ticks_to_remaining;
    9e52:	2b00      	cmp	r3, #0
    9e54:	bfb8      	it	lt
    9e56:	425b      	neglt	r3, r3
    9e58:	fb97 f7f3 	sdiv	r7, r7, r3
                signal += delta;
    9e5c:	443d      	add	r5, r7
                if (simfloat2int(signal) >= HEMISPHERE_MAX_CV && phase == 1) phase = 2;
    9e5e:	f1b5 6ff0 	cmp.w	r5, #125829120	; 0x7800000
                signal += delta;
    9e62:	66e5      	str	r5, [r4, #108]	; 0x6c
                if (simfloat2int(signal) >= HEMISPHERE_MAX_CV && phase == 1) phase = 2;
    9e64:	ea4f 33a5 	mov.w	r3, r5, asr #14
    9e68:	db28      	blt.n	9ebc <ADEG::Controller()+0xf4>
    9e6a:	2e01      	cmp	r6, #1
    9e6c:	d101      	bne.n	9e72 <ADEG::Controller()+0xaa>
    9e6e:	2302      	movs	r3, #2
                    phase = 0;
    9e70:	6723      	str	r3, [r4, #112]	; 0x70
            Out(0, simfloat2int(signal));
    9e72:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    9e74:	2300      	movs	r3, #0
    9e76:	1392      	asrs	r2, r2, #14
    9e78:	4619      	mov	r1, r3
    9e7a:	4620      	mov	r0, r4
    9e7c:	f7ff f82b 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    9e80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        } else if (Clock(1)) {
    9e82:	2101      	movs	r1, #1
    9e84:	4620      	mov	r0, r4
    9e86:	f7ff fb7d 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    9e8a:	2800      	cmp	r0, #0
    9e8c:	d0af      	beq.n	9dee <ADEG::Controller()+0x26>
            phase = 1;
    9e8e:	2301      	movs	r3, #1
    9e90:	6723      	str	r3, [r4, #112]	; 0x70
            effective_attack = decay;
    9e92:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    9e96:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
            effective_decay = attack;
    9e9a:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    9e9e:	e7a4      	b.n	9dea <ADEG::Controller()+0x22>
                    : effective_decay + Proportion(DetentedIn(1), HEMISPHERE_MAX_CV, HEM_ADEG_MAX_VALUE);
    9ea0:	2101      	movs	r1, #1
    9ea2:	4620      	mov	r0, r4
    9ea4:	f7ff f80e 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9ea8:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    9eac:	0380      	lsls	r0, r0, #14
    9eae:	fb90 f0f3 	sdiv	r0, r0, r3
                    ? effective_attack + Proportion(DetentedIn(0), HEMISPHERE_MAX_CV, HEM_ADEG_MAX_VALUE)
    9eb2:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
        int scaled = simfloat2int(proportion * max_value);
    9eb6:	ebc0 2000 	rsb	r0, r0, r0, lsl #8
    9eba:	e7b2      	b.n	9e22 <ADEG::Controller()+0x5a>
                if (simfloat2int(signal) <= 0 && phase == 2) {
    9ebc:	2b00      	cmp	r3, #0
    9ebe:	dcd8      	bgt.n	9e72 <ADEG::Controller()+0xaa>
    9ec0:	2e02      	cmp	r6, #2
    9ec2:	d1d6      	bne.n	9e72 <ADEG::Controller()+0xaa>
                    ClockOut(1);
    9ec4:	2264      	movs	r2, #100	; 0x64
    9ec6:	2101      	movs	r1, #1
    9ec8:	4620      	mov	r0, r4
    9eca:	f7ff fd2c 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
                    phase = 0;
    9ece:	2300      	movs	r3, #0
    9ed0:	e7ce      	b.n	9e70 <ADEG::Controller()+0xa8>

00009ed2 <HemisphereApplet::GateOut(int, bool)>:
    void GateOut(int ch, bool high) {
    9ed2:	b508      	push	{r3, lr}
        Out(ch, 0, (high ? PULSE_VOLTAGE : 0));
    9ed4:	2a00      	cmp	r2, #0
    9ed6:	bf14      	ite	ne
    9ed8:	2305      	movne	r3, #5
    9eda:	2300      	moveq	r3, #0
    9edc:	2200      	movs	r2, #0
    9ede:	f7fe fffa 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    9ee2:	bd08      	pop	{r3, pc}

00009ee4 <Schmitt::Controller()>:
    void Controller() {
    9ee4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        ForEachChannel(ch)
    9ee8:	2700      	movs	r7, #0
    void Controller() {
    9eea:	4604      	mov	r4, r0
    9eec:	f100 056f 	add.w	r5, r0, #111	; 0x6f
    9ef0:	f100 0620 	add.w	r6, r0, #32
            if (state[ch] && In(ch) < low) state[ch] = 0;
    9ef4:	46b8      	mov	r8, r7
            if (!state[ch] && In(ch) > high) state[ch] = 1;
    9ef6:	f04f 0901 	mov.w	r9, #1
    9efa:	f815 3f01 	ldrb.w	r3, [r5, #1]!
    9efe:	b933      	cbnz	r3, 9f0e <Schmitt::Controller()+0x2a>
    9f00:	f8b4 207a 	ldrh.w	r2, [r4, #122]	; 0x7a
    9f04:	6833      	ldr	r3, [r6, #0]
    9f06:	429a      	cmp	r2, r3
    9f08:	da08      	bge.n	9f1c <Schmitt::Controller()+0x38>
    9f0a:	f885 9000 	strb.w	r9, [r5]
            if (state[ch] && In(ch) < low) state[ch] = 0;
    9f0e:	f8b4 2078 	ldrh.w	r2, [r4, #120]	; 0x78
    9f12:	6833      	ldr	r3, [r6, #0]
    9f14:	429a      	cmp	r2, r3
    9f16:	dd01      	ble.n	9f1c <Schmitt::Controller()+0x38>
    9f18:	f885 8000 	strb.w	r8, [r5]
            GateOut(ch, state[ch]);
    9f1c:	782a      	ldrb	r2, [r5, #0]
    9f1e:	4639      	mov	r1, r7
    9f20:	4620      	mov	r0, r4
    9f22:	f7ff ffd6 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
        ForEachChannel(ch)
    9f26:	3604      	adds	r6, #4
    9f28:	b14f      	cbz	r7, 9f3e <Schmitt::Controller()+0x5a>
        if (--gate_countdown < -SCHMITT_FLASH_SPEED) gate_countdown = SCHMITT_FLASH_SPEED;
    9f2a:	6f63      	ldr	r3, [r4, #116]	; 0x74
    9f2c:	3b01      	subs	r3, #1
    9f2e:	f513 6f7a 	cmn.w	r3, #4000	; 0xfa0
    9f32:	bfb8      	it	lt
    9f34:	f44f 637a 	movlt.w	r3, #4000	; 0xfa0
    9f38:	6763      	str	r3, [r4, #116]	; 0x74
    }
    9f3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9f3e:	2701      	movs	r7, #1
    9f40:	e7db      	b.n	9efa <Schmitt::Controller()+0x16>

00009f42 <Compare::Controller()>:
    void Controller() {
    9f42:	b538      	push	{r3, r4, r5, lr}
    9f44:	4604      	mov	r4, r0
        mod_cv = cv_level + DetentedIn(1);
    9f46:	2101      	movs	r1, #1
    9f48:	f7fe ffbc 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    9f4c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    9f4e:	22ff      	movs	r2, #255	; 0xff
    9f50:	039b      	lsls	r3, r3, #14
    9f52:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    9f56:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
    9f5a:	4353      	muls	r3, r2
    9f5c:	eb00 30a3 	add.w	r0, r0, r3, asr #14
    9f60:	4290      	cmp	r0, r2
    9f62:	bfa8      	it	ge
    9f64:	4610      	movge	r0, r2
        if (In(0) > mod_cv) {
    9f66:	6a23      	ldr	r3, [r4, #32]
    9f68:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    9f6c:	4298      	cmp	r0, r3
        mod_cv = constrain(mod_cv, 0, HEMISPHERE_MAX_CV);
    9f6e:	6720      	str	r0, [r4, #112]	; 0x70
        if (In(0) > mod_cv) {
    9f70:	da0d      	bge.n	9f8e <Compare::Controller()+0x4c>
            in_greater = 1;
    9f72:	2501      	movs	r5, #1
            GateOut(0, 1);
    9f74:	462a      	mov	r2, r5
    9f76:	2100      	movs	r1, #0
            in_greater = 1;
    9f78:	f884 5074 	strb.w	r5, [r4, #116]	; 0x74
            GateOut(0, 1);
    9f7c:	4620      	mov	r0, r4
    9f7e:	f7ff ffa8 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
            GateOut(1, 0);
    9f82:	2200      	movs	r2, #0
    9f84:	4629      	mov	r1, r5
            GateOut(0, 0);
    9f86:	4620      	mov	r0, r4
    9f88:	f7ff ffa3 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
    }
    9f8c:	bd38      	pop	{r3, r4, r5, pc}
            in_greater = 0;
    9f8e:	2500      	movs	r5, #0
            GateOut(1, 1);
    9f90:	2201      	movs	r2, #1
    9f92:	4611      	mov	r1, r2
            in_greater = 0;
    9f94:	f884 5074 	strb.w	r5, [r4, #116]	; 0x74
            GateOut(1, 1);
    9f98:	4620      	mov	r0, r4
    9f9a:	f7ff ff9a 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
            GateOut(0, 0);
    9f9e:	462a      	mov	r2, r5
    9fa0:	4629      	mov	r1, r5
    9fa2:	e7f0      	b.n	9f86 <Compare::Controller()+0x44>

00009fa4 <Trending::Controller()>:
        if (--sample_countdown < 0) {
    9fa4:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
    9fa8:	3b01      	subs	r3, #1
    9faa:	2b00      	cmp	r3, #0
    void Controller() {
    9fac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9fb0:	4604      	mov	r4, r0
        if (--sample_countdown < 0) {
    9fb2:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    9fb6:	da58      	bge.n	a06a <Trending::Controller()+0xc6>
            sample_countdown = (TRENDING_MAX_SENS - sensitivity) * 20;
    9fb8:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    9fbc:	2214      	movs	r2, #20
    9fbe:	f1c3 037c 	rsb	r3, r3, #124	; 0x7c
    9fc2:	4353      	muls	r3, r2
    9fc4:	2b60      	cmp	r3, #96	; 0x60
    9fc6:	bfb8      	it	lt
    9fc8:	2360      	movlt	r3, #96	; 0x60
    9fca:	2600      	movs	r6, #0
    9fcc:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
            ForEachChannel(ch)
    9fd0:	f100 077c 	add.w	r7, r0, #124	; 0x7c
    9fd4:	f100 0594 	add.w	r5, r0, #148	; 0x94
        if (result[ch] > 3) trend = Trend::rising;
    9fd8:	46b1      	mov	r9, r6
                if (assign[ch] == Trend::changedstate && trend != last_trend[ch]) fire[ch] = 1;
    9fda:	f04f 0a01 	mov.w	sl, #1
        if (result[ch] > 3) trend = Trend::rising;
    9fde:	693b      	ldr	r3, [r7, #16]
    9fe0:	2b03      	cmp	r3, #3
    9fe2:	dc2e      	bgt.n	a042 <Trending::Controller()+0x9e>
        if (result[ch] < -3) trend = Trend::falling;
    9fe4:	3304      	adds	r3, #4
    9fe6:	bfcc      	ite	gt
    9fe8:	f04f 0803 	movgt.w	r8, #3
    9fec:	f04f 0801 	movle.w	r8, #1
                if (reset[ch]) {
    9ff0:	782b      	ldrb	r3, [r5, #0]
    9ff2:	b13b      	cbz	r3, a004 <Trending::Controller()+0x60>
                    Out(ch, 0);
    9ff4:	2300      	movs	r3, #0
    9ff6:	461a      	mov	r2, r3
    9ff8:	4631      	mov	r1, r6
    9ffa:	4620      	mov	r0, r4
    9ffc:	f7fe ff6b 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                    reset[ch] = 0;
    a000:	f885 9000 	strb.w	r9, [r5]
                if (assign[ch] < Trend::changedstate) {
    a004:	792a      	ldrb	r2, [r5, #4]
    a006:	2a03      	cmp	r2, #3
    a008:	d809      	bhi.n	a01e <Trending::Controller()+0x7a>
                    if (assign[ch] == Trend::moving && trend != Trend::steady) gate = 1;
    a00a:	2a02      	cmp	r2, #2
    a00c:	d01c      	beq.n	a048 <Trending::Controller()+0xa4>
                    if (assign[ch] == trend) gate = 1;
    a00e:	eba2 0308 	sub.w	r3, r2, r8
    a012:	425a      	negs	r2, r3
    a014:	415a      	adcs	r2, r3
                    GateOut(ch, gate);
    a016:	4631      	mov	r1, r6
    a018:	4620      	mov	r0, r4
    a01a:	f7ff ff5a 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
                if (assign[ch] == Trend::changedstate && trend != last_trend[ch]) fire[ch] = 1;
    a01e:	792b      	ldrb	r3, [r5, #4]
    a020:	2b04      	cmp	r3, #4
    a022:	d116      	bne.n	a052 <Trending::Controller()+0xae>
    a024:	687b      	ldr	r3, [r7, #4]
    a026:	4543      	cmp	r3, r8
    a028:	d013      	beq.n	a052 <Trending::Controller()+0xae>
    a02a:	f885 a002 	strb.w	sl, [r5, #2]
                    ClockOut(ch);
    a02e:	2264      	movs	r2, #100	; 0x64
    a030:	4631      	mov	r1, r6
    a032:	4620      	mov	r0, r4
    a034:	f7ff fc77 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
                    fire[ch] = 0;
    a038:	f885 9002 	strb.w	r9, [r5, #2]
    a03c:	e00c      	b.n	a058 <Trending::Controller()+0xb4>
    a03e:	2601      	movs	r6, #1
    a040:	e7cd      	b.n	9fde <Trending::Controller()+0x3a>
        if (result[ch] > 3) trend = Trend::rising;
    a042:	f04f 0800 	mov.w	r8, #0
    a046:	e7d3      	b.n	9ff0 <Trending::Controller()+0x4c>
                    if (assign[ch] == Trend::moving && trend != Trend::steady) gate = 1;
    a048:	f1b8 0203 	subs.w	r2, r8, #3
    a04c:	bf18      	it	ne
    a04e:	2201      	movne	r2, #1
    a050:	e7e1      	b.n	a016 <Trending::Controller()+0x72>
                if (fire[ch]) {
    a052:	78ab      	ldrb	r3, [r5, #2]
    a054:	2b00      	cmp	r3, #0
    a056:	d1ea      	bne.n	a02e <Trending::Controller()+0x8a>
                last_trend[ch] = trend;
    a058:	f847 8f04 	str.w	r8, [r7, #4]!
            ForEachChannel(ch)
    a05c:	3501      	adds	r5, #1
                result[ch] = 0;
    a05e:	f8c7 900c 	str.w	r9, [r7, #12]
            ForEachChannel(ch)
    a062:	2e00      	cmp	r6, #0
    a064:	d0eb      	beq.n	a03e <Trending::Controller()+0x9a>
    }
    a066:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a06a:	f100 015f 	add.w	r1, r0, #95	; 0x5f
    a06e:	f100 031c 	add.w	r3, r0, #28
    a072:	3424      	adds	r4, #36	; 0x24
                if (assign[ch] == Trend::changedvalue && changed) fire[ch] = 1;
    a074:	2601      	movs	r6, #1
        return inputs[ch];
    a076:	f853 0f04 	ldr.w	r0, [r3, #4]!
    bool Changed(int ch) {return changed_cv[ch];}
    a07a:	f811 7f01 	ldrb.w	r7, [r1, #1]!
                if (Observe(ch, signal[ch], last_signal[ch])) last_signal[ch] = signal[ch];
    a07e:	6d9d      	ldr	r5, [r3, #88]	; 0x58
                signal[ch] = In(ch);
    a080:	6518      	str	r0, [r3, #80]	; 0x50
        if (abs(c_signal - l_signal) > 10) {
    a082:	1b42      	subs	r2, r0, r5
    a084:	2a00      	cmp	r2, #0
    a086:	bfb8      	it	lt
    a088:	4252      	neglt	r2, r2
    a08a:	2a0a      	cmp	r2, #10
    a08c:	dd07      	ble.n	a09e <Trending::Controller()+0xfa>
            if (c_signal > l_signal) result[ch] += 1;
    a08e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
                if (Observe(ch, signal[ch], last_signal[ch])) last_signal[ch] = signal[ch];
    a090:	6598      	str	r0, [r3, #88]	; 0x58
            if (c_signal > l_signal) result[ch] += 1;
    a092:	42a8      	cmp	r0, r5
    a094:	bfcc      	ite	gt
    a096:	3201      	addgt	r2, #1
            else result[ch] -= 1;
    a098:	f102 32ff 	addle.w	r2, r2, #4294967295	; 0xffffffff
        return update;
    a09c:	66da      	str	r2, [r3, #108]	; 0x6c
                if (assign[ch] == Trend::changedvalue && changed) fire[ch] = 1;
    a09e:	f891 2038 	ldrb.w	r2, [r1, #56]	; 0x38
    a0a2:	2a05      	cmp	r2, #5
    a0a4:	d102      	bne.n	a0ac <Trending::Controller()+0x108>
    a0a6:	b10f      	cbz	r7, a0ac <Trending::Controller()+0x108>
    a0a8:	f881 6036 	strb.w	r6, [r1, #54]	; 0x36
            ForEachChannel(ch)
    a0ac:	42a3      	cmp	r3, r4
    a0ae:	d1e2      	bne.n	a076 <Trending::Controller()+0xd2>
    a0b0:	e7d9      	b.n	a066 <Trending::Controller()+0xc2>

0000a0b2 <ShiftGate::Controller()>:
        if (Clock(0)) StartADCLag();
    a0b2:	2200      	movs	r2, #0
    void Controller() {
    a0b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        if (Clock(0)) StartADCLag();
    a0b8:	4611      	mov	r1, r2
    void Controller() {
    a0ba:	4605      	mov	r5, r0
        if (Clock(0)) StartADCLag();
    a0bc:	f7ff fa62 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    a0c0:	b108      	cbz	r0, a0c6 <ShiftGate::Controller()+0x14>
        adc_lag_countdown[ch] = HEMISPHERE_ADC_LAG;
    a0c2:	2321      	movs	r3, #33	; 0x21
    a0c4:	64eb      	str	r3, [r5, #76]	; 0x4c
        return (--adc_lag_countdown[ch] == 0);
    a0c6:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    a0c8:	f103 39ff 	add.w	r9, r3, #4294967295	; 0xffffffff
    a0cc:	f8c5 904c 	str.w	r9, [r5, #76]	; 0x4c
        if (EndOfADCLag()) {
    a0d0:	f1b9 0f00 	cmp.w	r9, #0
    a0d4:	d12c      	bne.n	a130 <ShiftGate::Controller()+0x7e>
    a0d6:	f105 066e 	add.w	r6, r5, #110	; 0x6e
    a0da:	f105 0773 	add.w	r7, r5, #115	; 0x73
        return inputs[ch];
    a0de:	f105 0820 	add.w	r8, r5, #32
                int last = (reg[ch] >> (length[ch] - 1)) & 0x01;
    a0e2:	f917 3f01 	ldrsb.w	r3, [r7, #1]!
    a0e6:	f836 4f02 	ldrh.w	r4, [r6, #2]!
    a0ea:	3b01      	subs	r3, #1
    a0ec:	411c      	asrs	r4, r3
                if (!Clock(1)) { // Digital 2 freezes the buffer
    a0ee:	2200      	movs	r2, #0
    a0f0:	2101      	movs	r1, #1
    a0f2:	4628      	mov	r0, r5
                int last = (reg[ch] >> (length[ch] - 1)) & 0x01;
    a0f4:	f004 0401 	and.w	r4, r4, #1
                if (!Clock(1)) { // Digital 2 freezes the buffer
    a0f8:	f7ff fa44 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    a0fc:	b930      	cbnz	r0, a10c <ShiftGate::Controller()+0x5a>
                    bool data = In(ch) > HEMISPHERE_3V_CV ? 0x01 : 0x00;
    a0fe:	f858 3029 	ldr.w	r3, [r8, r9, lsl #2]
    a102:	f5b3 5f90 	cmp.w	r3, #4608	; 0x1200
    a106:	bfc8      	it	gt
    a108:	f084 0401 	eorgt.w	r4, r4, #1
                reg[ch] = (reg[ch] << 1) + last;
    a10c:	8833      	ldrh	r3, [r6, #0]
    a10e:	eb04 0243 	add.w	r2, r4, r3, lsl #1
                if (trigger[ch]) {
    a112:	78bb      	ldrb	r3, [r7, #2]
                reg[ch] = (reg[ch] << 1) + last;
    a114:	b292      	uxth	r2, r2
    a116:	8032      	strh	r2, [r6, #0]
                if (trigger[ch]) {
    a118:	f002 0201 	and.w	r2, r2, #1
    a11c:	b16b      	cbz	r3, a13a <ShiftGate::Controller()+0x88>
                    if (clock) ClockOut(ch);
    a11e:	b122      	cbz	r2, a12a <ShiftGate::Controller()+0x78>
    a120:	2264      	movs	r2, #100	; 0x64
    a122:	4649      	mov	r1, r9
    a124:	4628      	mov	r0, r5
    a126:	f7ff fbfe 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
            ForEachChannel(ch)
    a12a:	f1b9 0f01 	cmp.w	r9, #1
    a12e:	d101      	bne.n	a134 <ShiftGate::Controller()+0x82>
    }
    a130:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a134:	f04f 0901 	mov.w	r9, #1
    a138:	e7d3      	b.n	a0e2 <ShiftGate::Controller()+0x30>
                else GateOut(ch, clock);
    a13a:	4649      	mov	r1, r9
    a13c:	4628      	mov	r0, r5
    a13e:	f7ff fec8 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
    a142:	e7f2      	b.n	a12a <ShiftGate::Controller()+0x78>

0000a144 <HemisphereManager::SetApplet(int, int)>:
    void SetApplet(int hemisphere, int index) {
    a144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        my_applet[hemisphere] = index;
    a146:	eb00 0381 	add.w	r3, r0, r1, lsl #2
        available_applets[index].Start(hemisphere);
    a14a:	2728      	movs	r7, #40	; 0x28
        my_applet[hemisphere] = index;
    a14c:	f8c3 2844 	str.w	r2, [r3, #2116]	; 0x844
        if (midi_in_hemisphere == hemisphere) midi_in_hemisphere = -1;
    a150:	f8d0 3858 	ldr.w	r3, [r0, #2136]	; 0x858
    a154:	428b      	cmp	r3, r1
    a156:	bf04      	itt	eq
    a158:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    a15c:	f8c0 3858 	streq.w	r3, [r0, #2136]	; 0x858
        if (available_applets[index].id & 0x80) midi_in_hemisphere = hemisphere;
    a160:	2328      	movs	r3, #40	; 0x28
    a162:	fb03 0302 	mla	r3, r3, r2, r0
    void SetApplet(int hemisphere, int index) {
    a166:	4604      	mov	r4, r0
        if (available_applets[index].id & 0x80) midi_in_hemisphere = hemisphere;
    a168:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a16a:	061b      	lsls	r3, r3, #24
        available_applets[index].Start(hemisphere);
    a16c:	fb02 7307 	mla	r3, r2, r7, r7
    void SetApplet(int hemisphere, int index) {
    a170:	4615      	mov	r5, r2
        available_applets[index].Start(hemisphere);
    a172:	4403      	add	r3, r0
        if (available_applets[index].id & 0x80) midi_in_hemisphere = hemisphere;
    a174:	bf48      	it	mi
    a176:	f8c0 1858 	strmi.w	r1, [r0, #2136]	; 0x858
        apply_value(hemisphere, available_applets[index].id);
    a17a:	fb07 4505 	mla	r5, r7, r5, r4
        available_applets[index].Start(hemisphere);
    a17e:	1e08      	subs	r0, r1, #0
    void SetApplet(int hemisphere, int index) {
    a180:	460e      	mov	r6, r1
        available_applets[index].Start(hemisphere);
    a182:	685b      	ldr	r3, [r3, #4]
    a184:	bf18      	it	ne
    a186:	2001      	movne	r0, #1
    a188:	4798      	blx	r3
        apply_value(hemisphere, available_applets[index].id);
    a18a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    a18c:	4631      	mov	r1, r6
    a18e:	f104 0008 	add.w	r0, r4, #8
    }
    a192:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        apply_value(hemisphere, available_applets[index].id);
    a196:	f7fa bdef 	b.w	4d78 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]>
    a19a:	Address 0x000000000000a19a is out of bounds.


0000a19c <HEMISPHERE_handleEncoderEvent(UI::Event const&)>:
        if (clock_setup) {
    a19c:	4b20      	ldr	r3, [pc, #128]	; (a220 <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x84>)
        int h = (event.control == OC::CONTROL_ENCODER_L) ? LEFT_HEMISPHERE : RIGHT_HEMISPHERE;
    a19e:	8842      	ldrh	r2, [r0, #2]
            ClockSetup.OnEncoderMove(LEFT_HEMISPHERE, event.value);
    a1a0:	f9b0 1004 	ldrsh.w	r1, [r0, #4]
        if (clock_setup) {
    a1a4:	f893 0850 	ldrb.w	r0, [r3, #2128]	; 0x850
        if (event.control == OC::CONTROL_BUTTON_DOWN) manager.ToggleClockSetup();
        if (event.control == OC::CONTROL_BUTTON_L) manager.ToggleClockRun();
    }
}

void HEMISPHERE_handleEncoderEvent(const UI::Event &event) {
    a1a8:	b570      	push	{r4, r5, r6, lr}
        if (clock_setup) {
    a1aa:	b128      	cbz	r0, a1b8 <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x1c>
            ClockSetup.OnEncoderMove(LEFT_HEMISPHERE, event.value);
    a1ac:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
    a1b0:	2000      	movs	r0, #0
    manager.DelegateEncoderMovement(event);
}
    a1b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            available_applets[index].OnEncoderMove(h, event.value);
    a1b6:	4718      	bx	r3
        int h = (event.control == OC::CONTROL_ENCODER_L) ? LEFT_HEMISPHERE : RIGHT_HEMISPHERE;
    a1b8:	f1b2 0020 	subs.w	r0, r2, #32
        } else if (select_mode == h) {
    a1bc:	f8d3 484c 	ldr.w	r4, [r3, #2124]	; 0x84c
        int h = (event.control == OC::CONTROL_ENCODER_L) ? LEFT_HEMISPHERE : RIGHT_HEMISPHERE;
    a1c0:	bf18      	it	ne
    a1c2:	2001      	movne	r0, #1
        } else if (select_mode == h) {
    a1c4:	42a0      	cmp	r0, r4
    a1c6:	d121      	bne.n	a20c <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x70>
        if (SelectModeEnabled() and help_hemisphere == -1) {
    a1c8:	f8d3 2854 	ldr.w	r2, [r3, #2132]	; 0x854
    a1cc:	3201      	adds	r2, #1
    a1ce:	d11a      	bne.n	a206 <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x6a>
            int index = get_next_applet_index(my_applet[select_mode], dir);
    a1d0:	eb03 0284 	add.w	r2, r3, r4, lsl #2
            if (midi_in_hemisphere == (1 - select_mode)) {
    a1d4:	f8d3 5858 	ldr.w	r5, [r3, #2136]	; 0x858
            int index = get_next_applet_index(my_applet[select_mode], dir);
    a1d8:	f8d2 2844 	ldr.w	r2, [r2, #2116]	; 0x844
        if (available_applets[index].id & 0x80) {
    a1dc:	2628      	movs	r6, #40	; 0x28
        index += dir;
    a1de:	440a      	add	r2, r1
        if (index >= HEMISPHERE_AVAILABLE_APPLETS) index = 0;
    a1e0:	2a32      	cmp	r2, #50	; 0x32
    a1e2:	dc11      	bgt.n	a208 <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x6c>
        if (index < 0) index = HEMISPHERE_AVAILABLE_APPLETS - 1;
    a1e4:	2a00      	cmp	r2, #0
    a1e6:	bfb8      	it	lt
    a1e8:	2232      	movlt	r2, #50	; 0x32
        if (available_applets[index].id & 0x80) {
    a1ea:	fb06 3002 	mla	r0, r6, r2, r3
    a1ee:	6a40      	ldr	r0, [r0, #36]	; 0x24
    a1f0:	0600      	lsls	r0, r0, #24
    a1f2:	d504      	bpl.n	a1fe <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x62>
            if (midi_in_hemisphere == (1 - select_mode)) {
    a1f4:	fab4 f084 	clz	r0, r4
    a1f8:	0940      	lsrs	r0, r0, #5
    a1fa:	4285      	cmp	r5, r0
    a1fc:	d0ef      	beq.n	a1de <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x42>
            SetApplet(select_mode, index);
    a1fe:	4808      	ldr	r0, [pc, #32]	; (a220 <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x84>)
    a200:	4621      	mov	r1, r4
    a202:	f7ff ff9f 	bl	a144 <HemisphereManager::SetApplet(int, int)>
}
    a206:	bd70      	pop	{r4, r5, r6, pc}
        if (index >= HEMISPHERE_AVAILABLE_APPLETS) index = 0;
    a208:	2200      	movs	r2, #0
    a20a:	e7ee      	b.n	a1ea <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x4e>
            int index = my_applet[h];
    a20c:	eb03 0280 	add.w	r2, r3, r0, lsl #2
            available_applets[index].OnEncoderMove(h, event.value);
    a210:	2428      	movs	r4, #40	; 0x28
    a212:	f8d2 2844 	ldr.w	r2, [r2, #2116]	; 0x844
    a216:	fb04 3302 	mla	r3, r4, r2, r3
    a21a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    a21c:	e7c9      	b.n	a1b2 <HEMISPHERE_handleEncoderEvent(UI::Event const&)+0x16>
    a21e:	bf00      	nop
    a220:	200051b8 	.word	0x200051b8

0000a224 <HemisphereManager::DrawViews()>:
    void DrawViews() {
    a224:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
        if (clock_setup) {
    a228:	f890 5850 	ldrb.w	r5, [r0, #2128]	; 0x850
    void DrawViews() {
    a22c:	4604      	mov	r4, r0
        if (clock_setup) {
    a22e:	b135      	cbz	r5, a23e <HemisphereManager::DrawViews()+0x1a>
            ClockSetup.View(LEFT_HEMISPHERE);
    a230:	f8d0 382c 	ldr.w	r3, [r0, #2092]	; 0x82c
    a234:	2000      	movs	r0, #0
    }
    a236:	b003      	add	sp, #12
    a238:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            available_applets[index].View(help_hemisphere);
    a23c:	4718      	bx	r3
        } else if (help_hemisphere > -1) {
    a23e:	f8d0 3854 	ldr.w	r3, [r0, #2132]	; 0x854
    a242:	2b00      	cmp	r3, #0
    a244:	db0d      	blt.n	a262 <HemisphereManager::DrawViews()+0x3e>
            int index = my_applet[help_hemisphere];
    a246:	eb00 0383 	add.w	r3, r0, r3, lsl #2
            available_applets[index].View(help_hemisphere);
    a24a:	f04f 0228 	mov.w	r2, #40	; 0x28
    a24e:	f8d3 3844 	ldr.w	r3, [r3, #2116]	; 0x844
    a252:	fb02 0303 	mla	r3, r2, r3, r0
    a256:	bf18      	it	ne
    a258:	2001      	movne	r0, #1
    a25a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    a25c:	bf08      	it	eq
    a25e:	2000      	moveq	r0, #0
    a260:	e7e9      	b.n	a236 <HemisphereManager::DrawViews()+0x12>
                        graphics.drawBitmap8(56, 1, 8, clock_m->Cycle() ? METRO_L_ICON : METRO_R_ICON);
    a262:	f8df 8084 	ldr.w	r8, [pc, #132]	; a2e8 <HemisphereManager::DrawViews()+0xc4>
    a266:	f8df 9084 	ldr.w	r9, [pc, #132]	; a2ec <HemisphereManager::DrawViews()+0xc8>
    a26a:	4e21      	ldr	r6, [pc, #132]	; (a2f0 <HemisphereManager::DrawViews()+0xcc>)
    a26c:	f500 6704 	add.w	r7, r0, #2112	; 0x840
                available_applets[index].View(h);
    a270:	f857 3f04 	ldr.w	r3, [r7, #4]!
    a274:	2228      	movs	r2, #40	; 0x28
    a276:	fb02 4303 	mla	r3, r2, r3, r4
    a27a:	4628      	mov	r0, r5
    a27c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    a27e:	4798      	blx	r3
                if (h == 0) {
    a280:	b9d5      	cbnz	r5, a2b8 <HemisphereManager::DrawViews()+0x94>
                    if (clock_m->IsRunning() || clock_m->IsPaused()) {
    a282:	f8d4 5864 	ldr.w	r5, [r4, #2148]	; 0x864
    a286:	4628      	mov	r0, r5
    a288:	f7fd fe28 	bl	7edc <ClockManager::IsRunning()>
    a28c:	b908      	cbnz	r0, a292 <HemisphereManager::DrawViews()+0x6e>
    a28e:	7c6b      	ldrb	r3, [r5, #17]
    a290:	b16b      	cbz	r3, a2ae <HemisphereManager::DrawViews()+0x8a>
                        graphics.drawBitmap8(56, 1, 8, clock_m->Cycle() ? METRO_L_ICON : METRO_R_ICON);
    a292:	7cea      	ldrb	r2, [r5, #19]
    a294:	2a00      	cmp	r2, #0
    a296:	bf14      	ite	ne
    a298:	4643      	movne	r3, r8
    a29a:	464b      	moveq	r3, r9
                        graphics.drawBitmap8(56, 1, 8, CLOCK_ICON);
    a29c:	9300      	str	r3, [sp, #0]
    a29e:	2201      	movs	r2, #1
    a2a0:	2308      	movs	r3, #8
    a2a2:	2138      	movs	r1, #56	; 0x38
    a2a4:	4630      	mov	r0, r6
    a2a6:	f00f f9cd 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
    a2aa:	2501      	movs	r5, #1
    a2ac:	e7e0      	b.n	a270 <HemisphereManager::DrawViews()+0x4c>
                    } else if (clock_m->IsForwarded()) {
    a2ae:	7d6b      	ldrb	r3, [r5, #21]
    a2b0:	2b00      	cmp	r3, #0
    a2b2:	d0fa      	beq.n	a2aa <HemisphereManager::DrawViews()+0x86>
                        graphics.drawBitmap8(56, 1, 8, CLOCK_ICON);
    a2b4:	4b0f      	ldr	r3, [pc, #60]	; (a2f4 <HemisphereManager::DrawViews()+0xd0>)
    a2b6:	e7f1      	b.n	a29c <HemisphereManager::DrawViews()+0x78>
            if (select_mode == LEFT_HEMISPHERE) graphics.drawFrame(0, 0, 64, 64);
    a2b8:	f8d4 284c 	ldr.w	r2, [r4, #2124]	; 0x84c
    a2bc:	b92a      	cbnz	r2, a2ca <HemisphereManager::DrawViews()+0xa6>
    a2be:	2340      	movs	r3, #64	; 0x40
    a2c0:	480b      	ldr	r0, [pc, #44]	; (a2f0 <HemisphereManager::DrawViews()+0xcc>)
    a2c2:	9300      	str	r3, [sp, #0]
    a2c4:	4611      	mov	r1, r2
    a2c6:	f00f f998 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
            if (select_mode == RIGHT_HEMISPHERE) graphics.drawFrame(64, 0, 64, 64);
    a2ca:	f8d4 384c 	ldr.w	r3, [r4, #2124]	; 0x84c
    a2ce:	2b01      	cmp	r3, #1
    a2d0:	d106      	bne.n	a2e0 <HemisphereManager::DrawViews()+0xbc>
    a2d2:	2340      	movs	r3, #64	; 0x40
    a2d4:	4806      	ldr	r0, [pc, #24]	; (a2f0 <HemisphereManager::DrawViews()+0xcc>)
    a2d6:	9300      	str	r3, [sp, #0]
    a2d8:	2200      	movs	r2, #0
    a2da:	4619      	mov	r1, r3
    a2dc:	f00f f98d 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
    }
    a2e0:	b003      	add	sp, #12
    a2e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    a2e6:	bf00      	nop
    a2e8:	00023cf0 	.word	0x00023cf0
    a2ec:	00023cf8 	.word	0x00023cf8
    a2f0:	200065e0 	.word	0x200065e0
    a2f4:	00023c28 	.word	0x00023c28

0000a2f8 <HEMISPHERE_menu()>:
void HEMISPHERE_menu() {
    a2f8:	b508      	push	{r3, lr}
    manager.DrawViews();
    a2fa:	4802      	ldr	r0, [pc, #8]	; (a304 <HEMISPHERE_menu()+0xc>)
    a2fc:	f7ff ff92 	bl	a224 <HemisphereManager::DrawViews()>
}
    a300:	bd08      	pop	{r3, pc}
    a302:	bf00      	nop
    a304:	200051b8 	.word	0x200051b8

0000a308 <HemisphereManager::SetHelpScreen(int)>:
    void SetHelpScreen(int hemisphere) {
    a308:	b538      	push	{r3, r4, r5, lr}
        if (help_hemisphere > -1) { // Turn off the previous help screen
    a30a:	f8d0 3854 	ldr.w	r3, [r0, #2132]	; 0x854
    a30e:	2b00      	cmp	r3, #0
    void SetHelpScreen(int hemisphere) {
    a310:	4604      	mov	r4, r0
    a312:	460d      	mov	r5, r1
        if (help_hemisphere > -1) { // Turn off the previous help screen
    a314:	db0d      	blt.n	a332 <HemisphereManager::SetHelpScreen(int)+0x2a>
            int index = my_applet[help_hemisphere];
    a316:	eb00 0383 	add.w	r3, r0, r3, lsl #2
            available_applets[index].ToggleHelpScreen(help_hemisphere);
    a31a:	f04f 0228 	mov.w	r2, #40	; 0x28
    a31e:	f8d3 3844 	ldr.w	r3, [r3, #2116]	; 0x844
    a322:	fb02 0303 	mla	r3, r2, r3, r0
    a326:	bf18      	it	ne
    a328:	2001      	movne	r0, #1
    a32a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a32c:	bf08      	it	eq
    a32e:	2000      	moveq	r0, #0
    a330:	4798      	blx	r3
        if (hemisphere > -1) { // Turn on the next hemisphere's screen
    a332:	2d00      	cmp	r5, #0
    a334:	db0d      	blt.n	a352 <HemisphereManager::SetHelpScreen(int)+0x4a>
            int index = my_applet[hemisphere];
    a336:	eb04 0385 	add.w	r3, r4, r5, lsl #2
            available_applets[index].ToggleHelpScreen(hemisphere);
    a33a:	f04f 0228 	mov.w	r2, #40	; 0x28
    a33e:	f8d3 3844 	ldr.w	r3, [r3, #2116]	; 0x844
    a342:	fb02 4303 	mla	r3, r2, r3, r4
    a346:	bf18      	it	ne
    a348:	2001      	movne	r0, #1
    a34a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a34c:	bf08      	it	eq
    a34e:	2000      	moveq	r0, #0
    a350:	4798      	blx	r3
        help_hemisphere = hemisphere;
    a352:	f8c4 5854 	str.w	r5, [r4, #2132]	; 0x854
    }
    a356:	bd38      	pop	{r3, r4, r5, pc}

0000a358 <HEMISPHERE_handleButtonEvent(UI::Event const&)>:
    if (event.type == UI::EVENT_BUTTON_PRESS) {
    a358:	7803      	ldrb	r3, [r0, #0]
    a35a:	2b01      	cmp	r3, #1
void HEMISPHERE_handleButtonEvent(const UI::Event &event) {
    a35c:	b570      	push	{r4, r5, r6, lr}
    a35e:	4606      	mov	r6, r0
    if (event.type == UI::EVENT_BUTTON_PRESS) {
    a360:	d122      	bne.n	a3a8 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x50>
        if (event.control == OC::CONTROL_BUTTON_UP || event.control == OC::CONTROL_BUTTON_DOWN) {
    a362:	8845      	ldrh	r5, [r0, #2]
    a364:	4c41      	ldr	r4, [pc, #260]	; (a46c <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x114>)
    a366:	1e6b      	subs	r3, r5, #1
    a368:	2b01      	cmp	r3, #1
    a36a:	d84b      	bhi.n	a404 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xac>
        if (OC::CORE::ticks - click_tick < HEMISPHERE_DOUBLE_CLICK_TIME && hemisphere == first_click) {
    a36c:	4a40      	ldr	r2, [pc, #256]	; (a470 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x118>)
    a36e:	f8d4 185c 	ldr.w	r1, [r4, #2140]	; 0x85c
    a372:	6813      	ldr	r3, [r2, #0]
            int hemisphere = (event.control == OC::CONTROL_BUTTON_UP) ? LEFT_HEMISPHERE : RIGHT_HEMISPHERE;
    a374:	3d01      	subs	r5, #1
        if (OC::CORE::ticks - click_tick < HEMISPHERE_DOUBLE_CLICK_TIME && hemisphere == first_click) {
    a376:	eba3 0301 	sub.w	r3, r3, r1
            int hemisphere = (event.control == OC::CONTROL_BUTTON_UP) ? LEFT_HEMISPHERE : RIGHT_HEMISPHERE;
    a37a:	bf18      	it	ne
    a37c:	2501      	movne	r5, #1
        if (OC::CORE::ticks - click_tick < HEMISPHERE_DOUBLE_CLICK_TIME && hemisphere == first_click) {
    a37e:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
    a382:	d21f      	bcs.n	a3c4 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x6c>
    a384:	f8d4 3860 	ldr.w	r3, [r4, #2144]	; 0x860
    a388:	429d      	cmp	r5, r3
    a38a:	d11b      	bne.n	a3c4 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x6c>
            SetHelpScreen(hemisphere);
    a38c:	4629      	mov	r1, r5
    a38e:	4620      	mov	r0, r4
    a390:	f7ff ffba 	bl	a308 <HemisphereManager::SetHelpScreen(int)>
            select_mode = -1;
    a394:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    a398:	f8c4 384c 	str.w	r3, [r4, #2124]	; 0x84c
            click_tick = 0;
    a39c:	2300      	movs	r3, #0
    a39e:	f8c4 385c 	str.w	r3, [r4, #2140]	; 0x85c
        clock_setup = 0; // Turn off clock setup with any button press
    a3a2:	2300      	movs	r3, #0
    a3a4:	f884 3850 	strb.w	r3, [r4, #2128]	; 0x850
    if (event.type == UI::EVENT_BUTTON_LONG_PRESS) {
    a3a8:	7833      	ldrb	r3, [r6, #0]
    a3aa:	2b02      	cmp	r3, #2
    a3ac:	d13d      	bne.n	a42a <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xd2>
    a3ae:	8873      	ldrh	r3, [r6, #2]
        if (event.control == OC::CONTROL_BUTTON_DOWN) manager.ToggleClockSetup();
    a3b0:	2b02      	cmp	r3, #2
    a3b2:	d144      	bne.n	a43e <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xe6>
        clock_setup = 1 - clock_setup;
    a3b4:	4a2d      	ldr	r2, [pc, #180]	; (a46c <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x114>)
    a3b6:	f892 3850 	ldrb.w	r3, [r2, #2128]	; 0x850
    a3ba:	f083 0301 	eor.w	r3, r3, #1
    a3be:	f882 3850 	strb.w	r3, [r2, #2128]	; 0x850
        if (event.control == OC::CONTROL_BUTTON_L) manager.ToggleClockRun();
    a3c2:	e032      	b.n	a42a <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xd2>
            if (help_hemisphere > -1) {
    a3c4:	f8d4 3854 	ldr.w	r3, [r4, #2132]	; 0x854
    a3c8:	2b00      	cmp	r3, #0
    a3ca:	db0a      	blt.n	a3e2 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x8a>
                if (help_hemisphere != hemisphere) SetHelpScreen(hemisphere);
    a3cc:	429d      	cmp	r5, r3
                else SetHelpScreen(-1); // Leave help screen if corresponding button is clicked
    a3ce:	4827      	ldr	r0, [pc, #156]	; (a46c <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x114>)
                if (help_hemisphere != hemisphere) SetHelpScreen(hemisphere);
    a3d0:	bf14      	ite	ne
    a3d2:	4629      	movne	r1, r5
                else SetHelpScreen(-1); // Leave help screen if corresponding button is clicked
    a3d4:	f04f 31ff 	moveq.w	r1, #4294967295	; 0xffffffff
    a3d8:	f7ff ff96 	bl	a308 <HemisphereManager::SetHelpScreen(int)>
            first_click = hemisphere;
    a3dc:	f8c4 5860 	str.w	r5, [r4, #2144]	; 0x860
    a3e0:	e7df      	b.n	a3a2 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x4a>
            } else if (!clock_setup) {
    a3e2:	f894 3850 	ldrb.w	r3, [r4, #2128]	; 0x850
    a3e6:	2b00      	cmp	r3, #0
    a3e8:	d1f8      	bne.n	a3dc <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x84>
                if (hemisphere == select_mode) select_mode = -1; // Leave Select Mode is same button is pressed
    a3ea:	f8d4 184c 	ldr.w	r1, [r4, #2124]	; 0x84c
    a3ee:	428d      	cmp	r5, r1
    a3f0:	bf14      	ite	ne
    a3f2:	462b      	movne	r3, r5
    a3f4:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    a3f8:	f8c4 384c 	str.w	r3, [r4, #2124]	; 0x84c
                click_tick = OC::CORE::ticks;
    a3fc:	6813      	ldr	r3, [r2, #0]
    a3fe:	f8c4 385c 	str.w	r3, [r4, #2140]	; 0x85c
    a402:	e7eb      	b.n	a3dc <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x84>
        if (clock_setup) {
    a404:	f894 3850 	ldrb.w	r3, [r4, #2128]	; 0x850
    a408:	b123      	cbz	r3, a414 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xbc>
            ClockSetup.OnButtonPress(LEFT_HEMISPHERE);
    a40a:	f8d4 3830 	ldr.w	r3, [r4, #2096]	; 0x830
    a40e:	2000      	movs	r0, #0
                available_applets[index].OnButtonPress(h);
    a410:	4798      	blx	r3
    a412:	e7c9      	b.n	a3a8 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x50>
        int h = (event.control == OC::CONTROL_BUTTON_L) ? LEFT_HEMISPHERE : RIGHT_HEMISPHERE;
    a414:	1f28      	subs	r0, r5, #4
        } else if (select_mode == h) {
    a416:	f8d4 384c 	ldr.w	r3, [r4, #2124]	; 0x84c
        int h = (event.control == OC::CONTROL_BUTTON_L) ? LEFT_HEMISPHERE : RIGHT_HEMISPHERE;
    a41a:	bf18      	it	ne
    a41c:	2001      	movne	r0, #1
        } else if (select_mode == h) {
    a41e:	4298      	cmp	r0, r3
    a420:	d104      	bne.n	a42c <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xd4>
            select_mode = -1; // Pushing a button for the selected side turns off select mode
    a422:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    a426:	f8c4 384c 	str.w	r3, [r4, #2124]	; 0x84c
}
    a42a:	bd70      	pop	{r4, r5, r6, pc}
            int index = my_applet[h];
    a42c:	eb04 0380 	add.w	r3, r4, r0, lsl #2
                available_applets[index].OnButtonPress(h);
    a430:	2228      	movs	r2, #40	; 0x28
    a432:	f8d3 3844 	ldr.w	r3, [r3, #2116]	; 0x844
    a436:	fb02 4403 	mla	r4, r2, r3, r4
    a43a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    a43c:	e7e8      	b.n	a410 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xb8>
        if (event.control == OC::CONTROL_BUTTON_L) manager.ToggleClockRun();
    a43e:	2b04      	cmp	r3, #4
    a440:	d1f3      	bne.n	a42a <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xd2>
    a442:	4b0a      	ldr	r3, [pc, #40]	; (a46c <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x114>)
    a444:	f8d3 4864 	ldr.w	r4, [r3, #2148]	; 0x864
        if (clock_m->IsRunning()) clock_m->Pause();
    a448:	4620      	mov	r0, r4
    a44a:	f7fd fd47 	bl	7edc <ClockManager::IsRunning()>
    a44e:	b110      	cbz	r0, a456 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xfe>
    void Pause() {paused = 1;}
    a450:	2301      	movs	r3, #1
    a452:	7463      	strb	r3, [r4, #17]
    a454:	e7e9      	b.n	a42a <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xd2>
        else if (clock_m->IsPaused()) clock_m->Start();
    a456:	7c63      	ldrb	r3, [r4, #17]
    a458:	b11b      	cbz	r3, a462 <HEMISPHERE_handleButtonEvent(UI::Event const&)+0x10a>
        running = 1;
    a45a:	2301      	movs	r3, #1
        forwarded = 0;
    a45c:	7560      	strb	r0, [r4, #21]
        running = 1;
    a45e:	8223      	strh	r3, [r4, #16]
    }
    a460:	e7e3      	b.n	a42a <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xd2>
    void ToggleForwarding() {forwarded = 1 - forwarded;}
    a462:	7d63      	ldrb	r3, [r4, #21]
    a464:	f083 0301 	eor.w	r3, r3, #1
    a468:	7563      	strb	r3, [r4, #21]
}
    a46a:	e7de      	b.n	a42a <HEMISPHERE_handleButtonEvent(UI::Event const&)+0xd2>
    a46c:	200051b8 	.word	0x200051b8
    a470:	200046cc 	.word	0x200046cc

0000a474 <HemisphereManager::RequestAppletData()>:
    void RequestAppletData() {
    a474:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            uint32_t data = available_applets[index].OnDataRequest(h);
    a476:	f8d0 3844 	ldr.w	r3, [r0, #2116]	; 0x844
    a47a:	2728      	movs	r7, #40	; 0x28
    a47c:	fb07 0303 	mla	r3, r7, r3, r0
    void RequestAppletData() {
    a480:	4604      	mov	r4, r0
            uint32_t data = available_applets[index].OnDataRequest(h);
    a482:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    a484:	2000      	movs	r0, #0
    a486:	4798      	blx	r3
            apply_value(2 + h, data & 0xffff);
    a488:	f104 0608 	add.w	r6, r4, #8
            uint32_t data = available_applets[index].OnDataRequest(h);
    a48c:	4605      	mov	r5, r0
            apply_value(2 + h, data & 0xffff);
    a48e:	b282      	uxth	r2, r0
    a490:	2102      	movs	r1, #2
    a492:	4630      	mov	r0, r6
    a494:	f7fa fc70 	bl	4d78 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]>
            apply_value(4 + h, (data >> 16) & 0xffff);
    a498:	0c2a      	lsrs	r2, r5, #16
    a49a:	2104      	movs	r1, #4
    a49c:	f7fa fc6c 	bl	4d78 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]>
            uint32_t data = available_applets[index].OnDataRequest(h);
    a4a0:	f8d4 3848 	ldr.w	r3, [r4, #2120]	; 0x848
    a4a4:	fb07 4403 	mla	r4, r7, r3, r4
    a4a8:	2001      	movs	r0, #1
    a4aa:	6c63      	ldr	r3, [r4, #68]	; 0x44
    a4ac:	4798      	blx	r3
            apply_value(2 + h, data & 0xffff);
    a4ae:	2103      	movs	r1, #3
            uint32_t data = available_applets[index].OnDataRequest(h);
    a4b0:	4604      	mov	r4, r0
            apply_value(2 + h, data & 0xffff);
    a4b2:	b282      	uxth	r2, r0
    a4b4:	4630      	mov	r0, r6
    a4b6:	f7fa fc5f 	bl	4d78 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]>
            apply_value(4 + h, (data >> 16) & 0xffff);
    a4ba:	0c22      	lsrs	r2, r4, #16
    a4bc:	2105      	movs	r1, #5
    }
    a4be:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            apply_value(4 + h, (data >> 16) & 0xffff);
    a4c2:	f7fa bc59 	b.w	4d78 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]>

0000a4c6 <HemisphereManager::OnSendSysEx()>:
    void OnSendSysEx() {
    a4c6:	b5f0      	push	{r4, r5, r6, r7, lr}
    a4c8:	4606      	mov	r6, r0
    a4ca:	b0b3      	sub	sp, #204	; 0xcc
        RequestAppletData();
    a4cc:	f7ff ffd2 	bl	a474 <HemisphereManager::RequestAppletData()>
        V[0] = (uint8_t)values_[HEMISPHERE_SELECTED_LEFT_ID];
    a4d0:	68b3      	ldr	r3, [r6, #8]
    a4d2:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
        V[1] = (uint8_t)values_[HEMISPHERE_SELECTED_RIGHT_ID];
    a4d6:	68f3      	ldr	r3, [r6, #12]
    a4d8:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
        V[2] = (uint8_t)(values_[HEMISPHERE_LEFT_DATA_L] & 0xff);
    a4dc:	8a33      	ldrh	r3, [r6, #16]
    a4de:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
        V[4] = (uint8_t)(values_[HEMISPHERE_RIGHT_DATA_L] & 0xff);
    a4e2:	8ab3      	ldrh	r3, [r6, #20]
    a4e4:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
        V[6] = (uint8_t)(values_[HEMISPHERE_LEFT_DATA_H] & 0xff);
    a4e8:	8b33      	ldrh	r3, [r6, #24]
    a4ea:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
        unpacked.set_data(10, V);
    a4ee:	aa0f      	add	r2, sp, #60	; 0x3c
        V[8] = (uint8_t)(values_[HEMISPHERE_RIGHT_DATA_H] & 0xff);
    a4f0:	8bb3      	ldrh	r3, [r6, #28]
    a4f2:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
        unpacked.set_data(10, V);
    a4f6:	a812      	add	r0, sp, #72	; 0x48
        PackedData packed = unpacked.pack();
    a4f8:	af22      	add	r7, sp, #136	; 0x88
        unpacked.set_data(10, V);
    a4fa:	210a      	movs	r1, #10
    a4fc:	f7fa fe24 	bl	5148 <_SysExData::set_data(int, unsigned char*)>
        PackedData packed = unpacked.pack();
    a500:	a912      	add	r1, sp, #72	; 0x48
    a502:	4638      	mov	r0, r7
    a504:	f7fa fe2c 	bl	5160 <_SysExData::pack()>
        SendSysEx(packed, 'H');
    a508:	2348      	movs	r3, #72	; 0x48
    a50a:	930d      	str	r3, [sp, #52]	; 0x34
    a50c:	ad25      	add	r5, sp, #148	; 0x94
    a50e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    a510:	466c      	mov	r4, sp
    a512:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    a514:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    a516:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    a518:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    a51a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    a51c:	682b      	ldr	r3, [r5, #0]
    a51e:	6023      	str	r3, [r4, #0]
    a520:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
    a524:	4630      	mov	r0, r6
    a526:	f7fa fe97 	bl	5258 <SystemExclusiveHandler::SendSysEx(_SysExData, char)>
    }
    a52a:	b033      	add	sp, #204	; 0xcc
    a52c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a52e:	Address 0x000000000000a52e is out of bounds.


0000a530 <HEMISPHERE_handleAppEvent(OC::AppEvent)>:
void HEMISPHERE_handleAppEvent(OC::AppEvent event) {
    a530:	b508      	push	{r3, lr}
    if (event == OC::APP_EVENT_SUSPEND) {
    a532:	b910      	cbnz	r0, a53a <HEMISPHERE_handleAppEvent(OC::AppEvent)+0xa>
        manager.OnSendSysEx();
    a534:	4801      	ldr	r0, [pc, #4]	; (a53c <HEMISPHERE_handleAppEvent(OC::AppEvent)+0xc>)
    a536:	f7ff ffc6 	bl	a4c6 <HemisphereManager::OnSendSysEx()>
}
    a53a:	bd08      	pop	{r3, pc}
    a53c:	200051b8 	.word	0x200051b8

0000a540 <HemisphereManager::get_applet_index_by_id(int)>:
        for (int i = 0; i < HEMISPHERE_AVAILABLE_APPLETS; i++)
    a540:	2300      	movs	r3, #0
    int get_applet_index_by_id(int id) {
    a542:	b530      	push	{r4, r5, lr}
        int index = 0;
    a544:	461a      	mov	r2, r3
            if (available_applets[i].id == id) index = i;
    a546:	3024      	adds	r0, #36	; 0x24
    a548:	2528      	movs	r5, #40	; 0x28
    a54a:	fb05 f403 	mul.w	r4, r5, r3
    a54e:	5904      	ldr	r4, [r0, r4]
    a550:	428c      	cmp	r4, r1
    a552:	bf08      	it	eq
    a554:	461a      	moveq	r2, r3
        for (int i = 0; i < HEMISPHERE_AVAILABLE_APPLETS; i++)
    a556:	3301      	adds	r3, #1
    a558:	2b33      	cmp	r3, #51	; 0x33
    a55a:	d1f6      	bne.n	a54a <HemisphereManager::get_applet_index_by_id(int)+0xa>
    }
    a55c:	4610      	mov	r0, r2
    a55e:	bd30      	pop	{r4, r5, pc}

0000a560 <HemisphereManager::Resume()>:
    void Resume() {
    a560:	b570      	push	{r4, r5, r6, lr}
            int index = get_applet_index_by_id(values_[h]);
    a562:	6881      	ldr	r1, [r0, #8]
    void Resume() {
    a564:	4604      	mov	r4, r0
            int index = get_applet_index_by_id(values_[h]);
    a566:	f7ff ffeb 	bl	a540 <HemisphereManager::get_applet_index_by_id(int)>
            available_applets[index].OnDataReceive(h, data);
    a56a:	2628      	movs	r6, #40	; 0x28
            SetApplet(h, index);
    a56c:	4602      	mov	r2, r0
            int index = get_applet_index_by_id(values_[h]);
    a56e:	4605      	mov	r5, r0
            SetApplet(h, index);
    a570:	2100      	movs	r1, #0
    a572:	4620      	mov	r0, r4
    a574:	f7ff fde6 	bl	a144 <HemisphereManager::SetApplet(int, int)>
            available_applets[index].OnDataReceive(h, data);
    a578:	fb06 4505 	mla	r5, r6, r5, r4
            uint32_t data = (values_[4 + h] << 16) + values_[2 + h];
    a57c:	6922      	ldr	r2, [r4, #16]
    a57e:	69a1      	ldr	r1, [r4, #24]
            available_applets[index].OnDataReceive(h, data);
    a580:	6cab      	ldr	r3, [r5, #72]	; 0x48
    a582:	eb02 4101 	add.w	r1, r2, r1, lsl #16
    a586:	2000      	movs	r0, #0
    a588:	4798      	blx	r3
            int index = get_applet_index_by_id(values_[h]);
    a58a:	68e1      	ldr	r1, [r4, #12]
    a58c:	4620      	mov	r0, r4
    a58e:	f7ff ffd7 	bl	a540 <HemisphereManager::get_applet_index_by_id(int)>
            SetApplet(h, index);
    a592:	2101      	movs	r1, #1
            int index = get_applet_index_by_id(values_[h]);
    a594:	4605      	mov	r5, r0
            SetApplet(h, index);
    a596:	4602      	mov	r2, r0
    a598:	4620      	mov	r0, r4
    a59a:	f7ff fdd3 	bl	a144 <HemisphereManager::SetApplet(int, int)>
            uint32_t data = (values_[4 + h] << 16) + values_[2 + h];
    a59e:	69e1      	ldr	r1, [r4, #28]
    a5a0:	6962      	ldr	r2, [r4, #20]
            available_applets[index].OnDataReceive(h, data);
    a5a2:	fb06 4405 	mla	r4, r6, r5, r4
    a5a6:	eb02 4101 	add.w	r1, r2, r1, lsl #16
    a5aa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    a5ac:	2001      	movs	r0, #1
    }
    a5ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            available_applets[index].OnDataReceive(h, data);
    a5b2:	4718      	bx	r3

0000a5b4 <HemisphereManager::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    a5b4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
        if (ExtractSysExData(V, 'H')) {
    a5b6:	2248      	movs	r2, #72	; 0x48
    a5b8:	a901      	add	r1, sp, #4
    void OnReceiveSysEx() {
    a5ba:	4604      	mov	r4, r0
        if (ExtractSysExData(V, 'H')) {
    a5bc:	f7fb f8a0 	bl	5700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>
    a5c0:	b320      	cbz	r0, a60c <HemisphereManager::OnReceiveSysEx()+0x58>
            values_[HEMISPHERE_SELECTED_LEFT_ID] = V[0];
    a5c2:	f89d 3004 	ldrb.w	r3, [sp, #4]
    a5c6:	60a3      	str	r3, [r4, #8]
            values_[HEMISPHERE_SELECTED_RIGHT_ID] = V[1];
    a5c8:	f89d 3005 	ldrb.w	r3, [sp, #5]
            values_[HEMISPHERE_LEFT_DATA_L] = ((uint16_t)V[3] << 8) + V[2];
    a5cc:	f89d 2007 	ldrb.w	r2, [sp, #7]
            values_[HEMISPHERE_SELECTED_RIGHT_ID] = V[1];
    a5d0:	60e3      	str	r3, [r4, #12]
            values_[HEMISPHERE_LEFT_DATA_L] = ((uint16_t)V[3] << 8) + V[2];
    a5d2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a5d6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
    a5da:	6123      	str	r3, [r4, #16]
            values_[HEMISPHERE_RIGHT_DATA_L] = ((uint16_t)V[5] << 8) + V[4];
    a5dc:	f89d 2009 	ldrb.w	r2, [sp, #9]
    a5e0:	f89d 3008 	ldrb.w	r3, [sp, #8]
    a5e4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
    a5e8:	6163      	str	r3, [r4, #20]
            values_[HEMISPHERE_LEFT_DATA_H] = ((uint16_t)V[7] << 8) + V[6];
    a5ea:	f89d 200b 	ldrb.w	r2, [sp, #11]
    a5ee:	f89d 300a 	ldrb.w	r3, [sp, #10]
    a5f2:	eb03 2302 	add.w	r3, r3, r2, lsl #8
    a5f6:	61a3      	str	r3, [r4, #24]
            values_[HEMISPHERE_RIGHT_DATA_H] = ((uint16_t)V[9] << 8) + V[8];
    a5f8:	f89d 200d 	ldrb.w	r2, [sp, #13]
    a5fc:	f89d 300c 	ldrb.w	r3, [sp, #12]
    a600:	eb03 2302 	add.w	r3, r3, r2, lsl #8
    a604:	61e3      	str	r3, [r4, #28]
            Resume();
    a606:	4620      	mov	r0, r4
    a608:	f7ff ffaa 	bl	a560 <HemisphereManager::Resume()>
    }
    a60c:	b004      	add	sp, #16
    a60e:	bd10      	pop	{r4, pc}

0000a610 <HemisphereManager::Init()>:
    void Init() {
    a610:	b5f0      	push	{r4, r5, r6, r7, lr}
        Applet applets[] = HEMISPHERE_APPLETS;
    a612:	4c1f      	ldr	r4, [pc, #124]	; (a690 <HemisphereManager::Init()+0x80>)
    void Init() {
    a614:	f2ad 7dfc 	subw	sp, sp, #2044	; 0x7fc
        select_mode = -1; // Not selecting
    a618:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
        Applet applets[] = HEMISPHERE_APPLETS;
    a61c:	f44f 65ff 	mov.w	r5, #2040	; 0x7f8
    void Init() {
    a620:	4606      	mov	r6, r0
        select_mode = -1; // Not selecting
    a622:	f8c0 784c 	str.w	r7, [r0, #2124]	; 0x84c
        midi_in_hemisphere = -1; // No MIDI In
    a626:	f8c0 7858 	str.w	r7, [r0, #2136]	; 0x858
        Applet applets[] = HEMISPHERE_APPLETS;
    a62a:	462a      	mov	r2, r5
    a62c:	f104 0190 	add.w	r1, r4, #144	; 0x90
    a630:	4668      	mov	r0, sp
    a632:	f00f fcdd 	bl	19ff0 <memcpy>
        ClockSetup = DECLARE_APPLET(9999, 0x01, ClockSetup);
    a636:	f604 0488 	addw	r4, r4, #2184	; 0x888
        memcpy(&available_applets, &applets, sizeof(applets));
    a63a:	462a      	mov	r2, r5
    a63c:	4669      	mov	r1, sp
    a63e:	f106 0024 	add.w	r0, r6, #36	; 0x24
    a642:	f00f fcd5 	bl	19ff0 <memcpy>
        ClockSetup = DECLARE_APPLET(9999, 0x01, ClockSetup);
    a646:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    a648:	f606 051c 	addw	r5, r6, #2076	; 0x81c
    a64c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    a64e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    a650:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    a652:	e894 0003 	ldmia.w	r4, {r0, r1}
        clock_setup = 0;
    a656:	2400      	movs	r4, #0
        ClockSetup = DECLARE_APPLET(9999, 0x01, ClockSetup);
    a658:	e885 0003 	stmia.w	r5, {r0, r1}
        help_hemisphere = -1;
    a65c:	f8c6 7854 	str.w	r7, [r6, #2132]	; 0x854
        clock_setup = 0;
    a660:	f886 4850 	strb.w	r4, [r6, #2128]	; 0x850
        SetApplet(0, get_applet_index_by_id(8)); // ADSR
    a664:	2108      	movs	r1, #8
    a666:	4630      	mov	r0, r6
    a668:	f7ff ff6a 	bl	a540 <HemisphereManager::get_applet_index_by_id(int)>
    a66c:	4621      	mov	r1, r4
    a66e:	4602      	mov	r2, r0
    a670:	4630      	mov	r0, r6
    a672:	f7ff fd67 	bl	a144 <HemisphereManager::SetApplet(int, int)>
        SetApplet(1, get_applet_index_by_id(26)); // Scale Duet
    a676:	211a      	movs	r1, #26
    a678:	4630      	mov	r0, r6
    a67a:	f7ff ff61 	bl	a540 <HemisphereManager::get_applet_index_by_id(int)>
    a67e:	2101      	movs	r1, #1
    a680:	4602      	mov	r2, r0
    a682:	4630      	mov	r0, r6
    a684:	f7ff fd5e 	bl	a144 <HemisphereManager::SetApplet(int, int)>
    }
    a688:	f20d 7dfc 	addw	sp, sp, #2044	; 0x7fc
    a68c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a68e:	bf00      	nop
    a690:	0002256c 	.word	0x0002256c

0000a694 <HEMISPHERE_init()>:
void HEMISPHERE_init() {
    a694:	b508      	push	{r3, lr}
    manager.Init();
    a696:	4802      	ldr	r0, [pc, #8]	; (a6a0 <HEMISPHERE_init()+0xc>)
    a698:	f7ff ffba 	bl	a610 <HemisphereManager::Init()>
}
    a69c:	bd08      	pop	{r3, pc}
    a69e:	bf00      	nop
    a6a0:	200051b8 	.word	0x200051b8

0000a6a4 <ReceiveManagerSysEx()>:
void ReceiveManagerSysEx() {
    a6a4:	b508      	push	{r3, lr}
    manager.OnReceiveSysEx();
    a6a6:	4802      	ldr	r0, [pc, #8]	; (a6b0 <ReceiveManagerSysEx()+0xc>)
    a6a8:	f7ff ff84 	bl	a5b4 <HemisphereManager::OnReceiveSysEx()>
}
    a6ac:	bd08      	pop	{r3, pc}
    a6ae:	bf00      	nop
    a6b0:	200051b8 	.word	0x200051b8

0000a6b4 <CaptainMIDILog::DrawAt(int)>:
    void DrawAt(int y) {
    a6b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (message == 5) {
    a6b6:	7883      	ldrb	r3, [r0, #2]
    a6b8:	2b05      	cmp	r3, #5
    void DrawAt(int y) {
    a6ba:	4604      	mov	r4, r0
    a6bc:	460e      	mov	r6, r1
        if (message == 5) {
    a6be:	d133      	bne.n	a728 <CaptainMIDILog::DrawAt(int)+0x74>
            int app_code = static_cast<char>(data1);
    a6c0:	7904      	ldrb	r4, [r0, #4]
            if (app_code > 0) {
    a6c2:	b164      	cbz	r4, a6de <CaptainMIDILog::DrawAt(int)+0x2a>
  text_x_ = x;
    a6c4:	485c      	ldr	r0, [pc, #368]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a6c6:	2301      	movs	r3, #1
  text_y_ = y;
    a6c8:	6081      	str	r1, [r0, #8]
                graphics.print("SysEx: ");
    a6ca:	495c      	ldr	r1, [pc, #368]	; (a83c <CaptainMIDILog::DrawAt(int)+0x188>)
  text_x_ = x;
    a6cc:	6043      	str	r3, [r0, #4]
    a6ce:	f00f fa02 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                if (app_code == 'M') graphics.print("Captain MIDI");
    a6d2:	2c4d      	cmp	r4, #77	; 0x4d
    a6d4:	4858      	ldr	r0, [pc, #352]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a6d6:	d103      	bne.n	a6e0 <CaptainMIDILog::DrawAt(int)+0x2c>
    a6d8:	4959      	ldr	r1, [pc, #356]	; (a840 <CaptainMIDILog::DrawAt(int)+0x18c>)
                if (app_code == 'W') graphics.print("Waveform Ed");
    a6da:	f00f f9fc 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    }
    a6de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                if (app_code == 'H') graphics.print("Hemisphere");
    a6e0:	2c48      	cmp	r4, #72	; 0x48
    a6e2:	d101      	bne.n	a6e8 <CaptainMIDILog::DrawAt(int)+0x34>
    a6e4:	4957      	ldr	r1, [pc, #348]	; (a844 <CaptainMIDILog::DrawAt(int)+0x190>)
    a6e6:	e7f8      	b.n	a6da <CaptainMIDILog::DrawAt(int)+0x26>
                if (app_code == 'D') graphics.print("D. Timeline");
    a6e8:	2c44      	cmp	r4, #68	; 0x44
    a6ea:	d101      	bne.n	a6f0 <CaptainMIDILog::DrawAt(int)+0x3c>
    a6ec:	4956      	ldr	r1, [pc, #344]	; (a848 <CaptainMIDILog::DrawAt(int)+0x194>)
    a6ee:	e7f4      	b.n	a6da <CaptainMIDILog::DrawAt(int)+0x26>
                if (app_code == 'E') graphics.print("Scale Ed");
    a6f0:	2c45      	cmp	r4, #69	; 0x45
    a6f2:	d101      	bne.n	a6f8 <CaptainMIDILog::DrawAt(int)+0x44>
    a6f4:	4955      	ldr	r1, [pc, #340]	; (a84c <CaptainMIDILog::DrawAt(int)+0x198>)
    a6f6:	e7f0      	b.n	a6da <CaptainMIDILog::DrawAt(int)+0x26>
                if (app_code == 'T') graphics.print("Enigma");
    a6f8:	2c54      	cmp	r4, #84	; 0x54
    a6fa:	d101      	bne.n	a700 <CaptainMIDILog::DrawAt(int)+0x4c>
    a6fc:	4954      	ldr	r1, [pc, #336]	; (a850 <CaptainMIDILog::DrawAt(int)+0x19c>)
    a6fe:	e7ec      	b.n	a6da <CaptainMIDILog::DrawAt(int)+0x26>
                if (app_code == 'W') graphics.print("Waveform Ed");
    a700:	2c57      	cmp	r4, #87	; 0x57
    a702:	d101      	bne.n	a708 <CaptainMIDILog::DrawAt(int)+0x54>
    a704:	4953      	ldr	r1, [pc, #332]	; (a854 <CaptainMIDILog::DrawAt(int)+0x1a0>)
    a706:	e7e8      	b.n	a6da <CaptainMIDILog::DrawAt(int)+0x26>
                if (app_code == '_') graphics.print("O_C EEPROM");
    a708:	2c5f      	cmp	r4, #95	; 0x5f
    a70a:	d104      	bne.n	a716 <CaptainMIDILog::DrawAt(int)+0x62>
    a70c:	4952      	ldr	r1, [pc, #328]	; (a858 <CaptainMIDILog::DrawAt(int)+0x1a4>)
    }
    a70e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                if (app_code == 'B') graphics.print("Backup");
    a712:	f00f b9e0 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    a716:	2c42      	cmp	r4, #66	; 0x42
    a718:	d102      	bne.n	a720 <CaptainMIDILog::DrawAt(int)+0x6c>
    a71a:	4950      	ldr	r1, [pc, #320]	; (a85c <CaptainMIDILog::DrawAt(int)+0x1a8>)
    a71c:	4846      	ldr	r0, [pc, #280]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a71e:	e7f6      	b.n	a70e <CaptainMIDILog::DrawAt(int)+0x5a>
                if (app_code == 'N') graphics.print("Neural Net");
    a720:	2c4e      	cmp	r4, #78	; 0x4e
    a722:	d1dc      	bne.n	a6de <CaptainMIDILog::DrawAt(int)+0x2a>
    a724:	494e      	ldr	r1, [pc, #312]	; (a860 <CaptainMIDILog::DrawAt(int)+0x1ac>)
    a726:	e7f9      	b.n	a71c <CaptainMIDILog::DrawAt(int)+0x68>
    a728:	4d43      	ldr	r5, [pc, #268]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a72a:	2301      	movs	r3, #1
    a72c:	606b      	str	r3, [r5, #4]
            if (midi_in) graphics.print(">");
    a72e:	7803      	ldrb	r3, [r0, #0]
  text_y_ = y;
    a730:	60a9      	str	r1, [r5, #8]
    a732:	b11b      	cbz	r3, a73c <CaptainMIDILog::DrawAt(int)+0x88>
    a734:	494b      	ldr	r1, [pc, #300]	; (a864 <CaptainMIDILog::DrawAt(int)+0x1b0>)
    a736:	4628      	mov	r0, r5
    a738:	f00f f9cd 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.print(io);
    a73c:	7861      	ldrb	r1, [r4, #1]
    a73e:	483e      	ldr	r0, [pc, #248]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a740:	f00f f994 	bl	19a6c <weegfx::Graphics::print(char)>
            if (!midi_in) graphics.print(">");
    a744:	7823      	ldrb	r3, [r4, #0]
    a746:	b91b      	cbnz	r3, a750 <CaptainMIDILog::DrawAt(int)+0x9c>
    a748:	4946      	ldr	r1, [pc, #280]	; (a864 <CaptainMIDILog::DrawAt(int)+0x1b0>)
    a74a:	483b      	ldr	r0, [pc, #236]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a74c:	f00f f9c3 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.print(" ");
    a750:	4945      	ldr	r1, [pc, #276]	; (a868 <CaptainMIDILog::DrawAt(int)+0x1b4>)
    a752:	4839      	ldr	r0, [pc, #228]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a754:	f00f f9bf 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.print(midi_channels[channel]);
    a758:	78e2      	ldrb	r2, [r4, #3]
    a75a:	4b44      	ldr	r3, [pc, #272]	; (a86c <CaptainMIDILog::DrawAt(int)+0x1b8>)
    a75c:	4836      	ldr	r0, [pc, #216]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a75e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    a762:	f00f f9b8 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    a766:	2325      	movs	r3, #37	; 0x25
    a768:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    a76a:	60ae      	str	r6, [r5, #8]
            graphics.print(midi_messages[message]);
    a76c:	4b40      	ldr	r3, [pc, #256]	; (a870 <CaptainMIDILog::DrawAt(int)+0x1bc>)
    a76e:	78a2      	ldrb	r2, [r4, #2]
    a770:	4831      	ldr	r0, [pc, #196]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a772:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    a776:	f00f f9ae 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    a77a:	2349      	movs	r3, #73	; 0x49
    a77c:	606b      	str	r3, [r5, #4]
            uint8_t x_offset = (data2 < 100) ? 6 : 0;
    a77e:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
  text_y_ = y;
    a782:	60ae      	str	r6, [r5, #8]
    a784:	2b63      	cmp	r3, #99	; 0x63
    a786:	dc53      	bgt.n	a830 <CaptainMIDILog::DrawAt(int)+0x17c>
            x_offset += (data2 < 10) ? 6 : 0;
    a788:	2b09      	cmp	r3, #9
            uint8_t x_offset = (data2 < 100) ? 6 : 0;
    a78a:	f04f 0206 	mov.w	r2, #6
            x_offset += (data2 < 10) ? 6 : 0;
    a78e:	dd51      	ble.n	a834 <CaptainMIDILog::DrawAt(int)+0x180>
    a790:	2300      	movs	r3, #0
    a792:	189f      	adds	r7, r3, r2
            if (message == 0 || message == 1) {
    a794:	78a3      	ldrb	r3, [r4, #2]
    a796:	2b01      	cmp	r3, #1
    a798:	d811      	bhi.n	a7be <CaptainMIDILog::DrawAt(int)+0x10a>
                graphics.print(midi_note_numbers[data1]);
    a79a:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
    a79e:	4b35      	ldr	r3, [pc, #212]	; (a874 <CaptainMIDILog::DrawAt(int)+0x1c0>)
    a7a0:	4825      	ldr	r0, [pc, #148]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a7a2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    a7a6:	f00f f996 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                graphics.setPrintPos(91 + x_offset, y);
    a7aa:	f107 025b 	add.w	r2, r7, #91	; 0x5b
    a7ae:	b2d2      	uxtb	r2, r2
                graphics.print(data2); // Velocity
    a7b0:	f9b4 1006 	ldrsh.w	r1, [r4, #6]
    a7b4:	4820      	ldr	r0, [pc, #128]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
                graphics.setPrintPos(91 + x_offset, y);
    a7b6:	606a      	str	r2, [r5, #4]
    a7b8:	60ae      	str	r6, [r5, #8]
                graphics.print(data2); // Velocity
    a7ba:	f00f fa00 	bl	19bbe <weegfx::Graphics::print(int)>
            if (message == 2 || message == 3) {
    a7be:	78a3      	ldrb	r3, [r4, #2]
    a7c0:	1e9a      	subs	r2, r3, #2
    a7c2:	2a01      	cmp	r2, #1
    a7c4:	d810      	bhi.n	a7e8 <CaptainMIDILog::DrawAt(int)+0x134>
                if (message == 2) graphics.print(data1); // Controller number
    a7c6:	2b02      	cmp	r3, #2
    a7c8:	d104      	bne.n	a7d4 <CaptainMIDILog::DrawAt(int)+0x120>
    a7ca:	f9b4 1004 	ldrsh.w	r1, [r4, #4]
    a7ce:	481a      	ldr	r0, [pc, #104]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a7d0:	f00f f9f5 	bl	19bbe <weegfx::Graphics::print(int)>
                graphics.setPrintPos(91 + x_offset, y);
    a7d4:	f107 035b 	add.w	r3, r7, #91	; 0x5b
    a7d8:	b2db      	uxtb	r3, r3
                graphics.print(data2); // Value
    a7da:	f9b4 1006 	ldrsh.w	r1, [r4, #6]
    a7de:	4816      	ldr	r0, [pc, #88]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
                graphics.setPrintPos(91 + x_offset, y);
    a7e0:	606b      	str	r3, [r5, #4]
    a7e2:	60ae      	str	r6, [r5, #8]
                graphics.print(data2); // Value
    a7e4:	f00f f9eb 	bl	19bbe <weegfx::Graphics::print(int)>
            if (message == 4) {
    a7e8:	78a3      	ldrb	r3, [r4, #2]
    a7ea:	2b04      	cmp	r3, #4
    a7ec:	d10c      	bne.n	a808 <CaptainMIDILog::DrawAt(int)+0x154>
                if (data2 > 0) graphics.print("+");
    a7ee:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
    a7f2:	2b00      	cmp	r3, #0
    a7f4:	dd03      	ble.n	a7fe <CaptainMIDILog::DrawAt(int)+0x14a>
    a7f6:	4920      	ldr	r1, [pc, #128]	; (a878 <CaptainMIDILog::DrawAt(int)+0x1c4>)
    a7f8:	480f      	ldr	r0, [pc, #60]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a7fa:	f00f f96c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                graphics.print(data2); // Aftertouch or bend value
    a7fe:	f9b4 1006 	ldrsh.w	r1, [r4, #6]
    a802:	480d      	ldr	r0, [pc, #52]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a804:	f00f f9db 	bl	19bbe <weegfx::Graphics::print(int)>
            if (message == 6) {
    a808:	78a3      	ldrb	r3, [r4, #2]
    a80a:	2b06      	cmp	r3, #6
    a80c:	f47f af67 	bne.w	a6de <CaptainMIDILog::DrawAt(int)+0x2a>
                graphics.print(data1);
    a810:	f9b4 1004 	ldrsh.w	r1, [r4, #4]
    a814:	4808      	ldr	r0, [pc, #32]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a816:	f00f f9d2 	bl	19bbe <weegfx::Graphics::print(int)>
                graphics.print("/");
    a81a:	4918      	ldr	r1, [pc, #96]	; (a87c <CaptainMIDILog::DrawAt(int)+0x1c8>)
    a81c:	4806      	ldr	r0, [pc, #24]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    a81e:	f00f f95a 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                graphics.print(data2);
    a822:	f9b4 1006 	ldrsh.w	r1, [r4, #6]
    a826:	4804      	ldr	r0, [pc, #16]	; (a838 <CaptainMIDILog::DrawAt(int)+0x184>)
    }
    a828:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                graphics.print(data2);
    a82c:	f00f b9c7 	b.w	19bbe <weegfx::Graphics::print(int)>
            uint8_t x_offset = (data2 < 100) ? 6 : 0;
    a830:	2200      	movs	r2, #0
    a832:	e7ad      	b.n	a790 <CaptainMIDILog::DrawAt(int)+0xdc>
            x_offset += (data2 < 10) ? 6 : 0;
    a834:	4613      	mov	r3, r2
    a836:	e7ac      	b.n	a792 <CaptainMIDILog::DrawAt(int)+0xde>
    a838:	200065e0 	.word	0x200065e0
    a83c:	00021076 	.word	0x00021076
    a840:	0002107e 	.word	0x0002107e
    a844:	0002108b 	.word	0x0002108b
    a848:	00021096 	.word	0x00021096
    a84c:	000210a2 	.word	0x000210a2
    a850:	000210ab 	.word	0x000210ab
    a854:	000210b2 	.word	0x000210b2
    a858:	000210be 	.word	0x000210be
    a85c:	000210c9 	.word	0x000210c9
    a860:	000210d0 	.word	0x000210d0
    a864:	00020fec 	.word	0x00020fec
    a868:	000211c7 	.word	0x000211c7
    a86c:	00023e60 	.word	0x00023e60
    a870:	00023ea4 	.word	0x00023ea4
    a874:	00023f34 	.word	0x00023f34
    a878:	0001e41c 	.word	0x0001e41c
    a87c:	00021018 	.word	0x00021018

0000a880 <CaptainMIDI::Reset()>:
    void Reset() {
    a880:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        for (int ch = 0; ch < 4; ch++)
    a884:	2500      	movs	r5, #0
    void Reset() {
    a886:	4604      	mov	r4, r0
    a888:	f500 67cc 	add.w	r7, r0, #1632	; 0x660
    a88c:	f200 6672 	addw	r6, r0, #1650	; 0x672
            note_in[ch] = -1;
    a890:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
            indicator_in[ch] = 0;
    a894:	46a8      	mov	r8, r5
            Out(ch, 0);
    a896:	f100 0a08 	add.w	sl, r0, #8
            note_in[ch] = -1;
    a89a:	f847 9f04 	str.w	r9, [r7, #4]!
            note_out[ch] = -1;
    a89e:	f8c7 9020 	str.w	r9, [r7, #32]
            indicator_in[ch] = 0;
    a8a2:	f826 8f02 	strh.w	r8, [r6, #2]!
            Out(ch, 0);
    a8a6:	2300      	movs	r3, #0
    a8a8:	4629      	mov	r1, r5
            indicator_out[ch] = 0;
    a8aa:	f8a6 8040 	strh.w	r8, [r6, #64]	; 0x40
            Out(ch, 0);
    a8ae:	461a      	mov	r2, r3
    a8b0:	4650      	mov	r0, sl
        for (int ch = 0; ch < 4; ch++)
    a8b2:	3501      	adds	r5, #1
            Out(ch, 0);
    a8b4:	f7fb f98a 	bl	5bcc <HSApplication::Out(int, int, int)>
        for (int ch = 0; ch < 4; ch++)
    a8b8:	2d04      	cmp	r5, #4
    a8ba:	d1ee      	bne.n	a89a <CaptainMIDI::Reset()+0x1a>
        clock_count = 0;
    a8bc:	f04f 0300 	mov.w	r3, #0
    a8c0:	f884 367c 	strb.w	r3, [r4, #1660]	; 0x67c
    }
    a8c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000a8c8 <CaptainMIDI::Start()>:
    void Start() {
    a8c8:	b538      	push	{r3, r4, r5, lr}
    end_ = end;
    a8ca:	2207      	movs	r2, #7
        screen = 0;
    a8cc:	2300      	movs	r3, #0
    void Start() {
    a8ce:	4604      	mov	r4, r0
    a8d0:	f8c0 2318 	str.w	r2, [r0, #792]	; 0x318
        screen = 0;
    a8d4:	f8c0 3324 	str.w	r3, [r0, #804]	; 0x324
        display = 0;
    a8d8:	f880 3328 	strb.w	r3, [r0, #808]	; 0x328
    editing_ = false;
    a8dc:	f880 3310 	strb.w	r3, [r0, #784]	; 0x310
    start_ = start;
    a8e0:	f8c0 3314 	str.w	r3, [r0, #788]	; 0x314
    cursor_pos_ = start;
    a8e4:	f8c0 331c 	str.w	r3, [r0, #796]	; 0x31c
    screen_line_ = 0;
    a8e8:	f8c0 3320 	str.w	r3, [r0, #800]	; 0x320
        log_index = 0;
    a8ec:	f8c0 365c 	str.w	r3, [r0, #1628]	; 0x65c
        log_view = 0;
    a8f0:	f8c0 3660 	str.w	r3, [r0, #1632]	; 0x660
        Reset();
    a8f4:	f7ff ffc4 	bl	a880 <CaptainMIDI::Reset()>
        for (int s = 0; s < 4; s++)
    a8f8:	f504 7482 	add.w	r4, r4, #260	; 0x104
        Reset();
    a8fc:	2220      	movs	r2, #32
                if (values_[s * MIDI_PARAMETER_COUNT + 32 + p] == 0) values_[s * MIDI_PARAMETER_COUNT + 32 + p] = 127;
    a8fe:	207f      	movs	r0, #127	; 0x7f
    void Start() {
    a900:	4623      	mov	r3, r4
            for (int p = 0; p < 8; p++)
    a902:	f104 0120 	add.w	r1, r4, #32
                if (values_[s * MIDI_PARAMETER_COUNT + 32 + p] == 0) values_[s * MIDI_PARAMETER_COUNT + 32 + p] = 127;
    a906:	f853 5f04 	ldr.w	r5, [r3, #4]!
    a90a:	b905      	cbnz	r5, a90e <CaptainMIDI::Start()+0x46>
    a90c:	6018      	str	r0, [r3, #0]
            for (int p = 0; p < 8; p++)
    a90e:	428b      	cmp	r3, r1
    a910:	d1f9      	bne.n	a906 <CaptainMIDI::Start()+0x3e>
        for (int s = 0; s < 4; s++)
    a912:	3228      	adds	r2, #40	; 0x28
    a914:	2ac0      	cmp	r2, #192	; 0xc0
    a916:	f104 04a0 	add.w	r4, r4, #160	; 0xa0
    a91a:	d1f1      	bne.n	a900 <CaptainMIDI::Start()+0x38>
	}
    a91c:	bd38      	pop	{r3, r4, r5, pc}

0000a91e <non-virtual thunk to CaptainMIDI::Start()>:
    void Start() {
    a91e:	f1a0 0008 	sub.w	r0, r0, #8
    a922:	e7d1      	b.n	a8c8 <CaptainMIDI::Start()>

0000a924 <MIDI_init()>:
void MIDI_init() {
    a924:	b508      	push	{r3, lr}
    captain_midi_instance.Start();
    a926:	4802      	ldr	r0, [pc, #8]	; (a930 <MIDI_init()+0xc>)
    a928:	f7ff ffce 	bl	a8c8 <CaptainMIDI::Start()>
}
    a92c:	bd08      	pop	{r3, pc}
    a92e:	bf00      	nop
    a930:	200046ec 	.word	0x200046ec

0000a934 <CaptainMIDI::DrawSetupScreens()>:
    void DrawSetupScreens() {
    a934:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a938:	4604      	mov	r4, r0
        gfxHeader("");
    a93a:	49b6      	ldr	r1, [pc, #728]	; (ac14 <CaptainMIDI::DrawSetupScreens()+0x2e0>)
    void DrawSetupScreens() {
    a93c:	b08f      	sub	sp, #60	; 0x3c
        gfxHeader("");
    a93e:	3008      	adds	r0, #8
    a940:	f7fb fa20 	bl	5d84 <HSApplication::gfxHeader(char const*)>
        if (screen == 0) graphics.print("MIDI Assign");
    a944:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
    a948:	b91b      	cbnz	r3, a952 <CaptainMIDI::DrawSetupScreens()+0x1e>
    a94a:	49b3      	ldr	r1, [pc, #716]	; (ac18 <CaptainMIDI::DrawSetupScreens()+0x2e4>)
    a94c:	48b3      	ldr	r0, [pc, #716]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
    a94e:	f00f f8c2 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (screen == 1) graphics.print("MIDI Channel");
    a952:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
    a956:	2b01      	cmp	r3, #1
    a958:	d103      	bne.n	a962 <CaptainMIDI::DrawSetupScreens()+0x2e>
    a95a:	49b1      	ldr	r1, [pc, #708]	; (ac20 <CaptainMIDI::DrawSetupScreens()+0x2ec>)
    a95c:	48af      	ldr	r0, [pc, #700]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
    a95e:	f00f f8ba 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (screen == 2) graphics.print("Transpose");
    a962:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
    a966:	2b02      	cmp	r3, #2
    a968:	d103      	bne.n	a972 <CaptainMIDI::DrawSetupScreens()+0x3e>
    a96a:	49ae      	ldr	r1, [pc, #696]	; (ac24 <CaptainMIDI::DrawSetupScreens()+0x2f0>)
    a96c:	48ab      	ldr	r0, [pc, #684]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
    a96e:	f00f f8b2 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (screen == 3) graphics.print("Range Low");
    a972:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
    a976:	2b03      	cmp	r3, #3
    a978:	d103      	bne.n	a982 <CaptainMIDI::DrawSetupScreens()+0x4e>
    a97a:	49ab      	ldr	r1, [pc, #684]	; (ac28 <CaptainMIDI::DrawSetupScreens()+0x2f4>)
    a97c:	48a7      	ldr	r0, [pc, #668]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
    a97e:	f00f f8aa 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (screen == 4) graphics.print("Range High");
    a982:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
    a986:	2b04      	cmp	r3, #4
    a988:	d103      	bne.n	a992 <CaptainMIDI::DrawSetupScreens()+0x5e>
    a98a:	49a8      	ldr	r1, [pc, #672]	; (ac2c <CaptainMIDI::DrawSetupScreens()+0x2f8>)
    a98c:	48a3      	ldr	r0, [pc, #652]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
    a98e:	f00f f8a2 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    a992:	4da2      	ldr	r5, [pc, #648]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
        graphics.print(str);
    a994:	49a6      	ldr	r1, [pc, #664]	; (ac30 <CaptainMIDI::DrawSetupScreens()+0x2fc>)
    a996:	2356      	movs	r3, #86	; 0x56
    a998:	606b      	str	r3, [r5, #4]
    a99a:	4628      	mov	r0, r5
  text_y_ = y;
    a99c:	2301      	movs	r3, #1
    a99e:	60ab      	str	r3, [r5, #8]
    a9a0:	f00f f899 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(get_setup_number() + 1);
    a9a4:	f8d4 1308 	ldr.w	r1, [r4, #776]	; 0x308
        graphics.print(num);
    a9a8:	4628      	mov	r0, r5
    a9aa:	3101      	adds	r1, #1
    a9ac:	f00f f907 	bl	19bbe <weegfx::Graphics::print(int)>
template <int screen_lines, weegfx::coord_t start_x, weegfx::coord_t value_x, weegfx::coord_t end_x = kDefaultMenuEndX>
class SettingsList {
public:

  SettingsList(const ScreenCursor<screen_lines> &cursor)
  : cursor_(cursor)
    a9b0:	f8d4 b31c 	ldr.w	fp, [r4, #796]	; 0x31c
    return cursor_pos_ - screen_line_;
    a9b4:	f8d4 7320 	ldr.w	r7, [r4, #800]	; 0x320
  : cursor_(cursor)
    a9b8:	f894 3310 	ldrb.w	r3, [r4, #784]	; 0x310
    a9bc:	9307      	str	r3, [sp, #28]
    return cursor_pos_ - screen_line_;
    a9be:	ebab 0707 	sub.w	r7, fp, r7
    return cursor_pos_ - screen_line_ + screen_lines - 1;
    a9c2:	1cfb      	adds	r3, r7, #3
    a9c4:	9306      	str	r3, [sp, #24]
  SettingsListItem() { }
    a9c6:	4b9b      	ldr	r3, [pc, #620]	; (ac34 <CaptainMIDI::DrawSetupScreens()+0x300>)
    a9c8:	2218      	movs	r2, #24
    a9ca:	fb02 3907 	mla	r9, r2, r7, r3
    a9ce:	f04f 0811 	mov.w	r8, #17
    a9d2:	f1a8 0302 	sub.w	r3, r8, #2
    a9d6:	9305      	str	r3, [sp, #20]
        while (settings_list.available())
    a9d8:	9b06      	ldr	r3, [sp, #24]
    a9da:	42bb      	cmp	r3, r7
    a9dc:	da02      	bge.n	a9e4 <CaptainMIDI::DrawSetupScreens()+0xb0>
    }
    a9de:	b00f      	add	sp, #60	; 0x3c
    a9e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  bool available() const {
    return current_item_ <= last_item_;
  }

  int Next(SettingsListItem &item) {
    item.selected = current_item_ == cursor_.cursor_pos();
    a9e4:	45bb      	cmp	fp, r7
    a9e6:	bf0c      	ite	eq
    a9e8:	2301      	moveq	r3, #1
    a9ea:	2300      	movne	r3, #0
    a9ec:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    item.editing = item.selected && cursor_.editing();
    a9f0:	9b07      	ldr	r3, [sp, #28]
    a9f2:	bf18      	it	ne
    a9f4:	2300      	movne	r3, #0
    a9f6:	9303      	str	r3, [sp, #12]
    a9f8:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
    item.x = start_x;
    a9fc:	2300      	movs	r3, #0
    a9fe:	930a      	str	r3, [sp, #40]	; 0x28
    item.y = y_;
    aa00:	9b05      	ldr	r3, [sp, #20]
    aa02:	930b      	str	r3, [sp, #44]	; 0x2c
    item.valuex = value_x;
    aa04:	235f      	movs	r3, #95	; 0x5f
    aa06:	930c      	str	r3, [sp, #48]	; 0x30
    item.endx = end_x;
    aa08:	237e      	movs	r3, #126	; 0x7e
    aa0a:	930d      	str	r3, [sp, #52]	; 0x34
    return values_[index];
    aa0c:	f104 0388 	add.w	r3, r4, #136	; 0x88
            int p = current % 8; // Menu position from 0-7
    aa10:	f007 0607 	and.w	r6, r7, #7
    aa14:	f853 a027 	ldr.w	sl, [r3, r7, lsl #2]
    aa18:	427b      	negs	r3, r7
    aa1a:	f003 0307 	and.w	r3, r3, #7
    aa1e:	bf58      	it	pl
    aa20:	425e      	negpl	r6, r3
            if (p < 4) { // It's a MIDI In assignment
    aa22:	2e03      	cmp	r6, #3
    aa24:	f8d4 3308 	ldr.w	r3, [r4, #776]	; 0x308
    aa28:	dc71      	bgt.n	ab0e <CaptainMIDI::DrawSetupScreens()+0x1da>
                if (indicator_in[p] > 0 || note_in[p] > -1) {
    aa2a:	eb04 0246 	add.w	r2, r4, r6, lsl #1
    aa2e:	f8b2 2674 	ldrh.w	r2, [r2, #1652]	; 0x674
    aa32:	b92a      	cbnz	r2, aa40 <CaptainMIDI::DrawSetupScreens()+0x10c>
    aa34:	eb04 0286 	add.w	r2, r4, r6, lsl #2
    aa38:	f8d2 2664 	ldr.w	r2, [r2, #1636]	; 0x664
    aa3c:	2a00      	cmp	r2, #0
    aa3e:	db17      	blt.n	aa70 <CaptainMIDI::DrawSetupScreens()+0x13c>
        return values_[ch + setup_offset];
    aa40:	2228      	movs	r2, #40	; 0x28
    aa42:	fb02 6303 	mla	r3, r2, r3, r6
    aa46:	3322      	adds	r3, #34	; 0x22
                    if (get_in_assign(p) == MIDI_IN_NOTE) {
    aa48:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    aa4c:	2b01      	cmp	r3, #1
    aa4e:	d14e      	bne.n	aaee <CaptainMIDI::DrawSetupScreens()+0x1ba>
                        if (note_in[p] > -1) {
    aa50:	eb04 0386 	add.w	r3, r4, r6, lsl #2
    aa54:	f8d3 3664 	ldr.w	r3, [r3, #1636]	; 0x664
    aa58:	2b00      	cmp	r3, #0
    aa5a:	db09      	blt.n	aa70 <CaptainMIDI::DrawSetupScreens()+0x13c>
  text_x_ = x;
    aa5c:	2246      	movs	r2, #70	; 0x46
    aa5e:	606a      	str	r2, [r5, #4]
                            graphics.print(midi_note_numbers[note_in[p]]);
    aa60:	4a75      	ldr	r2, [pc, #468]	; (ac38 <CaptainMIDI::DrawSetupScreens()+0x304>)
    aa62:	486e      	ldr	r0, [pc, #440]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
    aa64:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
  text_y_ = y;
    aa68:	f8c5 8008 	str.w	r8, [r5, #8]
    aa6c:	f00f f833 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        int setup_offset = get_setup_number() * MIDI_PARAMETER_COUNT;
    aa70:	f8d4 3308 	ldr.w	r3, [r4, #776]	; 0x308
        return values_[8 + ch + setup_offset];
    aa74:	2228      	movs	r2, #40	; 0x28
    aa76:	fb02 6303 	mla	r3, r2, r3, r6
    aa7a:	f103 022a 	add.w	r2, r3, #42	; 0x2a
                if (get_in_channel(p) > 0 && get_in_assign(p) == MIDI_IN_NOTE)
    aa7e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
    aa82:	2a00      	cmp	r2, #0
    aa84:	dd3c      	ble.n	ab00 <CaptainMIDI::DrawSetupScreens()+0x1cc>
        return values_[ch + setup_offset];
    aa86:	3322      	adds	r3, #34	; 0x22
                if (get_in_channel(p) > 0 && get_in_assign(p) == MIDI_IN_NOTE)
    aa88:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    aa8c:	2b01      	cmp	r3, #1
    aa8e:	d137      	bne.n	ab00 <CaptainMIDI::DrawSetupScreens()+0x1cc>
                    graphics.drawBitmap8(56, list_item.y + 1, 8, MIDI_note_icon);
    aa90:	4b6a      	ldr	r3, [pc, #424]	; (ac3c <CaptainMIDI::DrawSetupScreens()+0x308>)
    aa92:	9300      	str	r3, [sp, #0]
    aa94:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
    aa98:	2308      	movs	r3, #8
    aa9a:	2138      	movs	r1, #56	; 0x38
    aa9c:	4628      	mov	r0, r5
    aa9e:	f00e fdd1 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
            bool suppress = 0; // Don't show the setting if it's not relevant
    aaa2:	2300      	movs	r3, #0
                else if (screen > 1) suppress = 1;
    aaa4:	9304      	str	r3, [sp, #16]
        int setup_offset = get_setup_number() * MIDI_PARAMETER_COUNT;
    aaa6:	f8d4 3308 	ldr.w	r3, [r4, #776]	; 0x308
        return values_[ch + setup_offset];
    aaaa:	2228      	movs	r2, #40	; 0x28
    aaac:	fb02 6303 	mla	r3, r2, r3, r6
    aab0:	3322      	adds	r3, #34	; 0x22
                if (get_in_assign(p) >= MIDI_IN_CLOCK_4TH) {
    aab2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    aab6:	2b0c      	cmp	r3, #12
    aab8:	dd14      	ble.n	aae4 <CaptainMIDI::DrawSetupScreens()+0x1b0>
                    uint8_t o_x = (clock_count < 12) ? 2 : 0;
    aaba:	f894 167c 	ldrb.w	r1, [r4, #1660]	; 0x67c
                    graphics.drawBitmap8(80 + o_x, list_item.y + 1, 8, MIDI_clock_icon);
    aabe:	4b60      	ldr	r3, [pc, #384]	; (ac40 <CaptainMIDI::DrawSetupScreens()+0x30c>)
    aac0:	9300      	str	r3, [sp, #0]
                    uint8_t o_x = (clock_count < 12) ? 2 : 0;
    aac2:	290b      	cmp	r1, #11
    aac4:	bf8c      	ite	hi
    aac6:	2100      	movhi	r1, #0
    aac8:	2101      	movls	r1, #1
    aaca:	0049      	lsls	r1, r1, #1
                    graphics.drawBitmap8(80 + o_x, list_item.y + 1, 8, MIDI_clock_icon);
    aacc:	2308      	movs	r3, #8
    aace:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
    aad2:	3150      	adds	r1, #80	; 0x50
    aad4:	4628      	mov	r0, r5
    aad6:	f00e fdb5 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
                    if (screen > 0) suppress = 1;
    aada:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
    aade:	2b00      	cmp	r3, #0
    aae0:	f300 80b8 	bgt.w	ac54 <CaptainMIDI::DrawSetupScreens()+0x320>
            if (!suppress) list_item.DrawDefault(value, CaptainMIDI::value_attr(current));
    aae4:	9b04      	ldr	r3, [sp, #16]
    aae6:	2b00      	cmp	r3, #0
    aae8:	f040 80b4 	bne.w	ac54 <CaptainMIDI::DrawSetupScreens()+0x320>
    aaec:	e046      	b.n	ab7c <CaptainMIDI::DrawSetupScreens()+0x248>
                    } else graphics.drawBitmap8(70, list_item.y + 2, 8, MIDI_midi_icon);
    aaee:	4b55      	ldr	r3, [pc, #340]	; (ac44 <CaptainMIDI::DrawSetupScreens()+0x310>)
    aaf0:	9300      	str	r3, [sp, #0]
    aaf2:	4642      	mov	r2, r8
    aaf4:	2308      	movs	r3, #8
    aaf6:	2146      	movs	r1, #70	; 0x46
    aaf8:	4628      	mov	r0, r5
    aafa:	f00e fda3 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
    aafe:	e7b7      	b.n	aa70 <CaptainMIDI::DrawSetupScreens()+0x13c>
                else if (screen > 1) suppress = 1;
    ab00:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
    ab04:	2b01      	cmp	r3, #1
    ab06:	bfd4      	ite	le
    ab08:	2300      	movle	r3, #0
    ab0a:	2301      	movgt	r3, #1
    ab0c:	e7ca      	b.n	aaa4 <CaptainMIDI::DrawSetupScreens()+0x170>
                if (indicator_out[p] > 0 || note_out[p] > -1) {
    ab0e:	eb04 0146 	add.w	r1, r4, r6, lsl #1
                p -= 4;
    ab12:	1f32      	subs	r2, r6, #4
                if (indicator_out[p] > 0 || note_out[p] > -1) {
    ab14:	f8b1 16ac 	ldrh.w	r1, [r1, #1708]	; 0x6ac
    ab18:	b929      	cbnz	r1, ab26 <CaptainMIDI::DrawSetupScreens()+0x1f2>
    ab1a:	eb04 0186 	add.w	r1, r4, r6, lsl #2
    ab1e:	f8d1 1674 	ldr.w	r1, [r1, #1652]	; 0x674
    ab22:	2900      	cmp	r1, #0
    ab24:	db10      	blt.n	ab48 <CaptainMIDI::DrawSetupScreens()+0x214>
        return values_[4 + ch + setup_offset];
    ab26:	2128      	movs	r1, #40	; 0x28
    ab28:	fb01 6303 	mla	r3, r1, r3, r6
    ab2c:	3322      	adds	r3, #34	; 0x22
                    if ((get_out_assign(p) == MIDI_OUT_NOTE || get_out_assign(p) == MIDI_OUT_LEGATO)) {
    ab2e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    ab32:	3b01      	subs	r3, #1
    ab34:	2b01      	cmp	r3, #1
    ab36:	d95c      	bls.n	abf2 <CaptainMIDI::DrawSetupScreens()+0x2be>
                    } else graphics.drawBitmap8(70, list_item.y + 2, 8, MIDI_midi_icon);
    ab38:	4b42      	ldr	r3, [pc, #264]	; (ac44 <CaptainMIDI::DrawSetupScreens()+0x310>)
    ab3a:	9300      	str	r3, [sp, #0]
    ab3c:	4642      	mov	r2, r8
    ab3e:	2308      	movs	r3, #8
    ab40:	2146      	movs	r1, #70	; 0x46
    ab42:	4628      	mov	r0, r5
    ab44:	f00e fd7e 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
        int setup_offset = get_setup_number() * MIDI_PARAMETER_COUNT;
    ab48:	f8d4 3308 	ldr.w	r3, [r4, #776]	; 0x308
        return values_[12 + ch + setup_offset];
    ab4c:	2228      	movs	r2, #40	; 0x28
    ab4e:	fb02 6603 	mla	r6, r2, r3, r6
    ab52:	f106 032a 	add.w	r3, r6, #42	; 0x2a
                if (get_out_channel(p) > 0 && (get_out_assign(p) == MIDI_OUT_NOTE || get_out_assign(p) == MIDI_OUT_LEGATO))
    ab56:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    ab5a:	2b00      	cmp	r3, #0
    ab5c:	dd76      	ble.n	ac4c <CaptainMIDI::DrawSetupScreens()+0x318>
        return values_[4 + ch + setup_offset];
    ab5e:	3622      	adds	r6, #34	; 0x22
                if (get_out_channel(p) > 0 && (get_out_assign(p) == MIDI_OUT_NOTE || get_out_assign(p) == MIDI_OUT_LEGATO))
    ab60:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
    ab64:	3b01      	subs	r3, #1
    ab66:	2b01      	cmp	r3, #1
    ab68:	d870      	bhi.n	ac4c <CaptainMIDI::DrawSetupScreens()+0x318>
                    graphics.drawBitmap8(56, list_item.y + 1, 8, MIDI_note_icon);
    ab6a:	4b34      	ldr	r3, [pc, #208]	; (ac3c <CaptainMIDI::DrawSetupScreens()+0x308>)
    ab6c:	9300      	str	r3, [sp, #0]
    ab6e:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
    ab72:	2308      	movs	r3, #8
    ab74:	2138      	movs	r1, #56	; 0x38
    ab76:	4628      	mov	r0, r5
    ab78:	f00e fd64 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
  text_x_ = x;
    ab7c:	2302      	movs	r3, #2
    graphics.print(attr.name);
    ab7e:	f8d9 100c 	ldr.w	r1, [r9, #12]
    ab82:	4826      	ldr	r0, [pc, #152]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
    ab84:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    ab86:	f8c5 8008 	str.w	r8, [r5, #8]
    ab8a:	f00e ffa4 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    ab8e:	237e      	movs	r3, #126	; 0x7e
    ab90:	606b      	str	r3, [r5, #4]
    if(attr.value_names)
    ab92:	f8d9 3010 	ldr.w	r3, [r9, #16]
  text_y_ = y;
    ab96:	f8c5 8008 	str.w	r8, [r5, #8]
    ab9a:	2b00      	cmp	r3, #0
    ab9c:	d066      	beq.n	ac6c <CaptainMIDI::DrawSetupScreens()+0x338>
      graphics.print_right(attr.value_names[value]);
    ab9e:	f853 102a 	ldr.w	r1, [r3, sl, lsl #2]
    aba2:	4628      	mov	r0, r5
    aba4:	f00e ffa8 	bl	19af8 <weegfx::Graphics::print_right(char const*)>
    if (editing)
    aba8:	9b03      	ldr	r3, [sp, #12]
    abaa:	b193      	cbz	r3, abd2 <CaptainMIDI::DrawSetupScreens()+0x29e>
  if (value == attr.max_)
    abac:	f8d9 3008 	ldr.w	r3, [r9, #8]
    abb0:	459a      	cmp	sl, r3
    abb2:	d060      	beq.n	ac76 <CaptainMIDI::DrawSetupScreens()+0x342>
    src += OC::kBitmapEditIndicatorW;
    abb4:	4b24      	ldr	r3, [pc, #144]	; (ac48 <CaptainMIDI::DrawSetupScreens()+0x314>)
  else if (value == attr.min_)
    abb6:	f8d9 1004 	ldr.w	r1, [r9, #4]
    src += OC::kBitmapEditIndicatorW;
    abba:	1d5a      	adds	r2, r3, #5
    abbc:	458a      	cmp	sl, r1
    abbe:	bf08      	it	eq
    abc0:	4613      	moveq	r3, r2
  graphics.drawBitmap8(x - 5, y + 1, OC::kBitmapEditIndicatorW, src);
    abc2:	9300      	str	r3, [sp, #0]
    abc4:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
    abc8:	2305      	movs	r3, #5
    abca:	215a      	movs	r1, #90	; 0x5a
    abcc:	4628      	mov	r0, r5
    abce:	f00e fd39 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
    if (selected)
    abd2:	45bb      	cmp	fp, r7
    abd4:	d107      	bne.n	abe6 <CaptainMIDI::DrawSetupScreens()+0x2b2>
      graphics.invertRect(x, y, kDisplayWidth - x, kMenuLineH - 1);
    abd6:	230b      	movs	r3, #11
    abd8:	9300      	str	r3, [sp, #0]
    abda:	9a05      	ldr	r2, [sp, #20]
    abdc:	2380      	movs	r3, #128	; 0x80
    abde:	2100      	movs	r1, #0
    abe0:	4628      	mov	r0, r5
    abe2:	f00e fc1c 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
    abe6:	3701      	adds	r7, #1
    abe8:	f108 080c 	add.w	r8, r8, #12
    abec:	f109 0918 	add.w	r9, r9, #24
    abf0:	e6ef      	b.n	a9d2 <CaptainMIDI::DrawSetupScreens()+0x9e>
                        if (note_out[p] > -1) {
    abf2:	eb04 0382 	add.w	r3, r4, r2, lsl #2
    abf6:	f8d3 3684 	ldr.w	r3, [r3, #1668]	; 0x684
    abfa:	2b00      	cmp	r3, #0
    abfc:	dba4      	blt.n	ab48 <CaptainMIDI::DrawSetupScreens()+0x214>
  text_x_ = x;
    abfe:	2246      	movs	r2, #70	; 0x46
    ac00:	606a      	str	r2, [r5, #4]
                            graphics.print(midi_note_numbers[note_out[p]]);
    ac02:	4a0d      	ldr	r2, [pc, #52]	; (ac38 <CaptainMIDI::DrawSetupScreens()+0x304>)
    ac04:	4805      	ldr	r0, [pc, #20]	; (ac1c <CaptainMIDI::DrawSetupScreens()+0x2e8>)
    ac06:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
  text_y_ = y;
    ac0a:	f8c5 8008 	str.w	r8, [r5, #8]
    ac0e:	f00e ff62 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    ac12:	e799      	b.n	ab48 <CaptainMIDI::DrawSetupScreens()+0x214>
    ac14:	000211c8 	.word	0x000211c8
    ac18:	000210db 	.word	0x000210db
    ac1c:	200065e0 	.word	0x200065e0
    ac20:	000210e7 	.word	0x000210e7
    ac24:	00020ab5 	.word	0x00020ab5
    ac28:	000210f4 	.word	0x000210f4
    ac2c:	000210fe 	.word	0x000210fe
    ac30:	00021109 	.word	0x00021109
    ac34:	00025080 	.word	0x00025080
    ac38:	00023f34 	.word	0x00023f34
    ac3c:	00023ed0 	.word	0x00023ed0
    ac40:	00023ee8 	.word	0x00023ee8
    ac44:	00023ec8 	.word	0x00023ec8
    ac48:	0001dfe8 	.word	0x0001dfe8
                else if (screen > 1) suppress = 1;
    ac4c:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
    ac50:	2b01      	cmp	r3, #1
    ac52:	dd93      	ble.n	ab7c <CaptainMIDI::DrawSetupScreens()+0x248>
  text_x_ = x;
    ac54:	2302      	movs	r3, #2
                graphics.print("                   --");
    ac56:	4909      	ldr	r1, [pc, #36]	; (ac7c <CaptainMIDI::DrawSetupScreens()+0x348>)
    ac58:	4809      	ldr	r0, [pc, #36]	; (ac80 <CaptainMIDI::DrawSetupScreens()+0x34c>)
    ac5a:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    ac5c:	f8c5 8008 	str.w	r8, [r5, #8]
    ac60:	f00e ff39 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                list_item.DrawCustom();
    ac64:	a809      	add	r0, sp, #36	; 0x24
    ac66:	f7fa f9e5 	bl	5034 <OC::menu::SettingsListItem::DrawCustom() const>
    ac6a:	e7bc      	b.n	abe6 <CaptainMIDI::DrawSetupScreens()+0x2b2>
      graphics.pretty_print_right(value);
    ac6c:	4651      	mov	r1, sl
    ac6e:	4628      	mov	r0, r5
    ac70:	f00e ff06 	bl	19a80 <weegfx::Graphics::pretty_print_right(int)>
    ac74:	e798      	b.n	aba8 <CaptainMIDI::DrawSetupScreens()+0x274>
    src += OC::kBitmapEditIndicatorW * 2;
    ac76:	4b03      	ldr	r3, [pc, #12]	; (ac84 <CaptainMIDI::DrawSetupScreens()+0x350>)
    ac78:	e7a3      	b.n	abc2 <CaptainMIDI::DrawSetupScreens()+0x28e>
    ac7a:	bf00      	nop
    ac7c:	00021110 	.word	0x00021110
    ac80:	200065e0 	.word	0x200065e0
    ac84:	0001dff2 	.word	0x0001dff2

0000ac88 <CaptainMIDI::DrawCopyScreen()>:
    void DrawCopyScreen() {
    ac88:	b570      	push	{r4, r5, r6, lr}
  text_x_ = x;
    ac8a:	4c27      	ldr	r4, [pc, #156]	; (ad28 <CaptainMIDI::DrawCopyScreen()+0xa0>)
        gfxHeader("Copy");
    ac8c:	4927      	ldr	r1, [pc, #156]	; (ad2c <CaptainMIDI::DrawCopyScreen()+0xa4>)
    void DrawCopyScreen() {
    ac8e:	4605      	mov	r5, r0
        gfxHeader("Copy");
    ac90:	3008      	adds	r0, #8
    ac92:	f7fb f877 	bl	5d84 <HSApplication::gfxHeader(char const*)>
  text_y_ = y;
    ac96:	261c      	movs	r6, #28
  text_x_ = x;
    ac98:	2308      	movs	r3, #8
        graphics.print("Setup ");
    ac9a:	4925      	ldr	r1, [pc, #148]	; (ad30 <CaptainMIDI::DrawCopyScreen()+0xa8>)
    ac9c:	6063      	str	r3, [r4, #4]
    ac9e:	4620      	mov	r0, r4
  text_y_ = y;
    aca0:	60a6      	str	r6, [r4, #8]
    aca2:	f00e ff18 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(copy_setup_source + 1);
    aca6:	f8d5 132c 	ldr.w	r1, [r5, #812]	; 0x32c
    acaa:	4620      	mov	r0, r4
    acac:	3101      	adds	r1, #1
    acae:	f00e ff86 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(" -");
    acb2:	4920      	ldr	r1, [pc, #128]	; (ad34 <CaptainMIDI::DrawCopyScreen()+0xac>)
    acb4:	4620      	mov	r0, r4
    acb6:	f00e ff0e 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    acba:	233a      	movs	r3, #58	; 0x3a
        graphics.print("> ");
    acbc:	491e      	ldr	r1, [pc, #120]	; (ad38 <CaptainMIDI::DrawCopyScreen()+0xb0>)
    acbe:	6063      	str	r3, [r4, #4]
    acc0:	4620      	mov	r0, r4
  text_y_ = y;
    acc2:	60a6      	str	r6, [r4, #8]
    acc4:	f00e ff07 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (copy_setup_source == copy_setup_target) graphics.print("SysEx");
    acc8:	f8d5 232c 	ldr.w	r2, [r5, #812]	; 0x32c
    accc:	f8d5 3330 	ldr.w	r3, [r5, #816]	; 0x330
    acd0:	429a      	cmp	r2, r3
    acd2:	d11d      	bne.n	ad10 <CaptainMIDI::DrawCopyScreen()+0x88>
    acd4:	4919      	ldr	r1, [pc, #100]	; (ad3c <CaptainMIDI::DrawCopyScreen()+0xb4>)
    acd6:	4620      	mov	r0, r4
    acd8:	f00e fefd 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    acdc:	2300      	movs	r3, #0
  text_y_ = y;
    acde:	2637      	movs	r6, #55	; 0x37
        graphics.print("[CANCEL]");
    ace0:	4917      	ldr	r1, [pc, #92]	; (ad40 <CaptainMIDI::DrawCopyScreen()+0xb8>)
    ace2:	4811      	ldr	r0, [pc, #68]	; (ad28 <CaptainMIDI::DrawCopyScreen()+0xa0>)
  text_x_ = x;
    ace4:	6063      	str	r3, [r4, #4]
  text_y_ = y;
    ace6:	60a6      	str	r6, [r4, #8]
    ace8:	f00e fef5 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    acec:	235a      	movs	r3, #90	; 0x5a
        graphics.print(copy_setup_source == copy_setup_target ? "[DUMP]" : "[COPY]");
    acee:	f8d5 032c 	ldr.w	r0, [r5, #812]	; 0x32c
    acf2:	f8d5 1330 	ldr.w	r1, [r5, #816]	; 0x330
    acf6:	6063      	str	r3, [r4, #4]
    acf8:	4a12      	ldr	r2, [pc, #72]	; (ad44 <CaptainMIDI::DrawCopyScreen()+0xbc>)
    acfa:	4b13      	ldr	r3, [pc, #76]	; (ad48 <CaptainMIDI::DrawCopyScreen()+0xc0>)
  text_y_ = y;
    acfc:	60a6      	str	r6, [r4, #8]
    acfe:	4288      	cmp	r0, r1
    ad00:	bf0c      	ite	eq
    ad02:	4611      	moveq	r1, r2
    ad04:	4619      	movne	r1, r3
    }
    ad06:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        graphics.print(copy_setup_source == copy_setup_target ? "[DUMP]" : "[COPY]");
    ad0a:	4807      	ldr	r0, [pc, #28]	; (ad28 <CaptainMIDI::DrawCopyScreen()+0xa0>)
    ad0c:	f00e bee3 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.print("Setup ");
    ad10:	4620      	mov	r0, r4
    ad12:	4907      	ldr	r1, [pc, #28]	; (ad30 <CaptainMIDI::DrawCopyScreen()+0xa8>)
    ad14:	f00e fedf 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.print(copy_setup_target + 1);
    ad18:	f8d5 1330 	ldr.w	r1, [r5, #816]	; 0x330
    ad1c:	4620      	mov	r0, r4
    ad1e:	3101      	adds	r1, #1
    ad20:	f00e ff4d 	bl	19bbe <weegfx::Graphics::print(int)>
    ad24:	e7da      	b.n	acdc <CaptainMIDI::DrawCopyScreen()+0x54>
    ad26:	bf00      	nop
    ad28:	200065e0 	.word	0x200065e0
    ad2c:	00021134 	.word	0x00021134
    ad30:	00021109 	.word	0x00021109
    ad34:	0001f2ee 	.word	0x0001f2ee
    ad38:	00020efb 	.word	0x00020efb
    ad3c:	00021139 	.word	0x00021139
    ad40:	00020f47 	.word	0x00020f47
    ad44:	00021126 	.word	0x00021126
    ad48:	0002112d 	.word	0x0002112d

0000ad4c <CaptainMIDI::View()>:
    void View() {
    ad4c:	b537      	push	{r0, r1, r2, r4, r5, lr}
        if (copy_mode) DrawCopyScreen();
    ad4e:	f890 5329 	ldrb.w	r5, [r0, #809]	; 0x329
    void View() {
    ad52:	4604      	mov	r4, r0
        if (copy_mode) DrawCopyScreen();
    ad54:	b11d      	cbz	r5, ad5e <CaptainMIDI::View()+0x12>
    ad56:	f7ff ff97 	bl	ac88 <CaptainMIDI::DrawCopyScreen()>
    }
    ad5a:	b003      	add	sp, #12
    ad5c:	bd30      	pop	{r4, r5, pc}
        else if (display == 0) DrawSetupScreens();
    ad5e:	f890 3328 	ldrb.w	r3, [r0, #808]	; 0x328
    ad62:	b913      	cbnz	r3, ad6a <CaptainMIDI::View()+0x1e>
    ad64:	f7ff fde6 	bl	a934 <CaptainMIDI::DrawSetupScreens()>
    ad68:	e7f7      	b.n	ad5a <CaptainMIDI::View()+0xe>
        gfxHeader("IO Ch Type  Values");
    ad6a:	491f      	ldr	r1, [pc, #124]	; (ade8 <CaptainMIDI::View()+0x9c>)
    ad6c:	3008      	adds	r0, #8
    ad6e:	f7fb f809 	bl	5d84 <HSApplication::gfxHeader(char const*)>
        if (log_index) {
    ad72:	f8d4 365c 	ldr.w	r3, [r4, #1628]	; 0x65c
    ad76:	2b00      	cmp	r3, #0
    ad78:	d0ef      	beq.n	ad5a <CaptainMIDI::View()+0xe>
                int ix = l + log_view; // Log index
    ad7a:	f8d4 0660 	ldr.w	r0, [r4, #1632]	; 0x660
                if (ix < log_index) {
    ad7e:	f8d4 365c 	ldr.w	r3, [r4, #1628]	; 0x65c
                int ix = l + log_view; // Log index
    ad82:	4428      	add	r0, r5
                if (ix < log_index) {
    ad84:	4298      	cmp	r0, r3
    ad86:	da07      	bge.n	ad98 <CaptainMIDI::View()+0x4c>
                    log[ix].DrawAt(l * 8 + 15);
    ad88:	00e9      	lsls	r1, r5, #3
    ad8a:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    ad8e:	310f      	adds	r1, #15
    ad90:	f500 704d 	add.w	r0, r0, #820	; 0x334
    ad94:	f7ff fc8e 	bl	a6b4 <CaptainMIDILog::DrawAt(int)>
            for (int l = 0; l < 6; l++)
    ad98:	3501      	adds	r5, #1
    ad9a:	2d06      	cmp	r5, #6
    ad9c:	d1ed      	bne.n	ad7a <CaptainMIDI::View()+0x2e>
            if (log_index > 6) {
    ad9e:	f8d4 365c 	ldr.w	r3, [r4, #1628]	; 0x65c
    ada2:	2b06      	cmp	r3, #6
    ada4:	ddd9      	ble.n	ad5a <CaptainMIDI::View()+0xe>
                graphics.drawFrame(122, 14, 6, 48);
    ada6:	2330      	movs	r3, #48	; 0x30
    ada8:	9300      	str	r3, [sp, #0]
    adaa:	4810      	ldr	r0, [pc, #64]	; (adec <CaptainMIDI::View()+0xa0>)
    adac:	462b      	mov	r3, r5
    adae:	220e      	movs	r2, #14
    adb0:	217a      	movs	r1, #122	; 0x7a
    adb2:	f00e fc22 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    adb6:	f8d4 2660 	ldr.w	r2, [r4, #1632]	; 0x660
                int y = Proportion(log_view, log_index - 6, 38);
    adba:	f8d4 365c 	ldr.w	r3, [r4, #1628]	; 0x65c
                graphics.drawRect(124, 16 + y, 2, 6);
    adbe:	480b      	ldr	r0, [pc, #44]	; (adec <CaptainMIDI::View()+0xa0>)
    adc0:	9500      	str	r5, [sp, #0]
                int y = Proportion(log_view, log_index - 6, 38);
    adc2:	3b06      	subs	r3, #6
    adc4:	0392      	lsls	r2, r2, #14
    adc6:	fb92 f2f3 	sdiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
    adca:	2326      	movs	r3, #38	; 0x26
    adcc:	435a      	muls	r2, r3
    adce:	1392      	asrs	r2, r2, #14
                graphics.drawRect(124, 16 + y, 2, 6);
    add0:	429a      	cmp	r2, r3
    add2:	bfa8      	it	ge
    add4:	461a      	movge	r2, r3
    add6:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    adda:	2302      	movs	r3, #2
    addc:	3210      	adds	r2, #16
    adde:	217c      	movs	r1, #124	; 0x7c
    ade0:	f00e fa58 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
    }
    ade4:	e7b9      	b.n	ad5a <CaptainMIDI::View()+0xe>
    ade6:	bf00      	nop
    ade8:	0002113f 	.word	0x0002113f
    adec:	200065e0 	.word	0x200065e0

0000adf0 <non-virtual thunk to CaptainMIDI::View()>:
    void View() {
    adf0:	f1a0 0008 	sub.w	r0, r0, #8
    adf4:	e7aa      	b.n	ad4c <CaptainMIDI::View()>
    adf6:	bf00      	nop

0000adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>:
        if (message == 5 && display == 0) return;
    adf8:	2b05      	cmp	r3, #5
    void UpdateLog(bool midi_in, int ch, uint8_t message, uint8_t channel, int16_t data1, int16_t data2) {
    adfa:	b570      	push	{r4, r5, r6, lr}
    adfc:	4604      	mov	r4, r0
        if (message == 5 && display == 0) return;
    adfe:	d102      	bne.n	ae06 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)+0xe>
    ae00:	f890 0328 	ldrb.w	r0, [r0, #808]	; 0x328
    ae04:	b3b0      	cbz	r0, ae74 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)+0x7c>
        char io = midi_in ? ('A' + ch) : ('1' + ch);
    ae06:	b2d2      	uxtb	r2, r2
    ae08:	b3a9      	cbz	r1, ae76 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)+0x7e>
    ae0a:	3241      	adds	r2, #65	; 0x41
        log[log_index++] = {midi_in, io, message, channel, data1, data2};
    ae0c:	f8d4 065c 	ldr.w	r0, [r4, #1628]	; 0x65c
    ae10:	1c45      	adds	r5, r0, #1
    ae12:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    ae16:	f8c4 565c 	str.w	r5, [r4, #1628]	; 0x65c
    ae1a:	f880 3336 	strb.w	r3, [r0, #822]	; 0x336
    ae1e:	f89d 3010 	ldrb.w	r3, [sp, #16]
    ae22:	f880 3337 	strb.w	r3, [r0, #823]	; 0x337
    ae26:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    ae2a:	f8a0 3338 	strh.w	r3, [r0, #824]	; 0x338
        char io = midi_in ? ('A' + ch) : ('1' + ch);
    ae2e:	b2d2      	uxtb	r2, r2
        log[log_index++] = {midi_in, io, message, channel, data1, data2};
    ae30:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
    ae34:	f880 1334 	strb.w	r1, [r0, #820]	; 0x334
        if (log_index == MIDI_LOG_MAX_SIZE) {
    ae38:	2d65      	cmp	r5, #101	; 0x65
        log[log_index++] = {midi_in, io, message, channel, data1, data2};
    ae3a:	f880 2335 	strb.w	r2, [r0, #821]	; 0x335
    ae3e:	f8a0 333a 	strh.w	r3, [r0, #826]	; 0x33a
        if (log_index == MIDI_LOG_MAX_SIZE) {
    ae42:	d110      	bne.n	ae66 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)+0x6e>
    ae44:	f504 754d 	add.w	r5, r4, #820	; 0x334
    ae48:	f204 6654 	addw	r6, r4, #1620	; 0x654
                memcpy(&log[i], &log[i+1], sizeof(log[i + 1]));
    ae4c:	4628      	mov	r0, r5
    ae4e:	3508      	adds	r5, #8
    ae50:	2208      	movs	r2, #8
    ae52:	4629      	mov	r1, r5
    ae54:	f00f f8cc 	bl	19ff0 <memcpy>
            for (int i = 0; i < MIDI_LOG_MAX_SIZE - 1; i++)
    ae58:	42b5      	cmp	r5, r6
    ae5a:	d1f7      	bne.n	ae4c <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)+0x54>
            log_index--;
    ae5c:	f8d4 365c 	ldr.w	r3, [r4, #1628]	; 0x65c
    ae60:	3b01      	subs	r3, #1
    ae62:	f8c4 365c 	str.w	r3, [r4, #1628]	; 0x65c
        log_view = log_index - 6;
    ae66:	f8d4 365c 	ldr.w	r3, [r4, #1628]	; 0x65c
        if (log_view < 0) log_view = 0;
    ae6a:	3b06      	subs	r3, #6
    ae6c:	bf48      	it	mi
    ae6e:	2300      	movmi	r3, #0
    ae70:	f8c4 3660 	str.w	r3, [r4, #1632]	; 0x660
    }
    ae74:	bd70      	pop	{r4, r5, r6, pc}
        char io = midi_in ? ('A' + ch) : ('1' + ch);
    ae76:	3231      	adds	r2, #49	; 0x31
    ae78:	e7c8      	b.n	ae0c <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)+0x14>
    ae7a:	Address 0x000000000000ae7a is out of bounds.


0000ae7c <CaptainMIDI::midi_in()>:
    void midi_in() {
    ae7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ae80:	4604      	mov	r4, r0
    ae82:	b089      	sub	sp, #36	; 0x24
		return usb_midi_read(channel);
    ae84:	2000      	movs	r0, #0
    ae86:	f010 f845 	bl	1af14 <usb_midi_read>
        if (usbMIDI.read()) {
    ae8a:	2800      	cmp	r0, #0
    ae8c:	f000 80d3 	beq.w	b036 <CaptainMIDI::midi_in()+0x1ba>
                return usb_midi_msg_type;
    ae90:	4bb0      	ldr	r3, [pc, #704]	; (b154 <CaptainMIDI::midi_in()+0x2d8>)
            int message = usbMIDI.getType();
    ae92:	781f      	ldrb	r7, [r3, #0]
        }
        uint8_t getCable(void) __attribute__((always_inline)) {
                return usb_midi_msg_cable;
        }
        uint8_t getChannel(void) __attribute__((always_inline)) {
                return usb_midi_msg_channel;
    ae94:	4bb0      	ldr	r3, [pc, #704]	; (b158 <CaptainMIDI::midi_in()+0x2dc>)
            int channel = usbMIDI.getChannel();
    ae96:	f893 a000 	ldrb.w	sl, [r3]
        }
        uint8_t getData1(void) __attribute__((always_inline)) {
                return usb_midi_msg_data1;
    ae9a:	4bb0      	ldr	r3, [pc, #704]	; (b15c <CaptainMIDI::midi_in()+0x2e0>)
    ae9c:	f893 8000 	ldrb.w	r8, [r3]
        }
        uint8_t getData2(void) __attribute__((always_inline)) {
                return usb_midi_msg_data2;
    aea0:	4baf      	ldr	r3, [pc, #700]	; (b160 <CaptainMIDI::midi_in()+0x2e4>)
            if (message == MIDI_MSG_SYSEX) OnReceiveSysEx();
    aea2:	2f07      	cmp	r7, #7
            int data2 = usbMIDI.getData2();
    aea4:	f893 9000 	ldrb.w	r9, [r3]
            if (message == MIDI_MSG_SYSEX) OnReceiveSysEx();
    aea8:	d15d      	bne.n	af66 <CaptainMIDI::midi_in()+0xea>
    aeaa:	6823      	ldr	r3, [r4, #0]
    aeac:	4620      	mov	r0, r4
    aeae:	685b      	ldr	r3, [r3, #4]
    aeb0:	4798      	blx	r3
    void midi_in() {
    aeb2:	2600      	movs	r6, #0
                if (indicator) indicator_in[ch] = MIDI_INDICATOR_COUNTDOWN;
    aeb4:	f204 6374 	addw	r3, r4, #1652	; 0x674
    aeb8:	f204 6b64 	addw	fp, r4, #1636	; 0x664
    void midi_in() {
    aebc:	9606      	str	r6, [sp, #24]
    aebe:	9605      	str	r6, [sp, #20]
                if (indicator) indicator_in[ch] = MIDI_INDICATOR_COUNTDOWN;
    aec0:	9307      	str	r3, [sp, #28]
        int setup_offset = get_setup_number() * MIDI_PARAMETER_COUNT;
    aec2:	f8d4 3308 	ldr.w	r3, [r4, #776]	; 0x308
        return values_[ch + setup_offset];
    aec6:	2228      	movs	r2, #40	; 0x28
    aec8:	fb02 6303 	mla	r3, r2, r3, r6
    aecc:	f103 0222 	add.w	r2, r3, #34	; 0x22
                if (message == MIDI_MSG_NOTE_ON && in_ch == channel) {
    aed0:	2f01      	cmp	r7, #1
        return values_[ch + setup_offset];
    aed2:	f854 5022 	ldr.w	r5, [r4, r2, lsl #2]
        return values_[8 + ch + setup_offset];
    aed6:	f103 022a 	add.w	r2, r3, #42	; 0x2a
    aeda:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
    aede:	9204      	str	r2, [sp, #16]
                if (message == MIDI_MSG_NOTE_ON && in_ch == channel) {
    aee0:	f040 8085 	bne.w	afee <CaptainMIDI::midi_in()+0x172>
    aee4:	4592      	cmp	sl, r2
    aee6:	d154      	bne.n	af92 <CaptainMIDI::midi_in()+0x116>
                    if (note_in[ch] == -1) { // If this channel isn't already occupied with another note, handle Note On
    aee8:	f8db 2000 	ldr.w	r2, [fp]
    aeec:	3201      	adds	r2, #1
    aeee:	d150      	bne.n	af92 <CaptainMIDI::midi_in()+0x116>
                        if (in_fn == MIDI_IN_NOTE && !note_captured) {
    aef0:	2d01      	cmp	r5, #1
    aef2:	d148      	bne.n	af86 <CaptainMIDI::midi_in()+0x10a>
    aef4:	9a05      	ldr	r2, [sp, #20]
    aef6:	2a00      	cmp	r2, #0
    aef8:	f040 8097 	bne.w	b02a <CaptainMIDI::midi_in()+0x1ae>
        return values_[16 + ch + setup_offset];
    aefc:	f103 0232 	add.w	r2, r3, #50	; 0x32
                            int note = data1 + get_in_transpose(ch);
    af00:	f854 5022 	ldr.w	r5, [r4, r2, lsl #2]
        int range_low = values_[24 + ch + setup_offset];
    af04:	f103 023a 	add.w	r2, r3, #58	; 0x3a
                            int note = data1 + get_in_transpose(ch);
    af08:	4445      	add	r5, r8
        return (note >= range_low && note <= range_high);
    af0a:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
    af0e:	f385 0507 	usat	r5, #7, r5
    af12:	4295      	cmp	r5, r2
    af14:	f2c0 8089 	blt.w	b02a <CaptainMIDI::midi_in()+0x1ae>
        int range_high = values_[32 + ch + setup_offset];
    af18:	3342      	adds	r3, #66	; 0x42
        return (note >= range_low && note <= range_high);
    af1a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    af1e:	429d      	cmp	r5, r3
    af20:	f300 8083 	bgt.w	b02a <CaptainMIDI::midi_in()+0x1ae>
                                Out(ch, MIDIQuantizer::CV(note));
    af24:	9905      	ldr	r1, [sp, #20]
    af26:	b2e8      	uxtb	r0, r5
    af28:	f7fa fd3d 	bl	59a6 <MIDIQuantizer::CV(unsigned char, int)>
    af2c:	9b05      	ldr	r3, [sp, #20]
    af2e:	4602      	mov	r2, r0
    af30:	4631      	mov	r1, r6
    af32:	f104 0008 	add.w	r0, r4, #8
    af36:	f7fa fe49 	bl	5bcc <HSApplication::Out(int, int, int)>
                                UpdateLog(1, ch, 0, in_ch, note, data2);
    af3a:	b22d      	sxth	r5, r5
    af3c:	fa0f f389 	sxth.w	r3, r9
    af40:	9302      	str	r3, [sp, #8]
    af42:	9501      	str	r5, [sp, #4]
    af44:	9b05      	ldr	r3, [sp, #20]
    af46:	f8cd a000 	str.w	sl, [sp]
    af4a:	4632      	mov	r2, r6
    af4c:	4639      	mov	r1, r7
    af4e:	4620      	mov	r0, r4
    af50:	f7ff ff52 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
                                note_in[ch] = data1;
    af54:	f8cb 8000 	str.w	r8, [fp]
                                note_captured = 1;
    af58:	9705      	str	r7, [sp, #20]
                if (indicator) indicator_in[ch] = MIDI_INDICATOR_COUNTDOWN;
    af5a:	9a07      	ldr	r2, [sp, #28]
    af5c:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
    af60:	f822 3016 	strh.w	r3, [r2, r6, lsl #1]
    af64:	e061      	b.n	b02a <CaptainMIDI::midi_in()+0x1ae>
            if (message == MIDI_MSG_REALTIME && data1 == 0) {
    af66:	2f08      	cmp	r7, #8
    af68:	d1a3      	bne.n	aeb2 <CaptainMIDI::midi_in()+0x36>
    af6a:	f1b8 0f00 	cmp.w	r8, #0
    af6e:	d1a0      	bne.n	aeb2 <CaptainMIDI::midi_in()+0x36>
                if (++clock_count >= 24) clock_count = 0;
    af70:	f894 367c 	ldrb.w	r3, [r4, #1660]	; 0x67c
    af74:	3301      	adds	r3, #1
    af76:	b2db      	uxtb	r3, r3
    af78:	2b17      	cmp	r3, #23
    af7a:	bf94      	ite	ls
    af7c:	f884 367c 	strbls.w	r3, [r4, #1660]	; 0x67c
    af80:	f884 867c 	strbhi.w	r8, [r4, #1660]	; 0x67c
    af84:	e795      	b.n	aeb2 <CaptainMIDI::midi_in()+0x36>
                        if (in_fn == MIDI_IN_GATE && !gate_captured) {
    af86:	2d02      	cmp	r5, #2
    af88:	d008      	beq.n	af9c <CaptainMIDI::midi_in()+0x120>
                        if (in_fn == MIDI_IN_TRIGGER) {
    af8a:	2d03      	cmp	r5, #3
    af8c:	d017      	beq.n	afbe <CaptainMIDI::midi_in()+0x142>
                        if (in_fn == MIDI_IN_VELOCITY) {
    af8e:	2d04      	cmp	r5, #4
    af90:	d01d      	beq.n	afce <CaptainMIDI::midi_in()+0x152>
                bool cc = (in_fn == MIDI_IN_MOD || in_fn >= MIDI_IN_EXPRESSION);
    af92:	2d05      	cmp	r5, #5
    af94:	f000 811c 	beq.w	b1d0 <CaptainMIDI::midi_in()+0x354>
    af98:	2300      	movs	r3, #0
    af9a:	e05d      	b.n	b058 <CaptainMIDI::midi_in()+0x1dc>
                        if (in_fn == MIDI_IN_GATE && !gate_captured) {
    af9c:	9b06      	ldr	r3, [sp, #24]
    af9e:	2b00      	cmp	r3, #0
    afa0:	f040 810b 	bne.w	b1ba <CaptainMIDI::midi_in()+0x33e>
        Out(ch, 0, (high ? PULSE_VOLTAGE : 0));
    afa4:	2305      	movs	r3, #5
    afa6:	9a06      	ldr	r2, [sp, #24]
    afa8:	4631      	mov	r1, r6
    afaa:	f104 0008 	add.w	r0, r4, #8
    afae:	f7fa fe0d 	bl	5bcc <HSApplication::Out(int, int, int)>
                            note_in[ch] = data1;
    afb2:	f8cb 8000 	str.w	r8, [fp]
                            indicator = 1;
    afb6:	463b      	mov	r3, r7
                bool indicator = 0;
    afb8:	2201      	movs	r2, #1
    afba:	9206      	str	r2, [sp, #24]
    afbc:	e0c2      	b.n	b144 <CaptainMIDI::midi_in()+0x2c8>
                            ClockOut(ch);
    afbe:	2264      	movs	r2, #100	; 0x64
    afc0:	4631      	mov	r1, r6
    afc2:	f104 0008 	add.w	r0, r4, #8
    afc6:	f7fa fed3 	bl	5d70 <HSApplication::ClockOut(int, int)>
                            gate_captured = 1;
    afca:	9706      	str	r7, [sp, #24]
    afcc:	e7c5      	b.n	af5a <CaptainMIDI::midi_in()+0xde>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    afce:	237f      	movs	r3, #127	; 0x7f
    afd0:	ea4f 3289 	mov.w	r2, r9, lsl #14
    afd4:	fbb2 f2f3 	udiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
    afd8:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    afdc:	435a      	muls	r2, r3
                            Out(ch, Proportion(data2, 127, HSAPPLICATION_5V));
    afde:	1392      	asrs	r2, r2, #14
    afe0:	2300      	movs	r3, #0
        Out(ch, 0, (high ? PULSE_VOLTAGE : 0));
    afe2:	4631      	mov	r1, r6
    afe4:	f104 0008 	add.w	r0, r4, #8
    afe8:	f7fa fdf0 	bl	5bcc <HSApplication::Out(int, int, int)>
                if (message == MIDI_MSG_AFTERTOUCH && in_fn == MIDI_IN_AFTERTOUCH && in_ch == channel) {
    afec:	e7b5      	b.n	af5a <CaptainMIDI::midi_in()+0xde>
                if (message == MIDI_MSG_NOTE_OFF && in_ch == channel) {
    afee:	bb7f      	cbnz	r7, b050 <CaptainMIDI::midi_in()+0x1d4>
    aff0:	9b04      	ldr	r3, [sp, #16]
    aff2:	459a      	cmp	sl, r3
    aff4:	d1cd      	bne.n	af92 <CaptainMIDI::midi_in()+0x116>
                    if (note_in[ch] == data1) { // If the note off matches the note on assingned to this output
    aff6:	f8db 3000 	ldr.w	r3, [fp]
    affa:	4543      	cmp	r3, r8
    affc:	d1c9      	bne.n	af92 <CaptainMIDI::midi_in()+0x116>
                        note_in[ch] = -1;
    affe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
                        if (in_fn == MIDI_IN_GATE) {
    b002:	2d02      	cmp	r5, #2
                        note_in[ch] = -1;
    b004:	f8cb 3000 	str.w	r3, [fp]
                        if (in_fn == MIDI_IN_GATE) {
    b008:	d102      	bne.n	b010 <CaptainMIDI::midi_in()+0x194>
    b00a:	463b      	mov	r3, r7
    b00c:	463a      	mov	r2, r7
    b00e:	e7e8      	b.n	afe2 <CaptainMIDI::midi_in()+0x166>
                        } else if (in_fn == MIDI_IN_NOTE) {
    b010:	2d01      	cmp	r5, #1
    b012:	d113      	bne.n	b03c <CaptainMIDI::midi_in()+0x1c0>
                            UpdateLog(1, ch, 1, in_ch, data1, 0);
    b014:	9702      	str	r7, [sp, #8]
    b016:	f8cd 8004 	str.w	r8, [sp, #4]
    b01a:	f8cd a000 	str.w	sl, [sp]
    b01e:	462b      	mov	r3, r5
    b020:	4632      	mov	r2, r6
    b022:	4629      	mov	r1, r5
    b024:	4620      	mov	r0, r4
    b026:	f7ff fee7 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
            for (int ch = 0; ch < 4; ch++)
    b02a:	3601      	adds	r6, #1
    b02c:	2e04      	cmp	r6, #4
    b02e:	f10b 0b04 	add.w	fp, fp, #4
    b032:	f47f af46 	bne.w	aec2 <CaptainMIDI::midi_in()+0x46>
    }
    b036:	b009      	add	sp, #36	; 0x24
    b038:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        } else if (in_fn == MIDI_IN_VELOCITY) {
    b03c:	2d04      	cmp	r5, #4
    b03e:	d1a8      	bne.n	af92 <CaptainMIDI::midi_in()+0x116>
                            Out(ch, 0);
    b040:	463b      	mov	r3, r7
    b042:	463a      	mov	r2, r7
    b044:	4631      	mov	r1, r6
    b046:	f104 0008 	add.w	r0, r4, #8
    b04a:	f7fa fdbf 	bl	5bcc <HSApplication::Out(int, int, int)>
    b04e:	e7ec      	b.n	b02a <CaptainMIDI::midi_in()+0x1ae>
                bool cc = (in_fn == MIDI_IN_MOD || in_fn >= MIDI_IN_EXPRESSION);
    b050:	2d05      	cmp	r5, #5
                bool indicator = 0;
    b052:	f04f 0300 	mov.w	r3, #0
                bool cc = (in_fn == MIDI_IN_MOD || in_fn >= MIDI_IN_EXPRESSION);
    b056:	d026      	beq.n	b0a6 <CaptainMIDI::midi_in()+0x22a>
    b058:	2d07      	cmp	r5, #7
    b05a:	dc24      	bgt.n	b0a6 <CaptainMIDI::midi_in()+0x22a>
                if (message == MIDI_MSG_AFTERTOUCH && in_fn == MIDI_IN_AFTERTOUCH && in_ch == channel) {
    b05c:	2f05      	cmp	r7, #5
    b05e:	f000 8081 	beq.w	b164 <CaptainMIDI::midi_in()+0x2e8>
                if (message == MIDI_MSG_PITCHBEND && in_fn == MIDI_IN_PITCHBEND && in_ch == channel) {
    b062:	2f06      	cmp	r7, #6
    b064:	d157      	bne.n	b116 <CaptainMIDI::midi_in()+0x29a>
    b066:	2d07      	cmp	r5, #7
    b068:	d155      	bne.n	b116 <CaptainMIDI::midi_in()+0x29a>
    b06a:	9b04      	ldr	r3, [sp, #16]
    b06c:	459a      	cmp	sl, r3
    b06e:	d1dc      	bne.n	b02a <CaptainMIDI::midi_in()+0x1ae>
                    int data = (data2 << 7) + data1 - 8192;
    b070:	eb08 15c9 	add.w	r5, r8, r9, lsl #7
    b074:	f5a5 5500 	sub.w	r5, r5, #8192	; 0x2000
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    b078:	03aa      	lsls	r2, r5, #14
    b07a:	f647 73ff 	movw	r3, #32767	; 0x7fff
    b07e:	fb92 f2f3 	sdiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
    b082:	f44f 5390 	mov.w	r3, #4608	; 0x1200
    b086:	435a      	muls	r2, r3
                    Out(ch, Proportion(data, 0x7fff, HSAPPLICATION_3V));
    b088:	1392      	asrs	r2, r2, #14
    b08a:	2300      	movs	r3, #0
    b08c:	4631      	mov	r1, r6
    b08e:	f104 0008 	add.w	r0, r4, #8
    b092:	f7fa fd9b 	bl	5bcc <HSApplication::Out(int, int, int)>
                    UpdateLog(1, ch, 4, in_ch, 0, data);
    b096:	b22d      	sxth	r5, r5
    b098:	2300      	movs	r3, #0
    b09a:	9301      	str	r3, [sp, #4]
    b09c:	9502      	str	r5, [sp, #8]
    b09e:	f8cd a000 	str.w	sl, [sp]
    b0a2:	2304      	movs	r3, #4
    b0a4:	e07b      	b.n	b19e <CaptainMIDI::midi_in()+0x322>
                if (cc && message == MIDI_MSG_MIDI_CC && in_ch == channel) {
    b0a6:	2f03      	cmp	r7, #3
    b0a8:	d1d8      	bne.n	b05c <CaptainMIDI::midi_in()+0x1e0>
    b0aa:	9a04      	ldr	r2, [sp, #16]
    b0ac:	4592      	cmp	sl, r2
    b0ae:	d132      	bne.n	b116 <CaptainMIDI::midi_in()+0x29a>
                    if (in_fn == MIDI_IN_EXPRESSION) cc = 11;
    b0b0:	2d08      	cmp	r5, #8
    b0b2:	d04b      	beq.n	b14c <CaptainMIDI::midi_in()+0x2d0>
                    if (in_fn == MIDI_IN_PAN) cc = 10;
    b0b4:	2d09      	cmp	r5, #9
    b0b6:	d04b      	beq.n	b150 <CaptainMIDI::midi_in()+0x2d4>
                    if (in_fn == MIDI_IN_HOLD) cc = 64;
    b0b8:	2d0a      	cmp	r5, #10
    b0ba:	f000 8084 	beq.w	b1c6 <CaptainMIDI::midi_in()+0x34a>
                    if (in_fn == MIDI_IN_BREATH) cc = 2;
    b0be:	2d0b      	cmp	r5, #11
    b0c0:	d075      	beq.n	b1ae <CaptainMIDI::midi_in()+0x332>
                    if (in_fn == MIDI_IN_Y_AXIS) cc = 74;
    b0c2:	2d0c      	cmp	r5, #12
    b0c4:	d077      	beq.n	b1b6 <CaptainMIDI::midi_in()+0x33a>
                    uint8_t cc = 1; // Modulation wheel
    b0c6:	2201      	movs	r2, #1
                    if (data1 == cc) {
    b0c8:	4542      	cmp	r2, r8
    b0ca:	d124      	bne.n	b116 <CaptainMIDI::midi_in()+0x29a>
                        if (in_fn == MIDI_IN_HOLD && data2 > 0) data2 = 127;
    b0cc:	2d0a      	cmp	r5, #10
    b0ce:	d104      	bne.n	b0da <CaptainMIDI::midi_in()+0x25e>
    b0d0:	f1b9 0f00 	cmp.w	r9, #0
    b0d4:	bf18      	it	ne
    b0d6:	f04f 097f 	movne.w	r9, #127	; 0x7f
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    b0da:	237f      	movs	r3, #127	; 0x7f
    b0dc:	ea4f 3289 	mov.w	r2, r9, lsl #14
    b0e0:	fbb2 f2f3 	udiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
    b0e4:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    b0e8:	435a      	muls	r2, r3
                        Out(ch, Proportion(data2, 127, HSAPPLICATION_5V));
    b0ea:	1392      	asrs	r2, r2, #14
    b0ec:	2300      	movs	r3, #0
    b0ee:	4631      	mov	r1, r6
    b0f0:	f104 0008 	add.w	r0, r4, #8
    b0f4:	f7fa fd6a 	bl	5bcc <HSApplication::Out(int, int, int)>
                        UpdateLog(1, ch, 2, in_ch, data1, data2);
    b0f8:	fa0f f389 	sxth.w	r3, r9
    b0fc:	9302      	str	r3, [sp, #8]
    b0fe:	f89d 3010 	ldrb.w	r3, [sp, #16]
    b102:	9300      	str	r3, [sp, #0]
    b104:	f8cd 8004 	str.w	r8, [sp, #4]
    b108:	2302      	movs	r3, #2
    b10a:	4632      	mov	r2, r6
    b10c:	2101      	movs	r1, #1
    b10e:	4620      	mov	r0, r4
    b110:	f7ff fe72 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
                        indicator = 1;
    b114:	2301      	movs	r3, #1
                if (in_fn >= MIDI_IN_CLOCK_4TH) {
    b116:	2d0c      	cmp	r5, #12
    b118:	dd14      	ble.n	b144 <CaptainMIDI::midi_in()+0x2c8>
        if (fn == MIDI_IN_CLOCK_4TH) mod = 24;
    b11a:	2d0d      	cmp	r5, #13
    b11c:	d045      	beq.n	b1aa <CaptainMIDI::midi_in()+0x32e>
        if (fn == MIDI_IN_CLOCK_8TH) mod = 12;
    b11e:	2d0e      	cmp	r5, #14
    b120:	d14d      	bne.n	b1be <CaptainMIDI::midi_in()+0x342>
    b122:	210c      	movs	r1, #12
                    if (clock_count % mod == 0) ClockOut(ch);
    b124:	f894 267c 	ldrb.w	r2, [r4, #1660]	; 0x67c
    b128:	fbb2 f0f1 	udiv	r0, r2, r1
    b12c:	fb01 2210 	mls	r2, r1, r0, r2
    b130:	b2d2      	uxtb	r2, r2
    b132:	b93a      	cbnz	r2, b144 <CaptainMIDI::midi_in()+0x2c8>
    b134:	2264      	movs	r2, #100	; 0x64
    b136:	4631      	mov	r1, r6
    b138:	f104 0008 	add.w	r0, r4, #8
    b13c:	9304      	str	r3, [sp, #16]
    b13e:	f7fa fe17 	bl	5d70 <HSApplication::ClockOut(int, int)>
    b142:	9b04      	ldr	r3, [sp, #16]
                if (indicator) indicator_in[ch] = MIDI_INDICATOR_COUNTDOWN;
    b144:	2b00      	cmp	r3, #0
    b146:	f43f af70 	beq.w	b02a <CaptainMIDI::midi_in()+0x1ae>
    b14a:	e706      	b.n	af5a <CaptainMIDI::midi_in()+0xde>
                    if (in_fn == MIDI_IN_EXPRESSION) cc = 11;
    b14c:	220b      	movs	r2, #11
    b14e:	e7bb      	b.n	b0c8 <CaptainMIDI::midi_in()+0x24c>
                    if (in_fn == MIDI_IN_PAN) cc = 10;
    b150:	220a      	movs	r2, #10
    b152:	e7b9      	b.n	b0c8 <CaptainMIDI::midi_in()+0x24c>
    b154:	20006884 	.word	0x20006884
    b158:	2000675d 	.word	0x2000675d
    b15c:	2000675e 	.word	0x2000675e
    b160:	2000675f 	.word	0x2000675f
                if (message == MIDI_MSG_AFTERTOUCH && in_fn == MIDI_IN_AFTERTOUCH && in_ch == channel) {
    b164:	2d06      	cmp	r5, #6
    b166:	d1d6      	bne.n	b116 <CaptainMIDI::midi_in()+0x29a>
    b168:	9b04      	ldr	r3, [sp, #16]
    b16a:	459a      	cmp	sl, r3
    b16c:	f47f af5d 	bne.w	b02a <CaptainMIDI::midi_in()+0x1ae>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    b170:	237f      	movs	r3, #127	; 0x7f
    b172:	ea4f 3289 	mov.w	r2, r9, lsl #14
    b176:	fbb2 f2f3 	udiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
    b17a:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    b17e:	435a      	muls	r2, r3
                    Out(ch, Proportion(data2, 127, HSAPPLICATION_5V));
    b180:	1392      	asrs	r2, r2, #14
    b182:	2300      	movs	r3, #0
    b184:	4631      	mov	r1, r6
    b186:	f104 0008 	add.w	r0, r4, #8
    b18a:	f7fa fd1f 	bl	5bcc <HSApplication::Out(int, int, int)>
                    UpdateLog(1, ch, 3, in_ch, data1, data2);
    b18e:	fa0f f389 	sxth.w	r3, r9
    b192:	9302      	str	r3, [sp, #8]
    b194:	f8cd 8004 	str.w	r8, [sp, #4]
    b198:	f8cd a000 	str.w	sl, [sp]
    b19c:	2303      	movs	r3, #3
                    UpdateLog(1, ch, 4, in_ch, 0, data);
    b19e:	4632      	mov	r2, r6
    b1a0:	2101      	movs	r1, #1
    b1a2:	4620      	mov	r0, r4
    b1a4:	f7ff fe28 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
                if (indicator) indicator_in[ch] = MIDI_INDICATOR_COUNTDOWN;
    b1a8:	e6d7      	b.n	af5a <CaptainMIDI::midi_in()+0xde>
        if (fn == MIDI_IN_CLOCK_4TH) mod = 24;
    b1aa:	2118      	movs	r1, #24
    b1ac:	e7ba      	b.n	b124 <CaptainMIDI::midi_in()+0x2a8>
                    if (in_fn == MIDI_IN_BREATH) cc = 2;
    b1ae:	2202      	movs	r2, #2
                    if (data1 == cc) {
    b1b0:	4590      	cmp	r8, r2
    b1b2:	d1b0      	bne.n	b116 <CaptainMIDI::midi_in()+0x29a>
    b1b4:	e791      	b.n	b0da <CaptainMIDI::midi_in()+0x25e>
                    if (in_fn == MIDI_IN_Y_AXIS) cc = 74;
    b1b6:	224a      	movs	r2, #74	; 0x4a
    b1b8:	e7fa      	b.n	b1b0 <CaptainMIDI::midi_in()+0x334>
                bool indicator = 0;
    b1ba:	2300      	movs	r3, #0
    b1bc:	e6fc      	b.n	afb8 <CaptainMIDI::midi_in()+0x13c>
        if (fn == MIDI_IN_CLOCK_16TH) mod = 6;
    b1be:	2d0f      	cmp	r5, #15
    b1c0:	d1b8      	bne.n	b134 <CaptainMIDI::midi_in()+0x2b8>
    b1c2:	2106      	movs	r1, #6
    b1c4:	e7ae      	b.n	b124 <CaptainMIDI::midi_in()+0x2a8>
                    if (data1 == cc) {
    b1c6:	f1b8 0f40 	cmp.w	r8, #64	; 0x40
    b1ca:	f47f af2e 	bne.w	b02a <CaptainMIDI::midi_in()+0x1ae>
    b1ce:	e77f      	b.n	b0d0 <CaptainMIDI::midi_in()+0x254>
                if (message == MIDI_MSG_AFTERTOUCH && in_fn == MIDI_IN_AFTERTOUCH && in_ch == channel) {
    b1d0:	2f05      	cmp	r7, #5
    b1d2:	f43f af2a 	beq.w	b02a <CaptainMIDI::midi_in()+0x1ae>
    b1d6:	2300      	movs	r3, #0
    b1d8:	e743      	b.n	b062 <CaptainMIDI::midi_in()+0x1e6>
    b1da:	bf00      	nop

0000b1dc <LogicGate::Calculate(unsigned short)>:
        uint16_t v = source_state & (0x01 << source);
    b1dc:	8903      	ldrh	r3, [r0, #8]
    bool Calculate(uint16_t source_state_) {
    b1de:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        uint16_t v = source_state & (0x01 << source);
    b1e2:	2701      	movs	r7, #1
    b1e4:	8984      	ldrh	r4, [r0, #12]
        switch(type) {
    b1e6:	6845      	ldr	r5, [r0, #4]
        uint16_t v = source_state & (0x01 << source);
    b1e8:	fa07 f303 	lsl.w	r3, r7, r3
        source_state = source_state_ | (0x01 << 14); // Add the ON state
    b1ec:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
        return static_cast<bool>(v);
    b1f0:	ea13 0c01 	ands.w	ip, r3, r1
        uint16_t v = source_state & (0x01 << source);
    b1f4:	fa07 f404 	lsl.w	r4, r7, r4
        return static_cast<bool>(v);
    b1f8:	bf14      	ite	ne
    b1fa:	463e      	movne	r6, r7
    b1fc:	2600      	moveq	r6, #0
        switch(type) {
    b1fe:	3d01      	subs	r5, #1
        return static_cast<bool>(v);
    b200:	ea14 0801 	ands.w	r8, r4, r1
    b204:	fa1f fe83 	uxth.w	lr, r3
    b208:	b2a2      	uxth	r2, r4
        source_state = source_state_ | (0x01 << 14); // Add the ON state
    b20a:	8041      	strh	r1, [r0, #2]
        bool v3 = source_value(source3);
    b20c:	6904      	ldr	r4, [r0, #16]
        return static_cast<bool>(v);
    b20e:	bf14      	ite	ne
    b210:	463b      	movne	r3, r7
    b212:	2300      	moveq	r3, #0
        switch(type) {
    b214:	2d0a      	cmp	r5, #10
    b216:	d85d      	bhi.n	b2d4 <LogicGate::Calculate(unsigned short)+0xf8>
    b218:	e8df f005 	tbb	[pc, r5]
    b21c:	140d0b06 	.word	0x140d0b06
    b220:	23211a16 	.word	0x23211a16
    b224:	3c2d      	.short	0x3c2d
    b226:	46          	.byte	0x46
    b227:	00          	.byte	0x00
    bool not_fn(bool a) {return !a;}
    b228:	fabc f38c 	clz	r3, ip
    b22c:	095b      	lsrs	r3, r3, #5
            default                        : state = 0;
    b22e:	7003      	strb	r3, [r0, #0]
    b230:	e01e      	b.n	b270 <LogicGate::Calculate(unsigned short)+0x94>
            case LogicGateType::AND        : state = and_fn(v1, v2); break;
    b232:	4033      	ands	r3, r6
    b234:	e7fb      	b.n	b22e <LogicGate::Calculate(unsigned short)+0x52>
    bool or_fn(bool a, bool b) {return a | b;}
    b236:	ea42 020e 	orr.w	r2, r2, lr
    b23a:	4211      	tst	r1, r2
    b23c:	bf14      	ite	ne
    b23e:	2301      	movne	r3, #1
    b240:	2300      	moveq	r3, #0
    b242:	e7f4      	b.n	b22e <LogicGate::Calculate(unsigned short)+0x52>
    bool xor_fn(bool a, bool b) {return a != b;}
    b244:	4073      	eors	r3, r6
    b246:	e7f2      	b.n	b22e <LogicGate::Calculate(unsigned short)+0x52>
            case LogicGateType::NAND       : state = !and_fn(v1, v2); break;
    b248:	4033      	ands	r3, r6
            case LogicGateType::XNOR       : state = !xor_fn(v1, v2); break;
    b24a:	f083 0301 	eor.w	r3, r3, #1
    b24e:	e7ee      	b.n	b22e <LogicGate::Calculate(unsigned short)+0x52>
            case LogicGateType::NOR        : state = !or_fn(v1, v2); break;
    b250:	ea42 020e 	orr.w	r2, r2, lr
    b254:	4211      	tst	r1, r2
    b256:	bf0c      	ite	eq
    b258:	2301      	moveq	r3, #1
    b25a:	2300      	movne	r3, #0
    b25c:	e7e7      	b.n	b22e <LogicGate::Calculate(unsigned short)+0x52>
    bool xor_fn(bool a, bool b) {return a != b;}
    b25e:	4073      	eors	r3, r6
    b260:	e7f3      	b.n	b24a <LogicGate::Calculate(unsigned short)+0x6e>
        if (!clock && clocked) clocked = 0;
    b262:	7843      	ldrb	r3, [r0, #1]
    b264:	f1b8 0f00 	cmp.w	r8, #0
    b268:	d136      	bne.n	b2d8 <LogicGate::Calculate(unsigned short)+0xfc>
    b26a:	b10b      	cbz	r3, b270 <LogicGate::Calculate(unsigned short)+0x94>
    b26c:	2300      	movs	r3, #0
    b26e:	7043      	strb	r3, [r0, #1]
        return state;
    b270:	7800      	ldrb	r0, [r0, #0]
    }
    b272:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (!clock && clocked) clocked = 0;
    b276:	7843      	ldrb	r3, [r0, #1]
        if (clock && T) state = 1 - state;
    b278:	7802      	ldrb	r2, [r0, #0]
        if (!clock && clocked) clocked = 0;
    b27a:	f1b8 0f00 	cmp.w	r8, #0
    b27e:	d0f4      	beq.n	b26a <LogicGate::Calculate(unsigned short)+0x8e>
        if (clock && clocked) clock = 0;
    b280:	2b00      	cmp	r3, #0
    b282:	d1f5      	bne.n	b270 <LogicGate::Calculate(unsigned short)+0x94>
        if (clock && !clocked) clocked = 1;
    b284:	2301      	movs	r3, #1
    b286:	7043      	strb	r3, [r0, #1]
        if (clock && T) state = 1 - state;
    b288:	f1bc 0f00 	cmp.w	ip, #0
    b28c:	d0f0      	beq.n	b270 <LogicGate::Calculate(unsigned short)+0x94>
    b28e:	405a      	eors	r2, r3
    b290:	7002      	strb	r2, [r0, #0]
    b292:	e7ed      	b.n	b270 <LogicGate::Calculate(unsigned short)+0x94>
        if (reset) state = 0;
    b294:	f1bc 0f00 	cmp.w	ip, #0
    b298:	d001      	beq.n	b29e <LogicGate::Calculate(unsigned short)+0xc2>
    b29a:	2300      	movs	r3, #0
    b29c:	7003      	strb	r3, [r0, #0]
        if (set) state = 1;
    b29e:	f1b8 0f00 	cmp.w	r8, #0
    b2a2:	d0e5      	beq.n	b270 <LogicGate::Calculate(unsigned short)+0x94>
    b2a4:	2301      	movs	r3, #1
    b2a6:	e7c2      	b.n	b22e <LogicGate::Calculate(unsigned short)+0x52>
        uint16_t v = source_state & (0x01 << source);
    b2a8:	b2a4      	uxth	r4, r4
        int v = (d1 * weight1) + (d2 * weight2) + (d3 * weight3);
    b2aa:	6985      	ldr	r5, [r0, #24]
        uint16_t v = source_state & (0x01 << source);
    b2ac:	fa07 f204 	lsl.w	r2, r7, r4
        int v = (d1 * weight1) + (d2 * weight2) + (d3 * weight3);
    b2b0:	6944      	ldr	r4, [r0, #20]
        return static_cast<bool>(v);
    b2b2:	4211      	tst	r1, r2
        int v = (d1 * weight1) + (d2 * weight2) + (d3 * weight3);
    b2b4:	fb05 f303 	mul.w	r3, r5, r3
    b2b8:	69c1      	ldr	r1, [r0, #28]
        return static_cast<bool>(v);
    b2ba:	bf14      	ite	ne
    b2bc:	2201      	movne	r2, #1
    b2be:	2200      	moveq	r2, #0
        int v = (d1 * weight1) + (d2 * weight2) + (d3 * weight3);
    b2c0:	fb04 3306 	mla	r3, r4, r6, r3
    b2c4:	fb01 3302 	mla	r3, r1, r2, r3
        return (v > threshold);
    b2c8:	6a02      	ldr	r2, [r0, #32]
    b2ca:	4293      	cmp	r3, r2
    b2cc:	bfd4      	ite	le
    b2ce:	2300      	movle	r3, #0
    b2d0:	2301      	movgt	r3, #1
    b2d2:	e7ac      	b.n	b22e <LogicGate::Calculate(unsigned short)+0x52>
            default                        : state = 0;
    b2d4:	2300      	movs	r3, #0
    b2d6:	e7aa      	b.n	b22e <LogicGate::Calculate(unsigned short)+0x52>
        if (clock && clocked) clock = 0;
    b2d8:	2b00      	cmp	r3, #0
    b2da:	d1c9      	bne.n	b270 <LogicGate::Calculate(unsigned short)+0x94>
        if (clock && !clocked) clocked = 1;
    b2dc:	2301      	movs	r3, #1
    b2de:	7043      	strb	r3, [r0, #1]
        if (clock) state = D;
    b2e0:	7006      	strb	r6, [r0, #0]
            case LogicGateType::D_FLIPFLOP : state = d_flipflop_fn(v1, v2); break;
    b2e2:	e7c5      	b.n	b270 <LogicGate::Calculate(unsigned short)+0x94>

0000b2e4 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)>:
        if (cursor < 4) { // Other cursors are handled in the left-hand pane
    b2e4:	2b03      	cmp	r3, #3
    void PrintParamNameAt(byte x, byte y, byte cursor) {
    b2e6:	b538      	push	{r3, r4, r5, lr}
    b2e8:	4605      	mov	r5, r0
    b2ea:	461c      	mov	r4, r3
        if (cursor < 4) { // Other cursors are handled in the left-hand pane
    b2ec:	d831      	bhi.n	b352 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x6e>
  text_x_ = x;
    b2ee:	4819      	ldr	r0, [pc, #100]	; (b354 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x70>)
            graphics.setPrintPos(x, y);
    b2f0:	6041      	str	r1, [r0, #4]
    b2f2:	6082      	str	r2, [r0, #8]
            if (cursor == 0) graphics.print("Type");
    b2f4:	b923      	cbnz	r3, b300 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x1c>
    b2f6:	4918      	ldr	r1, [pc, #96]	; (b358 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x74>)
    }
    b2f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                    graphics.print("Opd");
    b2fc:	f00e bbeb 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
                if (type == LogicGateType::D_FLIPFLOP) {
    b300:	686b      	ldr	r3, [r5, #4]
    b302:	2b08      	cmp	r3, #8
    b304:	d108      	bne.n	b318 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x34>
                    if (cursor == 1) graphics.print("Data");
    b306:	2c01      	cmp	r4, #1
    b308:	d101      	bne.n	b30e <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x2a>
    b30a:	4914      	ldr	r1, [pc, #80]	; (b35c <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x78>)
    b30c:	e7f4      	b.n	b2f8 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x14>
                    if (cursor == 2) graphics.print("Clock");
    b30e:	2c02      	cmp	r4, #2
    b310:	d11f      	bne.n	b352 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x6e>
    b312:	4913      	ldr	r1, [pc, #76]	; (b360 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x7c>)
    b314:	480f      	ldr	r0, [pc, #60]	; (b354 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x70>)
    b316:	e7ef      	b.n	b2f8 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x14>
                } else if (type == LogicGateType::T_FLIPFLOP) {
    b318:	2b09      	cmp	r3, #9
    b31a:	d103      	bne.n	b324 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x40>
                    if (cursor == 1) graphics.print("Toggl");
    b31c:	2c01      	cmp	r4, #1
    b31e:	d1f6      	bne.n	b30e <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x2a>
    b320:	4910      	ldr	r1, [pc, #64]	; (b364 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x80>)
    b322:	e7e9      	b.n	b2f8 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x14>
                } else if (type == LogicGateType::LATCH) {
    b324:	2b0a      	cmp	r3, #10
    b326:	d107      	bne.n	b338 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x54>
                    if (cursor == 1) graphics.print("Reset");
    b328:	2c01      	cmp	r4, #1
    b32a:	d101      	bne.n	b330 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x4c>
    b32c:	490e      	ldr	r1, [pc, #56]	; (b368 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x84>)
    b32e:	e7e3      	b.n	b2f8 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x14>
                    if (cursor == 2) graphics.print("Set");
    b330:	2c02      	cmp	r4, #2
    b332:	d10e      	bne.n	b352 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x6e>
    b334:	490d      	ldr	r1, [pc, #52]	; (b36c <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x88>)
    b336:	e7df      	b.n	b2f8 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x14>
                } else if (type == LogicGateType::TL_NEURON) {
    b338:	2b0b      	cmp	r3, #11
    b33a:	d108      	bne.n	b34e <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x6a>
                    graphics.print("Den ");
    b33c:	490c      	ldr	r1, [pc, #48]	; (b370 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x8c>)
    b33e:	f00e fbca 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                    graphics.print(cursor);
    b342:	4621      	mov	r1, r4
    b344:	4803      	ldr	r0, [pc, #12]	; (b354 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x70>)
    }
    b346:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                    graphics.print(cursor);
    b34a:	f00e bc38 	b.w	19bbe <weegfx::Graphics::print(int)>
                    graphics.print("Opd");
    b34e:	4909      	ldr	r1, [pc, #36]	; (b374 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x90>)
    b350:	e7d2      	b.n	b2f8 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)+0x14>
    }
    b352:	bd38      	pop	{r3, r4, r5, pc}
    b354:	200065e0 	.word	0x200065e0
    b358:	00020b0b 	.word	0x00020b0b
    b35c:	00020efe 	.word	0x00020efe
    b360:	000207ba 	.word	0x000207ba
    b364:	00021152 	.word	0x00021152
    b368:	0002135a 	.word	0x0002135a
    b36c:	000206ce 	.word	0x000206ce
    b370:	00021158 	.word	0x00021158
    b374:	0002115d 	.word	0x0002115d

0000b378 <NeuralNetwork::OnRightButtonPress()>:
    void OnRightButtonPress() {
    b378:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        if (copy_mode) {
    b37c:	f890 33f5 	ldrb.w	r3, [r0, #1013]	; 0x3f5
    void OnRightButtonPress() {
    b380:	4604      	mov	r4, r0
        if (copy_mode) {
    b382:	b15b      	cbz	r3, b39c <NeuralNetwork::OnRightButtonPress()+0x24>
            CopySetup(copy_setup_target, setup);
    b384:	f8d0 73f8 	ldr.w	r7, [r0, #1016]	; 0x3f8
    b388:	f8d0 83f0 	ldr.w	r8, [r0, #1008]	; 0x3f0
        if (source == target) {
    b38c:	4547      	cmp	r7, r8
    b38e:	d12a      	bne.n	b3e6 <NeuralNetwork::OnRightButtonPress()+0x6e>
            OnSendSysEx();
    b390:	6803      	ldr	r3, [r0, #0]
    b392:	691b      	ldr	r3, [r3, #16]
    b394:	4798      	blx	r3
        copy_mode = 0;
    b396:	2300      	movs	r3, #0
    b398:	f884 33f5 	strb.w	r3, [r4, #1013]	; 0x3f5
        cursor++;
    b39c:	f894 23ea 	ldrb.w	r2, [r4, #1002]	; 0x3ea
        if (selected < 6) {
    b3a0:	f8d4 33ec 	ldr.w	r3, [r4, #1004]	; 0x3ec
        cursor++;
    b3a4:	3201      	adds	r2, #1
    b3a6:	b2d2      	uxtb	r2, r2
        if (selected < 6) {
    b3a8:	2b05      	cmp	r3, #5
        cursor++;
    b3aa:	f884 23ea 	strb.w	r2, [r4, #1002]	; 0x3ea
        if (selected < 6) {
    b3ae:	dc48      	bgt.n	b442 <NeuralNetwork::OnRightButtonPress()+0xca>
            byte ix = (setup * 6) + selected;
    b3b0:	f8d4 13f0 	ldr.w	r1, [r4, #1008]	; 0x3f0
    b3b4:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    b3b8:	eb03 0341 	add.w	r3, r3, r1, lsl #1
            if (cursor >= neuron[ix].NumParam()) cursor = 0;
    b3bc:	b2db      	uxtb	r3, r3
    b3be:	2124      	movs	r1, #36	; 0x24
    b3c0:	fb01 4303 	mla	r3, r1, r3, r4
    b3c4:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    b3c8:	2b0b      	cmp	r3, #11
    b3ca:	bf9a      	itte	ls
    b3cc:	491e      	ldrls	r1, [pc, #120]	; (b448 <NeuralNetwork::OnRightButtonPress()+0xd0>)
    b3ce:	5ccb      	ldrbls	r3, [r1, r3]
    b3d0:	2303      	movhi	r3, #3
    b3d2:	429a      	cmp	r2, r3
    b3d4:	d302      	bcc.n	b3dc <NeuralNetwork::OnRightButtonPress()+0x64>
    b3d6:	2300      	movs	r3, #0
    b3d8:	f884 33ea 	strb.w	r3, [r4, #1002]	; 0x3ea
        cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    b3dc:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    b3e0:	6263      	str	r3, [r4, #36]	; 0x24
    }
    b3e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                memcpy(&neuron[(target * 6) + n], &neuron[(source * 6) + n], sizeof(neuron[(source * 6) + n]));
    b3e6:	2306      	movs	r3, #6
    b3e8:	fb03 f107 	mul.w	r1, r3, r7
    b3ec:	2224      	movs	r2, #36	; 0x24
    b3ee:	fb03 f508 	mul.w	r5, r3, r8
    b3f2:	fb02 0601 	mla	r6, r2, r1, r0
    b3f6:	1a6d      	subs	r5, r5, r1
    b3f8:	f506 767f 	add.w	r6, r6, #1020	; 0x3fc
    b3fc:	4355      	muls	r5, r2
    b3fe:	f04f 0900 	mov.w	r9, #0
    b402:	1971      	adds	r1, r6, r5
    b404:	4630      	mov	r0, r6
    b406:	2224      	movs	r2, #36	; 0x24
            for (byte n = 0; n < 6; n++)
    b408:	f109 0901 	add.w	r9, r9, #1
                memcpy(&neuron[(target * 6) + n], &neuron[(source * 6) + n], sizeof(neuron[(source * 6) + n]));
    b40c:	f00e fdf0 	bl	19ff0 <memcpy>
            for (byte n = 0; n < 6; n++)
    b410:	f1b9 0f06 	cmp.w	r9, #6
    b414:	f106 0624 	add.w	r6, r6, #36	; 0x24
    b418:	d1f3      	bne.n	b402 <NeuralNetwork::OnRightButtonPress()+0x8a>
    b41a:	eb04 1308 	add.w	r3, r4, r8, lsl #4
    b41e:	f504 62ed 	add.w	r2, r4, #1896	; 0x768
                output_neuron[(target * 4) + 0] = output_neuron[(source * 4) + o];
    b422:	eb04 1107 	add.w	r1, r4, r7, lsl #4
    b426:	f503 63eb 	add.w	r3, r3, #1880	; 0x758
    b42a:	eb02 1208 	add.w	r2, r2, r8, lsl #4
    b42e:	f501 61eb 	add.w	r1, r1, #1880	; 0x758
    b432:	f853 0f04 	ldr.w	r0, [r3, #4]!
    b436:	6048      	str	r0, [r1, #4]
            for (byte o = 0; o < 4; o++)
    b438:	429a      	cmp	r2, r3
    b43a:	d1fa      	bne.n	b432 <NeuralNetwork::OnRightButtonPress()+0xba>
            setup = target;
    b43c:	f8c4 73f0 	str.w	r7, [r4, #1008]	; 0x3f0
    b440:	e7a9      	b.n	b396 <NeuralNetwork::OnRightButtonPress()+0x1e>
            if (cursor >= 4) cursor = 0;
    b442:	2a03      	cmp	r2, #3
    b444:	d8c7      	bhi.n	b3d6 <NeuralNetwork::OnRightButtonPress()+0x5e>
    b446:	e7c9      	b.n	b3dc <NeuralNetwork::OnRightButtonPress()+0x64>
    b448:	00022f38 	.word	0x00022f38

0000b44c <NeuralNetwork_handleButtonEvent(UI::Event const&)>:
    if (event.control == OC::CONTROL_BUTTON_L) {
    b44c:	8843      	ldrh	r3, [r0, #2]
    b44e:	2b04      	cmp	r3, #4
void NeuralNetwork_handleButtonEvent(const UI::Event &event) {
    b450:	b510      	push	{r4, lr}
    b452:	4604      	mov	r4, r0
    if (event.control == OC::CONTROL_BUTTON_L) {
    b454:	d126      	bne.n	b4a4 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x58>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) NeuralNetwork_instance.OnLeftButtonLongPress();
    b456:	7803      	ldrb	r3, [r0, #0]
    b458:	2b02      	cmp	r3, #2
    b45a:	4b33      	ldr	r3, [pc, #204]	; (b528 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0xdc>)
    b45c:	d114      	bne.n	b488 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x3c>
        all_connections = 1 - all_connections;
    b45e:	f893 23f6 	ldrb.w	r2, [r3, #1014]	; 0x3f6
    b462:	f082 0201 	eor.w	r2, r2, #1
    b466:	f883 23f6 	strb.w	r2, [r3, #1014]	; 0x3f6
    if (event.control == OC::CONTROL_BUTTON_UP) NeuralNetwork_instance.OnUpButtonPress();
    b46a:	8863      	ldrh	r3, [r4, #2]
    b46c:	2b01      	cmp	r3, #1
    b46e:	d132      	bne.n	b4d6 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x8a>
        if (copy_mode) {
    b470:	4b2d      	ldr	r3, [pc, #180]	; (b528 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0xdc>)
    b472:	f893 13f5 	ldrb.w	r1, [r3, #1013]	; 0x3f5
    b476:	b1f1      	cbz	r1, b4b6 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x6a>
            copy_setup_target = constrain(copy_setup_target + 1, 0, 3);
    b478:	f8d3 23f8 	ldr.w	r2, [r3, #1016]	; 0x3f8
    b47c:	3201      	adds	r2, #1
    b47e:	f382 0202 	usat	r2, #2, r2
        if (copy_setup_target > 3) copy_setup_target = 0;
    b482:	f8c3 23f8 	str.w	r2, [r3, #1016]	; 0x3f8
}
    b486:	e025      	b.n	b4d4 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x88>
        if (copy_mode) copy_mode = 0;
    b488:	f893 23f5 	ldrb.w	r2, [r3, #1013]	; 0x3f5
    b48c:	b11a      	cbz	r2, b496 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x4a>
    b48e:	2200      	movs	r2, #0
    b490:	f883 23f5 	strb.w	r2, [r3, #1013]	; 0x3f5
    b494:	e7e9      	b.n	b46a <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x1e>
        else screen = 1 - screen;
    b496:	f893 23f4 	ldrb.w	r2, [r3, #1012]	; 0x3f4
    b49a:	f082 0201 	eor.w	r2, r2, #1
    b49e:	f883 23f4 	strb.w	r2, [r3, #1012]	; 0x3f4
    b4a2:	e7e2      	b.n	b46a <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x1e>
    if (event.control == OC::CONTROL_BUTTON_R && event.type == UI::EVENT_BUTTON_PRESS) NeuralNetwork_instance.OnRightButtonPress();
    b4a4:	2b08      	cmp	r3, #8
    b4a6:	d1e0      	bne.n	b46a <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x1e>
    b4a8:	7803      	ldrb	r3, [r0, #0]
    b4aa:	2b01      	cmp	r3, #1
    b4ac:	d1dd      	bne.n	b46a <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x1e>
    b4ae:	481e      	ldr	r0, [pc, #120]	; (b528 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0xdc>)
    b4b0:	f7ff ff62 	bl	b378 <NeuralNetwork::OnRightButtonPress()>
    b4b4:	e7d9      	b.n	b46a <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x1e>
            setup = constrain(setup + 1, 0, 3);
    b4b6:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	; 0x3f0
            cursor = 0;
    b4ba:	f883 13ea 	strb.w	r1, [r3, #1002]	; 0x3ea
            setup = constrain(setup + 1, 0, 3);
    b4be:	3201      	adds	r2, #1
    b4c0:	f382 0202 	usat	r2, #2, r2
    b4c4:	f8c3 23f0 	str.w	r2, [r3, #1008]	; 0x3f0
            if (selected < 6) selected = 0;
    b4c8:	f8d3 23ec 	ldr.w	r2, [r3, #1004]	; 0x3ec
    b4cc:	2a05      	cmp	r2, #5
    b4ce:	dc01      	bgt.n	b4d4 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x88>
    b4d0:	f8c3 13ec 	str.w	r1, [r3, #1004]	; 0x3ec
}
    b4d4:	bd10      	pop	{r4, pc}
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
    b4d6:	2b02      	cmp	r3, #2
    b4d8:	d1fc      	bne.n	b4d4 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x88>
        if (event.type == UI::EVENT_BUTTON_PRESS) NeuralNetwork_instance.OnDownButtonPress();
    b4da:	7823      	ldrb	r3, [r4, #0]
    b4dc:	2b01      	cmp	r3, #1
    b4de:	d112      	bne.n	b506 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0xba>
        if (copy_mode) {
    b4e0:	4b11      	ldr	r3, [pc, #68]	; (b528 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0xdc>)
    b4e2:	f893 23f5 	ldrb.w	r2, [r3, #1013]	; 0x3f5
    b4e6:	b132      	cbz	r2, b4f6 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0xaa>
            copy_setup_target = constrain(copy_setup_target - 1, 0, 3);
    b4e8:	f8d3 23f8 	ldr.w	r2, [r3, #1016]	; 0x3f8
    b4ec:	3a01      	subs	r2, #1
    b4ee:	f382 0202 	usat	r2, #2, r2
    b4f2:	f8c3 23f8 	str.w	r2, [r3, #1016]	; 0x3f8
        setup = constrain(setup - 1, 0, 3);
    b4f6:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	; 0x3f0
    b4fa:	3a01      	subs	r2, #1
    b4fc:	f382 0202 	usat	r2, #2, r2
    b500:	f8c3 23f0 	str.w	r2, [r3, #1008]	; 0x3f0
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) NeuralNetwork_instance.OnDownButtonLongPress();
    b504:	e7e6      	b.n	b4d4 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x88>
    b506:	2b02      	cmp	r3, #2
    b508:	d1e4      	bne.n	b4d4 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x88>
        copy_mode = 1 - copy_mode;
    b50a:	4b07      	ldr	r3, [pc, #28]	; (b528 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0xdc>)
    b50c:	f893 23f5 	ldrb.w	r2, [r3, #1013]	; 0x3f5
    b510:	f082 0201 	eor.w	r2, r2, #1
    b514:	f883 23f5 	strb.w	r2, [r3, #1013]	; 0x3f5
        copy_setup_target = setup + 1;
    b518:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	; 0x3f0
    b51c:	3201      	adds	r2, #1
        if (copy_setup_target > 3) copy_setup_target = 0;
    b51e:	2a03      	cmp	r2, #3
    b520:	bfc8      	it	gt
    b522:	2200      	movgt	r2, #0
    b524:	e7ad      	b.n	b482 <NeuralNetwork_handleButtonEvent(UI::Event const&)+0x36>
    b526:	bf00      	nop
    b528:	2000058c 	.word	0x2000058c

0000b52c <NeuralNetwork::DrawSelectorScreen()>:
    void DrawSelectorScreen() {
    b52c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        byte offset_ix = setup * 6;
    b530:	f8d0 73f0 	ldr.w	r7, [r0, #1008]	; 0x3f0
    b534:	f8df 9218 	ldr.w	r9, [pc, #536]	; b750 <NeuralNetwork::DrawSelectorScreen()+0x224>
    b538:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    b53c:	007f      	lsls	r7, r7, #1
    void DrawSelectorScreen() {
    b53e:	b087      	sub	sp, #28
    b540:	4604      	mov	r4, r0
        byte offset_ix = setup * 6;
    b542:	b2ff      	uxtb	r7, r7
    b544:	2600      	movs	r6, #0
            graphics.print(gate_name[type]);
    b546:	f04f 0824 	mov.w	r8, #36	; 0x24
            neuron[ix].DrawSmallAt(x + 1, y, (selected == n && CursorBlink()));
    b54a:	f8d4 23ec 	ldr.w	r2, [r4, #1004]	; 0x3ec
            byte cell_y = n % 2;
    b54e:	f006 0b01 	and.w	fp, r6, #1
    b552:	fa57 f586 	uxtab	r5, r7, r6
            byte x = (cell_x * 32) + 24;
    b556:	0133      	lsls	r3, r6, #4
            byte y = (cell_y * 24) + 16;
    b558:	eb0b 0b4b 	add.w	fp, fp, fp, lsl #1
            neuron[ix].DrawSmallAt(x + 1, y, (selected == n && CursorBlink()));
    b55c:	42b2      	cmp	r2, r6
    b55e:	fa5f fa86 	uxtb.w	sl, r6
            byte ix = offset_ix + n;
    b562:	b2ed      	uxtb	r5, r5
            byte x = (cell_x * 32) + 24;
    b564:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
            byte y = (cell_y * 24) + 16;
    b568:	ea4f 0bcb 	mov.w	fp, fp, lsl #3
            neuron[ix].DrawSmallAt(x + 1, y, (selected == n && CursorBlink()));
    b56c:	d117      	bne.n	b59e <NeuralNetwork::DrawSelectorScreen()+0x72>
    b56e:	6a62      	ldr	r2, [r4, #36]	; 0x24
    b570:	2a00      	cmp	r2, #0
    b572:	dd14      	ble.n	b59e <NeuralNetwork::DrawSelectorScreen()+0x72>
    b574:	fb08 4205 	mla	r2, r8, r5, r4
    b578:	4875      	ldr	r0, [pc, #468]	; (b750 <NeuralNetwork::DrawSelectorScreen()+0x224>)
    b57a:	f8d2 1400 	ldr.w	r1, [r2, #1024]	; 0x400
    b57e:	9303      	str	r3, [sp, #12]
    b580:	f103 0219 	add.w	r2, r3, #25
            graphics.setPrintPos(x, y);
    b584:	b2d2      	uxtb	r2, r2
    b586:	f8c9 2004 	str.w	r2, [r9, #4]
    b58a:	f10b 0210 	add.w	r2, fp, #16
    b58e:	f8c9 2008 	str.w	r2, [r9, #8]
            graphics.print(gate_name[type]);
    b592:	4a70      	ldr	r2, [pc, #448]	; (b754 <NeuralNetwork::DrawSelectorScreen()+0x228>)
    b594:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    b598:	f00e fa9d 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    b59c:	9b03      	ldr	r3, [sp, #12]
        graphics.drawBitmap8(x + 4, y + 10, 16, NN_LOGIC_ICON[type]);
    b59e:	f103 011d 	add.w	r1, r3, #29
    b5a2:	fb08 4305 	mla	r3, r8, r5, r4
    b5a6:	b2c9      	uxtb	r1, r1
    b5a8:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    b5ac:	4b6a      	ldr	r3, [pc, #424]	; (b758 <NeuralNetwork::DrawSelectorScreen()+0x22c>)
    b5ae:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    b5b2:	9300      	str	r3, [sp, #0]
    b5b4:	f10b 021a 	add.w	r2, fp, #26
    b5b8:	2310      	movs	r3, #16
    b5ba:	4648      	mov	r0, r9
    b5bc:	f00e f842 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
            if (selected == n || all_connections) {
    b5c0:	f8d4 33ec 	ldr.w	r3, [r4, #1004]	; 0x3ec
    b5c4:	42b3      	cmp	r3, r6
    b5c6:	d002      	beq.n	b5ce <NeuralNetwork::DrawSelectorScreen()+0xa2>
    b5c8:	f894 33f6 	ldrb.w	r3, [r4, #1014]	; 0x3f6
    b5cc:	b313      	cbz	r3, b614 <NeuralNetwork::DrawSelectorScreen()+0xe8>
        if (type > LogicGateType::NONE) draw_line_from(source1, n);
    b5ce:	fb08 4305 	mla	r3, r8, r5, r4
    b5d2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    b5d6:	2a00      	cmp	r2, #0
    b5d8:	dd04      	ble.n	b5e4 <NeuralNetwork::DrawSelectorScreen()+0xb8>
    b5da:	f893 0404 	ldrb.w	r0, [r3, #1028]	; 0x404
    b5de:	4651      	mov	r1, sl
    b5e0:	f7f9 f9a4 	bl	492c <LogicGate::draw_line_from(unsigned char, unsigned char) [clone .isra.0]>
        if (type >= LogicGateType::AND) draw_line_from(source2, n);
    b5e4:	fb08 4305 	mla	r3, r8, r5, r4
    b5e8:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    b5ec:	2a01      	cmp	r2, #1
    b5ee:	dd04      	ble.n	b5fa <NeuralNetwork::DrawSelectorScreen()+0xce>
    b5f0:	f893 0408 	ldrb.w	r0, [r3, #1032]	; 0x408
    b5f4:	4651      	mov	r1, sl
    b5f6:	f7f9 f999 	bl	492c <LogicGate::draw_line_from(unsigned char, unsigned char) [clone .isra.0]>
        if (type == LogicGateType::TL_NEURON) draw_line_from(source3, n);
    b5fa:	fb08 4305 	mla	r3, r8, r5, r4
    b5fe:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    b602:	2b0b      	cmp	r3, #11
    b604:	d106      	bne.n	b614 <NeuralNetwork::DrawSelectorScreen()+0xe8>
            neuron[ix].DrawSmallAt(x + 1, y, (selected == n && CursorBlink()));
    b606:	fb08 4505 	mla	r5, r8, r5, r4
    b60a:	4651      	mov	r1, sl
    b60c:	f895 040c 	ldrb.w	r0, [r5, #1036]	; 0x40c
    b610:	f7f9 f98c 	bl	492c <LogicGate::draw_line_from(unsigned char, unsigned char) [clone .isra.0]>
        for (byte n = 0; n < 6; n++)
    b614:	3601      	adds	r6, #1
    b616:	2e06      	cmp	r6, #6
    b618:	d197      	bne.n	b54a <NeuralNetwork::DrawSelectorScreen()+0x1e>
    b61a:	4d4d      	ldr	r5, [pc, #308]	; (b750 <NeuralNetwork::DrawSelectorScreen()+0x224>)
        graphics.print(str);
    b61c:	494f      	ldr	r1, [pc, #316]	; (b75c <NeuralNetwork::DrawSelectorScreen()+0x230>)
  text_y_ = y;
    b61e:	2310      	movs	r3, #16
  text_x_ = x;
    b620:	2700      	movs	r7, #0
    b622:	4628      	mov	r0, r5
    b624:	606f      	str	r7, [r5, #4]
  text_y_ = y;
    b626:	60ab      	str	r3, [r5, #8]
    b628:	f00e fa55 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        for (byte i = 0; i < 8; i++)
    b62c:	f204 799b 	addw	r9, r4, #1947	; 0x79b
        graphics.invertRect(x, y, w, h);
    b630:	f04f 0a08 	mov.w	sl, #8
            byte cell_y = i % 4;
    b634:	f007 0103 	and.w	r1, r7, #3
            byte cell_x = i / 4;
    b638:	f3c7 0685 	ubfx	r6, r7, #2, #6
            byte y = (cell_y * 10) + 24;
    b63c:	eb01 0881 	add.w	r8, r1, r1, lsl #2
            byte x = (cell_x * 6);
    b640:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    b644:	0076      	lsls	r6, r6, #1
            byte y = (cell_y * 10) + 24;
    b646:	ea4f 0848 	mov.w	r8, r8, lsl #1
            gfxPrint(x, y, cell_y + 1);
    b64a:	b2f6      	uxtb	r6, r6
    b64c:	f108 0818 	add.w	r8, r8, #24
        graphics.print(num);
    b650:	3101      	adds	r1, #1
    b652:	4628      	mov	r0, r5
  text_x_ = x;
    b654:	606e      	str	r6, [r5, #4]
  text_y_ = y;
    b656:	f8c5 8008 	str.w	r8, [r5, #8]
    b65a:	f00e fab0 	bl	19bbe <weegfx::Graphics::print(int)>
            if (input_state[i]) gfxInvert(x, y, 6, 8);
    b65e:	f819 3f01 	ldrb.w	r3, [r9, #1]!
    b662:	b13b      	cbz	r3, b674 <NeuralNetwork::DrawSelectorScreen()+0x148>
        graphics.invertRect(x, y, w, h);
    b664:	f8cd a000 	str.w	sl, [sp]
    b668:	2306      	movs	r3, #6
    b66a:	4642      	mov	r2, r8
    b66c:	4631      	mov	r1, r6
    b66e:	4628      	mov	r0, r5
    b670:	f00d fed5 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
        for (byte i = 0; i < 8; i++)
    b674:	3701      	adds	r7, #1
    b676:	2f08      	cmp	r7, #8
    b678:	d1dc      	bne.n	b634 <NeuralNetwork::DrawSelectorScreen()+0x108>
    b67a:	2700      	movs	r7, #0
        graphics.print(str);
    b67c:	f8df b0d0 	ldr.w	fp, [pc, #208]	; b750 <NeuralNetwork::DrawSelectorScreen()+0x224>
    b680:	f104 0938 	add.w	r9, r4, #56	; 0x38
    b684:	f04f 0810 	mov.w	r8, #16
            char out_name[2] = {static_cast<char>(o + 'A'), '\0'};
    b688:	46ba      	mov	sl, r7
    b68a:	b2fe      	uxtb	r6, r7
    b68c:	f106 0341 	add.w	r3, r6, #65	; 0x41
    b690:	f88d 3014 	strb.w	r3, [sp, #20]
    b694:	a905      	add	r1, sp, #20
  text_x_ = x;
    b696:	2378      	movs	r3, #120	; 0x78
    b698:	4658      	mov	r0, fp
    b69a:	606b      	str	r3, [r5, #4]
    b69c:	f88d a015 	strb.w	sl, [sp, #21]
  text_y_ = y;
    b6a0:	f8c5 8008 	str.w	r8, [r5, #8]
    b6a4:	f00e fa17 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (ViewOut(o)) gfxInvert(x, y, 6, 8);
    b6a8:	f859 3f04 	ldr.w	r3, [r9, #4]!
    b6ac:	b13b      	cbz	r3, b6be <NeuralNetwork::DrawSelectorScreen()+0x192>
        graphics.invertRect(x, y, w, h);
    b6ae:	2308      	movs	r3, #8
    b6b0:	9300      	str	r3, [sp, #0]
    b6b2:	4642      	mov	r2, r8
    b6b4:	2306      	movs	r3, #6
    b6b6:	2178      	movs	r1, #120	; 0x78
    b6b8:	4658      	mov	r0, fp
    b6ba:	f00d feb0 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
            byte ix = (setup * 4) + o;
    b6be:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	; 0x3f0
            if (output_neuron[ix] == selected || all_connections) {
    b6c2:	f8d4 23ec 	ldr.w	r2, [r4, #1004]	; 0x3ec
            byte ix = (setup * 4) + o;
    b6c6:	eb06 0683 	add.w	r6, r6, r3, lsl #2
            if (output_neuron[ix] == selected || all_connections) {
    b6ca:	b2f6      	uxtb	r6, r6
    b6cc:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    b6d0:	f8d6 175c 	ldr.w	r1, [r6, #1884]	; 0x75c
    b6d4:	4291      	cmp	r1, r2
    b6d6:	d002      	beq.n	b6de <NeuralNetwork::DrawSelectorScreen()+0x1b2>
    b6d8:	f894 23f6 	ldrb.w	r2, [r4, #1014]	; 0x3f6
    b6dc:	b30a      	cbz	r2, b722 <NeuralNetwork::DrawSelectorScreen()+0x1f6>
                if (neuron[(setup * 6) + output_neuron[ix]].type > LogicGateType::NONE) {
    b6de:	2206      	movs	r2, #6
    b6e0:	fb02 1303 	mla	r3, r2, r3, r1
    b6e4:	2224      	movs	r2, #36	; 0x24
    b6e6:	fb02 4303 	mla	r3, r2, r3, r4
    b6ea:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    b6ee:	2b00      	cmp	r3, #0
    b6f0:	dd17      	ble.n	b722 <NeuralNetwork::DrawSelectorScreen()+0x1f6>
                    byte fy = ((output_neuron[ix] % 2) * 24) + 29;
    b6f2:	f001 0201 	and.w	r2, r1, #1
    b6f6:	2900      	cmp	r1, #0
    b6f8:	bfb8      	it	lt
    b6fa:	4252      	neglt	r2, r2
                    byte fx = ((output_neuron[ix] / 2) * 32) + 45;
    b6fc:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
                    byte fy = ((output_neuron[ix] % 2) * 24) + 29;
    b700:	eb02 0242 	add.w	r2, r2, r2, lsl #1
                    byte fx = ((output_neuron[ix] / 2) * 32) + 45;
    b704:	1049      	asrs	r1, r1, #1
        graphics.drawLine(x, y, x2, y2, p);
    b706:	2304      	movs	r3, #4
                    byte fy = ((output_neuron[ix] % 2) * 24) + 29;
    b708:	00d2      	lsls	r2, r2, #3
                    byte fx = ((output_neuron[ix] / 2) * 32) + 45;
    b70a:	0149      	lsls	r1, r1, #5
                    byte fy = ((output_neuron[ix] % 2) * 24) + 29;
    b70c:	321d      	adds	r2, #29
                    byte fx = ((output_neuron[ix] / 2) * 32) + 45;
    b70e:	312d      	adds	r1, #45	; 0x2d
    b710:	9301      	str	r3, [sp, #4]
    b712:	4443      	add	r3, r8
    b714:	9300      	str	r3, [sp, #0]
    b716:	b2d2      	uxtb	r2, r2
    b718:	2378      	movs	r3, #120	; 0x78
    b71a:	b2c9      	uxtb	r1, r1
    b71c:	4658      	mov	r0, fp
    b71e:	f00d ffdd 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
        for (byte o = 0; o < 4; o++)
    b722:	3701      	adds	r7, #1
    b724:	2f04      	cmp	r7, #4
    b726:	f108 080c 	add.w	r8, r8, #12
    b72a:	d1ae      	bne.n	b68a <NeuralNetwork::DrawSelectorScreen()+0x15e>
        if (selected == 6 && CursorBlink()) gfxLine(118, 16, 118, 60);
    b72c:	f8d4 33ec 	ldr.w	r3, [r4, #1004]	; 0x3ec
    b730:	2b06      	cmp	r3, #6
    b732:	d10a      	bne.n	b74a <NeuralNetwork::DrawSelectorScreen()+0x21e>
    b734:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b736:	2b00      	cmp	r3, #0
    b738:	dd07      	ble.n	b74a <NeuralNetwork::DrawSelectorScreen()+0x21e>
        graphics.drawLine(x, y, x2, y2);
    b73a:	233c      	movs	r3, #60	; 0x3c
    b73c:	9300      	str	r3, [sp, #0]
    b73e:	2376      	movs	r3, #118	; 0x76
    b740:	4803      	ldr	r0, [pc, #12]	; (b750 <NeuralNetwork::DrawSelectorScreen()+0x224>)
    b742:	2210      	movs	r2, #16
    b744:	4619      	mov	r1, r3
    b746:	f00e f853 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    }
    b74a:	b007      	add	sp, #28
    b74c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b750:	200065e0 	.word	0x200065e0
    b754:	00024240 	.word	0x00024240
    b758:	00023d60 	.word	0x00023d60
    b75c:	00021161 	.word	0x00021161

0000b760 <NeuralNetwork::DrawCopyScreen()>:
    void DrawCopyScreen() {
    b760:	b570      	push	{r4, r5, r6, lr}
  text_x_ = x;
    b762:	4c26      	ldr	r4, [pc, #152]	; (b7fc <NeuralNetwork::DrawCopyScreen()+0x9c>)
        gfxHeader("Copy");
    b764:	4926      	ldr	r1, [pc, #152]	; (b800 <NeuralNetwork::DrawCopyScreen()+0xa0>)
    void DrawCopyScreen() {
    b766:	4605      	mov	r5, r0
  text_y_ = y;
    b768:	261c      	movs	r6, #28
        gfxHeader("Copy");
    b76a:	f7fa fb0b 	bl	5d84 <HSApplication::gfxHeader(char const*)>
  text_x_ = x;
    b76e:	2308      	movs	r3, #8
        graphics.print("Setup ");
    b770:	4924      	ldr	r1, [pc, #144]	; (b804 <NeuralNetwork::DrawCopyScreen()+0xa4>)
    b772:	6063      	str	r3, [r4, #4]
    b774:	4620      	mov	r0, r4
  text_y_ = y;
    b776:	60a6      	str	r6, [r4, #8]
    b778:	f00e f9ad 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(setup + 1);
    b77c:	f8d5 13f0 	ldr.w	r1, [r5, #1008]	; 0x3f0
    b780:	4620      	mov	r0, r4
    b782:	3101      	adds	r1, #1
    b784:	f00e fa1b 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(" -");
    b788:	491f      	ldr	r1, [pc, #124]	; (b808 <NeuralNetwork::DrawCopyScreen()+0xa8>)
    b78a:	4620      	mov	r0, r4
    b78c:	f00e f9a3 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    b790:	233a      	movs	r3, #58	; 0x3a
        graphics.print("> ");
    b792:	491e      	ldr	r1, [pc, #120]	; (b80c <NeuralNetwork::DrawCopyScreen()+0xac>)
    b794:	6063      	str	r3, [r4, #4]
    b796:	4620      	mov	r0, r4
  text_y_ = y;
    b798:	60a6      	str	r6, [r4, #8]
    b79a:	f00e f99c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (setup == copy_setup_target) graphics.print("SysEx");
    b79e:	f8d5 23f0 	ldr.w	r2, [r5, #1008]	; 0x3f0
    b7a2:	f8d5 33f8 	ldr.w	r3, [r5, #1016]	; 0x3f8
    b7a6:	429a      	cmp	r2, r3
    b7a8:	d11d      	bne.n	b7e6 <NeuralNetwork::DrawCopyScreen()+0x86>
    b7aa:	4919      	ldr	r1, [pc, #100]	; (b810 <NeuralNetwork::DrawCopyScreen()+0xb0>)
    b7ac:	4620      	mov	r0, r4
    b7ae:	f00e f992 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    b7b2:	2300      	movs	r3, #0
  text_y_ = y;
    b7b4:	2637      	movs	r6, #55	; 0x37
        graphics.print("[CANCEL]");
    b7b6:	4917      	ldr	r1, [pc, #92]	; (b814 <NeuralNetwork::DrawCopyScreen()+0xb4>)
    b7b8:	4810      	ldr	r0, [pc, #64]	; (b7fc <NeuralNetwork::DrawCopyScreen()+0x9c>)
  text_x_ = x;
    b7ba:	6063      	str	r3, [r4, #4]
  text_y_ = y;
    b7bc:	60a6      	str	r6, [r4, #8]
    b7be:	f00e f98a 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    b7c2:	235a      	movs	r3, #90	; 0x5a
        graphics.print(setup == copy_setup_target ? "[DUMP]" : "[COPY]");
    b7c4:	f8d5 03f0 	ldr.w	r0, [r5, #1008]	; 0x3f0
    b7c8:	f8d5 13f8 	ldr.w	r1, [r5, #1016]	; 0x3f8
    b7cc:	6063      	str	r3, [r4, #4]
    b7ce:	4a12      	ldr	r2, [pc, #72]	; (b818 <NeuralNetwork::DrawCopyScreen()+0xb8>)
    b7d0:	4b12      	ldr	r3, [pc, #72]	; (b81c <NeuralNetwork::DrawCopyScreen()+0xbc>)
  text_y_ = y;
    b7d2:	60a6      	str	r6, [r4, #8]
    b7d4:	4288      	cmp	r0, r1
    b7d6:	bf0c      	ite	eq
    b7d8:	4611      	moveq	r1, r2
    b7da:	4619      	movne	r1, r3
    }
    b7dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        graphics.print(setup == copy_setup_target ? "[DUMP]" : "[COPY]");
    b7e0:	4806      	ldr	r0, [pc, #24]	; (b7fc <NeuralNetwork::DrawCopyScreen()+0x9c>)
    b7e2:	f00e b978 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.print("Setup ");
    b7e6:	4620      	mov	r0, r4
    b7e8:	4906      	ldr	r1, [pc, #24]	; (b804 <NeuralNetwork::DrawCopyScreen()+0xa4>)
    b7ea:	f00e f974 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            graphics.print(copy_setup_target + 1);
    b7ee:	f8d5 13f8 	ldr.w	r1, [r5, #1016]	; 0x3f8
    b7f2:	4620      	mov	r0, r4
    b7f4:	3101      	adds	r1, #1
    b7f6:	f00e f9e2 	bl	19bbe <weegfx::Graphics::print(int)>
    b7fa:	e7da      	b.n	b7b2 <NeuralNetwork::DrawCopyScreen()+0x52>
    b7fc:	200065e0 	.word	0x200065e0
    b800:	00021134 	.word	0x00021134
    b804:	00021109 	.word	0x00021109
    b808:	0001f2ee 	.word	0x0001f2ee
    b80c:	00020efb 	.word	0x00020efb
    b810:	00021139 	.word	0x00021139
    b814:	00020f47 	.word	0x00020f47
    b818:	00021126 	.word	0x00021126
    b81c:	0002112d 	.word	0x0002112d

0000b820 <NeuralNetwork::LoadFromEEPROMStage()>:
    void LoadFromEEPROMStage() {
    b820:	b4f0      	push	{r4, r5, r6, r7}
    b822:	4602      	mov	r2, r0
    b824:	f500 7c58 	add.w	ip, r0, #864	; 0x360
    b828:	4603      	mov	r3, r0
            neuron[n].type = values_[ix++];
    b82a:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
    b82e:	f8c3 1400 	str.w	r1, [r3, #1024]	; 0x400
            neuron[n].source1 = values_[ix++];
    b832:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
    b836:	f8c3 1404 	str.w	r1, [r3, #1028]	; 0x404
            neuron[n].source2 = values_[ix++];
    b83a:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
    b83e:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
            neuron[n].source3 = values_[ix++];
    b842:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
    b846:	f8c3 140c 	str.w	r1, [r3, #1036]	; 0x40c
            neuron[n].weight1 = values_[ix++] - 128;
    b84a:	f8d2 5098 	ldr.w	r5, [r2, #152]	; 0x98
    b84e:	3d80      	subs	r5, #128	; 0x80
    b850:	f8c3 5410 	str.w	r5, [r3, #1040]	; 0x410
            neuron[n].weight2 = values_[ix++] - 128;
    b854:	f8d2 409c 	ldr.w	r4, [r2, #156]	; 0x9c
    b858:	3c80      	subs	r4, #128	; 0x80
    b85a:	f8c3 4414 	str.w	r4, [r3, #1044]	; 0x414
            neuron[n].weight3 = values_[ix++] - 128;
    b85e:	f8d2 10a0 	ldr.w	r1, [r2, #160]	; 0xa0
    b862:	3980      	subs	r1, #128	; 0x80
    b864:	f8c3 1418 	str.w	r1, [r3, #1048]	; 0x418
            if (neuron[n].weight1 == -128) neuron[n].weight1 = 0;
    b868:	f115 0f80 	cmn.w	r5, #128	; 0x80
            neuron[n].threshold = values_[ix++] - 128;
    b86c:	f8d2 70a4 	ldr.w	r7, [r2, #164]	; 0xa4
            if (neuron[n].weight1 == -128) neuron[n].weight1 = 0;
    b870:	bf08      	it	eq
    b872:	2500      	moveq	r5, #0
            if (neuron[n].weight2 == -128) neuron[n].weight2 = 0;
    b874:	f114 0f80 	cmn.w	r4, #128	; 0x80
    b878:	bf08      	it	eq
    b87a:	2400      	moveq	r4, #0
            if (neuron[n].weight3 == -128) neuron[n].weight3 = 0;
    b87c:	f111 0f80 	cmn.w	r1, #128	; 0x80
    b880:	bf08      	it	eq
    b882:	2100      	moveq	r1, #0
            if (neuron[n].threshold == -128) neuron[n].threshold = 0;
    b884:	2f00      	cmp	r7, #0
            neuron[n].threshold = values_[ix++] - 128;
    b886:	f1a7 0680 	sub.w	r6, r7, #128	; 0x80
            if (neuron[n].threshold == -128) neuron[n].threshold = 0;
    b88a:	bf08      	it	eq
    b88c:	2600      	moveq	r6, #0
    b88e:	f8c3 5410 	str.w	r5, [r3, #1040]	; 0x410
            if (neuron[n].weight2 == -128) neuron[n].weight2 = 0;
    b892:	f8c3 4414 	str.w	r4, [r3, #1044]	; 0x414
            if (neuron[n].weight3 == -128) neuron[n].weight3 = 0;
    b896:	f8c3 1418 	str.w	r1, [r3, #1048]	; 0x418
            if (neuron[n].threshold == -128) neuron[n].threshold = 0;
    b89a:	f8c3 641c 	str.w	r6, [r3, #1052]	; 0x41c
        for (byte n = 0; n < 24; n++)
    b89e:	3324      	adds	r3, #36	; 0x24
    b8a0:	4563      	cmp	r3, ip
    b8a2:	f102 0220 	add.w	r2, r2, #32
    b8a6:	d1c0      	bne.n	b82a <NeuralNetwork::LoadFromEEPROMStage()+0xa>
        for (byte o = 0; o < 16; o++) output_neuron[o] = values_[ix++];
    b8a8:	f500 7162 	add.w	r1, r0, #904	; 0x388
    }
    b8ac:	bcf0      	pop	{r4, r5, r6, r7}
        for (byte o = 0; o < 16; o++) output_neuron[o] = values_[ix++];
    b8ae:	2240      	movs	r2, #64	; 0x40
    b8b0:	f200 705c 	addw	r0, r0, #1884	; 0x75c
    b8b4:	f00e bb9c 	b.w	19ff0 <memcpy>

0000b8b8 <NeuralNetwork::Resume()>:
    void Resume() {
    b8b8:	b508      	push	{r3, lr}
        LoadFromEEPROMStage();
    b8ba:	f7ff ffb1 	bl	b820 <NeuralNetwork::LoadFromEEPROMStage()>
    }
    b8be:	bd08      	pop	{r3, pc}

0000b8c0 <NeuralNetwork_handleAppEvent(OC::AppEvent)>:
    if (event ==  OC::APP_EVENT_RESUME) {
    b8c0:	2801      	cmp	r0, #1
void NeuralNetwork_handleAppEvent(OC::AppEvent event) {
    b8c2:	b538      	push	{r3, r4, r5, lr}
    if (event ==  OC::APP_EVENT_RESUME) {
    b8c4:	d103      	bne.n	b8ce <NeuralNetwork_handleAppEvent(OC::AppEvent)+0xe>
        LoadFromEEPROMStage();
    b8c6:	4823      	ldr	r0, [pc, #140]	; (b954 <NeuralNetwork_handleAppEvent(OC::AppEvent)+0x94>)
    b8c8:	f7ff ffaa 	bl	b820 <NeuralNetwork::LoadFromEEPROMStage()>
}
    b8cc:	bd38      	pop	{r3, r4, r5, pc}
    if (event == OC::APP_EVENT_SUSPEND) {
    b8ce:	2800      	cmp	r0, #0
    b8d0:	d1fc      	bne.n	b8cc <NeuralNetwork_handleAppEvent(OC::AppEvent)+0xc>
    b8d2:	4b20      	ldr	r3, [pc, #128]	; (b954 <NeuralNetwork_handleAppEvent(OC::AppEvent)+0x94>)
    b8d4:	2108      	movs	r1, #8
    b8d6:	461a      	mov	r2, r3
            values_[ix++] = neuron[n].type;
    b8d8:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
    b8dc:	f8c2 0088 	str.w	r0, [r2, #136]	; 0x88
            values_[ix++] = neuron[n].source1;
    b8e0:	f8d3 0404 	ldr.w	r0, [r3, #1028]	; 0x404
    b8e4:	f8c2 008c 	str.w	r0, [r2, #140]	; 0x8c
            values_[ix++] = neuron[n].source2;
    b8e8:	f8d3 0408 	ldr.w	r0, [r3, #1032]	; 0x408
    b8ec:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
            values_[ix++] = neuron[n].source3;
    b8f0:	f8d3 040c 	ldr.w	r0, [r3, #1036]	; 0x40c
    b8f4:	f8c2 0094 	str.w	r0, [r2, #148]	; 0x94
            values_[ix++] = neuron[n].weight1 + 128;
    b8f8:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
    b8fc:	3080      	adds	r0, #128	; 0x80
    b8fe:	f8c2 0098 	str.w	r0, [r2, #152]	; 0x98
            values_[ix++] = neuron[n].weight2 + 128;
    b902:	f8d3 0414 	ldr.w	r0, [r3, #1044]	; 0x414
    b906:	3080      	adds	r0, #128	; 0x80
    b908:	f8c2 009c 	str.w	r0, [r2, #156]	; 0x9c
            values_[ix++] = neuron[n].weight3 + 128;
    b90c:	f8d3 0418 	ldr.w	r0, [r3, #1048]	; 0x418
    b910:	3080      	adds	r0, #128	; 0x80
    b912:	f8c2 00a0 	str.w	r0, [r2, #160]	; 0xa0
            values_[ix++] = neuron[n].threshold + 128;
    b916:	f8d3 041c 	ldr.w	r0, [r3, #1052]	; 0x41c
        for (byte n = 0; n < 24; n++)
    b91a:	3108      	adds	r1, #8
            values_[ix++] = neuron[n].threshold + 128;
    b91c:	3080      	adds	r0, #128	; 0x80
        for (byte n = 0; n < 24; n++)
    b91e:	29c8      	cmp	r1, #200	; 0xc8
            values_[ix++] = neuron[n].threshold + 128;
    b920:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
        for (byte n = 0; n < 24; n++)
    b924:	f103 0324 	add.w	r3, r3, #36	; 0x24
    b928:	f102 0220 	add.w	r2, r2, #32
    b92c:	d1d4      	bne.n	b8d8 <NeuralNetwork_handleAppEvent(OC::AppEvent)+0x18>
        for (byte o = 0; o < 16; o++) values_[ix++] = output_neuron[o];
    b92e:	4c0a      	ldr	r4, [pc, #40]	; (b958 <NeuralNetwork_handleAppEvent(OC::AppEvent)+0x98>)
    b930:	f504 7575 	add.w	r5, r4, #980	; 0x3d4
    b934:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    b936:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    b938:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    b93a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    b93c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    b93e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    b940:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    b944:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        NeuralNetwork_instance.OnSendSysEx();
    b948:	f5a4 706e 	sub.w	r0, r4, #952	; 0x3b8
    b94c:	f7f9 fd14 	bl	5378 <NeuralNetwork::OnSendSysEx()>
}
    b950:	e7bc      	b.n	b8cc <NeuralNetwork_handleAppEvent(OC::AppEvent)+0xc>
    b952:	bf00      	nop
    b954:	2000058c 	.word	0x2000058c
    b958:	20000914 	.word	0x20000914

0000b95c <NeuralNetwork::DrawTLNeuron(unsigned char)>:
    void DrawTLNeuron(byte ix) {
    b95c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        int dendrite_weight[3] = {neuron[ix].weight1, neuron[ix].weight2, neuron[ix].weight3};
    b960:	f04f 0824 	mov.w	r8, #36	; 0x24
    b964:	fb08 f801 	mul.w	r8, r8, r1
    b968:	eb00 0308 	add.w	r3, r0, r8
    void DrawTLNeuron(byte ix) {
    b96c:	b089      	sub	sp, #36	; 0x24
        int dendrite_weight[3] = {neuron[ix].weight1, neuron[ix].weight2, neuron[ix].weight3};
    b96e:	f8d3 2410 	ldr.w	r2, [r3, #1040]	; 0x410
    b972:	9205      	str	r2, [sp, #20]
        graphics.drawCircle(x, y, r);
    b974:	4e52      	ldr	r6, [pc, #328]	; (bac0 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x164>)
    b976:	f8d3 2414 	ldr.w	r2, [r3, #1044]	; 0x414
    b97a:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
    b97e:	9206      	str	r2, [sp, #24]
    void DrawTLNeuron(byte ix) {
    b980:	4604      	mov	r4, r0
    b982:	4689      	mov	r9, r1
        int dendrite_weight[3] = {neuron[ix].weight1, neuron[ix].weight2, neuron[ix].weight3};
    b984:	9307      	str	r3, [sp, #28]
    b986:	f04f 0b16 	mov.w	fp, #22
        for (int d = 0; d < 3; d++)
    b98a:	2500      	movs	r5, #0
            int weight = dendrite_weight[d];
    b98c:	ab05      	add	r3, sp, #20
    b98e:	465a      	mov	r2, fp
    b990:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
    b994:	9303      	str	r3, [sp, #12]
            byte indent = d == 1 ? 4 : 0;
    b996:	1e6b      	subs	r3, r5, #1
    b998:	425f      	negs	r7, r3
    b99a:	415f      	adcs	r7, r3
            gfxCircle(73 + indent, 22 + (16 * d), 8); // Dendrite
    b99c:	00bf      	lsls	r7, r7, #2
    b99e:	f107 0a49 	add.w	sl, r7, #73	; 0x49
    b9a2:	2308      	movs	r3, #8
    b9a4:	4651      	mov	r1, sl
    b9a6:	4630      	mov	r0, r6
    b9a8:	f00d ff2b 	bl	19802 <weegfx::Graphics::drawCircle(int, int, int)>
            gfxPrint((weight < 0 ? 66 : 72) + indent , 19 + (16 * d), weight);
    b9ac:	9b03      	ldr	r3, [sp, #12]
        graphics.print(num);
    b9ae:	9903      	ldr	r1, [sp, #12]
    b9b0:	4843      	ldr	r0, [pc, #268]	; (bac0 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x164>)
    b9b2:	2b00      	cmp	r3, #0
    b9b4:	bfb4      	ite	lt
    b9b6:	2342      	movlt	r3, #66	; 0x42
    b9b8:	2348      	movge	r3, #72	; 0x48
    b9ba:	443b      	add	r3, r7
  text_x_ = x;
    b9bc:	6073      	str	r3, [r6, #4]
  text_y_ = y;
    b9be:	f1ab 0303 	sub.w	r3, fp, #3
    b9c2:	60b3      	str	r3, [r6, #8]
    b9c4:	f00e f8fb 	bl	19bbe <weegfx::Graphics::print(int)>
            if (cursor == (d + 4) && CursorBlink()) gfxCircle(73 + indent, 22 + (16 * d), 7);
    b9c8:	f894 13ea 	ldrb.w	r1, [r4, #1002]	; 0x3ea
    b9cc:	1d2b      	adds	r3, r5, #4
    b9ce:	4299      	cmp	r1, r3
    b9d0:	d108      	bne.n	b9e4 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x88>
    b9d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b9d4:	2b00      	cmp	r3, #0
    b9d6:	dd05      	ble.n	b9e4 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x88>
        graphics.drawCircle(x, y, r);
    b9d8:	2307      	movs	r3, #7
    b9da:	465a      	mov	r2, fp
    b9dc:	4651      	mov	r1, sl
    b9de:	4630      	mov	r0, r6
    b9e0:	f00d ff0f 	bl	19802 <weegfx::Graphics::drawCircle(int, int, int)>
            gfxDottedLine(81 + indent, 22 + (16 * d), 100, 38, neuron[ix].SourceValue(d) ? 1 : 3); // Synapse
    b9e4:	f107 0151 	add.w	r1, r7, #81	; 0x51
        if (s == 0) v = source_value(source1);
    b9e8:	eb04 0008 	add.w	r0, r4, r8
    b9ec:	2d00      	cmp	r5, #0
    b9ee:	d148      	bne.n	ba82 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x126>
        uint16_t v = source_state & (0x01 << source);
    b9f0:	f8b0 7404 	ldrh.w	r7, [r0, #1028]	; 0x404
    b9f4:	2301      	movs	r3, #1
    b9f6:	40bb      	lsls	r3, r7
    b9f8:	f8b0 03fe 	ldrh.w	r0, [r0, #1022]	; 0x3fe
    b9fc:	4203      	tst	r3, r0
    b9fe:	bf14      	ite	ne
    ba00:	2301      	movne	r3, #1
    ba02:	2303      	moveq	r3, #3
        graphics.drawLine(x, y, x2, y2, p);
    ba04:	9301      	str	r3, [sp, #4]
    ba06:	2326      	movs	r3, #38	; 0x26
    ba08:	9300      	str	r3, [sp, #0]
    ba0a:	465a      	mov	r2, fp
    ba0c:	2364      	movs	r3, #100	; 0x64
    ba0e:	4630      	mov	r0, r6
        for (int d = 0; d < 3; d++)
    ba10:	3501      	adds	r5, #1
    ba12:	f00d fe63 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
    ba16:	2d03      	cmp	r5, #3
    ba18:	f10b 0b10 	add.w	fp, fp, #16
    ba1c:	d1b6      	bne.n	b98c <NeuralNetwork::DrawTLNeuron(unsigned char)+0x30>
        int threshold = neuron[ix].threshold;
    ba1e:	2324      	movs	r3, #36	; 0x24
    ba20:	fb03 4309 	mla	r3, r3, r9, r4
        graphics.print(num);
    ba24:	4826      	ldr	r0, [pc, #152]	; (bac0 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x164>)
    ba26:	f8d3 141c 	ldr.w	r1, [r3, #1052]	; 0x41c
        if (threshold < 10 && threshold > -10) x += 5; // Shove over a bit if a one-digit number
    ba2a:	f101 0309 	add.w	r3, r1, #9
    ba2e:	2b12      	cmp	r3, #18
    ba30:	bf8c      	ite	hi
    ba32:	2369      	movhi	r3, #105	; 0x69
    ba34:	236e      	movls	r3, #110	; 0x6e
        if (threshold < 0) x -= 5; // Pull back if a sign is necessary
    ba36:	2900      	cmp	r1, #0
    ba38:	bfb8      	it	lt
    ba3a:	3b05      	sublt	r3, #5
  text_x_ = x;
    ba3c:	6073      	str	r3, [r6, #4]
  text_y_ = y;
    ba3e:	2322      	movs	r3, #34	; 0x22
    ba40:	60b3      	str	r3, [r6, #8]
    ba42:	f00e f8bc 	bl	19bbe <weegfx::Graphics::print(int)>
        if (cursor == 7 && CursorBlink()) gfxCircle(112, 38, 11);
    ba46:	f894 33ea 	ldrb.w	r3, [r4, #1002]	; 0x3ea
    ba4a:	2b07      	cmp	r3, #7
    ba4c:	d108      	bne.n	ba60 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x104>
    ba4e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    ba50:	2b00      	cmp	r3, #0
    ba52:	dd05      	ble.n	ba60 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x104>
        graphics.drawCircle(x, y, r);
    ba54:	481a      	ldr	r0, [pc, #104]	; (bac0 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x164>)
    ba56:	230b      	movs	r3, #11
    ba58:	2226      	movs	r2, #38	; 0x26
    ba5a:	2170      	movs	r1, #112	; 0x70
    ba5c:	f00d fed1 	bl	19802 <weegfx::Graphics::drawCircle(int, int, int)>
        if (neuron[ix].state) {
    ba60:	2324      	movs	r3, #36	; 0x24
    ba62:	fb03 4409 	mla	r4, r3, r9, r4
    ba66:	f894 33fc 	ldrb.w	r3, [r4, #1020]	; 0x3fc
    ba6a:	b9e3      	cbnz	r3, baa6 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x14a>
        int r = 0;
    ba6c:	2000      	movs	r0, #0
        gfxCircle(112, 38, 12 + (r * 2));
    ba6e:	3006      	adds	r0, #6
    ba70:	0043      	lsls	r3, r0, #1
    ba72:	4813      	ldr	r0, [pc, #76]	; (bac0 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x164>)
    ba74:	2226      	movs	r2, #38	; 0x26
    ba76:	2170      	movs	r1, #112	; 0x70
    }
    ba78:	b009      	add	sp, #36	; 0x24
    ba7a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ba7e:	f00d bec0 	b.w	19802 <weegfx::Graphics::drawCircle(int, int, int)>
        if (s == 1) v = source_value(source2);
    ba82:	2d01      	cmp	r5, #1
    ba84:	d104      	bne.n	ba90 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x134>
        uint16_t v = source_state & (0x01 << source);
    ba86:	f8b0 3408 	ldrh.w	r3, [r0, #1032]	; 0x408
    ba8a:	fa05 f303 	lsl.w	r3, r5, r3
    ba8e:	e7b3      	b.n	b9f8 <NeuralNetwork::DrawTLNeuron(unsigned char)+0x9c>
    ba90:	f8b0 740c 	ldrh.w	r7, [r0, #1036]	; 0x40c
    ba94:	f8b0 03fe 	ldrh.w	r0, [r0, #1022]	; 0x3fe
    ba98:	2301      	movs	r3, #1
    ba9a:	40bb      	lsls	r3, r7
            gfxDottedLine(81 + indent, 22 + (16 * d), 100, 38, neuron[ix].SourceValue(d) ? 1 : 3); // Synapse
    ba9c:	4203      	tst	r3, r0
    ba9e:	bf0c      	ite	eq
    baa0:	2303      	moveq	r3, #3
    baa2:	2301      	movne	r3, #1
    baa4:	e7ae      	b.n	ba04 <NeuralNetwork::DrawTLNeuron(unsigned char)+0xa8>
        		if (random(1, 100) > 60) r = random(0, 3) - 1;
    baa6:	2164      	movs	r1, #100	; 0x64
    baa8:	2001      	movs	r0, #1
    baaa:	f00e fa20 	bl	19eee <random(long, long)>
    baae:	283c      	cmp	r0, #60	; 0x3c
    bab0:	dddc      	ble.n	ba6c <NeuralNetwork::DrawTLNeuron(unsigned char)+0x110>
    bab2:	2103      	movs	r1, #3
    bab4:	2000      	movs	r0, #0
    bab6:	f00e fa1a 	bl	19eee <random(long, long)>
    baba:	3801      	subs	r0, #1
    babc:	e7d7      	b.n	ba6e <NeuralNetwork::DrawTLNeuron(unsigned char)+0x112>
    babe:	bf00      	nop
    bac0:	200065e0 	.word	0x200065e0

0000bac4 <NeuralNetwork::DrawInputs(unsigned char)>:
    void DrawInputs(byte ix) {
    bac4:	b537      	push	{r0, r1, r2, r4, r5, lr}
        if (s == 0) v = source_value(source1);
    bac6:	2224      	movs	r2, #36	; 0x24
    bac8:	fb02 0401 	mla	r4, r2, r1, r0
        uint16_t v = source_state & (0x01 << source);
    bacc:	2501      	movs	r5, #1
    bace:	f8b4 3404 	ldrh.w	r3, [r4, #1028]	; 0x404
    bad2:	f8b4 13fe 	ldrh.w	r1, [r4, #1022]	; 0x3fe
    bad6:	fa05 f303 	lsl.w	r3, r5, r3
    bada:	400b      	ands	r3, r1
        if (neuron[ix].type == LogicGateType::NOT) {
    badc:	f8d4 1400 	ldr.w	r1, [r4, #1024]	; 0x400
    bae0:	42a9      	cmp	r1, r5
    bae2:	d10c      	bne.n	bafe <NeuralNetwork::DrawInputs(unsigned char)+0x3a>
            gfxDottedLine(64, 36, 76, 36, neuron[ix].SourceValue(0) ? 1 : 3);
    bae4:	2b00      	cmp	r3, #0
    bae6:	bf14      	ite	ne
    bae8:	462b      	movne	r3, r5
    baea:	2303      	moveq	r3, #3
        graphics.drawLine(x, y, x2, y2, p);
    baec:	9301      	str	r3, [sp, #4]
    baee:	4810      	ldr	r0, [pc, #64]	; (bb30 <NeuralNetwork::DrawInputs(unsigned char)+0x6c>)
    baf0:	9200      	str	r2, [sp, #0]
    baf2:	234c      	movs	r3, #76	; 0x4c
    baf4:	2140      	movs	r1, #64	; 0x40
    baf6:	f00d fdf1 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
    }
    bafa:	b003      	add	sp, #12
    bafc:	bd30      	pop	{r4, r5, pc}
            gfxDottedLine(64, 28, 76, 28, neuron[ix].SourceValue(0) ? 1 : 3);
    bafe:	2b00      	cmp	r3, #0
    bb00:	bf14      	ite	ne
    bb02:	2301      	movne	r3, #1
    bb04:	2303      	moveq	r3, #3
    bb06:	221c      	movs	r2, #28
    bb08:	9301      	str	r3, [sp, #4]
    bb0a:	9200      	str	r2, [sp, #0]
    bb0c:	234c      	movs	r3, #76	; 0x4c
    bb0e:	4808      	ldr	r0, [pc, #32]	; (bb30 <NeuralNetwork::DrawInputs(unsigned char)+0x6c>)
    bb10:	2140      	movs	r1, #64	; 0x40
    bb12:	f00d fde3 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
    bb16:	f8b4 3408 	ldrh.w	r3, [r4, #1032]	; 0x408
    bb1a:	409d      	lsls	r5, r3
    bb1c:	f8b4 33fe 	ldrh.w	r3, [r4, #1022]	; 0x3fe
            gfxDottedLine(64, 44, 76, 44, neuron[ix].SourceValue(1) ? 1 : 3);
    bb20:	421d      	tst	r5, r3
    bb22:	bf14      	ite	ne
    bb24:	2301      	movne	r3, #1
    bb26:	2303      	moveq	r3, #3
    bb28:	9301      	str	r3, [sp, #4]
    bb2a:	222c      	movs	r2, #44	; 0x2c
    bb2c:	e7df      	b.n	baee <NeuralNetwork::DrawInputs(unsigned char)+0x2a>
    bb2e:	bf00      	nop
    bb30:	200065e0 	.word	0x200065e0

0000bb34 <NeuralNetwork::DrawBody(unsigned char)>:
    void DrawBody(byte ix) {
    bb34:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        if (neuron[ix].type == LogicGateType::NOT) {
    bb38:	2624      	movs	r6, #36	; 0x24
    bb3a:	fb06 0301 	mla	r3, r6, r1, r0
    void DrawBody(byte ix) {
    bb3e:	4604      	mov	r4, r0
        if (neuron[ix].type == LogicGateType::NOT) {
    bb40:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    bb44:	2b01      	cmp	r3, #1
    void DrawBody(byte ix) {
    bb46:	460d      	mov	r5, r1
        if (neuron[ix].type == LogicGateType::NOT) {
    bb48:	d115      	bne.n	bb76 <NeuralNetwork::DrawBody(unsigned char)+0x42>
        graphics.drawLine(x, y, x2, y2);
    bb4a:	234c      	movs	r3, #76	; 0x4c
    bb4c:	2734      	movs	r7, #52	; 0x34
    bb4e:	4619      	mov	r1, r3
    bb50:	489d      	ldr	r0, [pc, #628]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bb52:	9700      	str	r7, [sp, #0]
    bb54:	2214      	movs	r2, #20
    bb56:	f00d fe4b 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bb5a:	489b      	ldr	r0, [pc, #620]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bb5c:	9600      	str	r6, [sp, #0]
    bb5e:	236c      	movs	r3, #108	; 0x6c
    bb60:	2214      	movs	r2, #20
    bb62:	214c      	movs	r1, #76	; 0x4c
    bb64:	f00d fe44 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bb68:	4897      	ldr	r0, [pc, #604]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bb6a:	9600      	str	r6, [sp, #0]
    bb6c:	236c      	movs	r3, #108	; 0x6c
    bb6e:	463a      	mov	r2, r7
    bb70:	214c      	movs	r1, #76	; 0x4c
    bb72:	f00d fe3d 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        if (neuron[ix].type == LogicGateType::AND
    bb76:	2324      	movs	r3, #36	; 0x24
    bb78:	fb03 4305 	mla	r3, r3, r5, r4
    bb7c:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    bb80:	2b02      	cmp	r3, #2
    bb82:	d001      	beq.n	bb88 <NeuralNetwork::DrawBody(unsigned char)+0x54>
         || neuron[ix].type == LogicGateType::NAND
    bb84:	2b05      	cmp	r3, #5
    bb86:	d142      	bne.n	bc0e <NeuralNetwork::DrawBody(unsigned char)+0xda>
    bb88:	2634      	movs	r6, #52	; 0x34
    bb8a:	234c      	movs	r3, #76	; 0x4c
    bb8c:	2714      	movs	r7, #20
    bb8e:	4619      	mov	r1, r3
    bb90:	488d      	ldr	r0, [pc, #564]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bb92:	9600      	str	r6, [sp, #0]
    bb94:	2214      	movs	r2, #20
    bb96:	f00d fe2b 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bb9a:	f04f 081a 	mov.w	r8, #26
    bb9e:	463a      	mov	r2, r7
    bba0:	4889      	ldr	r0, [pc, #548]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bba2:	9700      	str	r7, [sp, #0]
    bba4:	2360      	movs	r3, #96	; 0x60
    bba6:	214c      	movs	r1, #76	; 0x4c
    bba8:	f00d fe22 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bbac:	463a      	mov	r2, r7
    bbae:	4886      	ldr	r0, [pc, #536]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bbb0:	f8cd 8000 	str.w	r8, [sp]
    bbb4:	2720      	movs	r7, #32
    bbb6:	2367      	movs	r3, #103	; 0x67
    bbb8:	2160      	movs	r1, #96	; 0x60
    bbba:	f00d fe19 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bbbe:	4642      	mov	r2, r8
    bbc0:	4881      	ldr	r0, [pc, #516]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bbc2:	9700      	str	r7, [sp, #0]
    bbc4:	236c      	movs	r3, #108	; 0x6c
    bbc6:	2167      	movs	r1, #103	; 0x67
    bbc8:	f00d fe12 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bbcc:	f04f 0828 	mov.w	r8, #40	; 0x28
    bbd0:	236c      	movs	r3, #108	; 0x6c
    bbd2:	463a      	mov	r2, r7
    bbd4:	4619      	mov	r1, r3
    bbd6:	487c      	ldr	r0, [pc, #496]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bbd8:	f8cd 8000 	str.w	r8, [sp]
    bbdc:	f00d fe08 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bbe0:	272e      	movs	r7, #46	; 0x2e
    bbe2:	4879      	ldr	r0, [pc, #484]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bbe4:	9600      	str	r6, [sp, #0]
    bbe6:	2360      	movs	r3, #96	; 0x60
    bbe8:	4632      	mov	r2, r6
    bbea:	214c      	movs	r1, #76	; 0x4c
    bbec:	f00d fe00 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bbf0:	4875      	ldr	r0, [pc, #468]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bbf2:	9700      	str	r7, [sp, #0]
    bbf4:	2367      	movs	r3, #103	; 0x67
    bbf6:	4632      	mov	r2, r6
    bbf8:	2160      	movs	r1, #96	; 0x60
    bbfa:	f00d fdf9 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bbfe:	4872      	ldr	r0, [pc, #456]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bc00:	f8cd 8000 	str.w	r8, [sp]
    bc04:	236c      	movs	r3, #108	; 0x6c
    bc06:	463a      	mov	r2, r7
    bc08:	2167      	movs	r1, #103	; 0x67
    bc0a:	f00d fdf1 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        if (neuron[ix].type == LogicGateType::OR
    bc0e:	2324      	movs	r3, #36	; 0x24
    bc10:	fb03 4305 	mla	r3, r3, r5, r4
    bc14:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    bc18:	1eda      	subs	r2, r3, #3
    bc1a:	2a01      	cmp	r2, #1
    bc1c:	d902      	bls.n	bc24 <NeuralNetwork::DrawBody(unsigned char)+0xf0>
         || neuron[ix].type == LogicGateType::NOR
    bc1e:	3b06      	subs	r3, #6
    bc20:	2b01      	cmp	r3, #1
    bc22:	d844      	bhi.n	bcae <NeuralNetwork::DrawBody(unsigned char)+0x17a>
    bc24:	f04f 0814 	mov.w	r8, #20
    bc28:	2624      	movs	r6, #36	; 0x24
    bc2a:	4867      	ldr	r0, [pc, #412]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bc2c:	f8cd 8000 	str.w	r8, [sp]
    bc30:	2360      	movs	r3, #96	; 0x60
    bc32:	4642      	mov	r2, r8
    bc34:	214c      	movs	r1, #76	; 0x4c
    bc36:	f00d fddb 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bc3a:	2734      	movs	r7, #52	; 0x34
    bc3c:	4862      	ldr	r0, [pc, #392]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bc3e:	9600      	str	r6, [sp, #0]
    bc40:	236c      	movs	r3, #108	; 0x6c
    bc42:	4642      	mov	r2, r8
    bc44:	2160      	movs	r1, #96	; 0x60
    bc46:	f00d fdd3 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bc4a:	485f      	ldr	r0, [pc, #380]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bc4c:	9700      	str	r7, [sp, #0]
    bc4e:	2360      	movs	r3, #96	; 0x60
    bc50:	463a      	mov	r2, r7
    bc52:	214c      	movs	r1, #76	; 0x4c
    bc54:	f00d fdcc 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bc58:	485b      	ldr	r0, [pc, #364]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bc5a:	9600      	str	r6, [sp, #0]
    bc5c:	236c      	movs	r3, #108	; 0x6c
    bc5e:	463a      	mov	r2, r7
    bc60:	2160      	movs	r1, #96	; 0x60
    bc62:	f00d fdc5 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bc66:	4858      	ldr	r0, [pc, #352]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bc68:	9600      	str	r6, [sp, #0]
    bc6a:	2350      	movs	r3, #80	; 0x50
    bc6c:	4642      	mov	r2, r8
    bc6e:	214c      	movs	r1, #76	; 0x4c
    bc70:	f00d fdbe 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bc74:	2350      	movs	r3, #80	; 0x50
    bc76:	4854      	ldr	r0, [pc, #336]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bc78:	9600      	str	r6, [sp, #0]
    bc7a:	463a      	mov	r2, r7
    bc7c:	214c      	movs	r1, #76	; 0x4c
    bc7e:	f00d fdb7 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
            if (neuron[ix].type == LogicGateType::XOR
    bc82:	fb06 4305 	mla	r3, r6, r5, r4
    bc86:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    bc8a:	2b04      	cmp	r3, #4
    bc8c:	d001      	beq.n	bc92 <NeuralNetwork::DrawBody(unsigned char)+0x15e>
             || neuron[ix].type == LogicGateType::XNOR
    bc8e:	2b07      	cmp	r3, #7
    bc90:	d10d      	bne.n	bcae <NeuralNetwork::DrawBody(unsigned char)+0x17a>
    bc92:	484d      	ldr	r0, [pc, #308]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bc94:	9600      	str	r6, [sp, #0]
    bc96:	234a      	movs	r3, #74	; 0x4a
    bc98:	2214      	movs	r2, #20
    bc9a:	2146      	movs	r1, #70	; 0x46
    bc9c:	f00d fda8 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bca0:	4849      	ldr	r0, [pc, #292]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bca2:	9600      	str	r6, [sp, #0]
    bca4:	234a      	movs	r3, #74	; 0x4a
    bca6:	2234      	movs	r2, #52	; 0x34
    bca8:	2146      	movs	r1, #70	; 0x46
    bcaa:	f00d fda1 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        if (neuron[ix].type == LogicGateType::D_FLIPFLOP || neuron[ix].type == LogicGateType::T_FLIPFLOP) {
    bcae:	2624      	movs	r6, #36	; 0x24
    bcb0:	fb06 4605 	mla	r6, r6, r5, r4
    bcb4:	f8d6 3400 	ldr.w	r3, [r6, #1024]	; 0x400
    bcb8:	3b08      	subs	r3, #8
    bcba:	2b01      	cmp	r3, #1
    bcbc:	d83d      	bhi.n	bd3a <NeuralNetwork::DrawBody(unsigned char)+0x206>
    bcbe:	2734      	movs	r7, #52	; 0x34
    bcc0:	234c      	movs	r3, #76	; 0x4c
    bcc2:	4619      	mov	r1, r3
    bcc4:	f04f 0814 	mov.w	r8, #20
    bcc8:	483f      	ldr	r0, [pc, #252]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bcca:	9700      	str	r7, [sp, #0]
    bccc:	2214      	movs	r2, #20
    bcce:	f00d fd8f 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bcd2:	483d      	ldr	r0, [pc, #244]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bcd4:	f8cd 8000 	str.w	r8, [sp]
    bcd8:	236c      	movs	r3, #108	; 0x6c
    bcda:	4642      	mov	r2, r8
    bcdc:	214c      	movs	r1, #76	; 0x4c
    bcde:	f00d fd87 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bce2:	463a      	mov	r2, r7
    bce4:	4838      	ldr	r0, [pc, #224]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bce6:	9700      	str	r7, [sp, #0]
    bce8:	236c      	movs	r3, #108	; 0x6c
    bcea:	214c      	movs	r1, #76	; 0x4c
    bcec:	f00d fd80 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bcf0:	236c      	movs	r3, #108	; 0x6c
    bcf2:	4619      	mov	r1, r3
    bcf4:	4834      	ldr	r0, [pc, #208]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bcf6:	9700      	str	r7, [sp, #0]
    bcf8:	4642      	mov	r2, r8
    bcfa:	272c      	movs	r7, #44	; 0x2c
    bcfc:	f00d fd78 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bd00:	4831      	ldr	r0, [pc, #196]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bd02:	9700      	str	r7, [sp, #0]
    bd04:	2354      	movs	r3, #84	; 0x54
    bd06:	2228      	movs	r2, #40	; 0x28
    bd08:	214c      	movs	r1, #76	; 0x4c
    bd0a:	f00d fd71 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bd0e:	482e      	ldr	r0, [pc, #184]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bd10:	9700      	str	r7, [sp, #0]
    bd12:	2354      	movs	r3, #84	; 0x54
    bd14:	2230      	movs	r2, #48	; 0x30
    bd16:	214c      	movs	r1, #76	; 0x4c
    bd18:	f00d fd6a 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
  text_x_ = x;
    bd1c:	482a      	ldr	r0, [pc, #168]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
            gfxPrint(78, 25, neuron[ix].type == LogicGateType::D_FLIPFLOP ? "D" : "T");
    bd1e:	f8d6 1400 	ldr.w	r1, [r6, #1024]	; 0x400
        graphics.print(str);
    bd22:	4a2a      	ldr	r2, [pc, #168]	; (bdcc <NeuralNetwork::DrawBody(unsigned char)+0x298>)
    bd24:	234e      	movs	r3, #78	; 0x4e
    bd26:	6043      	str	r3, [r0, #4]
  text_y_ = y;
    bd28:	2319      	movs	r3, #25
    bd2a:	6083      	str	r3, [r0, #8]
    bd2c:	4b28      	ldr	r3, [pc, #160]	; (bdd0 <NeuralNetwork::DrawBody(unsigned char)+0x29c>)
    bd2e:	2908      	cmp	r1, #8
    bd30:	bf0c      	ite	eq
    bd32:	4611      	moveq	r1, r2
    bd34:	4619      	movne	r1, r3
    bd36:	f00d fece 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (neuron[ix].type == LogicGateType::LATCH) {
    bd3a:	2624      	movs	r6, #36	; 0x24
    bd3c:	fb06 4405 	mla	r4, r6, r5, r4
    bd40:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
    bd44:	2b0a      	cmp	r3, #10
    bd46:	d13b      	bne.n	bdc0 <NeuralNetwork::DrawBody(unsigned char)+0x28c>
        graphics.drawLine(x, y, x2, y2);
    bd48:	221c      	movs	r2, #28
    bd4a:	481f      	ldr	r0, [pc, #124]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bd4c:	9200      	str	r2, [sp, #0]
    bd4e:	2354      	movs	r3, #84	; 0x54
    bd50:	214c      	movs	r1, #76	; 0x4c
    bd52:	f00d fd4d 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bd56:	222c      	movs	r2, #44	; 0x2c
        graphics.drawBitmap8(x, y, w, data);
    bd58:	4c1e      	ldr	r4, [pc, #120]	; (bdd4 <NeuralNetwork::DrawBody(unsigned char)+0x2a0>)
        graphics.drawLine(x, y, x2, y2);
    bd5a:	481b      	ldr	r0, [pc, #108]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bd5c:	9200      	str	r2, [sp, #0]
    bd5e:	2354      	movs	r3, #84	; 0x54
    bd60:	214c      	movs	r1, #76	; 0x4c
    bd62:	f00d fd45 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        graphics.drawBitmap8(x, y, w, data);
    bd66:	4818      	ldr	r0, [pc, #96]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bd68:	9400      	str	r4, [sp, #0]
    bd6a:	2310      	movs	r3, #16
    bd6c:	221b      	movs	r2, #27
    bd6e:	2154      	movs	r1, #84	; 0x54
    bd70:	f00d fc68 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
    bd74:	4814      	ldr	r0, [pc, #80]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bd76:	9400      	str	r4, [sp, #0]
    bd78:	2310      	movs	r3, #16
        graphics.drawLine(x, y, x2, y2);
    bd7a:	241e      	movs	r4, #30
        graphics.drawBitmap8(x, y, w, data);
    bd7c:	2227      	movs	r2, #39	; 0x27
    bd7e:	2154      	movs	r1, #84	; 0x54
    bd80:	f00d fc60 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
        graphics.drawLine(x, y, x2, y2);
    bd84:	4810      	ldr	r0, [pc, #64]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bd86:	9400      	str	r4, [sp, #0]
    bd88:	236c      	movs	r3, #108	; 0x6c
    bd8a:	4622      	mov	r2, r4
    bd8c:	2164      	movs	r1, #100	; 0x64
    bd8e:	f00d fd2f 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bd92:	236c      	movs	r3, #108	; 0x6c
    bd94:	4619      	mov	r1, r3
    bd96:	480c      	ldr	r0, [pc, #48]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bd98:	9600      	str	r6, [sp, #0]
    bd9a:	4622      	mov	r2, r4
    bd9c:	f00d fd28 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bda0:	2328      	movs	r3, #40	; 0x28
    bda2:	4809      	ldr	r0, [pc, #36]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bda4:	9300      	str	r3, [sp, #0]
    bda6:	4622      	mov	r2, r4
    bda8:	2354      	movs	r3, #84	; 0x54
    bdaa:	2166      	movs	r1, #102	; 0x66
    bdac:	f00d fd20 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    bdb0:	2320      	movs	r3, #32
    bdb2:	9300      	str	r3, [sp, #0]
    bdb4:	4804      	ldr	r0, [pc, #16]	; (bdc8 <NeuralNetwork::DrawBody(unsigned char)+0x294>)
    bdb6:	2354      	movs	r3, #84	; 0x54
    bdb8:	222a      	movs	r2, #42	; 0x2a
    bdba:	2164      	movs	r1, #100	; 0x64
    bdbc:	f00d fd18 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    }
    bdc0:	b002      	add	sp, #8
    bdc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bdc6:	bf00      	nop
    bdc8:	200065e0 	.word	0x200065e0
    bdcc:	00021b74 	.word	0x00021b74
    bdd0:	0001e2f1 	.word	0x0001e2f1
    bdd4:	00023dc0 	.word	0x00023dc0

0000bdd8 <NeuralNetwork::DrawEditScreen()>:
    void DrawEditScreen() {
    bdd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if (selected < 6) {
    bddc:	f8d0 33ec 	ldr.w	r3, [r0, #1004]	; 0x3ec
    bde0:	4d97      	ldr	r5, [pc, #604]	; (c040 <NeuralNetwork::DrawEditScreen()+0x268>)
    bde2:	2b05      	cmp	r3, #5
    bde4:	f04f 0600 	mov.w	r6, #0
    bde8:	f04f 030f 	mov.w	r3, #15
    void DrawEditScreen() {
    bdec:	b087      	sub	sp, #28
    bdee:	4604      	mov	r4, r0
  text_x_ = x;
    bdf0:	606e      	str	r6, [r5, #4]
  text_y_ = y;
    bdf2:	60ab      	str	r3, [r5, #8]
        if (selected < 6) {
    bdf4:	f300 80e0 	bgt.w	bfb8 <NeuralNetwork::DrawEditScreen()+0x1e0>
        graphics.print(str);
    bdf8:	4992      	ldr	r1, [pc, #584]	; (c044 <NeuralNetwork::DrawEditScreen()+0x26c>)
    bdfa:	4628      	mov	r0, r5
    bdfc:	f00d fe6b 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            gfxPrint(selected + 1);
    be00:	f8d4 13ec 	ldr.w	r1, [r4, #1004]	; 0x3ec
        graphics.print(num);
    be04:	4628      	mov	r0, r5
    be06:	3101      	adds	r1, #1
    be08:	f00d fed9 	bl	19bbe <weegfx::Graphics::print(int)>
            for (byte n = 0; n < 6; n++)
    be0c:	2704      	movs	r7, #4
                if (n == selected) gfxRect(x, y, 6, 4);
    be0e:	f8d4 33ec 	ldr.w	r3, [r4, #1004]	; 0x3ec
        graphics.drawRect(x, y, w, h);
    be12:	9700      	str	r7, [sp, #0]
                byte cell_x = n / 2;
    be14:	f3c6 0146 	ubfx	r1, r6, #1, #7
                byte x = (cell_x * 8) + 40;
    be18:	3105      	adds	r1, #5
                byte cell_y = n % 2;
    be1a:	f006 0201 	and.w	r2, r6, #1
                byte x = (cell_x * 8) + 40;
    be1e:	00c9      	lsls	r1, r1, #3
                byte y = (cell_y * 5) + 15;
    be20:	eb02 0282 	add.w	r2, r2, r2, lsl #2
                if (n == selected) gfxRect(x, y, 6, 4);
    be24:	42b3      	cmp	r3, r6
    be26:	b2c9      	uxtb	r1, r1
    be28:	f102 020f 	add.w	r2, r2, #15
    be2c:	f04f 0306 	mov.w	r3, #6
    be30:	4628      	mov	r0, r5
    be32:	d15f      	bne.n	bef4 <NeuralNetwork::DrawEditScreen()+0x11c>
    be34:	f00d fa2e 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
            for (byte n = 0; n < 6; n++)
    be38:	3601      	adds	r6, #1
    be3a:	2e06      	cmp	r6, #6
    be3c:	d1e7      	bne.n	be0e <NeuralNetwork::DrawEditScreen()+0x36>
            byte ix = (setup * 6) + selected;
    be3e:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	; 0x3f0
    be42:	f8d4 63ec 	ldr.w	r6, [r4, #1004]	; 0x3ec
    be46:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    be4a:	eb06 0643 	add.w	r6, r6, r3, lsl #1
    be4e:	b2f6      	uxtb	r6, r6
            byte p = neuron[ix].NumParam(); // Number of parameters for this neuron
    be50:	2724      	movs	r7, #36	; 0x24
    be52:	fb07 4706 	mla	r7, r7, r6, r4
            if (cursor == 2) graphics.print(source_name[source2]);
    be56:	f04f 0b24 	mov.w	fp, #36	; 0x24
    be5a:	f8d7 3400 	ldr.w	r3, [r7, #1024]	; 0x400
    be5e:	2b0b      	cmp	r3, #11
    be60:	bf96      	itet	ls
    be62:	4a79      	ldrls	r2, [pc, #484]	; (c048 <NeuralNetwork::DrawEditScreen()+0x270>)
    be64:	2303      	movhi	r3, #3
    be66:	5cd3      	ldrbls	r3, [r2, r3]
    be68:	9303      	str	r3, [sp, #12]
    be6a:	f507 777f 	add.w	r7, r7, #1020	; 0x3fc
    be6e:	f04f 0a19 	mov.w	sl, #25
    be72:	f04f 0900 	mov.w	r9, #0
    be76:	fb0b 4b06 	mla	fp, fp, r6, r4
                if (c < 4) { // This is the right-hand pane, so only show first four parameters
    be7a:	f1b9 0f03 	cmp.w	r9, #3
    be7e:	fa5f f889 	uxtb.w	r8, r9
    be82:	d820      	bhi.n	bec6 <NeuralNetwork::DrawEditScreen()+0xee>
                    neuron[ix].PrintParamNameAt(0, y, c);
    be84:	4643      	mov	r3, r8
    be86:	fa5f f28a 	uxtb.w	r2, sl
    be8a:	2100      	movs	r1, #0
    be8c:	4638      	mov	r0, r7
    be8e:	f7ff fa29 	bl	b2e4 <LogicGate::PrintParamNameAt(unsigned char, unsigned char, unsigned char)>
  text_x_ = x;
    be92:	2326      	movs	r3, #38	; 0x26
    be94:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    be96:	f8c5 a008 	str.w	sl, [r5, #8]
            if (cursor == 0) graphics.print(gate_name[type]);
    be9a:	f1b8 0f00 	cmp.w	r8, #0
    be9e:	d12c      	bne.n	befa <NeuralNetwork::DrawEditScreen()+0x122>
    bea0:	f8db 2400 	ldr.w	r2, [fp, #1024]	; 0x400
    bea4:	4b69      	ldr	r3, [pc, #420]	; (c04c <NeuralNetwork::DrawEditScreen()+0x274>)
            if (cursor == 3) graphics.print(source_name[source3]);
    bea6:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    beaa:	4865      	ldr	r0, [pc, #404]	; (c040 <NeuralNetwork::DrawEditScreen()+0x268>)
    beac:	f00d fe13 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                    if (c == cursor) gfxCursor(39, y + 8, 23);
    beb0:	f894 33ea 	ldrb.w	r3, [r4, #1002]	; 0x3ea
    beb4:	4543      	cmp	r3, r8
    beb6:	d106      	bne.n	bec6 <NeuralNetwork::DrawEditScreen()+0xee>
    beb8:	6a60      	ldr	r0, [r4, #36]	; 0x24
    beba:	2317      	movs	r3, #23
    bebc:	f10a 0208 	add.w	r2, sl, #8
    bec0:	2127      	movs	r1, #39	; 0x27
    bec2:	f7f8 fe71 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            for (byte c = 0; c < p; c++)
    bec6:	9a03      	ldr	r2, [sp, #12]
    bec8:	f109 0901 	add.w	r9, r9, #1
    becc:	fa5f f389 	uxtb.w	r3, r9
    bed0:	429a      	cmp	r2, r3
    bed2:	f10a 0a0a 	add.w	sl, sl, #10
    bed6:	d8d0      	bhi.n	be7a <NeuralNetwork::DrawEditScreen()+0xa2>
        if (neuron[ix].type == LogicGateType::TL_NEURON) DrawTLNeuron(ix);
    bed8:	2524      	movs	r5, #36	; 0x24
    beda:	fb05 4706 	mla	r7, r5, r6, r4
    bede:	f8d7 3400 	ldr.w	r3, [r7, #1024]	; 0x400
    bee2:	2b0b      	cmp	r3, #11
    bee4:	d11b      	bne.n	bf1e <NeuralNetwork::DrawEditScreen()+0x146>
    bee6:	4631      	mov	r1, r6
    bee8:	4620      	mov	r0, r4
    beea:	f7ff fd37 	bl	b95c <NeuralNetwork::DrawTLNeuron(unsigned char)>
    }
    beee:	b007      	add	sp, #28
    bef0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        graphics.drawFrame(x, y, w, h);
    bef4:	f00d fb81 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
    }
    bef8:	e79e      	b.n	be38 <NeuralNetwork::DrawEditScreen()+0x60>
            if (cursor == 1) graphics.print(source_name[source1]);
    befa:	f1b8 0f01 	cmp.w	r8, #1
    befe:	d103      	bne.n	bf08 <NeuralNetwork::DrawEditScreen()+0x130>
    bf00:	f8db 2404 	ldr.w	r2, [fp, #1028]	; 0x404
            if (cursor == 3) graphics.print(source_name[source3]);
    bf04:	4b52      	ldr	r3, [pc, #328]	; (c050 <NeuralNetwork::DrawEditScreen()+0x278>)
    bf06:	e7ce      	b.n	bea6 <NeuralNetwork::DrawEditScreen()+0xce>
            if (cursor == 2) graphics.print(source_name[source2]);
    bf08:	f1b8 0f02 	cmp.w	r8, #2
    bf0c:	d102      	bne.n	bf14 <NeuralNetwork::DrawEditScreen()+0x13c>
    bf0e:	f8db 2408 	ldr.w	r2, [fp, #1032]	; 0x408
    bf12:	e7f7      	b.n	bf04 <NeuralNetwork::DrawEditScreen()+0x12c>
            if (cursor == 3) graphics.print(source_name[source3]);
    bf14:	f1b8 0f03 	cmp.w	r8, #3
    bf18:	d1ca      	bne.n	beb0 <NeuralNetwork::DrawEditScreen()+0xd8>
    bf1a:	693a      	ldr	r2, [r7, #16]
    bf1c:	e7f2      	b.n	bf04 <NeuralNetwork::DrawEditScreen()+0x12c>
        if (neuron[ix].type != LogicGateType::NONE) {
    bf1e:	2b00      	cmp	r3, #0
    bf20:	d0e5      	beq.n	beee <NeuralNetwork::DrawEditScreen()+0x116>
            DrawInputs(ix);
    bf22:	4631      	mov	r1, r6
    bf24:	4620      	mov	r0, r4
    bf26:	f7ff fdcd 	bl	bac4 <NeuralNetwork::DrawInputs(unsigned char)>
            DrawBody(ix);
    bf2a:	4631      	mov	r1, r6
    bf2c:	4620      	mov	r0, r4
    bf2e:	f7ff fe01 	bl	bb34 <NeuralNetwork::DrawBody(unsigned char)>
        if (neuron[ix].type == LogicGateType::NOT
    bf32:	f8d7 3400 	ldr.w	r3, [r7, #1024]	; 0x400
    bf36:	2b01      	cmp	r3, #1
    bf38:	d002      	beq.n	bf40 <NeuralNetwork::DrawEditScreen()+0x168>
         || neuron[ix].type == LogicGateType::NAND
    bf3a:	3b05      	subs	r3, #5
    bf3c:	2b02      	cmp	r3, #2
    bf3e:	d820      	bhi.n	bf82 <NeuralNetwork::DrawEditScreen()+0x1aa>
        graphics.drawCircle(x, y, r);
    bf40:	483f      	ldr	r0, [pc, #252]	; (c040 <NeuralNetwork::DrawEditScreen()+0x268>)
    bf42:	2304      	movs	r3, #4
    bf44:	2224      	movs	r2, #36	; 0x24
    bf46:	2170      	movs	r1, #112	; 0x70
    bf48:	f00d fc5b 	bl	19802 <weegfx::Graphics::drawCircle(int, int, int)>
    		if (neuron[ix].state) {
    bf4c:	2324      	movs	r3, #36	; 0x24
    bf4e:	fb03 4306 	mla	r3, r3, r6, r4
    bf52:	f893 33fc 	ldrb.w	r3, [r3, #1020]	; 0x3fc
    bf56:	bb1b      	cbnz	r3, bfa0 <NeuralNetwork::DrawEditScreen()+0x1c8>
		int y = 0;
    bf58:	2000      	movs	r0, #0
        gfxDottedLine(116, 36 + (y * 2), 127, 36 + (y * 2), neuron[ix].state ? 1 : 3);
    bf5a:	2324      	movs	r3, #36	; 0x24
    bf5c:	fb03 4606 	mla	r6, r3, r6, r4
    bf60:	f100 0212 	add.w	r2, r0, #18
    bf64:	f896 33fc 	ldrb.w	r3, [r6, #1020]	; 0x3fc
        graphics.drawLine(x, y, x2, y2, p);
    bf68:	4835      	ldr	r0, [pc, #212]	; (c040 <NeuralNetwork::DrawEditScreen()+0x268>)
    bf6a:	2b00      	cmp	r3, #0
    bf6c:	bf14      	ite	ne
    bf6e:	2301      	movne	r3, #1
    bf70:	2303      	moveq	r3, #3
    bf72:	0052      	lsls	r2, r2, #1
    bf74:	e9cd 2300 	strd	r2, r3, [sp]
    bf78:	2174      	movs	r1, #116	; 0x74
    bf7a:	237f      	movs	r3, #127	; 0x7f
    bf7c:	f00d fbae 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
    }
    bf80:	e7b5      	b.n	beee <NeuralNetwork::DrawEditScreen()+0x116>
            gfxDottedLine(108, 36, 117, 36, neuron[ix].state ? 1 : 3);
    bf82:	f897 33fc 	ldrb.w	r3, [r7, #1020]	; 0x3fc
    bf86:	482e      	ldr	r0, [pc, #184]	; (c040 <NeuralNetwork::DrawEditScreen()+0x268>)
    bf88:	9500      	str	r5, [sp, #0]
    bf8a:	2b00      	cmp	r3, #0
    bf8c:	bf14      	ite	ne
    bf8e:	2301      	movne	r3, #1
    bf90:	2303      	moveq	r3, #3
    bf92:	9301      	str	r3, [sp, #4]
    bf94:	462a      	mov	r2, r5
    bf96:	2375      	movs	r3, #117	; 0x75
    bf98:	216c      	movs	r1, #108	; 0x6c
    bf9a:	f00d fb9f 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
    }
    bf9e:	e7d5      	b.n	bf4c <NeuralNetwork::DrawEditScreen()+0x174>
    			if (random(1, 100) > 60) y = random(0, 3) - 1;
    bfa0:	2164      	movs	r1, #100	; 0x64
    bfa2:	2001      	movs	r0, #1
    bfa4:	f00d ffa3 	bl	19eee <random(long, long)>
    bfa8:	283c      	cmp	r0, #60	; 0x3c
    bfaa:	ddd5      	ble.n	bf58 <NeuralNetwork::DrawEditScreen()+0x180>
    bfac:	2103      	movs	r1, #3
    bfae:	2000      	movs	r0, #0
    bfb0:	f00d ff9d 	bl	19eee <random(long, long)>
    bfb4:	3801      	subs	r0, #1
    bfb6:	e7d0      	b.n	bf5a <NeuralNetwork::DrawEditScreen()+0x182>
        graphics.print(str);
    bfb8:	4926      	ldr	r1, [pc, #152]	; (c054 <NeuralNetwork::DrawEditScreen()+0x27c>)
    bfba:	f8df 909c 	ldr.w	r9, [pc, #156]	; c058 <NeuralNetwork::DrawEditScreen()+0x280>
    bfbe:	f8df a09c 	ldr.w	sl, [pc, #156]	; c05c <NeuralNetwork::DrawEditScreen()+0x284>
    bfc2:	4628      	mov	r0, r5
    bfc4:	f00d fd87 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    bfc8:	f04f 0819 	mov.w	r8, #25
    bfcc:	fa5f fb86 	uxtb.w	fp, r6
  text_x_ = x;
    bfd0:	2700      	movs	r7, #0
    bfd2:	4649      	mov	r1, r9
    bfd4:	4628      	mov	r0, r5
    bfd6:	606f      	str	r7, [r5, #4]
  text_y_ = y;
    bfd8:	f8c5 8008 	str.w	r8, [r5, #8]
    bfdc:	f00d fd7b 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                char out_name[2] = {static_cast<char>(o + 'A'), '\0'};
    bfe0:	f10b 0341 	add.w	r3, fp, #65	; 0x41
        graphics.print(str);
    bfe4:	a905      	add	r1, sp, #20
    bfe6:	4628      	mov	r0, r5
    bfe8:	f88d 7015 	strb.w	r7, [sp, #21]
    bfec:	f88d 3014 	strb.w	r3, [sp, #20]
    bff0:	f00d fd71 	bl	19ad6 <weegfx::Graphics::print(char const*)>
                byte ix = (setup * 4) + o;
    bff4:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	; 0x3f0
    bff8:	f8c5 8008 	str.w	r8, [r5, #8]
    bffc:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
    c000:	b2df      	uxtb	r7, r3
                gfxPrint(output_neuron[ix] + 1);
    c002:	eb04 0787 	add.w	r7, r4, r7, lsl #2
  text_x_ = x;
    c006:	2340      	movs	r3, #64	; 0x40
        graphics.print(str);
    c008:	4651      	mov	r1, sl
    c00a:	4628      	mov	r0, r5
    c00c:	606b      	str	r3, [r5, #4]
    c00e:	f00d fd62 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    c012:	f8d7 175c 	ldr.w	r1, [r7, #1884]	; 0x75c
        graphics.print(num);
    c016:	4628      	mov	r0, r5
    c018:	3101      	adds	r1, #1
    c01a:	f00d fdd0 	bl	19bbe <weegfx::Graphics::print(int)>
                if (cursor == o) gfxCursor(65, y + 8, 47);
    c01e:	f894 33ea 	ldrb.w	r3, [r4, #1002]	; 0x3ea
    c022:	455b      	cmp	r3, fp
    c024:	d106      	bne.n	c034 <NeuralNetwork::DrawEditScreen()+0x25c>
    c026:	6a60      	ldr	r0, [r4, #36]	; 0x24
    c028:	232f      	movs	r3, #47	; 0x2f
    c02a:	f108 0208 	add.w	r2, r8, #8
    c02e:	2141      	movs	r1, #65	; 0x41
    c030:	f7f8 fdba 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
            for (byte o = 0; o < 4; o++)
    c034:	3601      	adds	r6, #1
    c036:	2e04      	cmp	r6, #4
    c038:	f108 080a 	add.w	r8, r8, #10
    c03c:	d1c6      	bne.n	bfcc <NeuralNetwork::DrawEditScreen()+0x1f4>
    c03e:	e756      	b.n	beee <NeuralNetwork::DrawEditScreen()+0x116>
    c040:	200065e0 	.word	0x200065e0
    c044:	0001f295 	.word	0x0001f295
    c048:	00022f38 	.word	0x00022f38
    c04c:	00024240 	.word	0x00024240
    c050:	00023cb0 	.word	0x00023cb0
    c054:	00021164 	.word	0x00021164
    c058:	00021173 	.word	0x00021173
    c05c:	0002117b 	.word	0x0002117b

0000c060 <NeuralNetwork::View()>:
    void View() {
    c060:	b538      	push	{r3, r4, r5, lr}
        if (copy_mode) DrawCopyScreen();
    c062:	f890 33f5 	ldrb.w	r3, [r0, #1013]	; 0x3f5
    void View() {
    c066:	4604      	mov	r4, r0
        if (copy_mode) DrawCopyScreen();
    c068:	b113      	cbz	r3, c070 <NeuralNetwork::View()+0x10>
    c06a:	f7ff fb79 	bl	b760 <NeuralNetwork::DrawCopyScreen()>
    }
    c06e:	bd38      	pop	{r3, r4, r5, pc}
    c070:	4d0d      	ldr	r5, [pc, #52]	; (c0a8 <NeuralNetwork::View()+0x48>)
        gfxHeader("Neural Net");
    c072:	490e      	ldr	r1, [pc, #56]	; (c0ac <NeuralNetwork::View()+0x4c>)
    c074:	f7f9 fe86 	bl	5d84 <HSApplication::gfxHeader(char const*)>
    c078:	2356      	movs	r3, #86	; 0x56
        graphics.print(str);
    c07a:	490d      	ldr	r1, [pc, #52]	; (c0b0 <NeuralNetwork::View()+0x50>)
    c07c:	606b      	str	r3, [r5, #4]
    c07e:	4628      	mov	r0, r5
  text_y_ = y;
    c080:	2301      	movs	r3, #1
    c082:	60ab      	str	r3, [r5, #8]
    c084:	f00d fd27 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(setup + 1);
    c088:	f8d4 13f0 	ldr.w	r1, [r4, #1008]	; 0x3f0
        graphics.print(num);
    c08c:	4628      	mov	r0, r5
    c08e:	3101      	adds	r1, #1
    c090:	f00d fd95 	bl	19bbe <weegfx::Graphics::print(int)>
        if (screen) DrawEditScreen();
    c094:	f894 33f4 	ldrb.w	r3, [r4, #1012]	; 0x3f4
    c098:	4620      	mov	r0, r4
    c09a:	b113      	cbz	r3, c0a2 <NeuralNetwork::View()+0x42>
    c09c:	f7ff fe9c 	bl	bdd8 <NeuralNetwork::DrawEditScreen()>
    c0a0:	e7e5      	b.n	c06e <NeuralNetwork::View()+0xe>
        else DrawSelectorScreen();
    c0a2:	f7ff fa43 	bl	b52c <NeuralNetwork::DrawSelectorScreen()>
    }
    c0a6:	e7e2      	b.n	c06e <NeuralNetwork::View()+0xe>
    c0a8:	200065e0 	.word	0x200065e0
    c0ac:	000210d0 	.word	0x000210d0
    c0b0:	00021109 	.word	0x00021109

0000c0b4 <Pong::StartNewGame()>:
	void StartNewGame() {
    c0b4:	b538      	push	{r3, r4, r5, lr}
		ball_delay = INITIAL_BALL_DELAY;
    c0b6:	f44f 73c8 	mov.w	r3, #400	; 0x190
		paddle_countdown = 0;
    c0ba:	2500      	movs	r5, #0
		ball_delay = INITIAL_BALL_DELAY;
    c0bc:	6003      	str	r3, [r0, #0]
		ball_countdown = ball_delay;
    c0be:	6043      	str	r3, [r0, #4]
		ball_x = 32;
    c0c0:	2320      	movs	r3, #32
	void StartNewGame() {
    c0c2:	4604      	mov	r4, r0
		ball_x = 32;
    c0c4:	6203      	str	r3, [r0, #32]
		paddle_countdown = 0;
    c0c6:	6085      	str	r5, [r0, #8]
		score = 0;
    c0c8:	6145      	str	r5, [r0, #20]
		level_up_x_advance = 0; // Used to smoothly move the paddle forward after level-up
    c0ca:	61c5      	str	r5, [r0, #28]
		ball_y = random(BOUNDARY_TOP + 2, BOUNDARY_BOTTOM - 2); // Start off in a random spot
    c0cc:	213b      	movs	r1, #59	; 0x3b
    c0ce:	200d      	movs	r0, #13
    c0d0:	f00d ff0d 	bl	19eee <random(long, long)>
		dir_x = 1;
    c0d4:	2301      	movs	r3, #1
    c0d6:	62a3      	str	r3, [r4, #40]	; 0x28
		ball_y = random(BOUNDARY_TOP + 2, BOUNDARY_BOTTOM - 2); // Start off in a random spot
    c0d8:	6260      	str	r0, [r4, #36]	; 0x24
		dir_y = random(0, 100) > 50 ? 1 : -1; // Start off in a random direction
    c0da:	2164      	movs	r1, #100	; 0x64
    c0dc:	4628      	mov	r0, r5
    c0de:	f00d ff06 	bl	19eee <random(long, long)>
    c0e2:	2832      	cmp	r0, #50	; 0x32
    c0e4:	bfcc      	ite	gt
    c0e6:	2301      	movgt	r3, #1
    c0e8:	f04f 33ff 	movle.w	r3, #4294967295	; 0xffffffff
    c0ec:	62e3      	str	r3, [r4, #44]	; 0x2c
		paddle_y = 1 + BOUNDARY_TOP;
    c0ee:	220c      	movs	r2, #12
		paddle_x = 16;
    c0f0:	2310      	movs	r3, #16
    c0f2:	6323      	str	r3, [r4, #48]	; 0x30
		paddle_y = 1 + BOUNDARY_TOP;
    c0f4:	6362      	str	r2, [r4, #52]	; 0x34
		paddle_h = 16;
    c0f6:	63a3      	str	r3, [r4, #56]	; 0x38
	}
    c0f8:	bd38      	pop	{r3, r4, r5, pc}
    c0fa:	Address 0x000000000000c0fa is out of bounds.


0000c0fc <PONGGAME_init()>:
void PONGGAME_init() {
    c0fc:	b508      	push	{r3, lr}
		return_countdown = 0;
    c0fe:	4804      	ldr	r0, [pc, #16]	; (c110 <PONGGAME_init()+0x14>)
    c100:	2300      	movs	r3, #0
    c102:	60c3      	str	r3, [r0, #12]
		bounce_countdown = 0;
    c104:	6103      	str	r3, [r0, #16]
		hi_score = 0;
    c106:	6183      	str	r3, [r0, #24]
		StartNewGame();
    c108:	f7ff ffd4 	bl	c0b4 <Pong::StartNewGame()>
}
    c10c:	bd08      	pop	{r3, pc}
    c10e:	bf00      	nop
    c110:	20005a20 	.word	0x20005a20

0000c114 <Pong::DrawBall()>:
    void DrawBall() {
    c114:	b570      	push	{r4, r5, r6, lr}
    		graphics.setPixel(ball_x, ball_y);
    c116:	6a43      	ldr	r3, [r0, #36]	; 0x24
  return frame_ + ((y >>3) << 7) + x;
    c118:	6a04      	ldr	r4, [r0, #32]
    c11a:	491c      	ldr	r1, [pc, #112]	; (c18c <Pong::DrawBall()+0x78>)
    c11c:	10da      	asrs	r2, r3, #3
    c11e:	680d      	ldr	r5, [r1, #0]
    c120:	eb04 14c2 	add.w	r4, r4, r2, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    c124:	f003 0307 	and.w	r3, r3, #7
    c128:	5d2e      	ldrb	r6, [r5, r4]
    c12a:	2201      	movs	r2, #1
    c12c:	fa02 f303 	lsl.w	r3, r2, r3
    c130:	4333      	orrs	r3, r6
    c132:	552b      	strb	r3, [r5, r4]
    		graphics.setPixel(ball_x + 1, ball_y + 1);
    c134:	6a43      	ldr	r3, [r0, #36]	; 0x24
    c136:	6a04      	ldr	r4, [r0, #32]
    c138:	4413      	add	r3, r2
  return frame_ + ((y >>3) << 7) + x;
    c13a:	10dd      	asrs	r5, r3, #3
    c13c:	4414      	add	r4, r2
    c13e:	eb04 14c5 	add.w	r4, r4, r5, lsl #7
    c142:	680d      	ldr	r5, [r1, #0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    c144:	f003 0307 	and.w	r3, r3, #7
    c148:	5d2e      	ldrb	r6, [r5, r4]
    c14a:	fa02 f303 	lsl.w	r3, r2, r3
    c14e:	4333      	orrs	r3, r6
    c150:	552b      	strb	r3, [r5, r4]
    		graphics.setPixel(ball_x + 1, ball_y);
    c152:	6a43      	ldr	r3, [r0, #36]	; 0x24
    c154:	6a04      	ldr	r4, [r0, #32]
  return frame_ + ((y >>3) << 7) + x;
    c156:	10dd      	asrs	r5, r3, #3
    c158:	4414      	add	r4, r2
    c15a:	eb04 14c5 	add.w	r4, r4, r5, lsl #7
    c15e:	680d      	ldr	r5, [r1, #0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    c160:	f003 0307 	and.w	r3, r3, #7
    c164:	5d2e      	ldrb	r6, [r5, r4]
    c166:	fa02 f303 	lsl.w	r3, r2, r3
    c16a:	4333      	orrs	r3, r6
    c16c:	552b      	strb	r3, [r5, r4]
    		graphics.setPixel(ball_x, ball_y + 1);
    c16e:	6a43      	ldr	r3, [r0, #36]	; 0x24
  return frame_ + ((y >>3) << 7) + x;
    c170:	6a00      	ldr	r0, [r0, #32]
    c172:	6809      	ldr	r1, [r1, #0]
    c174:	4413      	add	r3, r2
    c176:	10dc      	asrs	r4, r3, #3
    c178:	eb00 10c4 	add.w	r0, r0, r4, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    c17c:	f003 0307 	and.w	r3, r3, #7
    c180:	409a      	lsls	r2, r3
    c182:	5c0b      	ldrb	r3, [r1, r0]
    c184:	431a      	orrs	r2, r3
    c186:	540a      	strb	r2, [r1, r0]
    }
    c188:	bd70      	pop	{r4, r5, r6, pc}
    c18a:	bf00      	nop
    c18c:	200065e0 	.word	0x200065e0

0000c190 <PONGGAME_menu()>:
void PONGGAME_loop() {
	pong_instance.MoveBall();
	pong_instance.UpdateCVState();
}

void PONGGAME_menu() {
    c190:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	// Frame
	graphics.drawFrame(0, 9, 128, 55);
    c192:	4d1f      	ldr	r5, [pc, #124]	; (c210 <PONGGAME_menu()+0x80>)
    int get_score() {return score;}
    c194:	4c1f      	ldr	r4, [pc, #124]	; (c214 <PONGGAME_menu()+0x84>)
	graphics.drawFrame(0, 9, 128, 55);
    c196:	2337      	movs	r3, #55	; 0x37
    c198:	9300      	str	r3, [sp, #0]
    c19a:	2209      	movs	r2, #9
    c19c:	2380      	movs	r3, #128	; 0x80
    c19e:	2100      	movs	r1, #0
    c1a0:	4628      	mov	r0, r5
    c1a2:	f00d fa2a 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
    int get_score() {return score;}
    c1a6:	6966      	ldr	r6, [r4, #20]
    int get_hi_score() {return hi_score;}
    c1a8:	69a7      	ldr	r7, [r4, #24]
  text_x_ = x;
    c1aa:	2301      	movs	r3, #1
    c1ac:	606b      	str	r3, [r5, #4]
  text_y_ = y;
    c1ae:	60ab      	str	r3, [r5, #8]

	// Header
	graphics.setPrintPos(1,1);
	int score = pong_instance.get_score();
	int hi_score = pong_instance.get_hi_score();
	if (score == 0 && hi_score > 0) {
    c1b0:	bb36      	cbnz	r6, c200 <PONGGAME_menu()+0x70>
    c1b2:	2f00      	cmp	r7, #0
    c1b4:	dd24      	ble.n	c200 <PONGGAME_menu()+0x70>
		graphics.print("Pong High : ");
    c1b6:	4918      	ldr	r1, [pc, #96]	; (c218 <PONGGAME_menu()+0x88>)
    c1b8:	4628      	mov	r0, r5
    c1ba:	f00d fc8c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
	    graphics.print(hi_score);
    c1be:	4639      	mov	r1, r7
    c1c0:	4628      	mov	r0, r5
	} else {
		graphics.print("Pong Score: ");
	    graphics.print(score);
    c1c2:	f00d fcfc 	bl	19bbe <weegfx::Graphics::print(int)>
	}

	// Game pieces
	pong_instance.DrawBall();
    c1c6:	4813      	ldr	r0, [pc, #76]	; (c214 <PONGGAME_menu()+0x84>)
    c1c8:	f7ff ffa4 	bl	c114 <Pong::DrawBall()>
    		graphics.drawRect(paddle_x, paddle_y, PADDLE_WIDTH, paddle_h);
    c1cc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    c1ce:	6b62      	ldr	r2, [r4, #52]	; 0x34
    c1d0:	6b21      	ldr	r1, [r4, #48]	; 0x30
    c1d2:	9300      	str	r3, [sp, #0]
    c1d4:	480e      	ldr	r0, [pc, #56]	; (c210 <PONGGAME_menu()+0x80>)
    c1d6:	2303      	movs	r3, #3
    c1d8:	f00d f85c 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
    		int oc_y = ball_y - 8;
    c1dc:	6a62      	ldr	r2, [r4, #36]	; 0x24
    		graphics.drawRect(oc_x, oc_y, PADDLE_WIDTH, 16);
    c1de:	480c      	ldr	r0, [pc, #48]	; (c210 <PONGGAME_menu()+0x80>)
    		int oc_y = ball_y - 8;
    c1e0:	3a08      	subs	r2, #8
    		graphics.drawRect(oc_x, oc_y, PADDLE_WIDTH, 16);
    c1e2:	2a2d      	cmp	r2, #45	; 0x2d
    c1e4:	bfa8      	it	ge
    c1e6:	222d      	movge	r2, #45	; 0x2d
    c1e8:	2a0b      	cmp	r2, #11
    c1ea:	f04f 0310 	mov.w	r3, #16
    c1ee:	9300      	str	r3, [sp, #0]
    c1f0:	bfb8      	it	lt
    c1f2:	220b      	movlt	r2, #11
    c1f4:	2303      	movs	r3, #3
    c1f6:	216f      	movs	r1, #111	; 0x6f
    c1f8:	f00d f84c 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
    pong_instance.DrawPlayerPaddle();
    pong_instance.DrawOCPaddle();

}
    c1fc:	b003      	add	sp, #12
    c1fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		graphics.print("Pong Score: ");
    c200:	4906      	ldr	r1, [pc, #24]	; (c21c <PONGGAME_menu()+0x8c>)
    c202:	4803      	ldr	r0, [pc, #12]	; (c210 <PONGGAME_menu()+0x80>)
    c204:	f00d fc67 	bl	19ad6 <weegfx::Graphics::print(char const*)>
	    graphics.print(score);
    c208:	4801      	ldr	r0, [pc, #4]	; (c210 <PONGGAME_menu()+0x80>)
    c20a:	4631      	mov	r1, r6
    c20c:	e7d9      	b.n	c1c2 <PONGGAME_menu()+0x32>
    c20e:	bf00      	nop
    c210:	200065e0 	.word	0x200065e0
    c214:	20005a20 	.word	0x20005a20
    c218:	00021183 	.word	0x00021183
    c21c:	00021190 	.word	0x00021190

0000c220 <Pong::MovePaddleUp()>:
    		if (paddle_countdown <= 0) {
    c220:	6883      	ldr	r3, [r0, #8]
    c222:	2b00      	cmp	r3, #0
    c224:	dc07      	bgt.n	c236 <Pong::MovePaddleUp()+0x16>
    			--paddle_y;
    c226:	6b43      	ldr	r3, [r0, #52]	; 0x34
    c228:	3b01      	subs	r3, #1
    c22a:	2b0b      	cmp	r3, #11
    c22c:	bfb8      	it	lt
    c22e:	230b      	movlt	r3, #11
    c230:	6343      	str	r3, [r0, #52]	; 0x34
    			paddle_countdown = PADDLE_DELAY;
    c232:	23c8      	movs	r3, #200	; 0xc8
    c234:	6083      	str	r3, [r0, #8]
    }
    c236:	4770      	bx	lr

0000c238 <Pong::MovePaddleDown()>:
    	    if (paddle_countdown <= 0) {
    c238:	6883      	ldr	r3, [r0, #8]
    c23a:	2b00      	cmp	r3, #0
    c23c:	dc0a      	bgt.n	c254 <Pong::MovePaddleDown()+0x1c>
    	    		++paddle_y;
    c23e:	6b43      	ldr	r3, [r0, #52]	; 0x34
    c240:	1c5a      	adds	r2, r3, #1
    	    		if (paddle_y > (BOUNDARY_BOTTOM - paddle_h)) paddle_y = BOUNDARY_BOTTOM - paddle_h;
    c242:	6b83      	ldr	r3, [r0, #56]	; 0x38
    c244:	f1c3 033d 	rsb	r3, r3, #61	; 0x3d
    c248:	429a      	cmp	r2, r3
    c24a:	bfd4      	ite	le
    c24c:	6342      	strle	r2, [r0, #52]	; 0x34
    c24e:	6343      	strgt	r3, [r0, #52]	; 0x34
    	    		paddle_countdown = PADDLE_DELAY;
    c250:	23c8      	movs	r3, #200	; 0xc8
    c252:	6083      	str	r3, [r0, #8]
    }
    c254:	4770      	bx	lr

0000c256 <Pong::UpdateCVState()>:
    void UpdateCVState() {
    c256:	b570      	push	{r4, r5, r6, lr}
    c258:	4604      	mov	r4, r0
	    current_value = OC::ADC::raw_pitch_value(ADC_CHANNEL_1);
    c25a:	2000      	movs	r0, #0
    c25c:	f7f8 fea4 	bl	4fa8 <OC::ADC::raw_pitch_value(ADC_CHANNEL)>
	    if (current_value < -CENTER_DETENT) MovePaddleUp();
    c260:	f510 7f20 	cmn.w	r0, #640	; 0x280
    c264:	da2f      	bge.n	c2c6 <Pong::UpdateCVState()+0x70>
    c266:	4620      	mov	r0, r4
    c268:	f7ff ffda 	bl	c220 <Pong::MovePaddleUp()>
    		uint32_t out_A = return_countdown > 0 ? 5 : 0;
    c26c:	68e3      	ldr	r3, [r4, #12]
    		uint32_t out_C = (ball_y - BOUNDARY_TOP) * Y_POSITION_COEFF;
    c26e:	6a61      	ldr	r1, [r4, #36]	; 0x24
    		uint32_t out_A = return_countdown > 0 ? 5 : 0;
    c270:	2b00      	cmp	r3, #0
    		uint32_t out_B = bounce_countdown > 0 ? 5 : 0;
    c272:	6923      	ldr	r3, [r4, #16]
    		uint32_t out_A = return_countdown > 0 ? 5 : 0;
    c274:	bfcc      	ite	gt
    c276:	2205      	movgt	r2, #5
    c278:	2200      	movle	r2, #0
    		uint32_t out_B = bounce_countdown > 0 ? 5 : 0;
    c27a:	2b00      	cmp	r3, #0
    		uint32_t out_D = ((paddle_y + (paddle_h / 2)) - BOUNDARY_TOP) * Y_POSITION_COEFF;
    c27c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    c27e:	6b64      	ldr	r4, [r4, #52]	; 0x34
    		uint32_t out_C = (ball_y - BOUNDARY_TOP) * Y_POSITION_COEFF;
    c280:	f1a1 010b 	sub.w	r1, r1, #11
    		uint32_t out_D = ((paddle_y + (paddle_h / 2)) - BOUNDARY_TOP) * Y_POSITION_COEFF;
    c284:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    		uint32_t out_C = (ball_y - BOUNDARY_TOP) * Y_POSITION_COEFF;
    c288:	ea4f 16c1 	mov.w	r6, r1, lsl #7
	    OC::DAC::set_pitch(DAC_CHANNEL_A, 1, out_A);
    c28c:	f04f 0000 	mov.w	r0, #0
    c290:	f04f 0101 	mov.w	r1, #1
    		uint32_t out_B = bounce_countdown > 0 ? 5 : 0;
    c294:	bfcc      	ite	gt
    c296:	2505      	movgt	r5, #5
    c298:	2500      	movle	r5, #0
    		uint32_t out_D = ((paddle_y + (paddle_h / 2)) - BOUNDARY_TOP) * Y_POSITION_COEFF;
    c29a:	eb04 0463 	add.w	r4, r4, r3, asr #1
	    OC::DAC::set_pitch(DAC_CHANNEL_A, 1, out_A);
    c29e:	f7f8 fe07 	bl	4eb0 <OC::DAC::set_pitch(DAC_CHANNEL, long, long)>
	    OC::DAC::set_pitch(DAC_CHANNEL_B, 1, out_B);
    c2a2:	2101      	movs	r1, #1
    c2a4:	462a      	mov	r2, r5
    c2a6:	4608      	mov	r0, r1
    		uint32_t out_D = ((paddle_y + (paddle_h / 2)) - BOUNDARY_TOP) * Y_POSITION_COEFF;
    c2a8:	3c0b      	subs	r4, #11
	    OC::DAC::set_pitch(DAC_CHANNEL_B, 1, out_B);
    c2aa:	f7f8 fe01 	bl	4eb0 <OC::DAC::set_pitch(DAC_CHANNEL, long, long)>
    		uint32_t out_D = ((paddle_y + (paddle_h / 2)) - BOUNDARY_TOP) * Y_POSITION_COEFF;
    c2ae:	01e4      	lsls	r4, r4, #7
	    OC::DAC::set_pitch(DAC_CHANNEL_C, out_C, 0);
    c2b0:	4631      	mov	r1, r6
    c2b2:	2200      	movs	r2, #0
    c2b4:	2002      	movs	r0, #2
    c2b6:	f7f8 fdfb 	bl	4eb0 <OC::DAC::set_pitch(DAC_CHANNEL, long, long)>
	    OC::DAC::set_pitch(DAC_CHANNEL_D, out_D, 0);
    c2ba:	2200      	movs	r2, #0
    c2bc:	4621      	mov	r1, r4
    c2be:	2003      	movs	r0, #3
    c2c0:	f7f8 fdf6 	bl	4eb0 <OC::DAC::set_pitch(DAC_CHANNEL, long, long)>
    }
    c2c4:	bd70      	pop	{r4, r5, r6, pc}
	    if (current_value > CENTER_DETENT) MovePaddleDown();
    c2c6:	f5b0 7f20 	cmp.w	r0, #640	; 0x280
    c2ca:	ddcf      	ble.n	c26c <Pong::UpdateCVState()+0x16>
    c2cc:	4620      	mov	r0, r4
    c2ce:	f7ff ffb3 	bl	c238 <Pong::MovePaddleDown()>
    c2d2:	e7cb      	b.n	c26c <Pong::UpdateCVState()+0x16>

0000c2d4 <PONGGAME_loop()>:
void PONGGAME_loop() {
    c2d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    		if (ball_countdown <= 0) {
    c2d6:	4c37      	ldr	r4, [pc, #220]	; (c3b4 <PONGGAME_loop()+0xe0>)
    c2d8:	6863      	ldr	r3, [r4, #4]
    c2da:	2b00      	cmp	r3, #0
    c2dc:	dc61      	bgt.n	c3a2 <PONGGAME_loop()+0xce>
			if (level_up_x_advance-- > 0) paddle_x++;
    c2de:	69e6      	ldr	r6, [r4, #28]
    			ball_x += dir_x;
    c2e0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    c2e2:	6a23      	ldr	r3, [r4, #32]
			ball_y += dir_y;
    c2e4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    c2e6:	6a61      	ldr	r1, [r4, #36]	; 0x24
			if (level_up_x_advance-- > 0) paddle_x++;
    c2e8:	2e00      	cmp	r6, #0
    c2ea:	f106 35ff 	add.w	r5, r6, #4294967295	; 0xffffffff
    c2ee:	bfc8      	it	gt
    c2f0:	6b26      	ldrgt	r6, [r4, #48]	; 0x30
    c2f2:	61e5      	str	r5, [r4, #28]
    			ball_x += dir_x;
    c2f4:	4403      	add	r3, r0
			if (level_up_x_advance-- > 0) paddle_x++;
    c2f6:	bfc4      	itt	gt
    c2f8:	3601      	addgt	r6, #1
    c2fa:	6326      	strgt	r6, [r4, #48]	; 0x30
			if (ball_x > BOUNDARY_RIGHT || ball_x < BOUNDARY_LEFT) {
    c2fc:	1e9e      	subs	r6, r3, #2
    c2fe:	2e6b      	cmp	r6, #107	; 0x6b
				dir_x = -dir_x;
    c300:	bf88      	it	hi
    c302:	4240      	neghi	r0, r0
			ball_y += dir_y;
    c304:	4411      	add	r1, r2
				dir_x = -dir_x;
    c306:	bf82      	ittt	hi
    c308:	62a0      	strhi	r0, [r4, #40]	; 0x28
				bounce_countdown = TRIGGER_CYCLE_LENGTH;
    c30a:	f44f 70c8 	movhi.w	r0, #400	; 0x190
    c30e:	6120      	strhi	r0, [r4, #16]
			if (ball_y > BOUNDARY_BOTTOM || ball_y < BOUNDARY_TOP) {
    c310:	f1a1 000b 	sub.w	r0, r1, #11
    c314:	2832      	cmp	r0, #50	; 0x32
				dir_y = -dir_y;
    c316:	bf88      	it	hi
    c318:	4252      	neghi	r2, r2
			if ((ball_x <= paddle_x + PADDLE_WIDTH) && (ball_x >= paddle_x)
    c31a:	6b26      	ldr	r6, [r4, #48]	; 0x30
				dir_y = -dir_y;
    c31c:	bf82      	ittt	hi
    c31e:	62e2      	strhi	r2, [r4, #44]	; 0x2c
				bounce_countdown = TRIGGER_CYCLE_LENGTH;
    c320:	f44f 72c8 	movhi.w	r2, #400	; 0x190
    c324:	6122      	strhi	r2, [r4, #16]
			if ((ball_x <= paddle_x + PADDLE_WIDTH) && (ball_x >= paddle_x)
    c326:	1cf2      	adds	r2, r6, #3
    c328:	4293      	cmp	r3, r2
    			ball_x += dir_x;
    c32a:	6223      	str	r3, [r4, #32]
			ball_y += dir_y;
    c32c:	6261      	str	r1, [r4, #36]	; 0x24
			if ((ball_x <= paddle_x + PADDLE_WIDTH) && (ball_x >= paddle_x)
    c32e:	dc2c      	bgt.n	c38a <PONGGAME_loop()+0xb6>
    c330:	42b3      	cmp	r3, r6
    c332:	db2a      	blt.n	c38a <PONGGAME_loop()+0xb6>
			  && (ball_y <= paddle_y + paddle_h) && (ball_y >= paddle_y) && dir_x < 0) {
    c334:	6b60      	ldr	r0, [r4, #52]	; 0x34
    c336:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c338:	1887      	adds	r7, r0, r2
    c33a:	42b9      	cmp	r1, r7
    c33c:	dc25      	bgt.n	c38a <PONGGAME_loop()+0xb6>
    c33e:	4281      	cmp	r1, r0
    c340:	db23      	blt.n	c38a <PONGGAME_loop()+0xb6>
    c342:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    c344:	2900      	cmp	r1, #0
    c346:	da20      	bge.n	c38a <PONGGAME_loop()+0xb6>
				score++;
    c348:	6960      	ldr	r0, [r4, #20]
				dir_x = -dir_x;
    c34a:	4249      	negs	r1, r1
    c34c:	62a1      	str	r1, [r4, #40]	; 0x28
				return_countdown = TRIGGER_CYCLE_LENGTH;
    c34e:	f44f 71c8 	mov.w	r1, #400	; 0x190
				score++;
    c352:	3001      	adds	r0, #1
				return_countdown = TRIGGER_CYCLE_LENGTH;
    c354:	60e1      	str	r1, [r4, #12]
    c356:	2105      	movs	r1, #5
    c358:	fb90 f1f1 	sdiv	r1, r0, r1
    c35c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
				if (!(score % 5)) LevelUp();
    c360:	4288      	cmp	r0, r1
				score++;
    c362:	6160      	str	r0, [r4, #20]
				if (!(score % 5)) LevelUp();
    c364:	d111      	bne.n	c38a <PONGGAME_loop()+0xb6>
		ball_delay -= 50;
    c366:	6821      	ldr	r1, [r4, #0]
		paddle_h--;
    c368:	3a01      	subs	r2, #1
		if (paddle_x < 64) level_up_x_advance = 4;
    c36a:	2e3f      	cmp	r6, #63	; 0x3f
		ball_delay -= 50;
    c36c:	f1a1 0132 	sub.w	r1, r1, #50	; 0x32
		if (paddle_x < 64) level_up_x_advance = 4;
    c370:	bfd8      	it	le
    c372:	2504      	movle	r5, #4
    c374:	2a04      	cmp	r2, #4
    c376:	bfb8      	it	lt
    c378:	2204      	movlt	r2, #4
		if (ball_delay < 100) ball_delay = 100;
    c37a:	2963      	cmp	r1, #99	; 0x63
    c37c:	63a2      	str	r2, [r4, #56]	; 0x38
    c37e:	bfd8      	it	le
    c380:	2264      	movle	r2, #100	; 0x64
		ball_delay -= 50;
    c382:	6021      	str	r1, [r4, #0]
		if (paddle_x < 64) level_up_x_advance = 4;
    c384:	61e5      	str	r5, [r4, #28]
		if (ball_delay < 100) ball_delay = 100;
    c386:	bfd8      	it	le
    c388:	6022      	strle	r2, [r4, #0]
			if (ball_x < 2) {
    c38a:	2b01      	cmp	r3, #1
    c38c:	dc07      	bgt.n	c39e <PONGGAME_loop()+0xca>
				if (score > hi_score) hi_score = score;
    c38e:	6963      	ldr	r3, [r4, #20]
    c390:	69a2      	ldr	r2, [r4, #24]
				StartNewGame();
    c392:	4808      	ldr	r0, [pc, #32]	; (c3b4 <PONGGAME_loop()+0xe0>)
				if (score > hi_score) hi_score = score;
    c394:	4293      	cmp	r3, r2
    c396:	bfc8      	it	gt
    c398:	61a3      	strgt	r3, [r4, #24]
				StartNewGame();
    c39a:	f7ff fe8b 	bl	c0b4 <Pong::StartNewGame()>
			ball_countdown = ball_delay; // Reset delay to start a new movement cycle
    c39e:	6823      	ldr	r3, [r4, #0]
    c3a0:	6063      	str	r3, [r4, #4]
    		if (paddle_countdown <= 0) {paddle_countdown = 0;}
    c3a2:	68a3      	ldr	r3, [r4, #8]
	pong_instance.UpdateCVState();
    c3a4:	4803      	ldr	r0, [pc, #12]	; (c3b4 <PONGGAME_loop()+0xe0>)
    		if (paddle_countdown <= 0) {paddle_countdown = 0;}
    c3a6:	2b00      	cmp	r3, #0
    c3a8:	bfdc      	itt	le
    c3aa:	2300      	movle	r3, #0
    c3ac:	60a3      	strle	r3, [r4, #8]
	pong_instance.UpdateCVState();
    c3ae:	f7ff ff52 	bl	c256 <Pong::UpdateCVState()>
}
    c3b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c3b4:	20005a20 	.word	0x20005a20

0000c3b8 <PONGGAME_handleButtonEvent(UI::Event const&)>:

/* Controlling the game with the buttons is the worst experience ever, so this is really just here
 * to demonstrate how the buttons work.
 */
void PONGGAME_handleButtonEvent(const UI::Event &event) {
	if (UI::EVENT_BUTTON_PRESS == event.type) {
    c3b8:	7803      	ldrb	r3, [r0, #0]
    c3ba:	2b01      	cmp	r3, #1
void PONGGAME_handleButtonEvent(const UI::Event &event) {
    c3bc:	b510      	push	{r4, lr}
	if (UI::EVENT_BUTTON_PRESS == event.type) {
    c3be:	d104      	bne.n	c3ca <PONGGAME_handleButtonEvent(UI::Event const&)+0x12>
	    switch (event.control) {
    c3c0:	8843      	ldrh	r3, [r0, #2]
    c3c2:	2b01      	cmp	r3, #1
    c3c4:	d002      	beq.n	c3cc <PONGGAME_handleButtonEvent(UI::Event const&)+0x14>
    c3c6:	2b02      	cmp	r3, #2
    c3c8:	d007      	beq.n	c3da <PONGGAME_handleButtonEvent(UI::Event const&)+0x22>
	    	    pong_instance.MovePaddleDown();
	    		pong_instance.ResetPaddle();
	        break;
	    }
	}
}
    c3ca:	bd10      	pop	{r4, pc}
	    	    pong_instance.MovePaddleUp();
    c3cc:	4c05      	ldr	r4, [pc, #20]	; (c3e4 <PONGGAME_handleButtonEvent(UI::Event const&)+0x2c>)
    c3ce:	4620      	mov	r0, r4
    c3d0:	f7ff ff26 	bl	c220 <Pong::MovePaddleUp()>
    		paddle_countdown = 0;
    c3d4:	2300      	movs	r3, #0
    c3d6:	60a3      	str	r3, [r4, #8]
}
    c3d8:	e7f7      	b.n	c3ca <PONGGAME_handleButtonEvent(UI::Event const&)+0x12>
	    	    pong_instance.MovePaddleDown();
    c3da:	4c02      	ldr	r4, [pc, #8]	; (c3e4 <PONGGAME_handleButtonEvent(UI::Event const&)+0x2c>)
    c3dc:	4620      	mov	r0, r4
    c3de:	f7ff ff2b 	bl	c238 <Pong::MovePaddleDown()>
    c3e2:	e7f7      	b.n	c3d4 <PONGGAME_handleButtonEvent(UI::Event const&)+0x1c>
    c3e4:	20005a20 	.word	0x20005a20

0000c3e8 <PONGGAME_handleEncoderEvent(UI::Event const&)>:

/* The UI::Event has a value property, which is positive when the encoder is turned clockwise and
 * negative when it's turned widdershins. I just wanted to say "widdershins."
 */
void PONGGAME_handleEncoderEvent(const UI::Event &event) {
    c3e8:	b508      	push	{r3, lr}
	if (event.value < 0) pong_instance.MovePaddleUp();
    c3ea:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
    c3ee:	2b00      	cmp	r3, #0
    c3f0:	da06      	bge.n	c400 <PONGGAME_handleEncoderEvent(UI::Event const&)+0x18>
    c3f2:	4806      	ldr	r0, [pc, #24]	; (c40c <PONGGAME_handleEncoderEvent(UI::Event const&)+0x24>)
    c3f4:	f7ff ff14 	bl	c220 <Pong::MovePaddleUp()>
    		paddle_countdown = 0;
    c3f8:	4b04      	ldr	r3, [pc, #16]	; (c40c <PONGGAME_handleEncoderEvent(UI::Event const&)+0x24>)
    c3fa:	2200      	movs	r2, #0
    c3fc:	609a      	str	r2, [r3, #8]
	if (event.value > 0) pong_instance.MovePaddleDown();
	pong_instance.ResetPaddle();
}
    c3fe:	bd08      	pop	{r3, pc}
	if (event.value > 0) pong_instance.MovePaddleDown();
    c400:	d0fa      	beq.n	c3f8 <PONGGAME_handleEncoderEvent(UI::Event const&)+0x10>
    c402:	4802      	ldr	r0, [pc, #8]	; (c40c <PONGGAME_handleEncoderEvent(UI::Event const&)+0x24>)
    c404:	f7ff ff18 	bl	c238 <Pong::MovePaddleDown()>
    c408:	e7f6      	b.n	c3f8 <PONGGAME_handleEncoderEvent(UI::Event const&)+0x10>
    c40a:	bf00      	nop
    c40c:	20005a20 	.word	0x20005a20

0000c410 <SegmentDisplay::Init(unsigned char)>:
    }
};

class SegmentDisplay {
public:
    void Init(uint8_t segment_size) {
    c410:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    c414:	4604      	mov	r4, r0
        size = segment_size;
    c416:	f880 105b 	strb.w	r1, [r0, #91]	; 0x5b

        if (size == SegmentSize::BIG_SEGMENTS) {
    c41a:	f100 0a0d 	add.w	sl, r0, #13
    c41e:	f100 091a 	add.w	r9, r0, #26
    c422:	f100 0827 	add.w	r8, r0, #39	; 0x27
    c426:	f100 0734 	add.w	r7, r0, #52	; 0x34
    c42a:	f100 0641 	add.w	r6, r0, #65	; 0x41
    c42e:	f100 054e 	add.w	r5, r0, #78	; 0x4e
            segment[0] = {PixO{2,0}, PixO{3,0}, PixO{4,0}, PixO{5,0}, PixO{3,1}, PixO{4,1}, 6};
    c432:	220d      	movs	r2, #13
        if (size == SegmentSize::BIG_SEGMENTS) {
    c434:	bb71      	cbnz	r1, c494 <SegmentDisplay::Init(unsigned char)+0x84>
            segment[0] = {PixO{2,0}, PixO{3,0}, PixO{4,0}, PixO{5,0}, PixO{3,1}, PixO{4,1}, 6};
    c436:	4927      	ldr	r1, [pc, #156]	; (c4d4 <SegmentDisplay::Init(unsigned char)+0xc4>)
    c438:	f00d fdda 	bl	19ff0 <memcpy>
            segment[1] = {PixO{6,2}, PixO{6,3}, PixO{7,1}, PixO{7,2}, PixO{7,3}, PixO{7,4}, 6};
    c43c:	4926      	ldr	r1, [pc, #152]	; (c4d8 <SegmentDisplay::Init(unsigned char)+0xc8>)
    c43e:	220d      	movs	r2, #13
    c440:	4650      	mov	r0, sl
    c442:	f00d fdd5 	bl	19ff0 <memcpy>
            segment[2] = {PixO{6,8}, PixO{6,9}, PixO{7,7}, PixO{7,8}, PixO{7,9}, PixO{7,10}, 6};
    c446:	4925      	ldr	r1, [pc, #148]	; (c4dc <SegmentDisplay::Init(unsigned char)+0xcc>)
    c448:	220d      	movs	r2, #13
    c44a:	4648      	mov	r0, r9
    c44c:	f00d fdd0 	bl	19ff0 <memcpy>
            segment[3] = {PixO{3,10}, PixO{4,10}, PixO{2,11}, PixO{3,11}, PixO{4,11}, PixO{5,11}, 6};
    c450:	4923      	ldr	r1, [pc, #140]	; (c4e0 <SegmentDisplay::Init(unsigned char)+0xd0>)
    c452:	220d      	movs	r2, #13
    c454:	4640      	mov	r0, r8
    c456:	f00d fdcb 	bl	19ff0 <memcpy>
            segment[4] = {PixO{0,7}, PixO{0,8}, PixO{0,9}, PixO{0,10}, PixO{1,8}, PixO{1,9}, 6};
    c45a:	4922      	ldr	r1, [pc, #136]	; (c4e4 <SegmentDisplay::Init(unsigned char)+0xd4>)
    c45c:	220d      	movs	r2, #13
    c45e:	4638      	mov	r0, r7
    c460:	f00d fdc6 	bl	19ff0 <memcpy>
            segment[5] = {PixO{0,1}, PixO{0,2}, PixO{0,3}, PixO{0,4}, PixO{1,2}, PixO{1,3}, 6};
    c464:	4920      	ldr	r1, [pc, #128]	; (c4e8 <SegmentDisplay::Init(unsigned char)+0xd8>)
    c466:	220d      	movs	r2, #13
    c468:	4630      	mov	r0, r6
    c46a:	f00d fdc1 	bl	19ff0 <memcpy>
            segment[6] = {PixO{3,5}, PixO{4,5}, PixO{2,6}, PixO{3,6}, PixO{4,6}, PixO{5,6}, 6};
    c46e:	491f      	ldr	r1, [pc, #124]	; (c4ec <SegmentDisplay::Init(unsigned char)+0xdc>)
    c470:	220d      	movs	r2, #13
            segment[1] = {PixO{3,0}, PixO{3,1}, PixO{3,2}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
            segment[2] = {PixO{3,2}, PixO{3,3}, PixO{3,4}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
            segment[3] = {PixO{1,4}, PixO{2,4}, PixO{3,4}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
            segment[4] = {PixO{1,2}, PixO{1,3}, PixO{1,4}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
            segment[5] = {PixO{1,0}, PixO{1,1}, PixO{1,2}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
            segment[6] = {PixO{1,2}, PixO{2,2}, PixO{3,2}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
    c472:	4628      	mov	r0, r5
    c474:	f00d fdbc 	bl	19ff0 <memcpy>
        }

        uint8_t digits[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x67};
    c478:	491d      	ldr	r1, [pc, #116]	; (c4f0 <SegmentDisplay::Init(unsigned char)+0xe0>)
    c47a:	220a      	movs	r2, #10
    c47c:	a801      	add	r0, sp, #4
    c47e:	f00d fdb7 	bl	19ff0 <memcpy>
        memcpy(&digit, &digits, sizeof(digits));
    c482:	220a      	movs	r2, #10
    c484:	a901      	add	r1, sp, #4
    c486:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    c48a:	f00d fdb1 	bl	19ff0 <memcpy>
    }
    c48e:	b004      	add	sp, #16
    c490:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            segment[0] = {PixO{1,0}, PixO{2,0}, PixO{3,0}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
    c494:	4917      	ldr	r1, [pc, #92]	; (c4f4 <SegmentDisplay::Init(unsigned char)+0xe4>)
    c496:	f00d fdab 	bl	19ff0 <memcpy>
            segment[1] = {PixO{3,0}, PixO{3,1}, PixO{3,2}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
    c49a:	4917      	ldr	r1, [pc, #92]	; (c4f8 <SegmentDisplay::Init(unsigned char)+0xe8>)
    c49c:	220d      	movs	r2, #13
    c49e:	4650      	mov	r0, sl
    c4a0:	f00d fda6 	bl	19ff0 <memcpy>
            segment[2] = {PixO{3,2}, PixO{3,3}, PixO{3,4}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
    c4a4:	4915      	ldr	r1, [pc, #84]	; (c4fc <SegmentDisplay::Init(unsigned char)+0xec>)
    c4a6:	220d      	movs	r2, #13
    c4a8:	4648      	mov	r0, r9
    c4aa:	f00d fda1 	bl	19ff0 <memcpy>
            segment[3] = {PixO{1,4}, PixO{2,4}, PixO{3,4}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
    c4ae:	4914      	ldr	r1, [pc, #80]	; (c500 <SegmentDisplay::Init(unsigned char)+0xf0>)
    c4b0:	220d      	movs	r2, #13
    c4b2:	4640      	mov	r0, r8
    c4b4:	f00d fd9c 	bl	19ff0 <memcpy>
            segment[4] = {PixO{1,2}, PixO{1,3}, PixO{1,4}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
    c4b8:	4912      	ldr	r1, [pc, #72]	; (c504 <SegmentDisplay::Init(unsigned char)+0xf4>)
    c4ba:	220d      	movs	r2, #13
    c4bc:	4638      	mov	r0, r7
    c4be:	f00d fd97 	bl	19ff0 <memcpy>
            segment[5] = {PixO{1,0}, PixO{1,1}, PixO{1,2}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
    c4c2:	4911      	ldr	r1, [pc, #68]	; (c508 <SegmentDisplay::Init(unsigned char)+0xf8>)
    c4c4:	220d      	movs	r2, #13
    c4c6:	4630      	mov	r0, r6
    c4c8:	f00d fd92 	bl	19ff0 <memcpy>
            segment[6] = {PixO{1,2}, PixO{2,2}, PixO{3,2}, PixO{0,0}, PixO{0,0}, PixO{0,0}, 3};
    c4cc:	490f      	ldr	r1, [pc, #60]	; (c50c <SegmentDisplay::Init(unsigned char)+0xfc>)
    c4ce:	220d      	movs	r2, #13
    c4d0:	e7cf      	b.n	c472 <SegmentDisplay::Init(unsigned char)+0x62>
    c4d2:	bf00      	nop
    c4d4:	00022e1c 	.word	0x00022e1c
    c4d8:	00022e29 	.word	0x00022e29
    c4dc:	00022e36 	.word	0x00022e36
    c4e0:	00022e43 	.word	0x00022e43
    c4e4:	00022e50 	.word	0x00022e50
    c4e8:	00022e5d 	.word	0x00022e5d
    c4ec:	00022e6a 	.word	0x00022e6a
    c4f0:	0002119d 	.word	0x0002119d
    c4f4:	00022e77 	.word	0x00022e77
    c4f8:	00022e84 	.word	0x00022e84
    c4fc:	00022e91 	.word	0x00022e91
    c500:	00022e9e 	.word	0x00022e9e
    c504:	00022eab 	.word	0x00022eab
    c508:	00022eb8 	.word	0x00022eb8
    c50c:	00022ec5 	.word	0x00022ec5

0000c510 <CVRecV2::Start()>:
    void Start() {
    c510:	b508      	push	{r3, lr}
        segment.Init(SegmentSize::BIG_SEGMENTS);
    c512:	2100      	movs	r1, #0
    c514:	3070      	adds	r0, #112	; 0x70
    c516:	f7ff ff7b 	bl	c410 <SegmentDisplay::Init(unsigned char)>
    }
    c51a:	bd08      	pop	{r3, pc}

0000c51c <Binary::Start()>:
    void Start() {
    c51c:	b508      	push	{r3, lr}
        segment.Init(SegmentSize::BIG_SEGMENTS);
    c51e:	2100      	movs	r1, #0
    c520:	3078      	adds	r0, #120	; 0x78
    c522:	f7ff ff75 	bl	c410 <SegmentDisplay::Init(unsigned char)>
    }
    c526:	bd08      	pop	{r3, pc}

0000c528 <SegmentDisplay::PrintDigit(unsigned char)>:
                PrintDigit(to_print[d]);
            }
        }
    }

    void PrintDigit(uint8_t d) {
    c528:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return frame_ + ((y >>3) << 7) + x;
    c52c:	f8df e088 	ldr.w	lr, [pc, #136]	; c5b8 <SegmentDisplay::PrintDigit(unsigned char)+0x90>
    c530:	2400      	movs	r4, #0
        for (uint8_t b = 0; b < 7; b++)
        {
            if ((digit[d] >> b) & 0x01) segment[b].DrawAt(x_pos, y_pos);
    c532:	4401      	add	r1, r0
    c534:	270d      	movs	r7, #13
        for (uint8_t i = 0; i < size; i++) pixels[i].DrawAt(x, y);
    c536:	f100 0c0c 	add.w	ip, r0, #12
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    c53a:	f04f 0801 	mov.w	r8, #1
            if ((digit[d] >> b) & 0x01) segment[b].DrawAt(x_pos, y_pos);
    c53e:	f891 305c 	ldrb.w	r3, [r1, #92]	; 0x5c
    c542:	4123      	asrs	r3, r4
    c544:	07db      	lsls	r3, r3, #31
    c546:	d40f      	bmi.n	c568 <SegmentDisplay::PrintDigit(unsigned char)+0x40>
        for (uint8_t b = 0; b < 7; b++)
    c548:	3401      	adds	r4, #1
    c54a:	2c07      	cmp	r4, #7
    c54c:	d1f7      	bne.n	c53e <SegmentDisplay::PrintDigit(unsigned char)+0x16>
    int decimal;



    uint8_t DigitWidth() {
        return (size == SegmentSize::BIG_SEGMENTS ? 10 : 4);
    c54e:	f890 305b 	ldrb.w	r3, [r0, #91]	; 0x5b
        x_pos += DigitWidth();
    c552:	f890 2066 	ldrb.w	r2, [r0, #102]	; 0x66
        return (size == SegmentSize::BIG_SEGMENTS ? 10 : 4);
    c556:	2b00      	cmp	r3, #0
    c558:	bf0c      	ite	eq
    c55a:	230a      	moveq	r3, #10
    c55c:	2304      	movne	r3, #4
        x_pos += DigitWidth();
    c55e:	4413      	add	r3, r2
    c560:	f880 3066 	strb.w	r3, [r0, #102]	; 0x66
    }
    c564:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if ((digit[d] >> b) & 0x01) segment[b].DrawAt(x_pos, y_pos);
    c568:	f890 a066 	ldrb.w	sl, [r0, #102]	; 0x66
    c56c:	f890 9067 	ldrb.w	r9, [r0, #103]	; 0x67
        for (uint8_t i = 0; i < size; i++) pixels[i].DrawAt(x, y);
    c570:	fb07 f604 	mul.w	r6, r7, r4
    c574:	2500      	movs	r5, #0
    c576:	f91c 2006 	ldrsb.w	r2, [ip, r6]
    c57a:	b2eb      	uxtb	r3, r5
    c57c:	4293      	cmp	r3, r2
    c57e:	f105 0501 	add.w	r5, r5, #1
    c582:	dae1      	bge.n	c548 <SegmentDisplay::PrintDigit(unsigned char)+0x20>
    c584:	eb06 0243 	add.w	r2, r6, r3, lsl #1
    c588:	1883      	adds	r3, r0, r2
        graphics.setPixel(x + ox, y + oy);
    c58a:	5c82      	ldrb	r2, [r0, r2]
    c58c:	785b      	ldrb	r3, [r3, #1]
    c58e:	444b      	add	r3, r9
  return frame_ + ((y >>3) << 7) + x;
    c590:	ea4f 0be3 	mov.w	fp, r3, asr #3
    c594:	4452      	add	r2, sl
    c596:	eb02 12cb 	add.w	r2, r2, fp, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    c59a:	f8de b000 	ldr.w	fp, [lr]
    c59e:	f003 0307 	and.w	r3, r3, #7
    c5a2:	f81b b002 	ldrb.w	fp, [fp, r2]
    c5a6:	fa08 f303 	lsl.w	r3, r8, r3
    c5aa:	ea43 030b 	orr.w	r3, r3, fp
    c5ae:	f8de b000 	ldr.w	fp, [lr]
    c5b2:	f80b 3002 	strb.w	r3, [fp, r2]
        for (uint8_t i = 0; i < size; i++) pixels[i].DrawAt(x, y);
    c5b6:	e7de      	b.n	c576 <SegmentDisplay::PrintDigit(unsigned char)+0x4e>
    c5b8:	200065e0 	.word	0x200065e0

0000c5bc <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)>:
    void PrintWhole(uint8_t x, uint8_t y, int number, int range = 10000) {
    c5bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        int pwrs[] = {10000, 1000, 100, 10, 1};
    c5c0:	4f26      	ldr	r7, [pc, #152]	; (c65c <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0xa0>)
        x_pos = x;
    c5c2:	f880 1066 	strb.w	r1, [r0, #102]	; 0x66
    void PrintWhole(uint8_t x, uint8_t y, int number, int range = 10000) {
    c5c6:	469c      	mov	ip, r3
    c5c8:	4605      	mov	r5, r0
        y_pos = y;
    c5ca:	f880 2067 	strb.w	r2, [r0, #103]	; 0x67
        int pwrs[] = {10000, 1000, 100, 10, 1};
    c5ce:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    void PrintWhole(uint8_t x, uint8_t y, int number, int range = 10000) {
    c5d0:	b088      	sub	sp, #32
        int pwrs[] = {10000, 1000, 100, 10, 1};
    c5d2:	ac03      	add	r4, sp, #12
    c5d4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    void PrintWhole(uint8_t x, uint8_t y, int number, int range = 10000) {
    c5d6:	9e0e      	ldr	r6, [sp, #56]	; 0x38
        int pwrs[] = {10000, 1000, 100, 10, 1};
    c5d8:	683b      	ldr	r3, [r7, #0]
    c5da:	6023      	str	r3, [r4, #0]
        for (int r = 0; r < 5; r++)
    c5dc:	2200      	movs	r2, #0
    c5de:	af03      	add	r7, sp, #12
        int tmp = number;
    c5e0:	4660      	mov	r0, ip
        uint8_t q = 0;
    c5e2:	4614      	mov	r4, r2
                    if (pwrs[r] == 1) to_print[q++] = 0;
    c5e4:	4696      	mov	lr, r2
            if (pwrs[r] <= range) {
    c5e6:	f857 1b04 	ldr.w	r1, [r7], #4
    c5ea:	42b1      	cmp	r1, r6
    c5ec:	dc0d      	bgt.n	c60a <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0x4e>
                if (number >= pwrs[r]) {
    c5ee:	4561      	cmp	r1, ip
    c5f0:	dc1c      	bgt.n	c62c <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0x70>
                    to_print[q] = tmp / pwrs[r];
    c5f2:	fb90 f3f1 	sdiv	r3, r0, r1
    c5f6:	f104 0820 	add.w	r8, r4, #32
    c5fa:	44e8      	add	r8, sp
                    tmp -= (to_print[q++] * pwrs[r]);
    c5fc:	3401      	adds	r4, #1
                    to_print[q] = tmp / pwrs[r];
    c5fe:	f808 3c1c 	strb.w	r3, [r8, #-28]
                    tmp -= (to_print[q++] * pwrs[r]);
    c602:	b2db      	uxtb	r3, r3
    c604:	b2e4      	uxtb	r4, r4
    c606:	fb01 0013 	mls	r0, r1, r3, r0
        for (int r = 0; r < 5; r++)
    c60a:	3201      	adds	r2, #1
    c60c:	2a05      	cmp	r2, #5
    c60e:	d1ea      	bne.n	c5e6 <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0x2a>
        if (q) {
    c610:	b14c      	cbz	r4, c626 <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0x6a>
    c612:	af01      	add	r7, sp, #4
            for (int d = 0; d < q; d++)
    c614:	2600      	movs	r6, #0
                PrintDigit(to_print[d]);
    c616:	f817 1b01 	ldrb.w	r1, [r7], #1
    c61a:	4628      	mov	r0, r5
            for (int d = 0; d < q; d++)
    c61c:	3601      	adds	r6, #1
                PrintDigit(to_print[d]);
    c61e:	f7ff ff83 	bl	c528 <SegmentDisplay::PrintDigit(unsigned char)>
            for (int d = 0; d < q; d++)
    c622:	42b4      	cmp	r4, r6
    c624:	dcf7      	bgt.n	c616 <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0x5a>
    }
    c626:	b008      	add	sp, #32
    c628:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    if (pwrs[r] == 1) to_print[q++] = 0;
    c62c:	2901      	cmp	r1, #1
    c62e:	d108      	bne.n	c642 <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0x86>
    c630:	f104 0120 	add.w	r1, r4, #32
    c634:	1c63      	adds	r3, r4, #1
    c636:	eb0d 0401 	add.w	r4, sp, r1
    c63a:	f804 ec1c 	strb.w	lr, [r4, #-28]
    c63e:	b2dc      	uxtb	r4, r3
    c640:	e7e3      	b.n	c60a <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0x4e>
        return (size == SegmentSize::BIG_SEGMENTS ? 10 : 4);
    c642:	f895 305b 	ldrb.w	r3, [r5, #91]	; 0x5b
                    else x_pos += DigitWidth();
    c646:	f895 1066 	ldrb.w	r1, [r5, #102]	; 0x66
        return (size == SegmentSize::BIG_SEGMENTS ? 10 : 4);
    c64a:	2b00      	cmp	r3, #0
    c64c:	bf0c      	ite	eq
    c64e:	230a      	moveq	r3, #10
    c650:	2304      	movne	r3, #4
                    else x_pos += DigitWidth();
    c652:	440b      	add	r3, r1
    c654:	f885 3066 	strb.w	r3, [r5, #102]	; 0x66
    c658:	e7d7      	b.n	c60a <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)+0x4e>
    c65a:	bf00      	nop
    c65c:	00022ed4 	.word	0x00022ed4

0000c660 <Binary::View()>:
        gfxHeader(applet_name());
    c660:	6803      	ldr	r3, [r0, #0]
    void View() {
    c662:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        gfxHeader(applet_name());
    c664:	681b      	ldr	r3, [r3, #0]
    void View() {
    c666:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    c668:	4798      	blx	r3
    c66a:	4601      	mov	r1, r0
    c66c:	4620      	mov	r0, r4
    c66e:	f7fb ffc6 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        segment.SetPosition(11 + (hemisphere * 64), 32);
    c672:	7923      	ldrb	r3, [r4, #4]
    c674:	019b      	lsls	r3, r3, #6
    c676:	330b      	adds	r3, #11
        x_pos = x;
    c678:	f884 30de 	strb.w	r3, [r4, #222]	; 0xde
        y_pos = y;
    c67c:	2320      	movs	r3, #32
    c67e:	f104 0778 	add.w	r7, r4, #120	; 0x78
    c682:	f884 30df 	strb.w	r3, [r4, #223]	; 0xdf
        for (int b = 0; b < 4; b++)
    c686:	f104 056b 	add.w	r5, r4, #107	; 0x6b
    c68a:	f104 066f 	add.w	r6, r4, #111	; 0x6f
            segment.PrintDigit(static_cast<uint8_t>(bit[b]));
    c68e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
    c692:	4638      	mov	r0, r7
    c694:	f7ff ff48 	bl	c528 <SegmentDisplay::PrintDigit(unsigned char)>
        for (int b = 0; b < 4; b++)
    c698:	42b5      	cmp	r5, r6
    c69a:	d1f8      	bne.n	c68e <Binary::View()+0x2e>
        gfxRect(1, 15, ProportionCV(ViewOut(0), 62), 6);
    c69c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    c69e:	213e      	movs	r1, #62	; 0x3e
    c6a0:	f7f7 ffe0 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
    c6a4:	2506      	movs	r5, #6
    c6a6:	4603      	mov	r3, r0
    c6a8:	220f      	movs	r2, #15
    c6aa:	69a0      	ldr	r0, [r4, #24]
    c6ac:	9500      	str	r5, [sp, #0]
    c6ae:	2101      	movs	r1, #1
    c6b0:	f7f8 f9a6 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        gfxRect(1, 58, ProportionCV(ViewOut(1), 62), 6);
    c6b4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    c6b6:	213e      	movs	r1, #62	; 0x3e
    c6b8:	f7f7 ffd4 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
    c6bc:	9500      	str	r5, [sp, #0]
    c6be:	4603      	mov	r3, r0
    c6c0:	223a      	movs	r2, #58	; 0x3a
    c6c2:	69a0      	ldr	r0, [r4, #24]
    c6c4:	2101      	movs	r1, #1
    c6c6:	f7f8 f99b 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
    }
    c6ca:	b003      	add	sp, #12
    c6cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c6ce:	Address 0x000000000000c6ce is out of bounds.


0000c6d0 <SegmentDisplay::DrawDecimalPoint()>:

    uint8_t DecimalWidth() {
        return (size == SegmentSize::BIG_SEGMENTS ? 6 : 4);
    }

    void DrawDecimalPoint() {
    c6d0:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (size == SegmentSize::BIG_SEGMENTS) {
    c6d2:	f890 105b 	ldrb.w	r1, [r0, #91]	; 0x5b
  return frame_ + ((y >>3) << 7) + x;
    c6d6:	4d1f      	ldr	r5, [pc, #124]	; (c754 <SegmentDisplay::DrawDecimalPoint()+0x84>)
                {
                    graphics.setPixel(x_pos + x + 1, y_pos + y + 9);
                }
            }
        } else {
            graphics.setPixel(x_pos + 2, y_pos + 4);
    c6d8:	f890 3066 	ldrb.w	r3, [r0, #102]	; 0x66
    c6dc:	f890 2067 	ldrb.w	r2, [r0, #103]	; 0x67
    c6e0:	682c      	ldr	r4, [r5, #0]
        if (size == SegmentSize::BIG_SEGMENTS) {
    c6e2:	b3a9      	cbz	r1, c750 <SegmentDisplay::DrawDecimalPoint()+0x80>
            graphics.setPixel(x_pos + 2, y_pos + 4);
    c6e4:	3204      	adds	r2, #4
    c6e6:	10d1      	asrs	r1, r2, #3
    c6e8:	3302      	adds	r3, #2
    c6ea:	eb03 13c1 	add.w	r3, r3, r1, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    c6ee:	f002 0207 	and.w	r2, r2, #7
    c6f2:	2101      	movs	r1, #1
    c6f4:	fa01 f202 	lsl.w	r2, r1, r2
    c6f8:	5ce1      	ldrb	r1, [r4, r3]
    c6fa:	430a      	orrs	r2, r1
    c6fc:	54e2      	strb	r2, [r4, r3]
        return (size == SegmentSize::BIG_SEGMENTS ? 6 : 4);
    c6fe:	f890 305b 	ldrb.w	r3, [r0, #91]	; 0x5b
        }
        x_pos += DecimalWidth();
    c702:	f890 2066 	ldrb.w	r2, [r0, #102]	; 0x66
        return (size == SegmentSize::BIG_SEGMENTS ? 6 : 4);
    c706:	2b00      	cmp	r3, #0
    c708:	bf0c      	ite	eq
    c70a:	2306      	moveq	r3, #6
    c70c:	2304      	movne	r3, #4
        x_pos += DecimalWidth();
    c70e:	4413      	add	r3, r2
    c710:	f880 3066 	strb.w	r3, [r0, #102]	; 0x66
    }
    c714:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    graphics.setPixel(x_pos + x + 1, y_pos + y + 9);
    c716:	f890 3067 	ldrb.w	r3, [r0, #103]	; 0x67
    c71a:	f890 2066 	ldrb.w	r2, [r0, #102]	; 0x66
    c71e:	4423      	add	r3, r4
    c720:	3309      	adds	r3, #9
    c722:	440a      	add	r2, r1
  return frame_ + ((y >>3) << 7) + x;
    c724:	10df      	asrs	r7, r3, #3
    c726:	3201      	adds	r2, #1
    c728:	eb02 12c7 	add.w	r2, r2, r7, lsl #7
    c72c:	682f      	ldr	r7, [r5, #0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
    c72e:	f003 0307 	and.w	r3, r3, #7
    c732:	f817 c002 	ldrb.w	ip, [r7, r2]
    c736:	fa06 f303 	lsl.w	r3, r6, r3
                for (int y = 0; y < 3; y++)
    c73a:	3401      	adds	r4, #1
    c73c:	ea43 030c 	orr.w	r3, r3, ip
    c740:	2c03      	cmp	r4, #3
    c742:	54bb      	strb	r3, [r7, r2]
    c744:	d1e7      	bne.n	c716 <SegmentDisplay::DrawDecimalPoint()+0x46>
            for (int x = 0; x < 2; x++)
    c746:	2900      	cmp	r1, #0
    c748:	d1d9      	bne.n	c6fe <SegmentDisplay::DrawDecimalPoint()+0x2e>
    c74a:	2101      	movs	r1, #1
                for (int y = 0; y < 3; y++)
    c74c:	2400      	movs	r4, #0
    c74e:	e7e2      	b.n	c716 <SegmentDisplay::DrawDecimalPoint()+0x46>
    c750:	2601      	movs	r6, #1
    c752:	e7fb      	b.n	c74c <SegmentDisplay::DrawDecimalPoint()+0x7c>
    c754:	200065e0 	.word	0x200065e0

0000c758 <SegmentDisplay::PrintDecimal(int, int, int)>:
    void PrintDecimal(int number, int places, int range) {
    c758:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        int pwrs[] = {10000, 1000, 100, 10, 1};
    c75c:	4d1a      	ldr	r5, [pc, #104]	; (c7c8 <SegmentDisplay::PrintDecimal(int, int, int)+0x70>)
    void PrintDecimal(int number, int places, int range) {
    c75e:	4680      	mov	r8, r0
    c760:	460e      	mov	r6, r1
    c762:	4617      	mov	r7, r2
    c764:	469c      	mov	ip, r3
        int pwrs[] = {10000, 1000, 100, 10, 1};
    c766:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    void PrintDecimal(int number, int places, int range) {
    c768:	b088      	sub	sp, #32
        int pwrs[] = {10000, 1000, 100, 10, 1};
    c76a:	ac03      	add	r4, sp, #12
    c76c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    c76e:	682b      	ldr	r3, [r5, #0]
    c770:	6023      	str	r3, [r4, #0]
        for (int r = 0; r < 5; r++)
    c772:	2200      	movs	r2, #0
    c774:	a803      	add	r0, sp, #12
        uint8_t q = 0;
    c776:	4614      	mov	r4, r2
            if (pwrs[r] < range && places > 0) {
    c778:	f850 3b04 	ldr.w	r3, [r0], #4
    c77c:	4563      	cmp	r3, ip
    c77e:	da0e      	bge.n	c79e <SegmentDisplay::PrintDecimal(int, int, int)+0x46>
    c780:	2f00      	cmp	r7, #0
    c782:	dd0c      	ble.n	c79e <SegmentDisplay::PrintDecimal(int, int, int)+0x46>
                to_print[q] = tmp / pwrs[r];
    c784:	fb96 f1f3 	sdiv	r1, r6, r3
    c788:	f104 0520 	add.w	r5, r4, #32
    c78c:	446d      	add	r5, sp
                tmp -= (to_print[q++] * pwrs[r]);
    c78e:	3401      	adds	r4, #1
                to_print[q] = tmp / pwrs[r];
    c790:	f805 1c1c 	strb.w	r1, [r5, #-28]
                tmp -= (to_print[q++] * pwrs[r]);
    c794:	b2c9      	uxtb	r1, r1
    c796:	b2e4      	uxtb	r4, r4
    c798:	fb03 6611 	mls	r6, r3, r1, r6
                places--;
    c79c:	3f01      	subs	r7, #1
        for (int r = 0; r < 5; r++)
    c79e:	3201      	adds	r2, #1
    c7a0:	2a05      	cmp	r2, #5
    c7a2:	d1e9      	bne.n	c778 <SegmentDisplay::PrintDecimal(int, int, int)+0x20>
        DrawDecimalPoint();
    c7a4:	4640      	mov	r0, r8
    c7a6:	f7ff ff93 	bl	c6d0 <SegmentDisplay::DrawDecimalPoint()>
        if (q) {
    c7aa:	b14c      	cbz	r4, c7c0 <SegmentDisplay::PrintDecimal(int, int, int)+0x68>
    c7ac:	ae01      	add	r6, sp, #4
            for (int d = 0; d < q; d++)
    c7ae:	2500      	movs	r5, #0
                PrintDigit(to_print[d]);
    c7b0:	f816 1b01 	ldrb.w	r1, [r6], #1
    c7b4:	4640      	mov	r0, r8
            for (int d = 0; d < q; d++)
    c7b6:	3501      	adds	r5, #1
                PrintDigit(to_print[d]);
    c7b8:	f7ff feb6 	bl	c528 <SegmentDisplay::PrintDigit(unsigned char)>
            for (int d = 0; d < q; d++)
    c7bc:	42ac      	cmp	r4, r5
    c7be:	dcf7      	bgt.n	c7b0 <SegmentDisplay::PrintDecimal(int, int, int)+0x58>
    }
    c7c0:	b008      	add	sp, #32
    c7c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c7c6:	bf00      	nop
    c7c8:	00022ed4 	.word	0x00022ed4

0000c7cc <ScaleEditor::DrawInterface()>:
    void DrawInterface() {
    c7cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                if (ix < OC::user_scales[current_scale].num_notes) {
    c7d0:	4e50      	ldr	r6, [pc, #320]	; (c914 <ScaleEditor::DrawInterface()+0x148>)
    void DrawInterface() {
    c7d2:	b087      	sub	sp, #28
    c7d4:	4604      	mov	r4, r0
                    if (ix == current_note && !length_set_mode) gfxInvert(x, y, 32, 9);
    c7d6:	f04f 0800 	mov.w	r8, #0
            for (uint8_t cy = 0; cy < 4; cy++)
    c7da:	ea4f 1948 	mov.w	r9, r8, lsl #5
    c7de:	f109 0302 	add.w	r3, r9, #2
    c7e2:	b2db      	uxtb	r3, r3
    c7e4:	9304      	str	r3, [sp, #16]
                    if (ix == current_note && !length_set_mode) gfxInvert(x, y, 32, 9);
    c7e6:	4645      	mov	r5, r8
    c7e8:	270f      	movs	r7, #15
                if (ix < OC::user_scales[current_scale].num_notes) {
    c7ea:	f994 3086 	ldrsb.w	r3, [r4, #134]	; 0x86
    c7ee:	2228      	movs	r2, #40	; 0x28
    c7f0:	fb02 6203 	mla	r2, r2, r3, r6
    c7f4:	f107 0a09 	add.w	sl, r7, #9
    c7f8:	6852      	ldr	r2, [r2, #4]
    c7fa:	42aa      	cmp	r2, r5
    c7fc:	d946      	bls.n	c88c <ScaleEditor::DrawInterface()+0xc0>
                    uint32_t note_value = OC::user_scales[current_scale].notes[ix];
    c7fe:	2214      	movs	r2, #20
    c800:	fb02 5303 	mla	r3, r2, r3, r5
    c804:	3304      	adds	r3, #4
                    uint32_t frac_cents = ((note_value * 100000) >> 7) - cents * 1000;
    c806:	4944      	ldr	r1, [pc, #272]	; (c918 <ScaleEditor::DrawInterface()+0x14c>)
                    uint32_t note_value = OC::user_scales[current_scale].notes[ix];
    c808:	f936 2013 	ldrsh.w	r2, [r6, r3, lsl #1]
                    uint32_t cents = (note_value * 100) >> 7;
    c80c:	2364      	movs	r3, #100	; 0x64
    c80e:	fb12 f303 	smulbb	r3, r2, r3
    c812:	09db      	lsrs	r3, r3, #7
                    uint32_t frac_cents = ((note_value * 100000) >> 7) - cents * 1000;
    c814:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
    c818:	434a      	muls	r2, r1
    c81a:	fb0b f103 	mul.w	r1, fp, r3
    c81e:	ebc1 12d2 	rsb	r2, r1, r2, lsr #7
    c822:	9203      	str	r2, [sp, #12]
                    tinynumbers.PrintWhole(x + 2, y + 2, cents);
    c824:	f242 7110 	movw	r1, #10000	; 0x2710
    c828:	1cba      	adds	r2, r7, #2
    c82a:	f504 7010 	add.w	r0, r4, #576	; 0x240
    c82e:	9100      	str	r1, [sp, #0]
    c830:	b2d2      	uxtb	r2, r2
    c832:	9904      	ldr	r1, [sp, #16]
    c834:	9005      	str	r0, [sp, #20]
    c836:	f7ff fec1 	bl	c5bc <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)>
                    tinynumbers.PrintDecimal(frac_cents, 1, 1000);
    c83a:	465b      	mov	r3, fp
    c83c:	9903      	ldr	r1, [sp, #12]
    c83e:	9805      	ldr	r0, [sp, #20]
    c840:	2201      	movs	r2, #1
    c842:	f7ff ff89 	bl	c758 <SegmentDisplay::PrintDecimal(int, int, int)>
                    if (ix == current_note && !length_set_mode) gfxInvert(x, y, 32, 9);
    c846:	f994 3087 	ldrsb.w	r3, [r4, #135]	; 0x87
    c84a:	429d      	cmp	r5, r3
    c84c:	d11a      	bne.n	c884 <ScaleEditor::DrawInterface()+0xb8>
    c84e:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
    c852:	b17b      	cbz	r3, c874 <ScaleEditor::DrawInterface()+0xa8>
                    if (length_set_mode && ix == OC::user_scales[current_scale].num_notes - 1)
    c854:	f994 3086 	ldrsb.w	r3, [r4, #134]	; 0x86
    c858:	2228      	movs	r2, #40	; 0x28
    c85a:	fb02 6303 	mla	r3, r2, r3, r6
    c85e:	685b      	ldr	r3, [r3, #4]
    c860:	3b01      	subs	r3, #1
    c862:	42ab      	cmp	r3, r5
    c864:	d112      	bne.n	c88c <ScaleEditor::DrawInterface()+0xc0>
                        gfxCursor(x, y + 9, 32);
    c866:	6a60      	ldr	r0, [r4, #36]	; 0x24
    c868:	2320      	movs	r3, #32
    c86a:	4652      	mov	r2, sl
    c86c:	4649      	mov	r1, r9
    c86e:	f7f8 f99b 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
    c872:	e00b      	b.n	c88c <ScaleEditor::DrawInterface()+0xc0>
        graphics.invertRect(x, y, w, h);
    c874:	2309      	movs	r3, #9
    c876:	9300      	str	r3, [sp, #0]
    c878:	4828      	ldr	r0, [pc, #160]	; (c91c <ScaleEditor::DrawInterface()+0x150>)
    c87a:	2320      	movs	r3, #32
    c87c:	463a      	mov	r2, r7
    c87e:	4649      	mov	r1, r9
    c880:	f00c fdcd 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
                    if (length_set_mode && ix == OC::user_scales[current_scale].num_notes - 1)
    c884:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
    c888:	2b00      	cmp	r3, #0
    c88a:	d1e3      	bne.n	c854 <ScaleEditor::DrawInterface()+0x88>
            for (uint8_t cy = 0; cy < 4; cy++)
    c88c:	4657      	mov	r7, sl
    c88e:	2f33      	cmp	r7, #51	; 0x33
    c890:	f105 0504 	add.w	r5, r5, #4
    c894:	d1a9      	bne.n	c7ea <ScaleEditor::DrawInterface()+0x1e>
        for (uint8_t cx = 0; cx < 4; cx++)
    c896:	f108 0801 	add.w	r8, r8, #1
    c89a:	f1b8 0f04 	cmp.w	r8, #4
    c89e:	d19c      	bne.n	c7da <ScaleEditor::DrawInterface()+0xe>
        if (length_set_mode) {
    c8a0:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
            segment.PrintWhole(22, 52, OC::user_scales[current_scale].num_notes);
    c8a4:	f994 2086 	ldrsb.w	r2, [r4, #134]	; 0x86
    c8a8:	f504 75ea 	add.w	r5, r4, #468	; 0x1d4
        if (length_set_mode) {
    c8ac:	b173      	cbz	r3, c8cc <ScaleEditor::DrawInterface()+0x100>
            segment.PrintWhole(22, 52, OC::user_scales[current_scale].num_notes);
    c8ae:	2328      	movs	r3, #40	; 0x28
    c8b0:	fb03 6202 	mla	r2, r3, r2, r6
    c8b4:	f242 7310 	movw	r3, #10000	; 0x2710
    c8b8:	9300      	str	r3, [sp, #0]
    c8ba:	6853      	ldr	r3, [r2, #4]
    c8bc:	2116      	movs	r1, #22
    c8be:	2234      	movs	r2, #52	; 0x34
    c8c0:	4628      	mov	r0, r5
    c8c2:	f7ff fe7b 	bl	c5bc <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)>
    }
    c8c6:	b007      	add	sp, #28
    c8c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            uint32_t note_value = OC::user_scales[current_scale].notes[current_note];
    c8cc:	f994 3087 	ldrsb.w	r3, [r4, #135]	; 0x87
    c8d0:	2114      	movs	r1, #20
    c8d2:	fb01 3302 	mla	r3, r1, r2, r3
    c8d6:	3304      	adds	r3, #4
            uint32_t frac_cents = ((note_value * 100000) >> 7) - cents * 1000;
    c8d8:	490f      	ldr	r1, [pc, #60]	; (c918 <ScaleEditor::DrawInterface()+0x14c>)
            uint32_t note_value = OC::user_scales[current_scale].notes[current_note];
    c8da:	f936 2013 	ldrsh.w	r2, [r6, r3, lsl #1]
            uint32_t cents = (note_value * 100) >> 7;
    c8de:	2364      	movs	r3, #100	; 0x64
    c8e0:	fb12 f303 	smulbb	r3, r2, r3
    c8e4:	09db      	lsrs	r3, r3, #7
            uint32_t frac_cents = ((note_value * 100000) >> 7) - cents * 1000;
    c8e6:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
    c8ea:	fb06 f403 	mul.w	r4, r6, r3
    c8ee:	434a      	muls	r2, r1
    c8f0:	ebc4 14d2 	rsb	r4, r4, r2, lsr #7
            segment.PrintWhole(12, 52, cents);
    c8f4:	f242 7210 	movw	r2, #10000	; 0x2710
    c8f8:	9200      	str	r2, [sp, #0]
    c8fa:	4628      	mov	r0, r5
    c8fc:	2234      	movs	r2, #52	; 0x34
    c8fe:	210c      	movs	r1, #12
    c900:	f7ff fe5c 	bl	c5bc <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)>
            segment.PrintDecimal(frac_cents, 3, 1000);
    c904:	4633      	mov	r3, r6
    c906:	2203      	movs	r2, #3
    c908:	4621      	mov	r1, r4
    c90a:	4628      	mov	r0, r5
    c90c:	f7ff ff24 	bl	c758 <SegmentDisplay::PrintDecimal(int, int, int)>
    }
    c910:	e7d9      	b.n	c8c6 <ScaleEditor::DrawInterface()+0xfa>
    c912:	bf00      	nop
    c914:	1fffa728 	.word	0x1fffa728
    c918:	000186a0 	.word	0x000186a0
    c91c:	200065e0 	.word	0x200065e0

0000c920 <ScaleEditor::DrawImportScreen()>:
    void DrawImportScreen() {
    c920:	b570      	push	{r4, r5, r6, lr}
  text_x_ = x;
    c922:	4c15      	ldr	r4, [pc, #84]	; (c978 <ScaleEditor::DrawImportScreen()+0x58>)
        graphics.print(str);
    c924:	4915      	ldr	r1, [pc, #84]	; (c97c <ScaleEditor::DrawImportScreen()+0x5c>)
    c926:	2500      	movs	r5, #0
    c928:	4606      	mov	r6, r0
  text_y_ = y;
    c92a:	230f      	movs	r3, #15
    c92c:	4620      	mov	r0, r4
  text_x_ = x;
    c92e:	6065      	str	r5, [r4, #4]
  text_y_ = y;
    c930:	60a3      	str	r3, [r4, #8]
    c932:	f00d f8d0 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    c936:	2323      	movs	r3, #35	; 0x23
        gfxPrint(0, 35, OC::scale_names[current_import_scale]);
    c938:	f996 2088 	ldrsb.w	r2, [r6, #136]	; 0x88
    c93c:	60a3      	str	r3, [r4, #8]
    c93e:	4b10      	ldr	r3, [pc, #64]	; (c980 <ScaleEditor::DrawImportScreen()+0x60>)
  text_x_ = x;
    c940:	6065      	str	r5, [r4, #4]
    c942:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    c946:	4620      	mov	r0, r4
    c948:	f00d f8c5 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxCursor(0, 43, 127);
    c94c:	6a70      	ldr	r0, [r6, #36]	; 0x24
    c94e:	237f      	movs	r3, #127	; 0x7f
    c950:	4629      	mov	r1, r5
    c952:	222b      	movs	r2, #43	; 0x2b
    c954:	f7f8 f928 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
    c958:	6065      	str	r5, [r4, #4]
    c95a:	4620      	mov	r0, r4
  text_y_ = y;
    c95c:	2537      	movs	r5, #55	; 0x37
    c95e:	4909      	ldr	r1, [pc, #36]	; (c984 <ScaleEditor::DrawImportScreen()+0x64>)
    c960:	60a5      	str	r5, [r4, #8]
    c962:	f00d f8b8 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    c966:	234e      	movs	r3, #78	; 0x4e
    c968:	6063      	str	r3, [r4, #4]
  text_y_ = y;
    c96a:	60a5      	str	r5, [r4, #8]
    c96c:	4620      	mov	r0, r4
    c96e:	4906      	ldr	r1, [pc, #24]	; (c988 <ScaleEditor::DrawImportScreen()+0x68>)
    }
    c970:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    c974:	f00d b8af 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    c978:	200065e0 	.word	0x200065e0
    c97c:	000211a8 	.word	0x000211a8
    c980:	0001e500 	.word	0x0001e500
    c984:	00020f47 	.word	0x00020f47
    c988:	000211af 	.word	0x000211af

0000c98c <ScaleEditor::View()>:
    void View() {
    c98c:	b510      	push	{r4, lr}
    c98e:	4604      	mov	r4, r0
        gfxHeader("Scale Editor    ");
    c990:	490a      	ldr	r1, [pc, #40]	; (c9bc <ScaleEditor::View()+0x30>)
    c992:	f7f9 f9f7 	bl	5d84 <HSApplication::gfxHeader(char const*)>
        graphics.print(str);
    c996:	4b0a      	ldr	r3, [pc, #40]	; (c9c0 <ScaleEditor::View()+0x34>)
        gfxPrint(OC::scale_names_short[current_scale]);
    c998:	f994 2086 	ldrsb.w	r2, [r4, #134]	; 0x86
    c99c:	4809      	ldr	r0, [pc, #36]	; (c9c4 <ScaleEditor::View()+0x38>)
    c99e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    c9a2:	f00d f898 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (import_mode) DrawImportScreen();
    c9a6:	f894 3091 	ldrb.w	r3, [r4, #145]	; 0x91
    c9aa:	4620      	mov	r0, r4
    c9ac:	b113      	cbz	r3, c9b4 <ScaleEditor::View()+0x28>
    c9ae:	f7ff ffb7 	bl	c920 <ScaleEditor::DrawImportScreen()>
    }
    c9b2:	bd10      	pop	{r4, pc}
        else DrawInterface();
    c9b4:	f7ff ff0a 	bl	c7cc <ScaleEditor::DrawInterface()>
    }
    c9b8:	e7fb      	b.n	c9b2 <ScaleEditor::View()+0x26>
    c9ba:	bf00      	nop
    c9bc:	000211b8 	.word	0x000211b8
    c9c0:	0001e600 	.word	0x0001e600
    c9c4:	200065e0 	.word	0x200065e0

0000c9c8 <ScaleEditor::QuantizeCurrent()>:
    void QuantizeCurrent() {
    c9c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        int transpose = OC::user_scales[current_scale].span * octave;
    c9ca:	f990 3086 	ldrsb.w	r3, [r0, #134]	; 0x86
    c9ce:	4f12      	ldr	r7, [pc, #72]	; (ca18 <ScaleEditor::QuantizeCurrent()+0x50>)
    c9d0:	2228      	movs	r2, #40	; 0x28
    c9d2:	4353      	muls	r3, r2
    void QuantizeCurrent() {
    c9d4:	4604      	mov	r4, r0
        int transpose = OC::user_scales[current_scale].span * octave;
    c9d6:	5efe      	ldrsh	r6, [r7, r3]
    c9d8:	f8d0 31d0 	ldr.w	r3, [r0, #464]	; 0x1d0
        quantizer.Requantize();
    c9dc:	f100 0594 	add.w	r5, r0, #148	; 0x94
    c9e0:	4628      	mov	r0, r5
        int transpose = OC::user_scales[current_scale].span * octave;
    c9e2:	435e      	muls	r6, r3
        quantizer.Requantize();
    c9e4:	f7f4 fd5b 	bl	149e <braids::Quantizer::Requantize()>
        current_quantized = quantizer.Process(OC::user_scales[current_scale].notes[current_note] + transpose, 0, 0);
    c9e8:	f994 2086 	ldrsb.w	r2, [r4, #134]	; 0x86
    c9ec:	f994 3087 	ldrsb.w	r3, [r4, #135]	; 0x87
    c9f0:	2114      	movs	r1, #20
    c9f2:	fb01 3302 	mla	r3, r1, r2, r3
    c9f6:	3304      	adds	r3, #4
    c9f8:	4628      	mov	r0, r5
    c9fa:	f937 1013 	ldrsh.w	r1, [r7, r3, lsl #1]
    c9fe:	2300      	movs	r3, #0
    ca00:	461a      	mov	r2, r3
    ca02:	4431      	add	r1, r6
    ca04:	f7f4 fcc4 	bl	1390 <braids::Quantizer::Process(long, long, long)>
    ca08:	f8c4 01cc 	str.w	r0, [r4, #460]	; 0x1cc
        quantizer.Requantize(); // This is for the next one in the Controller
    ca0c:	4628      	mov	r0, r5
    }
    ca0e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        quantizer.Requantize(); // This is for the next one in the Controller
    ca12:	f7f4 bd44 	b.w	149e <braids::Quantizer::Requantize()>
    ca16:	bf00      	nop
    ca18:	1fffa728 	.word	0x1fffa728

0000ca1c <ScaleEditor::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    ca1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    ca1e:	b08b      	sub	sp, #44	; 0x2c
    ca20:	4604      	mov	r4, r0
        if (ExtractSysExData(V, 'E')) {
    ca22:	2245      	movs	r2, #69	; 0x45
    ca24:	a901      	add	r1, sp, #4
    ca26:	3080      	adds	r0, #128	; 0x80
    ca28:	f7f8 fe6a 	bl	5700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>
    ca2c:	2800      	cmp	r0, #0
    ca2e:	d03e      	beq.n	caae <ScaleEditor::OnReceiveSysEx()+0x92>
            OC::user_scales[current_scale].span = (int16_t)(high << 8) | low;
    ca30:	f994 3086 	ldrsb.w	r3, [r4, #134]	; 0x86
    ca34:	4a20      	ldr	r2, [pc, #128]	; (cab8 <ScaleEditor::OnReceiveSysEx()+0x9c>)
    ca36:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    ca3a:	2028      	movs	r0, #40	; 0x28
    ca3c:	4343      	muls	r3, r0
    ca3e:	52d1      	strh	r1, [r2, r3]
            uint8_t num_notes = V[ix++];
    ca40:	f89d 3006 	ldrb.w	r3, [sp, #6]
            OC::user_scales[current_scale].num_notes = constrain(num_notes, 4, 16);
    ca44:	2b03      	cmp	r3, #3
    ca46:	d934      	bls.n	cab2 <ScaleEditor::OnReceiveSysEx()+0x96>
    ca48:	2b10      	cmp	r3, #16
    ca4a:	bfa8      	it	ge
    ca4c:	2310      	movge	r3, #16
    ca4e:	f994 1086 	ldrsb.w	r1, [r4, #134]	; 0x86
    ca52:	fb00 2101 	mla	r1, r0, r1, r2
                OC::user_scales[current_scale].notes[i] = (uint16_t)(high << 8) | low;
    ca56:	2714      	movs	r7, #20
            OC::user_scales[current_scale].num_notes = constrain(num_notes, 4, 16);
    ca58:	604b      	str	r3, [r1, #4]
            for (int i = 0; i < 16; i++)
    ca5a:	2000      	movs	r0, #0
    ca5c:	ab01      	add	r3, sp, #4
                OC::user_scales[current_scale].notes[i] = (uint16_t)(high << 8) | low;
    ca5e:	f994 1086 	ldrsb.w	r1, [r4, #134]	; 0x86
    ca62:	791e      	ldrb	r6, [r3, #4]
    ca64:	78dd      	ldrb	r5, [r3, #3]
    ca66:	fb07 0101 	mla	r1, r7, r1, r0
    ca6a:	3104      	adds	r1, #4
            for (int i = 0; i < 16; i++)
    ca6c:	3001      	adds	r0, #1
                OC::user_scales[current_scale].notes[i] = (uint16_t)(high << 8) | low;
    ca6e:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
            for (int i = 0; i < 16; i++)
    ca72:	2810      	cmp	r0, #16
                OC::user_scales[current_scale].notes[i] = (uint16_t)(high << 8) | low;
    ca74:	f822 5011 	strh.w	r5, [r2, r1, lsl #1]
            for (int i = 0; i < 16; i++)
    ca78:	f103 0302 	add.w	r3, r3, #2
    ca7c:	d1ef      	bne.n	ca5e <ScaleEditor::OnReceiveSysEx()+0x42>
            undo_value = OC::user_scales[current_scale].notes[current_note];
    ca7e:	f994 0086 	ldrsb.w	r0, [r4, #134]	; 0x86
            current_note = 0;
    ca82:	2300      	movs	r3, #0
    ca84:	f884 3087 	strb.w	r3, [r4, #135]	; 0x87
            undo_value = OC::user_scales[current_scale].notes[current_note];
    ca88:	2328      	movs	r3, #40	; 0x28
    ca8a:	fb03 2200 	mla	r2, r3, r0, r2
    ca8e:	f9b2 3008 	ldrsh.w	r3, [r2, #8]
    ca92:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
            quantizer.Configure(OC::Scales::GetScale(current_scale), 0xffff);
    ca96:	f7f4 fa6d 	bl	f74 <OC::Scales::GetScale(int)>
    ca9a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ca9e:	4601      	mov	r1, r0
    caa0:	f104 0094 	add.w	r0, r4, #148	; 0x94
    caa4:	f7f9 faaa 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
            QuantizeCurrent();
    caa8:	4620      	mov	r0, r4
    caaa:	f7ff ff8d 	bl	c9c8 <ScaleEditor::QuantizeCurrent()>
    }
    caae:	b00b      	add	sp, #44	; 0x2c
    cab0:	bdf0      	pop	{r4, r5, r6, r7, pc}
            OC::user_scales[current_scale].num_notes = constrain(num_notes, 4, 16);
    cab2:	2304      	movs	r3, #4
    cab4:	e7cb      	b.n	ca4e <ScaleEditor::OnReceiveSysEx()+0x32>
    cab6:	bf00      	nop
    cab8:	1fffa728 	.word	0x1fffa728

0000cabc <non-virtual thunk to ScaleEditor::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
    cabc:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
    cac0:	e7ac      	b.n	ca1c <ScaleEditor::OnReceiveSysEx()>
    cac2:	bf00      	nop

0000cac4 <ScaleEditor::Start()>:
	void Start() {
    cac4:	b570      	push	{r4, r5, r6, lr}
	    current_scale = 0;
    cac6:	2500      	movs	r5, #0
	void Start() {
    cac8:	4604      	mov	r4, r0
	    current_scale = 0;
    caca:	f8a0 5086 	strh.w	r5, [r0, #134]	; 0x86
        quantizer.Configure(OC::Scales::GetScale(current_scale), 0xffff);
    cace:	4628      	mov	r0, r5
    cad0:	f7f4 fa50 	bl	f74 <OC::Scales::GetScale(int)>
    cad4:	f64f 72ff 	movw	r2, #65535	; 0xffff
    cad8:	4601      	mov	r1, r0
    cada:	f104 0094 	add.w	r0, r4, #148	; 0x94
    cade:	f7f9 fa8d 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
        current_import_scale = 5;
    cae2:	2305      	movs	r3, #5
        undo_value = OC::user_scales[current_scale].notes[0];
    cae4:	f994 2086 	ldrsb.w	r2, [r4, #134]	; 0x86
        current_import_scale = 5;
    cae8:	f884 3088 	strb.w	r3, [r4, #136]	; 0x88
        undo_value = OC::user_scales[current_scale].notes[0];
    caec:	4b0c      	ldr	r3, [pc, #48]	; (cb20 <ScaleEditor::Start()+0x5c>)
    caee:	2128      	movs	r1, #40	; 0x28
    caf0:	fb01 3302 	mla	r3, r1, r2, r3
        octave = 1;
    caf4:	2601      	movs	r6, #1
        undo_value = OC::user_scales[current_scale].notes[0];
    caf6:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
    cafa:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        QuantizeCurrent();
    cafe:	4620      	mov	r0, r4
        octave = 1;
    cb00:	f8c4 61d0 	str.w	r6, [r4, #464]	; 0x1d0
        QuantizeCurrent();
    cb04:	f7ff ff60 	bl	c9c8 <ScaleEditor::QuantizeCurrent()>
        segment.Init(SegmentSize::BIG_SEGMENTS);
    cb08:	4629      	mov	r1, r5
    cb0a:	f504 70ea 	add.w	r0, r4, #468	; 0x1d4
    cb0e:	f7ff fc7f 	bl	c410 <SegmentDisplay::Init(unsigned char)>
        tinynumbers.Init(SegmentSize::TINY_SEGMENTS);
    cb12:	4631      	mov	r1, r6
    cb14:	f504 7010 	add.w	r0, r4, #576	; 0x240
    cb18:	f7ff fc7a 	bl	c410 <SegmentDisplay::Init(unsigned char)>
	}
    cb1c:	bd70      	pop	{r4, r5, r6, pc}
    cb1e:	bf00      	nop
    cb20:	1fffa728 	.word	0x1fffa728

0000cb24 <ScaleEditor::OnRightButtonPress()>:
    void OnRightButtonPress() {
    cb24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        if (import_mode) ImportScale();
    cb28:	f890 3091 	ldrb.w	r3, [r0, #145]	; 0x91
    void OnRightButtonPress() {
    cb2c:	b08a      	sub	sp, #40	; 0x28
    cb2e:	4606      	mov	r6, r0
        if (import_mode) ImportScale();
    cb30:	2b00      	cmp	r3, #0
    cb32:	d03e      	beq.n	cbb2 <ScaleEditor::OnRightButtonPress()+0x8e>
        OC::Scale source = OC::Scales::GetScale(current_import_scale);
    cb34:	f990 0088 	ldrsb.w	r0, [r0, #136]	; 0x88
        memcpy(&OC::user_scales[current_scale], &source, sizeof(source));
    cb38:	f8df 808c 	ldr.w	r8, [pc, #140]	; cbc8 <ScaleEditor::OnRightButtonPress()+0xa4>
        OC::Scale source = OC::Scales::GetScale(current_import_scale);
    cb3c:	f7f4 fa1a 	bl	f74 <OC::Scales::GetScale(int)>
    cb40:	4604      	mov	r4, r0
    cb42:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    cb44:	466d      	mov	r5, sp
    cb46:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    cb48:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    cb4a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    cb4c:	e894 0003 	ldmia.w	r4, {r0, r1}
    cb50:	e885 0003 	stmia.w	r5, {r0, r1}
        memcpy(&OC::user_scales[current_scale], &source, sizeof(source));
    cb54:	466f      	mov	r7, sp
    cb56:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    cb58:	f996 4086 	ldrsb.w	r4, [r6, #134]	; 0x86
    cb5c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    cb60:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
    cb64:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    cb66:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    cb68:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    cb6a:	e895 0003 	ldmia.w	r5, {r0, r1}
    cb6e:	e884 0003 	stmia.w	r4, {r0, r1}
        quantizer.Configure(OC::Scales::GetScale(current_scale), 0xffff);
    cb72:	f996 0086 	ldrsb.w	r0, [r6, #134]	; 0x86
    cb76:	f7f4 f9fd 	bl	f74 <OC::Scales::GetScale(int)>
    cb7a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    cb7e:	4601      	mov	r1, r0
    cb80:	f106 0094 	add.w	r0, r6, #148	; 0x94
    cb84:	f7f9 fa3a 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
        QuantizeCurrent();
    cb88:	4630      	mov	r0, r6
    cb8a:	f7ff ff1d 	bl	c9c8 <ScaleEditor::QuantizeCurrent()>
        import_mode = 0;
    cb8e:	2300      	movs	r3, #0
        undo_value = OC::user_scales[current_scale].notes[current_note];
    cb90:	f996 2086 	ldrsb.w	r2, [r6, #134]	; 0x86
        import_mode = 0;
    cb94:	f886 3091 	strb.w	r3, [r6, #145]	; 0x91
        undo_value = OC::user_scales[current_scale].notes[current_note];
    cb98:	f996 3087 	ldrsb.w	r3, [r6, #135]	; 0x87
    cb9c:	2114      	movs	r1, #20
    cb9e:	fb01 3302 	mla	r3, r1, r2, r3
    cba2:	3304      	adds	r3, #4
    cba4:	f938 3013 	ldrsh.w	r3, [r8, r3, lsl #1]
    cba8:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
    }
    cbac:	b00a      	add	sp, #40	; 0x28
    cbae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        length_set_mode = 1 - length_set_mode;
    cbb2:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
    cbb6:	f083 0301 	eor.w	r3, r3, #1
    cbba:	f880 3090 	strb.w	r3, [r0, #144]	; 0x90
        cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    cbbe:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    cbc2:	6243      	str	r3, [r0, #36]	; 0x24
    }
    cbc4:	e7f2      	b.n	cbac <ScaleEditor::OnRightButtonPress()+0x88>
    cbc6:	bf00      	nop
    cbc8:	1fffa728 	.word	0x1fffa728

0000cbcc <ScaleEditor::SwitchScale(int)>:
    void SwitchScale(int direction) { // Up/Down buttons
    cbcc:	b538      	push	{r3, r4, r5, lr}
    cbce:	4604      	mov	r4, r0
        current_scale = constrain(current_scale + direction, 0, OC::Scales::SCALE_USER_LAST - 1);
    cbd0:	f990 0086 	ldrsb.w	r0, [r0, #134]	; 0x86
    cbd4:	4408      	add	r0, r1
    cbd6:	f380 0002 	usat	r0, #2, r0
    cbda:	f884 0086 	strb.w	r0, [r4, #134]	; 0x86
        quantizer.Configure(OC::Scales::GetScale(current_scale), 0xffff);
    cbde:	f7f4 f9c9 	bl	f74 <OC::Scales::GetScale(int)>
    cbe2:	f64f 72ff 	movw	r2, #65535	; 0xffff
    cbe6:	4601      	mov	r1, r0
    cbe8:	f104 0094 	add.w	r0, r4, #148	; 0x94
    cbec:	f7f9 fa06 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
        QuantizeCurrent();
    cbf0:	4620      	mov	r0, r4
    cbf2:	f7ff fee9 	bl	c9c8 <ScaleEditor::QuantizeCurrent()>
        uint8_t length = static_cast<uint8_t>(OC::user_scales[current_scale].num_notes);
    cbf6:	f994 1086 	ldrsb.w	r1, [r4, #134]	; 0x86
    cbfa:	4a0c      	ldr	r2, [pc, #48]	; (cc2c <ScaleEditor::SwitchScale(int)+0x60>)
        if (current_note > length - 1) current_note = OC::user_scales[current_scale].num_notes - 1;
    cbfc:	f994 0087 	ldrsb.w	r0, [r4, #135]	; 0x87
        uint8_t length = static_cast<uint8_t>(OC::user_scales[current_scale].num_notes);
    cc00:	2328      	movs	r3, #40	; 0x28
    cc02:	fb03 2301 	mla	r3, r3, r1, r2
    cc06:	685b      	ldr	r3, [r3, #4]
        if (current_note > length - 1) current_note = OC::user_scales[current_scale].num_notes - 1;
    cc08:	b2dd      	uxtb	r5, r3
    cc0a:	4285      	cmp	r5, r0
    cc0c:	bfdc      	itt	le
    cc0e:	f103 33ff 	addle.w	r3, r3, #4294967295	; 0xffffffff
    cc12:	f884 3087 	strble.w	r3, [r4, #135]	; 0x87
        undo_value = OC::user_scales[current_scale].notes[current_note];
    cc16:	f994 3087 	ldrsb.w	r3, [r4, #135]	; 0x87
    cc1a:	2014      	movs	r0, #20
    cc1c:	fb00 3301 	mla	r3, r0, r1, r3
    cc20:	3304      	adds	r3, #4
    cc22:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
    cc26:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    }
    cc2a:	bd38      	pop	{r3, r4, r5, pc}
    cc2c:	1fffa728 	.word	0x1fffa728

0000cc30 <SCALEEDITOR_handleButtonEvent(UI::Event const&)>:

void SCALEEDITOR_screensaver() {}

void SCALEEDITOR_handleButtonEvent(const UI::Event &event) {
    // For left encoder, handle press and long press
    if (event.control == OC::CONTROL_BUTTON_L) {
    cc30:	8843      	ldrh	r3, [r0, #2]
    cc32:	2b04      	cmp	r3, #4
void SCALEEDITOR_handleButtonEvent(const UI::Event &event) {
    cc34:	b510      	push	{r4, lr}
    cc36:	4604      	mov	r4, r0
    if (event.control == OC::CONTROL_BUTTON_L) {
    cc38:	d121      	bne.n	cc7e <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x4e>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) scale_editor_instance.OnLeftButtonLongPress();
    cc3a:	7822      	ldrb	r2, [r4, #0]
        if (import_mode) ToggleImportMode();
    cc3c:	4821      	ldr	r0, [pc, #132]	; (ccc4 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x94>)
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) scale_editor_instance.OnLeftButtonLongPress();
    cc3e:	2a02      	cmp	r2, #2
        if (import_mode) ToggleImportMode();
    cc40:	f890 3091 	ldrb.w	r3, [r0, #145]	; 0x91
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) scale_editor_instance.OnLeftButtonLongPress();
    cc44:	d12b      	bne.n	cc9e <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x6e>
        if (import_mode) ToggleImportMode();
    cc46:	b1c3      	cbz	r3, cc7a <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x4a>
        import_mode = 1 - import_mode;
    cc48:	2300      	movs	r3, #0
    cc4a:	f880 3091 	strb.w	r3, [r0, #145]	; 0x91

    // For up button, handle only press (long press is reserved)
    if (event.control == OC::CONTROL_BUTTON_UP) scale_editor_instance.OnUpButtonPress();

    // For down button, handle press and long press
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
    cc4e:	8863      	ldrh	r3, [r4, #2]
    cc50:	2b02      	cmp	r3, #2
    cc52:	d111      	bne.n	cc78 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x48>
        if (event.type == UI::EVENT_BUTTON_PRESS) scale_editor_instance.OnDownButtonPress();
    cc54:	7823      	ldrb	r3, [r4, #0]
    cc56:	2b01      	cmp	r3, #1
    cc58:	d104      	bne.n	cc64 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x34>
        SwitchScale(-1);
    cc5a:	481a      	ldr	r0, [pc, #104]	; (ccc4 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x94>)
    cc5c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    cc60:	f7ff ffb4 	bl	cbcc <ScaleEditor::SwitchScale(int)>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) scale_editor_instance.OnDownButtonLongPress();
    cc64:	7823      	ldrb	r3, [r4, #0]
    cc66:	2b02      	cmp	r3, #2
        import_mode = 1 - import_mode;
    cc68:	bf01      	itttt	eq
    cc6a:	4a16      	ldreq	r2, [pc, #88]	; (ccc4 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x94>)
    cc6c:	f892 3091 	ldrbeq.w	r3, [r2, #145]	; 0x91
    cc70:	f083 0301 	eoreq.w	r3, r3, #1
    cc74:	f882 3091 	strbeq.w	r3, [r2, #145]	; 0x91
    }
}
    cc78:	bd10      	pop	{r4, pc}
        else OnSendSysEx();
    cc7a:	f7f8 fbe7 	bl	544c <ScaleEditor::OnSendSysEx()>
    if (event.control == OC::CONTROL_BUTTON_R && event.type == UI::EVENT_BUTTON_PRESS) scale_editor_instance.OnRightButtonPress();
    cc7e:	8863      	ldrh	r3, [r4, #2]
    cc80:	2b08      	cmp	r3, #8
    cc82:	d105      	bne.n	cc90 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x60>
    cc84:	7823      	ldrb	r3, [r4, #0]
    cc86:	2b01      	cmp	r3, #1
    cc88:	d1f6      	bne.n	cc78 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x48>
    cc8a:	480e      	ldr	r0, [pc, #56]	; (ccc4 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x94>)
    cc8c:	f7ff ff4a 	bl	cb24 <ScaleEditor::OnRightButtonPress()>
    if (event.control == OC::CONTROL_BUTTON_UP) scale_editor_instance.OnUpButtonPress();
    cc90:	8861      	ldrh	r1, [r4, #2]
    cc92:	2901      	cmp	r1, #1
    cc94:	d1db      	bne.n	cc4e <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x1e>
        SwitchScale(1);
    cc96:	480b      	ldr	r0, [pc, #44]	; (ccc4 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x94>)
    cc98:	f7ff ff98 	bl	cbcc <ScaleEditor::SwitchScale(int)>
    }
    cc9c:	e7d7      	b.n	cc4e <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x1e>
        if (import_mode) import_mode = 0;
    cc9e:	2b00      	cmp	r3, #0
    cca0:	d1d2      	bne.n	cc48 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x18>
        OC::user_scales[current_scale].notes[current_note] = static_cast<int16_t>(undo_value);
    cca2:	f990 2086 	ldrsb.w	r2, [r0, #134]	; 0x86
    cca6:	f990 3087 	ldrsb.w	r3, [r0, #135]	; 0x87
    ccaa:	2114      	movs	r1, #20
    ccac:	fb01 3302 	mla	r3, r1, r2, r3
    ccb0:	3304      	adds	r3, #4
    ccb2:	4a05      	ldr	r2, [pc, #20]	; (ccc8 <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x98>)
    ccb4:	f8d0 108c 	ldr.w	r1, [r0, #140]	; 0x8c
    ccb8:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
        QuantizeCurrent();
    ccbc:	f7ff fe84 	bl	c9c8 <ScaleEditor::QuantizeCurrent()>
    }
    ccc0:	e7dd      	b.n	cc7e <SCALEEDITOR_handleButtonEvent(UI::Event const&)+0x4e>
    ccc2:	bf00      	nop
    ccc4:	20005a5c 	.word	0x20005a5c
    ccc8:	1fffa728 	.word	0x1fffa728

0000cccc <ScaleEditor::ChangeValue(int)>:
    void ChangeValue(int direction) {
    cccc:	b570      	push	{r4, r5, r6, lr}
        int16_t new_value = OC::user_scales[current_scale].notes[current_note] + direction;
    ccce:	f990 6086 	ldrsb.w	r6, [r0, #134]	; 0x86
    ccd2:	f990 3087 	ldrsb.w	r3, [r0, #135]	; 0x87
    ccd6:	2514      	movs	r5, #20
    ccd8:	fb05 3506 	mla	r5, r5, r6, r3
    ccdc:	1d2a      	adds	r2, r5, #4
    void ChangeValue(int direction) {
    ccde:	4604      	mov	r4, r0
        int16_t new_value = OC::user_scales[current_scale].notes[current_note] + direction;
    cce0:	481f      	ldr	r0, [pc, #124]	; (cd60 <ScaleEditor::ChangeValue(int)+0x94>)
    cce2:	f830 2012 	ldrh.w	r2, [r0, r2, lsl #1]
    cce6:	440a      	add	r2, r1
        int length = OC::user_scales[current_scale].num_notes;
    cce8:	2128      	movs	r1, #40	; 0x28
    ccea:	fb01 0106 	mla	r1, r1, r6, r0
        const int32_t min = current_note > 0 ? OC::user_scales[current_scale].notes[current_note - 1] : 0;
    ccee:	2b00      	cmp	r3, #0
        int length = OC::user_scales[current_scale].num_notes;
    ccf0:	6849      	ldr	r1, [r1, #4]
        const int32_t min = current_note > 0 ? OC::user_scales[current_scale].notes[current_note - 1] : 0;
    ccf2:	bfc8      	it	gt
    ccf4:	3503      	addgt	r5, #3
        const int32_t max = current_note < length - 1 ? OC::user_scales[current_scale].notes[current_note + 1] : OC::user_scales[current_scale].span;
    ccf6:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
        const int32_t min = current_note > 0 ? OC::user_scales[current_scale].notes[current_note - 1] : 0;
    ccfa:	bfcc      	ite	gt
    ccfc:	f930 5015 	ldrshgt.w	r5, [r0, r5, lsl #1]
    cd00:	2500      	movle	r5, #0
        const int32_t max = current_note < length - 1 ? OC::user_scales[current_scale].notes[current_note + 1] : OC::user_scales[current_scale].span;
    cd02:	428b      	cmp	r3, r1
    cd04:	bfbb      	ittet	lt
    cd06:	2114      	movlt	r1, #20
    cd08:	fb01 3106 	mlalt	r1, r1, r6, r3
    cd0c:	2128      	movge	r1, #40	; 0x28
    cd0e:	3105      	addlt	r1, #5
    cd10:	bfa8      	it	ge
    cd12:	4371      	mulge	r1, r6
        int16_t new_value = OC::user_scales[current_scale].notes[current_note] + direction;
    cd14:	b212      	sxth	r2, r2
        const int32_t max = current_note < length - 1 ? OC::user_scales[current_scale].notes[current_note + 1] : OC::user_scales[current_scale].span;
    cd16:	bfb4      	ite	lt
    cd18:	f930 1011 	ldrshlt.w	r1, [r0, r1, lsl #1]
    cd1c:	5e41      	ldrshge	r1, [r0, r1]
        if (new_value <= min) new_value = current_note > 0 ? min + 1 : 0;
    cd1e:	42aa      	cmp	r2, r5
    cd20:	dc04      	bgt.n	cd2c <ScaleEditor::ChangeValue(int)+0x60>
    cd22:	2b00      	cmp	r3, #0
    cd24:	bfc6      	itte	gt
    cd26:	3501      	addgt	r5, #1
    cd28:	b22a      	sxthgt	r2, r5
    cd2a:	2200      	movle	r2, #0
        if (new_value >= max) new_value = max - 1;
    cd2c:	428a      	cmp	r2, r1
    cd2e:	bfa4      	itt	ge
    cd30:	f101 31ff 	addge.w	r1, r1, #4294967295	; 0xffffffff
    cd34:	b20a      	sxthge	r2, r1
        OC::user_scales[current_scale].notes[current_note] = new_value;
    cd36:	2114      	movs	r1, #20
    cd38:	fb01 3306 	mla	r3, r1, r6, r3
    cd3c:	3304      	adds	r3, #4
    cd3e:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
        quantizer.Configure(OC::Scales::GetScale(current_scale), 0xffff);
    cd42:	f994 0086 	ldrsb.w	r0, [r4, #134]	; 0x86
    cd46:	f7f4 f915 	bl	f74 <OC::Scales::GetScale(int)>
    cd4a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    cd4e:	4601      	mov	r1, r0
    cd50:	f104 0094 	add.w	r0, r4, #148	; 0x94
    cd54:	f7f9 f952 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
        QuantizeCurrent();
    cd58:	4620      	mov	r0, r4
    cd5a:	f7ff fe35 	bl	c9c8 <ScaleEditor::QuantizeCurrent()>
    }
    cd5e:	bd70      	pop	{r4, r5, r6, pc}
    cd60:	1fffa728 	.word	0x1fffa728

0000cd64 <ScaleEditor::ChangeLength(int)>:
    void ChangeLength(int direction) {
    cd64:	b570      	push	{r4, r5, r6, lr}
        int length = OC::user_scales[current_scale].num_notes;
    cd66:	4a26      	ldr	r2, [pc, #152]	; (ce00 <ScaleEditor::ChangeLength(int)+0x9c>)
    void ChangeLength(int direction) {
    cd68:	4604      	mov	r4, r0
        int length = OC::user_scales[current_scale].num_notes;
    cd6a:	f990 0086 	ldrsb.w	r0, [r0, #134]	; 0x86
    cd6e:	2328      	movs	r3, #40	; 0x28
    cd70:	fb03 2300 	mla	r3, r3, r0, r2
        if (direction > 0 && OC::user_scales[current_scale].notes[length - 1] + 1 >= (12 <<7)) {
    cd74:	2900      	cmp	r1, #0
        int length = OC::user_scales[current_scale].num_notes;
    cd76:	685b      	ldr	r3, [r3, #4]
        if (direction > 0 && OC::user_scales[current_scale].notes[length - 1] + 1 >= (12 <<7)) {
    cd78:	dd09      	ble.n	cd8e <ScaleEditor::ChangeLength(int)+0x2a>
    cd7a:	2514      	movs	r5, #20
    cd7c:	fb05 3500 	mla	r5, r5, r0, r3
    cd80:	3503      	adds	r5, #3
    cd82:	f932 6015 	ldrsh.w	r6, [r2, r5, lsl #1]
    cd86:	f240 55fe 	movw	r5, #1534	; 0x5fe
    cd8a:	42ae      	cmp	r6, r5
    cd8c:	dc36      	bgt.n	cdfc <ScaleEditor::ChangeLength(int)+0x98>
        length = constrain(length + direction, 4, 16);
    cd8e:	440b      	add	r3, r1
    cd90:	2b10      	cmp	r3, #16
    cd92:	bfa8      	it	ge
    cd94:	2310      	movge	r3, #16
        OC::user_scales[current_scale].num_notes = length;
    cd96:	2528      	movs	r5, #40	; 0x28
    cd98:	2b04      	cmp	r3, #4
    cd9a:	fb05 2000 	mla	r0, r5, r0, r2
    cd9e:	bfb8      	it	lt
    cda0:	2304      	movlt	r3, #4
    cda2:	6043      	str	r3, [r0, #4]
        if (current_note > (length - 1)) current_note = length - 1;
    cda4:	f994 0087 	ldrsb.w	r0, [r4, #135]	; 0x87
    cda8:	4283      	cmp	r3, r0
    cdaa:	bfdc      	itt	le
    cdac:	f103 30ff 	addle.w	r0, r3, #4294967295	; 0xffffffff
    cdb0:	f884 0087 	strble.w	r0, [r4, #135]	; 0x87
        if (direction > 0 && OC::user_scales[current_scale].notes[length - 1] < OC::user_scales[current_scale].notes[length - 2]) {
    cdb4:	2900      	cmp	r1, #0
    cdb6:	dd10      	ble.n	cdda <ScaleEditor::ChangeLength(int)+0x76>
    cdb8:	f994 0086 	ldrsb.w	r0, [r4, #134]	; 0x86
    cdbc:	2114      	movs	r1, #20
    cdbe:	4348      	muls	r0, r1
    cdc0:	18c1      	adds	r1, r0, r3
    cdc2:	4403      	add	r3, r0
    cdc4:	3303      	adds	r3, #3
    cdc6:	3102      	adds	r1, #2
    cdc8:	f932 0013 	ldrsh.w	r0, [r2, r3, lsl #1]
    cdcc:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
    cdd0:	4288      	cmp	r0, r1
            OC::user_scales[current_scale].notes[length - 1] = OC::user_scales[current_scale].notes[length - 2] + 1;
    cdd2:	bfbc      	itt	lt
    cdd4:	3101      	addlt	r1, #1
    cdd6:	f822 1013 	strhlt.w	r1, [r2, r3, lsl #1]
        quantizer.Configure(OC::Scales::GetScale(current_scale), 0xffff);
    cdda:	f994 0086 	ldrsb.w	r0, [r4, #134]	; 0x86
    cdde:	f7f4 f8c9 	bl	f74 <OC::Scales::GetScale(int)>
    cde2:	f64f 72ff 	movw	r2, #65535	; 0xffff
    cde6:	4601      	mov	r1, r0
    cde8:	f104 0094 	add.w	r0, r4, #148	; 0x94
    cdec:	f7f9 f906 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
        QuantizeCurrent();
    cdf0:	4620      	mov	r0, r4
    cdf2:	f7ff fde9 	bl	c9c8 <ScaleEditor::QuantizeCurrent()>
    cdf6:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    cdfa:	6263      	str	r3, [r4, #36]	; 0x24
    }
    cdfc:	bd70      	pop	{r4, r5, r6, pc}
    cdfe:	bf00      	nop
    ce00:	1fffa728 	.word	0x1fffa728

0000ce04 <SCALEEDITOR_handleEncoderEvent(UI::Event const&)>:

void SCALEEDITOR_handleEncoderEvent(const UI::Event &event) {
    ce04:	b538      	push	{r3, r4, r5, lr}
    // Left encoder turned
    if (event.control == OC::CONTROL_ENCODER_L) scale_editor_instance.OnLeftEncoderMove(event.value);
    ce06:	8843      	ldrh	r3, [r0, #2]
    ce08:	2b20      	cmp	r3, #32
void SCALEEDITOR_handleEncoderEvent(const UI::Event &event) {
    ce0a:	4604      	mov	r4, r0
    if (event.control == OC::CONTROL_ENCODER_L) scale_editor_instance.OnLeftEncoderMove(event.value);
    ce0c:	d10a      	bne.n	ce24 <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x20>
    ce0e:	f9b0 1004 	ldrsh.w	r1, [r0, #4]
        if (!import_mode && !length_set_mode) ChangeValue(direction);
    ce12:	483a      	ldr	r0, [pc, #232]	; (cefc <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0xf8>)
    ce14:	f890 3091 	ldrb.w	r3, [r0, #145]	; 0x91
    ce18:	b9cb      	cbnz	r3, ce4e <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x4a>
    ce1a:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
    ce1e:	b9b3      	cbnz	r3, ce4e <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x4a>
    ce20:	f7ff ff54 	bl	cccc <ScaleEditor::ChangeValue(int)>

    // Right encoder turned
    if (event.control == OC::CONTROL_ENCODER_R) scale_editor_instance.OnRightEncoderMove(event.value);
    ce24:	8863      	ldrh	r3, [r4, #2]
    ce26:	2b40      	cmp	r3, #64	; 0x40
    ce28:	d111      	bne.n	ce4e <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x4a>
        if (import_mode) ChangeImport(direction);
    ce2a:	4834      	ldr	r0, [pc, #208]	; (cefc <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0xf8>)
    ce2c:	f9b4 1004 	ldrsh.w	r1, [r4, #4]
    ce30:	f890 3091 	ldrb.w	r3, [r0, #145]	; 0x91
    ce34:	b193      	cbz	r3, ce5c <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x58>
        current_import_scale += direction;
    ce36:	f890 3088 	ldrb.w	r3, [r0, #136]	; 0x88
    ce3a:	4419      	add	r1, r3
        if (current_import_scale == OC::Scales::NUM_SCALES) current_import_scale = 0;
    ce3c:	4b30      	ldr	r3, [pc, #192]	; (cf00 <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0xfc>)
    ce3e:	681b      	ldr	r3, [r3, #0]
        current_import_scale += direction;
    ce40:	b249      	sxtb	r1, r1
        if (current_import_scale == OC::Scales::NUM_SCALES) current_import_scale = 0;
    ce42:	4299      	cmp	r1, r3
    ce44:	d004      	beq.n	ce50 <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x4c>
        if (current_import_scale < 0) current_import_scale = OC::Scales::NUM_SCALES - 1;
    ce46:	2900      	cmp	r1, #0
    ce48:	db04      	blt.n	ce54 <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x50>
    ce4a:	f880 1088 	strb.w	r1, [r0, #136]	; 0x88
}
    ce4e:	bd38      	pop	{r3, r4, r5, pc}
        if (current_import_scale == OC::Scales::NUM_SCALES) current_import_scale = 0;
    ce50:	2100      	movs	r1, #0
    ce52:	e7fa      	b.n	ce4a <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x46>
        if (current_import_scale < 0) current_import_scale = OC::Scales::NUM_SCALES - 1;
    ce54:	3b01      	subs	r3, #1
    ce56:	f880 3088 	strb.w	r3, [r0, #136]	; 0x88
    ce5a:	e7f8      	b.n	ce4e <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x4a>
        else if (length_set_mode) ChangeLength(direction);
    ce5c:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
    ce60:	b113      	cbz	r3, ce68 <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x64>
    ce62:	f7ff ff7f 	bl	cd64 <ScaleEditor::ChangeLength(int)>
    ce66:	e7f2      	b.n	ce4e <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x4a>
        int length = OC::user_scales[current_scale].num_notes;
    ce68:	f990 5086 	ldrsb.w	r5, [r0, #134]	; 0x86
    ce6c:	4c25      	ldr	r4, [pc, #148]	; (cf04 <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x100>)
    ce6e:	2328      	movs	r3, #40	; 0x28
    ce70:	fb03 4305 	mla	r3, r3, r5, r4
    ce74:	685a      	ldr	r2, [r3, #4]
        current_note += direction;
    ce76:	f890 3087 	ldrb.w	r3, [r0, #135]	; 0x87
    ce7a:	440b      	add	r3, r1
    ce7c:	b2d9      	uxtb	r1, r3
    ce7e:	b25b      	sxtb	r3, r3
        if (current_note < 0) {
    ce80:	2b00      	cmp	r3, #0
        current_note += direction;
    ce82:	f880 3087 	strb.w	r3, [r0, #135]	; 0x87
        if (current_note < 0) {
    ce86:	da12      	bge.n	ceae <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0xaa>
            if (octave > -1) current_note = length - 1;
    ce88:	f8d0 31d0 	ldr.w	r3, [r0, #464]	; 0x1d0
    ce8c:	2b00      	cmp	r3, #0
            octave = constrain(octave - 1, -1, 4);
    ce8e:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
            if (octave > -1) current_note = length - 1;
    ce92:	bfac      	ite	ge
    ce94:	f102 31ff 	addge.w	r1, r2, #4294967295	; 0xffffffff
            else current_note += 1;
    ce98:	3101      	addlt	r1, #1
            octave = constrain(octave - 1, -1, 4);
    ce9a:	2b04      	cmp	r3, #4
    ce9c:	bfa8      	it	ge
    ce9e:	2304      	movge	r3, #4
            else current_note += 1;
    cea0:	b249      	sxtb	r1, r1
            octave = constrain(octave - 1, -1, 4);
    cea2:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
    cea6:	f880 1087 	strb.w	r1, [r0, #135]	; 0x87
    ceaa:	f8c0 31d0 	str.w	r3, [r0, #464]	; 0x1d0
        if (current_note == length) {
    ceae:	f990 3087 	ldrsb.w	r3, [r0, #135]	; 0x87
    ceb2:	4293      	cmp	r3, r2
    ceb4:	d113      	bne.n	cede <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0xda>
            if (octave < 4) current_note = 0;
    ceb6:	f8d0 31d0 	ldr.w	r3, [r0, #464]	; 0x1d0
    ceba:	2b03      	cmp	r3, #3
            else current_note -= 1;
    cebc:	bfc8      	it	gt
    cebe:	f102 32ff 	addgt.w	r2, r2, #4294967295	; 0xffffffff
            octave = constrain(octave + 1, -1, 4);
    cec2:	f103 0301 	add.w	r3, r3, #1
            else current_note -= 1;
    cec6:	bfcc      	ite	gt
    cec8:	b252      	sxtbgt	r2, r2
            if (octave < 4) current_note = 0;
    ceca:	2200      	movle	r2, #0
            octave = constrain(octave + 1, -1, 4);
    cecc:	2b04      	cmp	r3, #4
    cece:	bfa8      	it	ge
    ced0:	2304      	movge	r3, #4
    ced2:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
    ced6:	f880 2087 	strb.w	r2, [r0, #135]	; 0x87
    ceda:	f8c0 31d0 	str.w	r3, [r0, #464]	; 0x1d0
        undo_value = OC::user_scales[current_scale].notes[current_note];
    cede:	f990 3087 	ldrsb.w	r3, [r0, #135]	; 0x87
    cee2:	2214      	movs	r2, #20
    cee4:	fb02 3305 	mla	r3, r2, r5, r3
    cee8:	3304      	adds	r3, #4
    ceea:	f934 3013 	ldrsh.w	r3, [r4, r3, lsl #1]
    ceee:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
        QuantizeCurrent();
    cef2:	4802      	ldr	r0, [pc, #8]	; (cefc <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0xf8>)
    cef4:	f7ff fd68 	bl	c9c8 <ScaleEditor::QuantizeCurrent()>
}
    cef8:	e7a9      	b.n	ce4e <SCALEEDITOR_handleEncoderEvent(UI::Event const&)+0x4a>
    cefa:	bf00      	nop
    cefc:	20005a5c 	.word	0x20005a5c
    cf00:	0001e700 	.word	0x0001e700
    cf04:	1fffa728 	.word	0x1fffa728

0000cf08 <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)>:
    void DrawColumn(int pos, int y_offset, int cv, bool is_recording, bool is_index) {
    cf08:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cf0c:	4606      	mov	r6, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    cf0e:	039c      	lsls	r4, r3, #14
    cf10:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    cf14:	fb94 f4f3 	sdiv	r4, r4, r3
        int scaled = simfloat2int(proportion * max_value);
    cf18:	2316      	movs	r3, #22
    cf1a:	435c      	muls	r4, r3
    cf1c:	4617      	mov	r7, r2
        uint8_t y_pos = 24 - height + y_offset; // Find the top
    cf1e:	3218      	adds	r2, #24
        uint8_t width = (128 / length()) / 2;
    cf20:	f896 3088 	ldrb.w	r3, [r6, #136]	; 0x88
    void DrawColumn(int pos, int y_offset, int cv, bool is_recording, bool is_index) {
    cf24:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
    cf28:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
    cf2c:	4608      	mov	r0, r1
        uint8_t width = (128 / length()) / 2;
    cf2e:	2580      	movs	r5, #128	; 0x80
        uint8_t y_pos = 24 - height + y_offset; // Find the top
    cf30:	eba2 32a4 	sub.w	r2, r2, r4, asr #14
        uint8_t width = (128 / length()) / 2;
    cf34:	fbb5 f5f3 	udiv	r5, r5, r3
    cf38:	f3c4 3387 	ubfx	r3, r4, #14, #8
        uint8_t x_pos = (128 / length()) * pos;
    cf3c:	fb15 f101 	smulbb	r1, r5, r1
        uint8_t width = (128 / length()) / 2;
    cf40:	ea4f 0b65 	mov.w	fp, r5, asr #1
            gfxRect(x_pos + x_offset, y_pos, width, height);
    cf44:	f3c5 0586 	ubfx	r5, r5, #2, #7
    cf48:	fa5f fa81 	uxtb.w	sl, r1
        graphics.drawRect(x, y, w, h);
    cf4c:	9300      	str	r3, [sp, #0]
    cf4e:	fa55 f181 	uxtab	r1, r5, r1
    cf52:	b2d2      	uxtb	r2, r2
    cf54:	465b      	mov	r3, fp
        if (pos == 0) { // The cursor position is at the leftmost column
    cf56:	bb28      	cbnz	r0, cfa4 <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0x9c>
    cf58:	481c      	ldr	r0, [pc, #112]	; (cfcc <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xc4>)
    cf5a:	f00c f99b 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
            if (is_recording && CursorBlink()) {
    cf5e:	f1b9 0f00 	cmp.w	r9, #0
    cf62:	d00b      	beq.n	cf7c <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0x74>
    cf64:	6a73      	ldr	r3, [r6, #36]	; 0x24
    cf66:	2b00      	cmp	r3, #0
    cf68:	dd08      	ble.n	cf7c <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0x74>
        graphics.invertRect(x, y, w, h);
    cf6a:	2318      	movs	r3, #24
    cf6c:	9300      	str	r3, [sp, #0]
    cf6e:	4817      	ldr	r0, [pc, #92]	; (cfcc <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xc4>)
    cf70:	ea4f 034b 	mov.w	r3, fp, lsl #1
    cf74:	463a      	mov	r2, r7
    cf76:	4651      	mov	r1, sl
    cf78:	f00c fa51 	bl	1941e <weegfx::Graphics::invertRect(int, int, int, int)>
        if (is_index) {
    cf7c:	f1b8 0f00 	cmp.w	r8, #0
    cf80:	d021      	beq.n	cfc6 <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xbe>
            if (index_edit_enabled) {
    cf82:	f896 30ad 	ldrb.w	r3, [r6, #173]	; 0xad
    cf86:	b18b      	cbz	r3, cfac <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xa4>
                if (!CursorBlink()) graphics.drawLine(x_pos, start_y, x_pos, 63);
    cf88:	6a73      	ldr	r3, [r6, #36]	; 0x24
    cf8a:	2b00      	cmp	r3, #0
    cf8c:	dc1b      	bgt.n	cfc6 <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xbe>
    cf8e:	233f      	movs	r3, #63	; 0x3f
    cf90:	480e      	ldr	r0, [pc, #56]	; (cfcc <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xc4>)
    cf92:	930c      	str	r3, [sp, #48]	; 0x30
    cf94:	220f      	movs	r2, #15
    cf96:	4653      	mov	r3, sl
    cf98:	4651      	mov	r1, sl
    }
    cf9a:	b003      	add	sp, #12
    cf9c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                if (!CursorBlink()) graphics.drawLine(x_pos, start_y, x_pos, 63);
    cfa0:	f00c bc26 	b.w	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        graphics.drawFrame(x, y, w, h);
    cfa4:	4809      	ldr	r0, [pc, #36]	; (cfcc <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xc4>)
    cfa6:	f00c fb28 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
    }
    cfaa:	e7e7      	b.n	cf7c <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0x74>
        graphics.drawLine(x, y, x2, y2);
    cfac:	4d07      	ldr	r5, [pc, #28]	; (cfcc <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xc4>)
                for (int y = start_y; y < 63; y += 4)
    cfae:	240f      	movs	r4, #15
    cfb0:	1c63      	adds	r3, r4, #1
    cfb2:	9300      	str	r3, [sp, #0]
    cfb4:	4622      	mov	r2, r4
    cfb6:	4653      	mov	r3, sl
    cfb8:	4651      	mov	r1, sl
    cfba:	4628      	mov	r0, r5
    cfbc:	3404      	adds	r4, #4
    cfbe:	f00c fc17 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    cfc2:	2c3f      	cmp	r4, #63	; 0x3f
    cfc4:	d1f4      	bne.n	cfb0 <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)+0xa8>
    }
    cfc6:	b003      	add	sp, #12
    cfc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cfcc:	200065e0 	.word	0x200065e0

0000cfd0 <TheDarkestTimeline::DrawSetupScreen()>:
    void DrawSetupScreen() {
    cfd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  text_x_ = x;
    cfd4:	4c4d      	ldr	r4, [pc, #308]	; (d10c <TheDarkestTimeline::DrawSetupScreen()+0x13c>)
        graphics.print(str);
    cfd6:	494e      	ldr	r1, [pc, #312]	; (d110 <TheDarkestTimeline::DrawSetupScreen()+0x140>)
    cfd8:	4605      	mov	r5, r0
    cfda:	2601      	movs	r6, #1
  text_y_ = y;
    cfdc:	270f      	movs	r7, #15
    cfde:	4620      	mov	r0, r4
    cfe0:	60a7      	str	r7, [r4, #8]
  text_x_ = x;
    cfe2:	6066      	str	r6, [r4, #4]
    cfe4:	f00c fd77 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(OC::scale_names_short[scale()]);
    cfe8:	f895 2090 	ldrb.w	r2, [r5, #144]	; 0x90
        graphics.print(str);
    cfec:	4b49      	ldr	r3, [pc, #292]	; (d114 <TheDarkestTimeline::DrawSetupScreen()+0x144>)
    cfee:	4620      	mov	r0, r4
    cff0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    cff4:	f00c fd6f 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    cff8:	2366      	movs	r3, #102	; 0x66
        gfxPrint(102, 15, OC::Strings::note_names_unpadded[root()]);
    cffa:	f895 2094 	ldrb.w	r2, [r5, #148]	; 0x94
    cffe:	6063      	str	r3, [r4, #4]
        graphics.print(str);
    d000:	4b45      	ldr	r3, [pc, #276]	; (d118 <TheDarkestTimeline::DrawSetupScreen()+0x148>)
  text_y_ = y;
    d002:	60a7      	str	r7, [r4, #8]
    d004:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
        gfxPrint(midi_channels[midi_channel()]);
    d008:	4f44      	ldr	r7, [pc, #272]	; (d11c <TheDarkestTimeline::DrawSetupScreen()+0x14c>)
    d00a:	4620      	mov	r0, r4
    d00c:	f00c fd63 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    d010:	2319      	movs	r3, #25
    d012:	4943      	ldr	r1, [pc, #268]	; (d120 <TheDarkestTimeline::DrawSetupScreen()+0x150>)
    d014:	60a3      	str	r3, [r4, #8]
    d016:	4620      	mov	r0, r4
  text_x_ = x;
    d018:	6066      	str	r6, [r4, #4]
    d01a:	f00c fd5c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    d01e:	f895 3098 	ldrb.w	r3, [r5, #152]	; 0x98
        graphics.print(str);
    d022:	4620      	mov	r0, r4
    d024:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
    d028:	f00c fd55 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_y_ = y;
    d02c:	2323      	movs	r3, #35	; 0x23
        graphics.print(str);
    d02e:	493d      	ldr	r1, [pc, #244]	; (d124 <TheDarkestTimeline::DrawSetupScreen()+0x154>)
    d030:	60a3      	str	r3, [r4, #8]
    d032:	4620      	mov	r0, r4
  text_x_ = x;
    d034:	6066      	str	r6, [r4, #4]
    d036:	f00c fd4e 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(midi_channels[midi_channel_alt()]);
    d03a:	f895 309c 	ldrb.w	r3, [r5, #156]	; 0x9c
        graphics.print(str);
    d03e:	4620      	mov	r0, r4
    d040:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
    d044:	f00c fd47 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_y_ = y;
    d048:	232d      	movs	r3, #45	; 0x2d
        graphics.print(str);
    d04a:	4937      	ldr	r1, [pc, #220]	; (d128 <TheDarkestTimeline::DrawSetupScreen()+0x158>)
    d04c:	60a3      	str	r3, [r4, #8]
    d04e:	4620      	mov	r0, r4
  text_x_ = x;
    d050:	6066      	str	r6, [r4, #4]
    d052:	f00c fd40 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(midi_channels[midi_channel_in()]);
    d056:	f895 30a0 	ldrb.w	r3, [r5, #160]	; 0xa0
        graphics.print(str);
    d05a:	4620      	mov	r0, r4
    d05c:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
    d060:	f00c fd39 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(str);
    d064:	4931      	ldr	r1, [pc, #196]	; (d12c <TheDarkestTimeline::DrawSetupScreen()+0x15c>)
    d066:	6066      	str	r6, [r4, #4]
  text_y_ = y;
    d068:	2337      	movs	r3, #55	; 0x37
    d06a:	4620      	mov	r0, r4
    d06c:	60a3      	str	r3, [r4, #8]
    d06e:	f00c fd32 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (gate_time() > 0) {
    d072:	f895 10a4 	ldrb.w	r1, [r5, #164]	; 0xa4
    d076:	2900      	cmp	r1, #0
    d078:	d044      	beq.n	d104 <TheDarkestTimeline::DrawSetupScreen()+0x134>
        graphics.print(num);
    d07a:	4620      	mov	r0, r4
    d07c:	f00c fd9f 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    d080:	492b      	ldr	r1, [pc, #172]	; (d130 <TheDarkestTimeline::DrawSetupScreen()+0x160>)
    d082:	4620      	mov	r0, r4
    d084:	f00c fd27 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (setup_screen == 1) gfxCursor(60, 23, 30);
    d088:	f895 31e8 	ldrb.w	r3, [r5, #488]	; 0x1e8
    d08c:	2b01      	cmp	r3, #1
    d08e:	d105      	bne.n	d09c <TheDarkestTimeline::DrawSetupScreen()+0xcc>
    d090:	6a68      	ldr	r0, [r5, #36]	; 0x24
    d092:	231e      	movs	r3, #30
    d094:	2217      	movs	r2, #23
    d096:	213c      	movs	r1, #60	; 0x3c
    d098:	f7f7 fd86 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
        if (setup_screen == 2) gfxCursor(102, 23, 18);
    d09c:	f895 31e8 	ldrb.w	r3, [r5, #488]	; 0x1e8
    d0a0:	2b02      	cmp	r3, #2
    d0a2:	d105      	bne.n	d0b0 <TheDarkestTimeline::DrawSetupScreen()+0xe0>
    d0a4:	6a68      	ldr	r0, [r5, #36]	; 0x24
    d0a6:	2312      	movs	r3, #18
    d0a8:	2217      	movs	r2, #23
    d0aa:	2166      	movs	r1, #102	; 0x66
    d0ac:	f7f7 fd7c 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
        if (setup_screen == 3) gfxCursor(60, 33, 30);
    d0b0:	f895 31e8 	ldrb.w	r3, [r5, #488]	; 0x1e8
    d0b4:	2b03      	cmp	r3, #3
    d0b6:	d105      	bne.n	d0c4 <TheDarkestTimeline::DrawSetupScreen()+0xf4>
    d0b8:	6a68      	ldr	r0, [r5, #36]	; 0x24
    d0ba:	231e      	movs	r3, #30
    d0bc:	2221      	movs	r2, #33	; 0x21
    d0be:	213c      	movs	r1, #60	; 0x3c
    d0c0:	f7f7 fd72 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
        if (setup_screen == 4) gfxCursor(60, 43, 30);
    d0c4:	f895 31e8 	ldrb.w	r3, [r5, #488]	; 0x1e8
    d0c8:	2b04      	cmp	r3, #4
    d0ca:	d105      	bne.n	d0d8 <TheDarkestTimeline::DrawSetupScreen()+0x108>
    d0cc:	6a68      	ldr	r0, [r5, #36]	; 0x24
    d0ce:	231e      	movs	r3, #30
    d0d0:	222b      	movs	r2, #43	; 0x2b
    d0d2:	213c      	movs	r1, #60	; 0x3c
    d0d4:	f7f7 fd68 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
        if (setup_screen == 5) gfxCursor(60, 53, 30);
    d0d8:	f895 31e8 	ldrb.w	r3, [r5, #488]	; 0x1e8
    d0dc:	2b05      	cmp	r3, #5
    d0de:	d105      	bne.n	d0ec <TheDarkestTimeline::DrawSetupScreen()+0x11c>
    d0e0:	6a68      	ldr	r0, [r5, #36]	; 0x24
    d0e2:	231e      	movs	r3, #30
    d0e4:	2235      	movs	r2, #53	; 0x35
    d0e6:	213c      	movs	r1, #60	; 0x3c
    d0e8:	f7f7 fd5e 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
        if (setup_screen == 6) gfxCursor(60, 63, 30);
    d0ec:	f895 31e8 	ldrb.w	r3, [r5, #488]	; 0x1e8
    d0f0:	2b06      	cmp	r3, #6
    d0f2:	d109      	bne.n	d108 <TheDarkestTimeline::DrawSetupScreen()+0x138>
    d0f4:	6a68      	ldr	r0, [r5, #36]	; 0x24
    d0f6:	231e      	movs	r3, #30
    }
    d0f8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        if (setup_screen == 6) gfxCursor(60, 63, 30);
    d0fc:	223f      	movs	r2, #63	; 0x3f
    d0fe:	213c      	movs	r1, #60	; 0x3c
    d100:	f7f7 bd52 	b.w	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
    d104:	490b      	ldr	r1, [pc, #44]	; (d134 <TheDarkestTimeline::DrawSetupScreen()+0x164>)
    d106:	e7bc      	b.n	d082 <TheDarkestTimeline::DrawSetupScreen()+0xb2>
    }
    d108:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    d10c:	200065e0 	.word	0x200065e0
    d110:	000211c9 	.word	0x000211c9
    d114:	0001e600 	.word	0x0001e600
    d118:	0001f374 	.word	0x0001f374
    d11c:	00023e60 	.word	0x00023e60
    d120:	000211d4 	.word	0x000211d4
    d124:	000211df 	.word	0x000211df
    d128:	000211ea 	.word	0x000211ea
    d12c:	000211f5 	.word	0x000211f5
    d130:	000204fb 	.word	0x000204fb
    d134:	000208cb 	.word	0x000208cb

0000d138 <TheDarkestTimeline::move_cursor(int)>:
        cursor += direction;
    d138:	f890 20aa 	ldrb.w	r2, [r0, #170]	; 0xaa
    d13c:	4411      	add	r1, r2
    d13e:	b249      	sxtb	r1, r1
    uint8_t length() {return values_[DT_LENGTH];}
    d140:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
        cursor += direction;
    d144:	f880 10aa 	strb.w	r1, [r0, #170]	; 0xaa
        if (cursor < 0) cursor = length() - 1;
    d148:	2900      	cmp	r1, #0
    d14a:	bfbc      	itt	lt
    d14c:	f102 31ff 	addlt.w	r1, r2, #4294967295	; 0xffffffff
    d150:	f880 10aa 	strblt.w	r1, [r0, #170]	; 0xaa
    int move_cursor(int direction) {
    d154:	4603      	mov	r3, r0
        if (cursor >= length()) cursor = 0;
    d156:	f990 00aa 	ldrsb.w	r0, [r0, #170]	; 0xaa
    d15a:	b2d2      	uxtb	r2, r2
    d15c:	4290      	cmp	r0, r2
    d15e:	bfa8      	it	ge
    d160:	2000      	movge	r0, #0
    d162:	f883 00aa 	strb.w	r0, [r3, #170]	; 0xaa
    }
    d166:	4770      	bx	lr

0000d168 <TheDarkestTimeline::get_data_at(int, bool)>:
        if (timeline) step += 32;
    d168:	b102      	cbz	r2, d16c <TheDarkestTimeline::get_data_at(int, bool)+0x4>
    d16a:	3120      	adds	r1, #32
        if (step >= 0 && step <= 64) {
    d16c:	2940      	cmp	r1, #64	; 0x40
            note = OC::user_patterns[pattern].notes[num];
    d16e:	bf9a      	itte	ls
    d170:	4b02      	ldrls	r3, [pc, #8]	; (d17c <TheDarkestTimeline::get_data_at(int, bool)+0x14>)
    d172:	f833 0011 	ldrhls.w	r0, [r3, r1, lsl #1]
        uint16_t note = 0;
    d176:	2000      	movhi	r0, #0
    }
    d178:	4770      	bx	lr
    d17a:	bf00      	nop
    d17c:	1fffa628 	.word	0x1fffa628

0000d180 <TheDarkestTimeline::DrawTimeline(bool)>:
    void DrawTimeline(bool timeline) {
    d180:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
        int y_offset = 15 + (timeline * 24);
    d184:	2718      	movs	r7, #24
    d186:	434f      	muls	r7, r1
    void DrawTimeline(bool timeline) {
    d188:	4605      	mov	r5, r0
    d18a:	4688      	mov	r8, r1
        int y_offset = 15 + (timeline * 24);
    d18c:	370f      	adds	r7, #15
        for (int pos = 0; pos < length(); pos++)
    d18e:	2600      	movs	r6, #0
            DrawColumn(pos, y_offset, cv, record[timeline], is_index);
    d190:	eb00 0901 	add.w	r9, r0, r1
    uint8_t length() {return values_[DT_LENGTH];}
    d194:	f895 3088 	ldrb.w	r3, [r5, #136]	; 0x88
        for (int pos = 0; pos < length(); pos++)
    d198:	429e      	cmp	r6, r3
    d19a:	db02      	blt.n	d1a2 <TheDarkestTimeline::DrawTimeline(bool)+0x22>
    }
    d19c:	b002      	add	sp, #8
    d19e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        int idx = (((position + cursor) % length()) + index()) % 32;
    d1a2:	f995 40aa 	ldrsb.w	r4, [r5, #170]	; 0xaa
    d1a6:	f995 a08c 	ldrsb.w	sl, [r5, #140]	; 0x8c
    d1aa:	4434      	add	r4, r6
    d1ac:	fb94 f2f3 	sdiv	r2, r4, r3
    d1b0:	fb03 4412 	mls	r4, r3, r2, r4
    d1b4:	4454      	add	r4, sl
    d1b6:	4263      	negs	r3, r4
    d1b8:	f003 031f 	and.w	r3, r3, #31
    d1bc:	f004 041f 	and.w	r4, r4, #31
    d1c0:	bf58      	it	pl
    d1c2:	425c      	negpl	r4, r3
            int cv = get_data_at(idx, timeline);
    d1c4:	4621      	mov	r1, r4
    d1c6:	4642      	mov	r2, r8
    d1c8:	4628      	mov	r0, r5
    d1ca:	f7ff ffcd 	bl	d168 <TheDarkestTimeline::get_data_at(int, bool)>
            DrawColumn(pos, y_offset, cv, record[timeline], is_index);
    d1ce:	ebaa 0204 	sub.w	r2, sl, r4
    d1d2:	4254      	negs	r4, r2
    d1d4:	4154      	adcs	r4, r2
    d1d6:	9401      	str	r4, [sp, #4]
    d1d8:	f899 20ab 	ldrb.w	r2, [r9, #171]	; 0xab
    d1dc:	9200      	str	r2, [sp, #0]
            int cv = get_data_at(idx, timeline);
    d1de:	4603      	mov	r3, r0
            DrawColumn(pos, y_offset, cv, record[timeline], is_index);
    d1e0:	4631      	mov	r1, r6
    d1e2:	463a      	mov	r2, r7
    d1e4:	4628      	mov	r0, r5
    d1e6:	f7ff fe8f 	bl	cf08 <TheDarkestTimeline::DrawColumn(int, int, int, bool, bool)>
        for (int pos = 0; pos < length(); pos++)
    d1ea:	3601      	adds	r6, #1
    d1ec:	e7d2      	b.n	d194 <TheDarkestTimeline::DrawTimeline(bool)+0x14>
    d1ee:	Address 0x000000000000d1ee is out of bounds.


0000d1f0 <TheDarkestTimeline::DrawInterface()>:
    void DrawInterface() {
    d1f0:	b513      	push	{r0, r1, r4, lr}
        gfxPrint(116 + (length() < 10 ? 6 : 0), 2, length());
    d1f2:	f890 1088 	ldrb.w	r1, [r0, #136]	; 0x88
    void DrawInterface() {
    d1f6:	4604      	mov	r4, r0
        gfxPrint(116 + (length() < 10 ? 6 : 0), 2, length());
    d1f8:	290a      	cmp	r1, #10
  text_x_ = x;
    d1fa:	4816      	ldr	r0, [pc, #88]	; (d254 <TheDarkestTimeline::DrawInterface()+0x64>)
    d1fc:	bf34      	ite	cc
    d1fe:	237a      	movcc	r3, #122	; 0x7a
    d200:	2374      	movcs	r3, #116	; 0x74
    d202:	6043      	str	r3, [r0, #4]
  text_y_ = y;
    d204:	2302      	movs	r3, #2
    d206:	6083      	str	r3, [r0, #8]
        graphics.print(num);
    d208:	f00c fcd9 	bl	19bbe <weegfx::Graphics::print(int)>
        if (record[0] || record[1]) gfxBitmap(104, 1, 8, midi_channel_in() ? MIDI_ICON : CV_ICON);
    d20c:	f894 30ab 	ldrb.w	r3, [r4, #171]	; 0xab
    d210:	b913      	cbnz	r3, d218 <TheDarkestTimeline::DrawInterface()+0x28>
    d212:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
    d216:	b16b      	cbz	r3, d234 <TheDarkestTimeline::DrawInterface()+0x44>
    d218:	f894 10a0 	ldrb.w	r1, [r4, #160]	; 0xa0
    d21c:	4a0e      	ldr	r2, [pc, #56]	; (d258 <TheDarkestTimeline::DrawInterface()+0x68>)
    d21e:	4b0f      	ldr	r3, [pc, #60]	; (d25c <TheDarkestTimeline::DrawInterface()+0x6c>)
        graphics.drawBitmap8(x, y, w, data);
    d220:	480c      	ldr	r0, [pc, #48]	; (d254 <TheDarkestTimeline::DrawInterface()+0x64>)
    d222:	2900      	cmp	r1, #0
    d224:	bf08      	it	eq
    d226:	4613      	moveq	r3, r2
    d228:	9300      	str	r3, [sp, #0]
    d22a:	2201      	movs	r2, #1
    d22c:	2308      	movs	r3, #8
    d22e:	2168      	movs	r1, #104	; 0x68
    d230:	f00c fa08 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
        if (setup_screen == 0) {
    d234:	f894 11e8 	ldrb.w	r1, [r4, #488]	; 0x1e8
            DrawTimeline(DT_CV_TIMELINE);
    d238:	4620      	mov	r0, r4
        if (setup_screen == 0) {
    d23a:	b939      	cbnz	r1, d24c <TheDarkestTimeline::DrawInterface()+0x5c>
            DrawTimeline(DT_CV_TIMELINE);
    d23c:	f7ff ffa0 	bl	d180 <TheDarkestTimeline::DrawTimeline(bool)>
            DrawTimeline(DT_PROBABILITY_TIMELINE);
    d240:	2101      	movs	r1, #1
    d242:	4620      	mov	r0, r4
    d244:	f7ff ff9c 	bl	d180 <TheDarkestTimeline::DrawTimeline(bool)>
    }
    d248:	b002      	add	sp, #8
    d24a:	bd10      	pop	{r4, pc}
        } else DrawSetupScreen();
    d24c:	f7ff fec0 	bl	cfd0 <TheDarkestTimeline::DrawSetupScreen()>
    }
    d250:	e7fa      	b.n	d248 <TheDarkestTimeline::DrawInterface()+0x58>
    d252:	bf00      	nop
    d254:	200065e0 	.word	0x200065e0
    d258:	000241f0 	.word	0x000241f0
    d25c:	00024220 	.word	0x00024220

0000d260 <TheDarkestTimeline::View()>:
    void View() {
    d260:	b510      	push	{r4, lr}
        gfxHeader("Darkest Timeline");
    d262:	4904      	ldr	r1, [pc, #16]	; (d274 <TheDarkestTimeline::View()+0x14>)
    void View() {
    d264:	4604      	mov	r4, r0
        gfxHeader("Darkest Timeline");
    d266:	f7f8 fd8d 	bl	5d84 <HSApplication::gfxHeader(char const*)>
        DrawInterface();
    d26a:	4620      	mov	r0, r4
    d26c:	f7ff ffc0 	bl	d1f0 <TheDarkestTimeline::DrawInterface()>
    }
    d270:	bd10      	pop	{r4, pc}
    d272:	bf00      	nop
    d274:	00021200 	.word	0x00021200

0000d278 <TheDarkestTimeline::write_data_at(int, bool, unsigned short)>:
        if (timeline) step += 32;
    d278:	b102      	cbz	r2, d27c <TheDarkestTimeline::write_data_at(int, bool, unsigned short)+0x4>
    d27a:	3120      	adds	r1, #32
        if (step >= 0 && step <= 64) {
    d27c:	2940      	cmp	r1, #64	; 0x40
            OC::user_patterns[pattern].notes[num] = note;
    d27e:	bf9c      	itt	ls
    d280:	4a01      	ldrls	r2, [pc, #4]	; (d288 <TheDarkestTimeline::write_data_at(int, bool, unsigned short)+0x10>)
    d282:	f822 3011 	strhls.w	r3, [r2, r1, lsl #1]
    }
    d286:	4770      	bx	lr
    d288:	1fffa628 	.word	0x1fffa628

0000d28c <TheDarkestTimeline_handleButtonEvent(UI::Event const&)>:

void TheDarkestTimeline_screensaver() {}

void TheDarkestTimeline_handleButtonEvent(const UI::Event &event) {
    // For left encoder, handle press and long press
    if (event.control == OC::CONTROL_BUTTON_L) {
    d28c:	8843      	ldrh	r3, [r0, #2]
    d28e:	2b04      	cmp	r3, #4
void TheDarkestTimeline_handleButtonEvent(const UI::Event &event) {
    d290:	b570      	push	{r4, r5, r6, lr}
    d292:	4604      	mov	r4, r0
    if (event.control == OC::CONTROL_BUTTON_L) {
    d294:	d122      	bne.n	d2dc <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x50>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) TheDarkestTimeline_instance.OnLeftButtonLongPress();
    d296:	7803      	ldrb	r3, [r0, #0]
    d298:	2b02      	cmp	r3, #2
    d29a:	d12d      	bne.n	d2f8 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x6c>
                write_data_at(s, tl, random(0, HSAPPLICATION_5V));
    d29c:	4e39      	ldr	r6, [pc, #228]	; (d384 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xf8>)
    d29e:	2500      	movs	r5, #0
    d2a0:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
    d2a4:	2000      	movs	r0, #0
    d2a6:	f00c fe22 	bl	19eee <random(long, long)>
    d2aa:	4629      	mov	r1, r5
    d2ac:	b283      	uxth	r3, r0
    d2ae:	2200      	movs	r2, #0
    d2b0:	4630      	mov	r0, r6
            for (uint8_t s = 0; s < 32; s++)
    d2b2:	3501      	adds	r5, #1
                write_data_at(s, tl, random(0, HSAPPLICATION_5V));
    d2b4:	f7ff ffe0 	bl	d278 <TheDarkestTimeline::write_data_at(int, bool, unsigned short)>
            for (uint8_t s = 0; s < 32; s++)
    d2b8:	2d20      	cmp	r5, #32
    d2ba:	d1f1      	bne.n	d2a0 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x14>
                write_data_at(s, tl, random(0, HSAPPLICATION_5V));
    d2bc:	4e31      	ldr	r6, [pc, #196]	; (d384 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xf8>)
            for (uint8_t s = 0; s < 32; s++)
    d2be:	2500      	movs	r5, #0
                write_data_at(s, tl, random(0, HSAPPLICATION_5V));
    d2c0:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
    d2c4:	2000      	movs	r0, #0
    d2c6:	f00c fe12 	bl	19eee <random(long, long)>
    d2ca:	4629      	mov	r1, r5
    d2cc:	b283      	uxth	r3, r0
    d2ce:	2201      	movs	r2, #1
    d2d0:	4630      	mov	r0, r6
            for (uint8_t s = 0; s < 32; s++)
    d2d2:	3501      	adds	r5, #1
                write_data_at(s, tl, random(0, HSAPPLICATION_5V));
    d2d4:	f7ff ffd0 	bl	d278 <TheDarkestTimeline::write_data_at(int, bool, unsigned short)>
            for (uint8_t s = 0; s < 32; s++)
    d2d8:	2d20      	cmp	r5, #32
    d2da:	d1f1      	bne.n	d2c0 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x34>
        else TheDarkestTimeline_instance.OnLeftButtonPress();
    }

    // For right encoder, only handle press (long press is reserved)
    if (event.control == OC::CONTROL_BUTTON_R && event.type == UI::EVENT_BUTTON_PRESS) TheDarkestTimeline_instance.OnRightButtonPress();
    d2dc:	8863      	ldrh	r3, [r4, #2]
    d2de:	2b08      	cmp	r3, #8
    d2e0:	d120      	bne.n	d324 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x98>
    d2e2:	7823      	ldrb	r3, [r4, #0]
    d2e4:	2b01      	cmp	r3, #1
    d2e6:	d106      	bne.n	d2f6 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x6a>
        index_edit_enabled = 1 - index_edit_enabled;
    d2e8:	4a26      	ldr	r2, [pc, #152]	; (d384 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xf8>)
    d2ea:	f892 30ad 	ldrb.w	r3, [r2, #173]	; 0xad
    d2ee:	f083 0301 	eor.w	r3, r3, #1
    d2f2:	f882 30ad 	strb.w	r3, [r2, #173]	; 0xad
    // For down button, handle press and long press
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
        if (event.type == UI::EVENT_BUTTON_PRESS) TheDarkestTimeline_instance.OnDownButtonPress();
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) TheDarkestTimeline_instance.OnDownButtonLongPress();
    }
}
    d2f6:	bd70      	pop	{r4, r5, r6, pc}
        if (++setup_screen > (DT_SETTING_LAST - 2)) setup_screen = 0;
    d2f8:	4a22      	ldr	r2, [pc, #136]	; (d384 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xf8>)
    d2fa:	f892 31e8 	ldrb.w	r3, [r2, #488]	; 0x1e8
    d2fe:	3301      	adds	r3, #1
    d300:	b2db      	uxtb	r3, r3
    d302:	2b06      	cmp	r3, #6
    d304:	d906      	bls.n	d314 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x88>
    d306:	2300      	movs	r3, #0
    d308:	f882 31e8 	strb.w	r3, [r2, #488]	; 0x1e8
        cursor_countdown = HSAPPLICATION_CURSOR_TICKS;
    d30c:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    d310:	6253      	str	r3, [r2, #36]	; 0x24
    }
    d312:	e7e3      	b.n	d2dc <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x50>
    d314:	f882 31e8 	strb.w	r3, [r2, #488]	; 0x1e8
        if (setup_screen > 0) setup_screen_timeout_countdown = DT_SETUP_SCREEN_TIMEOUT;
    d318:	2b00      	cmp	r3, #0
    d31a:	d0f7      	beq.n	d30c <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x80>
    d31c:	4b1a      	ldr	r3, [pc, #104]	; (d388 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xfc>)
    d31e:	f8c2 31ec 	str.w	r3, [r2, #492]	; 0x1ec
    d322:	e7f3      	b.n	d30c <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x80>
    if (event.control == OC::CONTROL_BUTTON_UP) TheDarkestTimeline_instance.OnUpButtonPress();
    d324:	2b01      	cmp	r3, #1
    d326:	d00c      	beq.n	d342 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xb6>
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
    d328:	2b02      	cmp	r3, #2
    d32a:	d1e4      	bne.n	d2f6 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x6a>
        if (event.type == UI::EVENT_BUTTON_PRESS) TheDarkestTimeline_instance.OnDownButtonPress();
    d32c:	7823      	ldrb	r3, [r4, #0]
    d32e:	2b01      	cmp	r3, #1
    d330:	d10f      	bne.n	d352 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xc6>
        record[DT_PROBABILITY_TIMELINE] = 1 - record[DT_PROBABILITY_TIMELINE];
    d332:	4a14      	ldr	r2, [pc, #80]	; (d384 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xf8>)
    d334:	f892 30ac 	ldrb.w	r3, [r2, #172]	; 0xac
    d338:	f083 0301 	eor.w	r3, r3, #1
    d33c:	f882 30ac 	strb.w	r3, [r2, #172]	; 0xac
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) TheDarkestTimeline_instance.OnDownButtonLongPress();
    d340:	e7d9      	b.n	d2f6 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x6a>
        record[DT_CV_TIMELINE] = 1 - record[DT_CV_TIMELINE];
    d342:	4a10      	ldr	r2, [pc, #64]	; (d384 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xf8>)
    d344:	f892 30ab 	ldrb.w	r3, [r2, #171]	; 0xab
    d348:	f083 0301 	eor.w	r3, r3, #1
    d34c:	f882 30ab 	strb.w	r3, [r2, #171]	; 0xab
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
    d350:	e7d1      	b.n	d2f6 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x6a>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) TheDarkestTimeline_instance.OnDownButtonLongPress();
    d352:	2b02      	cmp	r3, #2
    d354:	d1cf      	bne.n	d2f6 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x6a>
                write_data_at(s, tl, 0);
    d356:	4d0b      	ldr	r5, [pc, #44]	; (d384 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xf8>)
    d358:	2400      	movs	r4, #0
    d35a:	2300      	movs	r3, #0
    d35c:	4621      	mov	r1, r4
    d35e:	461a      	mov	r2, r3
    d360:	4628      	mov	r0, r5
            for (uint8_t s = 0; s < 32; s++)
    d362:	3401      	adds	r4, #1
                write_data_at(s, tl, 0);
    d364:	f7ff ff88 	bl	d278 <TheDarkestTimeline::write_data_at(int, bool, unsigned short)>
            for (uint8_t s = 0; s < 32; s++)
    d368:	2c20      	cmp	r4, #32
    d36a:	d1f6      	bne.n	d35a <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xce>
                write_data_at(s, tl, 0);
    d36c:	4d05      	ldr	r5, [pc, #20]	; (d384 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xf8>)
            for (uint8_t s = 0; s < 32; s++)
    d36e:	2400      	movs	r4, #0
                write_data_at(s, tl, 0);
    d370:	4621      	mov	r1, r4
    d372:	2300      	movs	r3, #0
    d374:	2201      	movs	r2, #1
    d376:	4628      	mov	r0, r5
            for (uint8_t s = 0; s < 32; s++)
    d378:	3401      	adds	r4, #1
                write_data_at(s, tl, 0);
    d37a:	f7ff ff7d 	bl	d278 <TheDarkestTimeline::write_data_at(int, bool, unsigned short)>
            for (uint8_t s = 0; s < 32; s++)
    d37e:	2c20      	cmp	r4, #32
    d380:	d1f6      	bne.n	d370 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0xe4>
    d382:	e7b8      	b.n	d2f6 <TheDarkestTimeline_handleButtonEvent(UI::Event const&)+0x6a>
    d384:	20002444 	.word	0x20002444
    d388:	00028b0b 	.word	0x00028b0b

0000d38c <VectorOscillator::SetSegment(HS::VOSegment)>:
    void SetSegment(HS::VOSegment segment) {
    d38c:	b513      	push	{r0, r1, r4, lr}
    d38e:	f8ad 1004 	strh.w	r1, [sp, #4]
    d392:	4604      	mov	r4, r0
        if (segment_count < HS::VO_MAX_SEGMENTS) {
    d394:	7e00      	ldrb	r0, [r0, #24]
    d396:	280b      	cmp	r0, #11
    d398:	d80e      	bhi.n	d3b8 <VectorOscillator::SetSegment(HS::VOSegment)+0x2c>
            memcpy(&segments[segment_count], &segment, sizeof(segments[segment_count]));
    d39a:	2202      	movs	r2, #2
    d39c:	a901      	add	r1, sp, #4
    d39e:	eb04 0040 	add.w	r0, r4, r0, lsl #1
    d3a2:	f00c fe25 	bl	19ff0 <memcpy>
            total_time += segments[segment_count].time;
    d3a6:	7e23      	ldrb	r3, [r4, #24]
    d3a8:	eb04 0243 	add.w	r2, r4, r3, lsl #1
            segment_count++;
    d3ac:	3301      	adds	r3, #1
            total_time += segments[segment_count].time;
    d3ae:	7851      	ldrb	r1, [r2, #1]
    d3b0:	69e2      	ldr	r2, [r4, #28]
            segment_count++;
    d3b2:	7623      	strb	r3, [r4, #24]
            total_time += segments[segment_count].time;
    d3b4:	440a      	add	r2, r1
    d3b6:	61e2      	str	r2, [r4, #28]
    }
    d3b8:	b002      	add	sp, #8
    d3ba:	bd10      	pop	{r4, pc}

0000d3bc <VectorOscillator::SetSegment(unsigned char, HS::VOSegment)>:
    void SetSegment(byte ix, HS::VOSegment segment) {
    d3bc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    d3be:	f8ad 2004 	strh.w	r2, [sp, #4]
        ix = constrain(ix, 0, segment_count - 1);
    d3c2:	7e03      	ldrb	r3, [r0, #24]
        total_time -= segments[ix].time;
    d3c4:	69c2      	ldr	r2, [r0, #28]
        ix = constrain(ix, 0, segment_count - 1);
    d3c6:	1e5d      	subs	r5, r3, #1
    d3c8:	428d      	cmp	r5, r1
    d3ca:	bfa8      	it	ge
    d3cc:	460d      	movge	r5, r1
        total_time -= segments[ix].time;
    d3ce:	b2ed      	uxtb	r5, r5
    d3d0:	eb00 0345 	add.w	r3, r0, r5, lsl #1
    void SetSegment(byte ix, HS::VOSegment segment) {
    d3d4:	4604      	mov	r4, r0
        total_time -= segments[ix].time;
    d3d6:	7859      	ldrb	r1, [r3, #1]
    d3d8:	1a52      	subs	r2, r2, r1
    d3da:	61c2      	str	r2, [r0, #28]
        memcpy(&segments[ix], &segment, sizeof(segments[ix]));
    d3dc:	a901      	add	r1, sp, #4
    d3de:	2202      	movs	r2, #2
    d3e0:	4618      	mov	r0, r3
    d3e2:	f00c fe05 	bl	19ff0 <memcpy>
        total_time += segments[ix].time;
    d3e6:	69e3      	ldr	r3, [r4, #28]
    d3e8:	7842      	ldrb	r2, [r0, #1]
    d3ea:	4413      	add	r3, r2
    d3ec:	61e3      	str	r3, [r4, #28]
        if (ix == segment_count) segment_count++;
    d3ee:	7e23      	ldrb	r3, [r4, #24]
    d3f0:	42ab      	cmp	r3, r5
    d3f2:	bf04      	itt	eq
    d3f4:	3301      	addeq	r3, #1
    d3f6:	7623      	strbeq	r3, [r4, #24]
    }
    d3f8:	b003      	add	sp, #12
    d3fa:	bd30      	pop	{r4, r5, pc}

0000d3fc <VectorOscillator::GetSegment(unsigned char)>:
        ix = constrain(ix, 0, segment_count - 1);
    d3fc:	7e03      	ldrb	r3, [r0, #24]
    d3fe:	3b01      	subs	r3, #1
    d400:	428b      	cmp	r3, r1
    d402:	bfa8      	it	ge
    d404:	460b      	movge	r3, r1
        return segments[ix];
    d406:	b2d9      	uxtb	r1, r3
    HS::VOSegment GetSegment(byte ix) {
    d408:	b082      	sub	sp, #8
        return segments[ix];
    d40a:	f830 3011 	ldrh.w	r3, [r0, r1, lsl #1]
    d40e:	2000      	movs	r0, #0
    d410:	b2da      	uxtb	r2, r3
    d412:	f362 0007 	bfi	r0, r2, #0, #8
    d416:	f3c3 2307 	ubfx	r3, r3, #8, #8
    d41a:	f363 200f 	bfi	r0, r3, #8, #8
    }
    d41e:	b002      	add	sp, #8
    d420:	4770      	bx	lr

0000d422 <VectorOscillator::Phase(int)>:
    int32_t Phase(int degrees) {
    d422:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    		degrees = degrees % 3600;
    d426:	f44f 6361 	mov.w	r3, #3600	; 0xe10
    d42a:	fb91 f2f3 	sdiv	r2, r1, r3
    d42e:	fb02 1113 	mls	r1, r2, r3, r1
    		degrees = abs(degrees);
    d432:	ea81 74e1 	eor.w	r4, r1, r1, asr #31
    		byte time_index = Proportion(degrees, 3600, total_time);
    d436:	f8d0 c01c 	ldr.w	ip, [r0, #28]
    		for (byte ix = 0; ix < segment_count; ix++)
    d43a:	7e07      	ldrb	r7, [r0, #24]
    		degrees = abs(degrees);
    d43c:	eba4 74e1 	sub.w	r4, r4, r1, asr #31
        vosignal_t proportion = int2signal((int32_t)numerator) / (int32_t)denominator;
    d440:	02a2      	lsls	r2, r4, #10
    		for (byte ix = 0; ix < segment_count; ix++)
    d442:	2100      	movs	r1, #0
        vosignal_t proportion = int2signal((int32_t)numerator) / (int32_t)denominator;
    d444:	fbb2 f2f3 	udiv	r2, r2, r3
        int32_t scaled = signal2int(proportion * max_value);
    d448:	fb0c f202 	mul.w	r2, ip, r2
    int32_t Phase(int degrees) {
    d44c:	4605      	mov	r5, r0
    		byte time_index = Proportion(degrees, 3600, total_time);
    d44e:	f3c2 2287 	ubfx	r2, r2, #10, #8
    		byte time = 0;
    d452:	460b      	mov	r3, r1
    			time += segments[ix].time;
    d454:	1c46      	adds	r6, r0, #1
    d456:	b2c8      	uxtb	r0, r1
    		for (byte ix = 0; ix < segment_count; ix++)
    d458:	4287      	cmp	r7, r0
    d45a:	d801      	bhi.n	d460 <VectorOscillator::Phase(int)+0x3e>
    		byte segment = 0;
    d45c:	2000      	movs	r0, #0
    d45e:	e007      	b.n	d470 <VectorOscillator::Phase(int)+0x4e>
    			time += segments[ix].time;
    d460:	f816 e011 	ldrb.w	lr, [r6, r1, lsl #1]
    d464:	4473      	add	r3, lr
    d466:	b2db      	uxtb	r3, r3
    			if (time > time_index) {
    d468:	429a      	cmp	r2, r3
    d46a:	f101 0101 	add.w	r1, r1, #1
    d46e:	d2f2      	bcs.n	d456 <VectorOscillator::Phase(int)+0x34>
    		int start_degree = Proportion(time - segments[segment].time, total_time, 3600);
    d470:	eb05 0e40 	add.w	lr, r5, r0, lsl #1
    d474:	b206      	sxth	r6, r0
    d476:	f89e 1001 	ldrb.w	r1, [lr, #1]
    d47a:	1a5a      	subs	r2, r3, r1
        int32_t scaled = signal2int(proportion * max_value);
    d47c:	f44f 6361 	mov.w	r3, #3600	; 0xe10
        vosignal_t proportion = int2signal((int32_t)numerator) / (int32_t)denominator;
    d480:	0292      	lsls	r2, r2, #10
    d482:	ea4f 2881 	mov.w	r8, r1, lsl #10
    d486:	fb92 f2fc 	sdiv	r2, r2, ip
    d48a:	fb98 f8fc 	sdiv	r8, r8, ip
        int32_t scaled = signal2int(proportion * max_value);
    d48e:	435a      	muls	r2, r3
    d490:	fb03 f808 	mul.w	r8, r3, r8
    d494:	1292      	asrs	r2, r2, #10
    d496:	ea4f 28a8 	mov.w	r8, r8, asr #10
    		int start = signal2int(scale_level(segment == 0 ? segments[segment_count - 1].level : segments[segment - 1].level));
    d49a:	b9d0      	cbnz	r0, d4d2 <VectorOscillator::Phase(int)+0xb0>
    d49c:	3f01      	subs	r7, #1
    d49e:	f815 1017 	ldrb.w	r1, [r5, r7, lsl #1]
    d4a2:	f8b5 9034 	ldrh.w	r9, [r5, #52]	; 0x34
    d4a6:	4648      	mov	r0, r9
    d4a8:	f7f7 fa2c 	bl	4904 <VectorOscillator::scale_level(unsigned char) [clone .isra.0]>
    		int end = signal2int(scale_level(segments[segment].level));
    d4ac:	f815 1016 	ldrb.w	r1, [r5, r6, lsl #1]
    		int start = signal2int(scale_level(segment == 0 ? segments[segment_count - 1].level : segments[segment - 1].level));
    d4b0:	1287      	asrs	r7, r0, #10
    		int end = signal2int(scale_level(segments[segment].level));
    d4b2:	4648      	mov	r0, r9
    d4b4:	f7f7 fa26 	bl	4904 <VectorOscillator::scale_level(unsigned char) [clone .isra.0]>
    		int signal = Proportion(degrees - start_degree, segment_degrees, end - start) + start;
    d4b8:	1aa4      	subs	r4, r4, r2
    d4ba:	ebc7 20a0 	rsb	r0, r7, r0, asr #10
        vosignal_t proportion = int2signal((int32_t)numerator) / (int32_t)denominator;
    d4be:	02a4      	lsls	r4, r4, #10
    d4c0:	fb94 f4f8 	sdiv	r4, r4, r8
        int32_t scaled = signal2int(proportion * max_value);
    d4c4:	4344      	muls	r4, r0
        return signal + offset;
    d4c6:	6c28      	ldr	r0, [r5, #64]	; 0x40
    		int signal = Proportion(degrees - start_degree, segment_degrees, end - start) + start;
    d4c8:	eb07 27a4 	add.w	r7, r7, r4, asr #10
    }
    d4cc:	4438      	add	r0, r7
    d4ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    		int start = signal2int(scale_level(segment == 0 ? segments[segment_count - 1].level : segments[segment - 1].level));
    d4d2:	f81e 1c02 	ldrb.w	r1, [lr, #-2]
    d4d6:	e7e4      	b.n	d4a2 <VectorOscillator::Phase(int)+0x80>

0000d4d8 <VectorMorph::Controller()>:
    void Controller() {
    d4d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    		if (DetentedIn(1)) linked = 0; // Turn off linking if CV 2 gets input
    d4dc:	2101      	movs	r1, #1
    void Controller() {
    d4de:	4605      	mov	r5, r0
    		if (DetentedIn(1)) linked = 0; // Turn off linking if CV 2 gets input
    d4e0:	f7fb fcf0 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
    d4e4:	b110      	cbz	r0, d4ec <VectorMorph::Controller()+0x14>
    d4e6:	2300      	movs	r3, #0
    d4e8:	f885 3118 	strb.w	r3, [r5, #280]	; 0x118
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d4ec:	6a2c      	ldr	r4, [r5, #32]
    d4ee:	4f22      	ldr	r7, [pc, #136]	; (d578 <VectorMorph::Controller()+0xa0>)
        		last_phase[ch] = (phase[ch] * 10) + cv_phase;
    d4f0:	f8d5 1110 	ldr.w	r1, [r5, #272]	; 0x110
        		if (!linked || ch == 0) {
    d4f4:	f895 9118 	ldrb.w	r9, [r5, #280]	; 0x118
        int scaled = simfloat2int(proportion * max_value);
    d4f8:	f640 660f 	movw	r6, #3599	; 0xe0f
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d4fc:	03a4      	lsls	r4, r4, #14
    d4fe:	f44f 58f0 	mov.w	r8, #7680	; 0x1e00
    d502:	fb94 f4f8 	sdiv	r4, r4, r8
        int scaled = simfloat2int(proportion * max_value);
    d506:	4374      	muls	r4, r6
    d508:	13a4      	asrs	r4, r4, #14
    d50a:	42b4      	cmp	r4, r6
    d50c:	bfa8      	it	ge
    d50e:	4634      	movge	r4, r6
    d510:	42bc      	cmp	r4, r7
    d512:	bfb8      	it	lt
    d514:	463c      	movlt	r4, r7
        		last_phase[ch] = (phase[ch] * 10) + cv_phase;
    d516:	230a      	movs	r3, #10
    d518:	fb03 4101 	mla	r1, r3, r1, r4
    d51c:	f8c5 1100 	str.w	r1, [r5, #256]	; 0x100
			Out(ch, osc[ch].Phase(last_phase[ch]));
    d520:	f105 0070 	add.w	r0, r5, #112	; 0x70
    d524:	f7ff ff7d 	bl	d422 <VectorOscillator::Phase(int)>
    d528:	2300      	movs	r3, #0
    d52a:	4602      	mov	r2, r0
    d52c:	4619      	mov	r1, r3
    d52e:	4628      	mov	r0, r5
    d530:	f7fb fcd1 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        		if (!linked || ch == 0) {
    d534:	f1b9 0f00 	cmp.w	r9, #0
    d538:	d10b      	bne.n	d552 <VectorMorph::Controller()+0x7a>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d53a:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    d53c:	03a4      	lsls	r4, r4, #14
    d53e:	fb94 f4f8 	sdiv	r4, r4, r8
        int scaled = simfloat2int(proportion * max_value);
    d542:	4374      	muls	r4, r6
    d544:	13a4      	asrs	r4, r4, #14
    d546:	42b4      	cmp	r4, r6
    d548:	bfa8      	it	ge
    d54a:	4634      	movge	r4, r6
    d54c:	42bc      	cmp	r4, r7
    d54e:	bfb8      	it	lt
    d550:	463c      	movlt	r4, r7
        		last_phase[ch] = (phase[ch] * 10) + cv_phase;
    d552:	f8d5 3114 	ldr.w	r3, [r5, #276]	; 0x114
    d556:	220a      	movs	r2, #10
    d558:	fb02 4103 	mla	r1, r2, r3, r4
    d55c:	f8c5 1104 	str.w	r1, [r5, #260]	; 0x104
			Out(ch, osc[ch].Phase(last_phase[ch]));
    d560:	f105 00b8 	add.w	r0, r5, #184	; 0xb8
    d564:	f7ff ff5d 	bl	d422 <VectorOscillator::Phase(int)>
    d568:	2300      	movs	r3, #0
    d56a:	4602      	mov	r2, r0
    d56c:	2101      	movs	r1, #1
    d56e:	4628      	mov	r0, r5
    d570:	f7fb fcb1 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    d574:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    d578:	fffff1f1 	.word	0xfffff1f1

0000d57c <VectorOscillator::calculate_rise(unsigned char)>:
            } else rise = calculate_rise(segment_index);
            sustained = 0;
        }
    }

    vosignal_t calculate_rise(byte ix) {
    d57c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d57e:	8e87      	ldrh	r7, [r0, #52]	; 0x34
    d580:	eb00 0341 	add.w	r3, r0, r1, lsl #1
    d584:	4602      	mov	r2, r0
    d586:	460c      	mov	r4, r1
        // Determine the target level for this segment
        byte level = segments[ix].level;
        int time = static_cast<uint32_t>(segments[ix].time);
        target = scale_level(level);
    d588:	f810 1011 	ldrb.w	r1, [r0, r1, lsl #1]
        int time = static_cast<uint32_t>(segments[ix].time);
    d58c:	785e      	ldrb	r6, [r3, #1]
        target = scale_level(level);
    d58e:	4638      	mov	r0, r7
    d590:	f7f7 f9b8 	bl	4904 <VectorOscillator::scale_level(unsigned char) [clone .isra.0]>
    d594:	4605      	mov	r5, r0
    d596:	6250      	str	r0, [r2, #36]	; 0x24

        // Determine the starting level of this segment to get the total segment rise
        if (ix > 0) ix--;
    d598:	b1fc      	cbz	r4, d5da <VectorOscillator::calculate_rise(unsigned char)+0x5e>
        else ix = segment_count - 1;
    d59a:	3c01      	subs	r4, #1
    d59c:	b2e4      	uxtb	r4, r4
        vosignal_t proportion = int2signal((int32_t)numerator) / (int32_t)denominator;
    d59e:	69d3      	ldr	r3, [r2, #28]
        level = segments[ix].level;
    d5a0:	f812 1014 	ldrb.w	r1, [r2, r4, lsl #1]
        vosignal_t starting = scale_level(level);

        // How many ticks should a complete cycle last? cycle_ticks is 10 times that number.
        int32_t cycle_ticks = 16666667 / frequency;
    d5a4:	6b10      	ldr	r0, [r2, #48]	; 0x30
        vosignal_t proportion = int2signal((int32_t)numerator) / (int32_t)denominator;
    d5a6:	02b4      	lsls	r4, r6, #10
    d5a8:	fb94 f4f3 	sdiv	r4, r4, r3
        int32_t cycle_ticks = 16666667 / frequency;
    d5ac:	4b15      	ldr	r3, [pc, #84]	; (d604 <VectorOscillator::calculate_rise(unsigned char)+0x88>)
    d5ae:	fbb3 f3f0 	udiv	r3, r3, r0
        int32_t scaled = signal2int(proportion * max_value);
    d5b2:	435c      	muls	r4, r3
    d5b4:	12a4      	asrs	r4, r4, #10

        // The total difference between the target and the current signal, divided by how many ticks
        // it should take to get there, is the rise. The / 10 is to cancel the extra precision
        // from the previous two calculations.
        vosignal_t new_rise = 0;
        if (segment_ticks > 0) {
    d5b6:	2c00      	cmp	r4, #0
    d5b8:	dd1f      	ble.n	d5fa <VectorOscillator::calculate_rise(unsigned char)+0x7e>
        vosignal_t starting = scale_level(level);
    d5ba:	4638      	mov	r0, r7
    d5bc:	f7f7 f9a2 	bl	4904 <VectorOscillator::scale_level(unsigned char) [clone .isra.0]>
            new_rise = ((target - starting) * 10) / segment_ticks;
    d5c0:	260a      	movs	r6, #10
    d5c2:	1a2b      	subs	r3, r5, r0
        vosignal_t starting = scale_level(level);
    d5c4:	4601      	mov	r1, r0
            new_rise = ((target - starting) * 10) / segment_ticks;
    d5c6:	4373      	muls	r3, r6
    d5c8:	fb93 f0f4 	sdiv	r0, r3, r4
            if (new_rise == 0) {
    d5cc:	b950      	cbnz	r0, d5e4 <VectorOscillator::calculate_rise(unsigned char)+0x68>
                uint32_t prev_countdown = countdown;
                countdown = segment_ticks / 10;
    d5ce:	fb94 f4f6 	sdiv	r4, r4, r6
                uint32_t prev_countdown = countdown;
    d5d2:	6b93      	ldr	r3, [r2, #56]	; 0x38
                if (prev_countdown > 0 && prev_countdown < countdown) countdown = prev_countdown;
    d5d4:	b91b      	cbnz	r3, d5de <VectorOscillator::calculate_rise(unsigned char)+0x62>
                countdown = segment_ticks / 10;
    d5d6:	6394      	str	r4, [r2, #56]	; 0x38
            signal = target;
            countdown = 1;
        }

        return new_rise;
    }
    d5d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        else ix = segment_count - 1;
    d5da:	7e14      	ldrb	r4, [r2, #24]
    d5dc:	e7dd      	b.n	d59a <VectorOscillator::calculate_rise(unsigned char)+0x1e>
                if (prev_countdown > 0 && prev_countdown < countdown) countdown = prev_countdown;
    d5de:	429c      	cmp	r4, r3
    d5e0:	d8fa      	bhi.n	d5d8 <VectorOscillator::calculate_rise(unsigned char)+0x5c>
    d5e2:	e7f8      	b.n	d5d6 <VectorOscillator::calculate_rise(unsigned char)+0x5a>
            else if ((signal2int(target) - signal2int(starting)) * (signal2int(target) - signal2int(signal)) < 0) new_rise = -new_rise;
    d5e4:	6a12      	ldr	r2, [r2, #32]
    d5e6:	128b      	asrs	r3, r1, #10
    d5e8:	1292      	asrs	r2, r2, #10
    d5ea:	ebc2 22a5 	rsb	r2, r2, r5, asr #10
    d5ee:	ebc3 21a5 	rsb	r1, r3, r5, asr #10
    d5f2:	4351      	muls	r1, r2
    d5f4:	d5f0      	bpl.n	d5d8 <VectorOscillator::calculate_rise(unsigned char)+0x5c>
    d5f6:	4240      	negs	r0, r0
    d5f8:	e7ee      	b.n	d5d8 <VectorOscillator::calculate_rise(unsigned char)+0x5c>
            countdown = 1;
    d5fa:	2301      	movs	r3, #1
            signal = target;
    d5fc:	6215      	str	r5, [r2, #32]
            countdown = 1;
    d5fe:	6393      	str	r3, [r2, #56]	; 0x38
        vosignal_t new_rise = 0;
    d600:	2000      	movs	r0, #0
        return new_rise;
    d602:	e7e9      	b.n	d5d8 <VectorOscillator::calculate_rise(unsigned char)+0x5c>
    d604:	00fe502b 	.word	0x00fe502b

0000d608 <VectorOscillator::SetFrequency(unsigned long)>:
    void SetFrequency(uint32_t frequency_) {
    d608:	b510      	push	{r4, lr}
        frequency = frequency_;
    d60a:	6301      	str	r1, [r0, #48]	; 0x30
        rise = calculate_rise(segment_index);
    d60c:	f890 1029 	ldrb.w	r1, [r0, #41]	; 0x29
    void SetFrequency(uint32_t frequency_) {
    d610:	4604      	mov	r4, r0
        rise = calculate_rise(segment_index);
    d612:	f7ff ffb3 	bl	d57c <VectorOscillator::calculate_rise(unsigned char)>
    d616:	62e0      	str	r0, [r4, #44]	; 0x2c
    }
    d618:	bd10      	pop	{r4, pc}

0000d61a <VectorOscillator::Reset()>:
    void Reset() {
    d61a:	b538      	push	{r3, r4, r5, lr}
        signal = scale_level(segments[segment_count - 1].level);
    d61c:	7e03      	ldrb	r3, [r0, #24]
        segment_index = 0;
    d61e:	2500      	movs	r5, #0
        signal = scale_level(segments[segment_count - 1].level);
    d620:	3b01      	subs	r3, #1
        segment_index = 0;
    d622:	f880 5029 	strb.w	r5, [r0, #41]	; 0x29
    void Reset() {
    d626:	4604      	mov	r4, r0
        signal = scale_level(segments[segment_count - 1].level);
    d628:	f810 1013 	ldrb.w	r1, [r0, r3, lsl #1]
    d62c:	8e80      	ldrh	r0, [r0, #52]	; 0x34
    d62e:	f7f7 f969 	bl	4904 <VectorOscillator::scale_level(unsigned char) [clone .isra.0]>
        rise = calculate_rise(segment_index);
    d632:	4629      	mov	r1, r5
        signal = scale_level(segments[segment_count - 1].level);
    d634:	6220      	str	r0, [r4, #32]
        rise = calculate_rise(segment_index);
    d636:	4620      	mov	r0, r4
    d638:	f7ff ffa0 	bl	d57c <VectorOscillator::calculate_rise(unsigned char)>
        eoc = !cycle;
    d63c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
        rise = calculate_rise(segment_index);
    d640:	62e0      	str	r0, [r4, #44]	; 0x2c
        eoc = !cycle;
    d642:	f083 0301 	eor.w	r3, r3, #1
        sustained = 0;
    d646:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
        eoc = !cycle;
    d64a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    }
    d64e:	bd38      	pop	{r3, r4, r5, pc}

0000d650 <VectorOscillator::advance_segment()>:
    void advance_segment() {
    d650:	b510      	push	{r4, lr}
        if (sustain && segment_index == segment_count - 2) {
    d652:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
    d656:	f890 1029 	ldrb.w	r1, [r0, #41]	; 0x29
    d65a:	7e02      	ldrb	r2, [r0, #24]
    void advance_segment() {
    d65c:	4604      	mov	r4, r0
        if (sustain && segment_index == segment_count - 2) {
    d65e:	b113      	cbz	r3, d666 <VectorOscillator::advance_segment()+0x16>
    d660:	1e90      	subs	r0, r2, #2
    d662:	4281      	cmp	r1, r0
    d664:	d00f      	beq.n	d686 <VectorOscillator::advance_segment()+0x36>
            if (++segment_index >= segment_count) {
    d666:	3101      	adds	r1, #1
    d668:	b2c9      	uxtb	r1, r1
    d66a:	4291      	cmp	r1, r2
    d66c:	f884 1029 	strb.w	r1, [r4, #41]	; 0x29
    d670:	d30c      	bcc.n	d68c <VectorOscillator::advance_segment()+0x3c>
                if (cycle) Reset();
    d672:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
    d676:	b113      	cbz	r3, d67e <VectorOscillator::advance_segment()+0x2e>
    d678:	4620      	mov	r0, r4
    d67a:	f7ff ffce 	bl	d61a <VectorOscillator::Reset()>
                eoc = 1;
    d67e:	2301      	movs	r3, #1
    d680:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    void advance_segment() {
    d684:	2300      	movs	r3, #0
            sustained = 1;
    d686:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    }
    d68a:	bd10      	pop	{r4, pc}
            } else rise = calculate_rise(segment_index);
    d68c:	4620      	mov	r0, r4
    d68e:	f7ff ff75 	bl	d57c <VectorOscillator::calculate_rise(unsigned char)>
    d692:	62e0      	str	r0, [r4, #44]	; 0x2c
    d694:	e7f6      	b.n	d684 <VectorOscillator::advance_segment()+0x34>

0000d696 <VectorOscillator::Next()>:
    		if (eoc && cycle == 0) {
    d696:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
    int32_t Next() {
    d69a:	b510      	push	{r4, lr}
    d69c:	4604      	mov	r4, r0
    		if (eoc && cycle == 0) {
    d69e:	b16b      	cbz	r3, d6bc <VectorOscillator::Next()+0x26>
    d6a0:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
    d6a4:	b953      	cbnz	r3, d6bc <VectorOscillator::Next()+0x26>
    			vosignal_t nr_signal = scale_level(segments[segment_count - 1].level);
    d6a6:	7e03      	ldrb	r3, [r0, #24]
    d6a8:	3b01      	subs	r3, #1
    d6aa:	f810 1013 	ldrb.w	r1, [r0, r3, lsl #1]
    d6ae:	8e80      	ldrh	r0, [r0, #52]	; 0x34
    d6b0:	f7f7 f928 	bl	4904 <VectorOscillator::scale_level(unsigned char) [clone .isra.0]>
    			return signal2int(nr_signal) + offset;
    d6b4:	6c23      	ldr	r3, [r4, #64]	; 0x40
    d6b6:	eb03 20a0 	add.w	r0, r3, r0, asr #10
    }
    d6ba:	bd10      	pop	{r4, pc}
        if (!sustained) { // Observe sustain state
    d6bc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    d6c0:	bb3b      	cbnz	r3, d712 <VectorOscillator::Next()+0x7c>
        if (segment_count < 2) valid = 0;
    d6c2:	7e21      	ldrb	r1, [r4, #24]
        if (frequency == 0) valid = 0;
    d6c4:	6b22      	ldr	r2, [r4, #48]	; 0x30
			eoc = 0;
    d6c6:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        if (segment_count < 2) valid = 0;
    d6ca:	2901      	cmp	r1, #1
    d6cc:	d902      	bls.n	d6d4 <VectorOscillator::Next()+0x3e>
        if (frequency == 0) valid = 0;
    d6ce:	1e13      	subs	r3, r2, #0
    d6d0:	bf18      	it	ne
    d6d2:	2301      	movne	r3, #1
        if (total_time == 0) valid = 0;
    d6d4:	69e2      	ldr	r2, [r4, #28]
    d6d6:	2a00      	cmp	r2, #0
        if (scale == 0) valid = 0;
    d6d8:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
        if (total_time == 0) valid = 0;
    d6da:	bf08      	it	eq
    d6dc:	2300      	moveq	r3, #0
        if (scale == 0) valid = 0;
    d6de:	b1c2      	cbz	r2, d712 <VectorOscillator::Next()+0x7c>
			if (validate()) {
    d6e0:	b1bb      	cbz	r3, d712 <VectorOscillator::Next()+0x7c>
				if (rise) {
    d6e2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d6e4:	2b00      	cmp	r3, #0
    d6e6:	d019      	beq.n	d71c <VectorOscillator::Next()+0x86>
					signal += rise;
    d6e8:	6a22      	ldr	r2, [r4, #32]
    d6ea:	4413      	add	r3, r2
    d6ec:	6223      	str	r3, [r4, #32]
					if (rise >= 0 && signal >= target) advance_segment();
    d6ee:	6a62      	ldr	r2, [r4, #36]	; 0x24
    d6f0:	da07      	bge.n	d702 <VectorOscillator::Next()+0x6c>
					if (rise < 0 && signal <= target) advance_segment();
    d6f2:	6a22      	ldr	r2, [r4, #32]
    d6f4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d6f6:	429a      	cmp	r2, r3
    d6f8:	dc0b      	bgt.n	d712 <VectorOscillator::Next()+0x7c>
    d6fa:	4620      	mov	r0, r4
    d6fc:	f7ff ffa8 	bl	d650 <VectorOscillator::advance_segment()>
    d700:	e007      	b.n	d712 <VectorOscillator::Next()+0x7c>
					if (rise >= 0 && signal >= target) advance_segment();
    d702:	4293      	cmp	r3, r2
    d704:	db05      	blt.n	d712 <VectorOscillator::Next()+0x7c>
    d706:	4620      	mov	r0, r4
    d708:	f7ff ffa2 	bl	d650 <VectorOscillator::advance_segment()>
					if (rise < 0 && signal <= target) advance_segment();
    d70c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d70e:	2b00      	cmp	r3, #0
    d710:	dbef      	blt.n	d6f2 <VectorOscillator::Next()+0x5c>
        return signal2int(signal) + offset;
    d712:	6a23      	ldr	r3, [r4, #32]
    d714:	6c20      	ldr	r0, [r4, #64]	; 0x40
    d716:	eb00 20a3 	add.w	r0, r0, r3, asr #10
    d71a:	e7ce      	b.n	d6ba <VectorOscillator::Next()+0x24>
					if (countdown) {
    d71c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d71e:	2b00      	cmp	r3, #0
    d720:	d0f7      	beq.n	d712 <VectorOscillator::Next()+0x7c>
						--countdown;
    d722:	3b01      	subs	r3, #1
    d724:	63a3      	str	r3, [r4, #56]	; 0x38
						if (countdown == 0) advance_segment();
    d726:	2b00      	cmp	r3, #0
    d728:	d1f3      	bne.n	d712 <VectorOscillator::Next()+0x7c>
    d72a:	e7e6      	b.n	d6fa <VectorOscillator::Next()+0x64>

0000d72c <VectorMod::Controller()>:
    void Controller() {
    d72c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        ForEachChannel(ch)
    d730:	2600      	movs	r6, #0
    void Controller() {
    d732:	4605      	mov	r5, r0
    d734:	f100 071c 	add.w	r7, r0, #28
    d738:	f100 0470 	add.w	r4, r0, #112	; 0x70
            if (Clock(ch)) osc[ch].Start();
    d73c:	46b0      	mov	r8, r6
    d73e:	2200      	movs	r2, #0
    d740:	4631      	mov	r1, r6
    d742:	4628      	mov	r0, r5
    d744:	f7fb ff1e 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    d748:	b120      	cbz	r0, d754 <VectorMod::Controller()+0x28>
        Reset();
    d74a:	4620      	mov	r0, r4
    d74c:	f7ff ff65 	bl	d61a <VectorOscillator::Reset()>
        eoc = 0;
    d750:	f884 8028 	strb.w	r8, [r4, #40]	; 0x28
            bool cycle = (In(ch) > HEMISPHERE_3V_CV);
    d754:	f857 3f04 	ldr.w	r3, [r7, #4]!
    d758:	f5b3 5f90 	cmp.w	r3, #4608	; 0x1200
    d75c:	bfd4      	ite	le
    d75e:	2300      	movle	r3, #0
    d760:	2301      	movgt	r3, #1
    d762:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
            Out(ch, osc[ch].Next());
    d766:	4620      	mov	r0, r4
    d768:	f7ff ff95 	bl	d696 <VectorOscillator::Next()>
    d76c:	2300      	movs	r3, #0
    d76e:	4602      	mov	r2, r0
    d770:	4631      	mov	r1, r6
    d772:	4628      	mov	r0, r5
    d774:	f7fb fbaf 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
    d778:	3448      	adds	r4, #72	; 0x48
    d77a:	b10e      	cbz	r6, d780 <VectorMod::Controller()+0x54>
    }
    d77c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    d780:	2601      	movs	r6, #1
    d782:	e7dc      	b.n	d73e <VectorMod::Controller()+0x12>

0000d784 <VectorLFO::Controller()>:
        if (Changed(0)) {
    d784:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
    void Controller() {
    d788:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d78c:	4604      	mov	r4, r0
    d78e:	f100 0a70 	add.w	sl, r0, #112	; 0x70
        if (Changed(0)) {
    d792:	b1d3      	cbz	r3, d7ca <VectorLFO::Controller()+0x46>
            int mod = Proportion(DetentedIn(0), HEMISPHERE_3V_CV, 3000);
    d794:	2100      	movs	r1, #0
    d796:	f7fb fb95 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d79a:	f44f 5290 	mov.w	r2, #4608	; 0x1200
    d79e:	0383      	lsls	r3, r0, #14
    d7a0:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    d7a4:	f640 32b8 	movw	r2, #3000	; 0xbb8
    d7a8:	4353      	muls	r3, r2
    d7aa:	139b      	asrs	r3, r3, #14
            if (mod + freq[0] > 10) osc[0].SetFrequency(freq[0] + mod);
    d7ac:	4293      	cmp	r3, r2
    d7ae:	bfa8      	it	ge
    d7b0:	4613      	movge	r3, r2
    d7b2:	f8d4 1108 	ldr.w	r1, [r4, #264]	; 0x108
    d7b6:	4a31      	ldr	r2, [pc, #196]	; (d87c <VectorLFO::Controller()+0xf8>)
    d7b8:	4293      	cmp	r3, r2
    d7ba:	bfac      	ite	ge
    d7bc:	18c9      	addge	r1, r1, r3
    d7be:	1889      	addlt	r1, r1, r2
    d7c0:	290a      	cmp	r1, #10
    d7c2:	dd02      	ble.n	d7ca <VectorLFO::Controller()+0x46>
    d7c4:	4650      	mov	r0, sl
    d7c6:	f7ff ff1f 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
        int atten1 = DetentedIn(1);
    d7ca:	2101      	movs	r1, #1
    d7cc:	4620      	mov	r0, r4
    d7ce:	f7fb fb79 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        atten1 = constrain(atten1, 0, HEMISPHERE_MAX_CV);
    d7d2:	f5b0 5ff0 	cmp.w	r0, #7680	; 0x1e00
    d7d6:	bfa8      	it	ge
    d7d8:	f44f 50f0 	movge.w	r0, #7680	; 0x1e00
    d7dc:	ea20 77e0 	bic.w	r7, r0, r0, asr #31
        ForEachChannel(ch)
    d7e0:	2600      	movs	r6, #0
                signal = Proportion(HEMISPHERE_MAX_CV - atten1, HEMISPHERE_MAX_CV, signal); // signal from channel 1's iteration
    d7e2:	f5c7 53f0 	rsb	r3, r7, #7680	; 0x1e00
    d7e6:	f104 0938 	add.w	r9, r4, #56	; 0x38
    d7ea:	46d0      	mov	r8, sl
        int signal = 0; // Declared here because the first channel's output is used in the second channel; see below
    d7ec:	4635      	mov	r5, r6
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d7ee:	039b      	lsls	r3, r3, #14
    d7f0:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
    d7f4:	fbb3 fbf2 	udiv	fp, r3, r2
            if (Clock(ch)) {
    d7f8:	2200      	movs	r2, #0
    d7fa:	4631      	mov	r1, r6
    d7fc:	4620      	mov	r0, r4
    d7fe:	f7fb fec1 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    d802:	b1a8      	cbz	r0, d830 <VectorLFO::Controller()+0xac>
                int new_freq = 1666666 / ticks;
    d804:	f8d9 1000 	ldr.w	r1, [r9]
    d808:	4b1d      	ldr	r3, [pc, #116]	; (d880 <VectorLFO::Controller()+0xfc>)
    d80a:	fbb3 f1f1 	udiv	r1, r3, r1
    d80e:	4b1d      	ldr	r3, [pc, #116]	; (d884 <VectorLFO::Controller()+0x100>)
    d810:	4299      	cmp	r1, r3
    d812:	bfa8      	it	ge
    d814:	4619      	movge	r1, r3
    d816:	2903      	cmp	r1, #3
    d818:	bfb8      	it	lt
    d81a:	2103      	movlt	r1, #3
                osc[ch].SetFrequency(new_freq);
    d81c:	4640      	mov	r0, r8
    d81e:	9101      	str	r1, [sp, #4]
    d820:	f7ff fef2 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
                freq[ch] = new_freq;
    d824:	9901      	ldr	r1, [sp, #4]
    d826:	f8c9 10d0 	str.w	r1, [r9, #208]	; 0xd0
                osc[ch].Reset();
    d82a:	4640      	mov	r0, r8
    d82c:	f7ff fef5 	bl	d61a <VectorOscillator::Reset()>
            if (ch == 0) {
    d830:	b99e      	cbnz	r6, d85a <VectorLFO::Controller()+0xd6>
                signal = osc[ch].Next();
    d832:	4650      	mov	r0, sl
    d834:	f7ff ff2f 	bl	d696 <VectorOscillator::Next()>
    d838:	4605      	mov	r5, r0
            Out(ch, signal);
    d83a:	2300      	movs	r3, #0
    d83c:	462a      	mov	r2, r5
    d83e:	4631      	mov	r1, r6
    d840:	4620      	mov	r0, r4
    d842:	f7fb fb48 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
    d846:	f109 0904 	add.w	r9, r9, #4
    d84a:	f108 0848 	add.w	r8, r8, #72	; 0x48
    d84e:	b116      	cbz	r6, d856 <VectorLFO::Controller()+0xd2>
    }
    d850:	b003      	add	sp, #12
    d852:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d856:	2601      	movs	r6, #1
    d858:	e7ce      	b.n	d7f8 <VectorLFO::Controller()+0x74>
                signal += osc[ch].Next();
    d85a:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
    d85e:	f7ff ff1a 	bl	d696 <VectorOscillator::Next()>
        int scaled = simfloat2int(proportion * max_value);
    d862:	fb05 f50b 	mul.w	r5, r5, fp
    d866:	13ad      	asrs	r5, r5, #14
    d868:	4428      	add	r0, r5
                signal = Proportion(HEMISPHERE_MAX_CV, HEMISPHERE_MAX_CV + (HEMISPHERE_MAX_CV - atten1), signal);
    d86a:	f5c7 5270 	rsb	r2, r7, #15360	; 0x3c00
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d86e:	f04f 63f0 	mov.w	r3, #125829120	; 0x7800000
    d872:	fbb3 f3f2 	udiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    d876:	4343      	muls	r3, r0
    d878:	139d      	asrs	r5, r3, #14
        return scaled;
    d87a:	e7de      	b.n	d83a <VectorLFO::Controller()+0xb6>
    d87c:	fffff448 	.word	0xfffff448
    d880:	00196e6a 	.word	0x00196e6a
    d884:	0001863c 	.word	0x0001863c

0000d888 <BootsNCat::Controller()>:
    void Controller() {
    d888:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            if (Changed(ch)) eg[ch].SetScale((ch ? HEMISPHERE_3V_CV : HEMISPHERE_MAX_CV) - In(ch));
    d88a:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
    void Controller() {
    d88e:	4604      	mov	r4, r0
            if (Changed(ch)) eg[ch].SetScale((ch ? HEMISPHERE_3V_CV : HEMISPHERE_MAX_CV) - In(ch));
    d890:	b123      	cbz	r3, d89c <BootsNCat::Controller()+0x14>
    d892:	6a03      	ldr	r3, [r0, #32]
    d894:	f5c3 53f0 	rsb	r3, r3, #7680	; 0x1e00
    void SetScale(uint16_t scale_) {scale = scale_;}
    d898:	f8a0 30ec 	strh.w	r3, [r0, #236]	; 0xec
            if (Clock(ch, 1)) eg[ch].Start(); // Use physical-only clocking
    d89c:	2201      	movs	r2, #1
    d89e:	2100      	movs	r1, #0
    d8a0:	4620      	mov	r0, r4
    d8a2:	f7fb fe6f 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    d8a6:	b130      	cbz	r0, d8b6 <BootsNCat::Controller()+0x2e>
        Reset();
    d8a8:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
    d8ac:	f7ff feb5 	bl	d61a <VectorOscillator::Reset()>
        eoc = 0;
    d8b0:	2300      	movs	r3, #0
    d8b2:	f884 30e0 	strb.w	r3, [r4, #224]	; 0xe0
            if (Changed(ch)) eg[ch].SetScale((ch ? HEMISPHERE_3V_CV : HEMISPHERE_MAX_CV) - In(ch));
    d8b6:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
    d8ba:	b123      	cbz	r3, d8c6 <BootsNCat::Controller()+0x3e>
    d8bc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d8be:	f5c3 5390 	rsb	r3, r3, #4608	; 0x1200
    void SetScale(uint16_t scale_) {scale = scale_;}
    d8c2:	f8a4 3134 	strh.w	r3, [r4, #308]	; 0x134
            if (Clock(ch, 1)) eg[ch].Start(); // Use physical-only clocking
    d8c6:	2201      	movs	r2, #1
    d8c8:	4611      	mov	r1, r2
    d8ca:	4620      	mov	r0, r4
    d8cc:	f7fb fe5a 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    d8d0:	b130      	cbz	r0, d8e0 <BootsNCat::Controller()+0x58>
        Reset();
    d8d2:	f504 7080 	add.w	r0, r4, #256	; 0x100
    d8d6:	f7ff fea0 	bl	d61a <VectorOscillator::Reset()>
        eoc = 0;
    d8da:	2300      	movs	r3, #0
    d8dc:	f884 3128 	strb.w	r3, [r4, #296]	; 0x128
        if (!eg[0].GetEOC()) {
    d8e0:	f894 30e0 	ldrb.w	r3, [r4, #224]	; 0xe0
    d8e4:	2b00      	cmp	r3, #0
    d8e6:	d160      	bne.n	d9aa <BootsNCat::Controller()+0x122>
            levels[0] = eg[0].Next();
    d8e8:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
    d8ec:	f7ff fed3 	bl	d696 <VectorOscillator::Next()>
    d8f0:	4605      	mov	r5, r0
    d8f2:	f8c4 0150 	str.w	r0, [r4, #336]	; 0x150
            bd_signal = Proportion(levels[0], HEMISPHERE_MAX_CV, bass.Next());
    d8f6:	f104 0070 	add.w	r0, r4, #112	; 0x70
    d8fa:	f7ff fecc 	bl	d696 <VectorOscillator::Next()>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d8fe:	03ad      	lsls	r5, r5, #14
    d900:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    d904:	fb95 f5f3 	sdiv	r5, r5, r3
        int scaled = simfloat2int(proportion * max_value);
    d908:	4345      	muls	r5, r0
    d90a:	13ad      	asrs	r5, r5, #14
        if (--noise_tone_countdown == 0) {
    d90c:	f8d4 0148 	ldr.w	r0, [r4, #328]	; 0x148
    d910:	3801      	subs	r0, #1
    d912:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
    d916:	b968      	cbnz	r0, d934 <BootsNCat::Controller()+0xac>
            noise = random(0, (12 << 7) * 6) - ((12 << 7) * 3);
    d918:	f44f 5110 	mov.w	r1, #9216	; 0x2400
    d91c:	f00c fae7 	bl	19eee <random(long, long)>
            noise_tone_countdown = BNC_MAX_PARAM - tone[1] + 1;
    d920:	f8d4 315c 	ldr.w	r3, [r4, #348]	; 0x15c
            noise = random(0, (12 << 7) * 6) - ((12 << 7) * 3);
    d924:	f5a0 5090 	sub.w	r0, r0, #4608	; 0x1200
            noise_tone_countdown = BNC_MAX_PARAM - tone[1] + 1;
    d928:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
            noise = random(0, (12 << 7) * 6) - ((12 << 7) * 3);
    d92c:	f8c4 014c 	str.w	r0, [r4, #332]	; 0x14c
            noise_tone_countdown = BNC_MAX_PARAM - tone[1] + 1;
    d930:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
        if (!eg[1].GetEOC()) {
    d934:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
    d938:	bbcb      	cbnz	r3, d9ae <BootsNCat::Controller()+0x126>
            levels[1] = eg[1].Next();
    d93a:	f504 7080 	add.w	r0, r4, #256	; 0x100
    d93e:	f7ff feaa 	bl	d696 <VectorOscillator::Next()>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d942:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    d946:	0386      	lsls	r6, r0, #14
    d948:	fb96 f6f3 	sdiv	r6, r6, r3
        int scaled = simfloat2int(proportion * max_value);
    d94c:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
    d950:	f8c4 0154 	str.w	r0, [r4, #340]	; 0x154
    d954:	435e      	muls	r6, r3
    d956:	13b6      	asrs	r6, r6, #14
        signal = Proportion((BNC_MAX_PARAM - blend) + BNC_MAX_PARAM, BNC_MAX_PARAM * 2, bd_signal);
    d958:	f994 3168 	ldrsb.w	r3, [r4, #360]	; 0x168
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d95c:	277e      	movs	r7, #126	; 0x7e
    d95e:	f1c3 017e 	rsb	r1, r3, #126	; 0x7e
    d962:	039a      	lsls	r2, r3, #14
    d964:	fb92 f2f7 	sdiv	r2, r2, r7
        int scaled = simfloat2int(proportion * max_value);
    d968:	4372      	muls	r2, r6
        Out(0, signal);
    d96a:	2300      	movs	r3, #0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d96c:	0389      	lsls	r1, r1, #14
        int scaled = simfloat2int(proportion * max_value);
    d96e:	1392      	asrs	r2, r2, #14
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d970:	fb91 f1f7 	sdiv	r1, r1, r7
        int scaled = simfloat2int(proportion * max_value);
    d974:	4369      	muls	r1, r5
    d976:	eb02 32a1 	add.w	r2, r2, r1, asr #14
    d97a:	4620      	mov	r0, r4
    d97c:	4619      	mov	r1, r3
    d97e:	f7fb faaa 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        signal = Proportion((BNC_MAX_PARAM - blend) + BNC_MAX_PARAM, BNC_MAX_PARAM * 2, sd_signal);
    d982:	f994 3168 	ldrsb.w	r3, [r4, #360]	; 0x168
    d986:	1af9      	subs	r1, r7, r3
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d988:	039a      	lsls	r2, r3, #14
    d98a:	fb92 f2f7 	sdiv	r2, r2, r7
        int scaled = simfloat2int(proportion * max_value);
    d98e:	436a      	muls	r2, r5
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d990:	0389      	lsls	r1, r1, #14
        int scaled = simfloat2int(proportion * max_value);
    d992:	1392      	asrs	r2, r2, #14
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    d994:	fb91 f1f7 	sdiv	r1, r1, r7
        int scaled = simfloat2int(proportion * max_value);
    d998:	4371      	muls	r1, r6
        Out(1, signal);
    d99a:	eb02 32a1 	add.w	r2, r2, r1, asr #14
    d99e:	2300      	movs	r3, #0
    d9a0:	2101      	movs	r1, #1
    d9a2:	4620      	mov	r0, r4
    d9a4:	f7fb fa97 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    d9a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        int32_t bd_signal = 0;
    d9aa:	2500      	movs	r5, #0
    d9ac:	e7ae      	b.n	d90c <BootsNCat::Controller()+0x84>
        int32_t sd_signal = 0;
    d9ae:	2600      	movs	r6, #0
    d9b0:	e7d2      	b.n	d958 <BootsNCat::Controller()+0xd0>
    d9b2:	Address 0x000000000000d9b2 is out of bounds.


0000d9b4 <WaveformManager::Setup()>:
    bool static Validate() {
        return (HS::user_waveforms[0].level == 0xfc && HS::user_waveforms[0].time == 0xe2);
    }

    /* Add a triangle and sawtooth waveform */
    void static Setup() {
    d9b4:	b570      	push	{r4, r5, r6, lr}
        HS::user_waveforms[0] = VOSegment {0xfc, 0xe2};
    d9b6:	4c14      	ldr	r4, [pc, #80]	; (da08 <WaveformManager::Setup()+0x54>)
    d9b8:	4914      	ldr	r1, [pc, #80]	; (da0c <WaveformManager::Setup()+0x58>)
    d9ba:	2202      	movs	r2, #2
    d9bc:	4620      	mov	r0, r4
    d9be:	f00c fb17 	bl	19ff0 <memcpy>
        HS::user_waveforms[1] = VOSegment {0x02, 0xff}; // TOC entry: 2 steps
    d9c2:	2202      	movs	r2, #2
    d9c4:	4912      	ldr	r1, [pc, #72]	; (da10 <WaveformManager::Setup()+0x5c>)
    d9c6:	18a0      	adds	r0, r4, r2
    d9c8:	f00c fb12 	bl	19ff0 <memcpy>
        HS::user_waveforms[2] = VOSegment {0xff, 0x01}; // First segment of triangle
    d9cc:	4911      	ldr	r1, [pc, #68]	; (da14 <WaveformManager::Setup()+0x60>)
    d9ce:	2202      	movs	r2, #2
    d9d0:	1d20      	adds	r0, r4, #4
    d9d2:	f00c fb0d 	bl	19ff0 <memcpy>
        HS::user_waveforms[3] = VOSegment {0x00, 0x01}; // Second segment of triangle
    d9d6:	2500      	movs	r5, #0
    d9d8:	2601      	movs	r6, #1
        HS::user_waveforms[4] = VOSegment {0x02, 0xff}; // TOC entry: 2 steps
    d9da:	2202      	movs	r2, #2
    d9dc:	490c      	ldr	r1, [pc, #48]	; (da10 <WaveformManager::Setup()+0x5c>)
        HS::user_waveforms[3] = VOSegment {0x00, 0x01}; // Second segment of triangle
    d9de:	71a5      	strb	r5, [r4, #6]
        HS::user_waveforms[4] = VOSegment {0x02, 0xff}; // TOC entry: 2 steps
    d9e0:	f104 0008 	add.w	r0, r4, #8
        HS::user_waveforms[3] = VOSegment {0x00, 0x01}; // Second segment of triangle
    d9e4:	71e6      	strb	r6, [r4, #7]
        HS::user_waveforms[4] = VOSegment {0x02, 0xff}; // TOC entry: 2 steps
    d9e6:	f00c fb03 	bl	19ff0 <memcpy>
        HS::user_waveforms[5] = VOSegment {0xff, 0x00}; // First segment of sawtooth
    d9ea:	22ff      	movs	r2, #255	; 0xff
    d9ec:	72a2      	strb	r2, [r4, #10]
    d9ee:	72e5      	strb	r5, [r4, #11]
        HS::user_waveforms[6] = VOSegment {0x00, 0x01}; // Second segment of sawtooth
    d9f0:	7325      	strb	r5, [r4, #12]
    d9f2:	7366      	strb	r6, [r4, #13]
    d9f4:	2307      	movs	r3, #7
        for (byte i = 7; i < 64; i++) HS::user_waveforms[i] = VOSegment {0x00, 0xff};
    d9f6:	3301      	adds	r3, #1
    d9f8:	2b40      	cmp	r3, #64	; 0x40
    d9fa:	73a5      	strb	r5, [r4, #14]
    d9fc:	73e2      	strb	r2, [r4, #15]
    d9fe:	f104 0402 	add.w	r4, r4, #2
    da02:	d1f8      	bne.n	d9f6 <WaveformManager::Setup()+0x42>
    }
    da04:	bd70      	pop	{r4, r5, r6, pc}
    da06:	bf00      	nop
    da08:	20003668 	.word	0x20003668
    da0c:	00022ee8 	.word	0x00022ee8
    da10:	00022eea 	.word	0x00022eea
    da14:	00022eec 	.word	0x00022eec

0000da18 <WaveformEditor::Start()>:
    void Start() {
    da18:	b510      	push	{r4, lr}
        return (HS::user_waveforms[0].level == 0xfc && HS::user_waveforms[0].time == 0xe2);
    da1a:	4b0f      	ldr	r3, [pc, #60]	; (da58 <WaveformEditor::Start()+0x40>)
    da1c:	781a      	ldrb	r2, [r3, #0]
    da1e:	2afc      	cmp	r2, #252	; 0xfc
    da20:	4604      	mov	r4, r0
    da22:	d102      	bne.n	da2a <WaveformEditor::Start()+0x12>
    da24:	785b      	ldrb	r3, [r3, #1]
    da26:	2be2      	cmp	r3, #226	; 0xe2
    da28:	d001      	beq.n	da2e <WaveformEditor::Start()+0x16>
            WaveformManager::Setup();
    da2a:	f7ff ffc3 	bl	d9b4 <WaveformManager::Setup()>
        test_freq[0] = 100;    // Test 0: LFO
    da2e:	2364      	movs	r3, #100	; 0x64
    da30:	f8c4 31fc 	str.w	r3, [r4, #508]	; 0x1fc
        test_freq[1] = 44000;  // Test 1: Audio-Rate
    da34:	f64a 33e0 	movw	r3, #44000	; 0xabe0
    da38:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        test_freq[2] = 50;     // Test 2: Bi-polar one-shot modulation
    da3c:	2332      	movs	r3, #50	; 0x32
    da3e:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
        test_freq[3] = 50;     // Test 3: Uni-polar EG
    da42:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
        waveform_number = 0;
    da46:	2300      	movs	r3, #0
    da48:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        Resume();
    da4c:	6823      	ldr	r3, [r4, #0]
    da4e:	4620      	mov	r0, r4
    da50:	68db      	ldr	r3, [r3, #12]
    }
    da52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        Resume();
    da56:	4718      	bx	r3
    da58:	20003668 	.word	0x20003668

0000da5c <WaveformManager::WaveformCount()>:

    byte static WaveformCount() {
    da5c:	b510      	push	{r4, lr}
    da5e:	2200      	movs	r2, #0
    da60:	4c07      	ldr	r4, [pc, #28]	; (da80 <WaveformManager::WaveformCount()+0x24>)
        byte count = 0;
    da62:	4613      	mov	r3, r2
        for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
        {
            if (HS::user_waveforms[i].IsTOC()) count++;
    da64:	7861      	ldrb	r1, [r4, #1]
    da66:	7820      	ldrb	r0, [r4, #0]
    da68:	f7f6 ff57 	bl	491a <HS::VOSegment::IsTOC() [clone .isra.0]>
    da6c:	b108      	cbz	r0, da72 <WaveformManager::WaveformCount()+0x16>
    da6e:	3301      	adds	r3, #1
    da70:	b2db      	uxtb	r3, r3
        for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
    da72:	3201      	adds	r2, #1
    da74:	2a40      	cmp	r2, #64	; 0x40
    da76:	f104 0402 	add.w	r4, r4, #2
    da7a:	d1f3      	bne.n	da64 <WaveformManager::WaveformCount()+0x8>
        }
        return count;
    }
    da7c:	4618      	mov	r0, r3
    da7e:	bd10      	pop	{r4, pc}
    da80:	20003668 	.word	0x20003668

0000da84 <WaveformManager::GetNextWaveform(unsigned char, int)>:
     * waveforms without having to think about the spaces between them.
     *
     * waveform_number is the starting waveform, and direction is -1 or 1, which way you want to move
     * in the list.
     */
    byte static GetNextWaveform(byte waveform_number, int direction) {
    da84:	b510      	push	{r4, lr}
        int new_number = waveform_number + direction;
    da86:	1844      	adds	r4, r0, r1
        byte count = WaveformCount();
    da88:	f7ff ffe8 	bl	da5c <WaveformManager::WaveformCount()>
        if (new_number < 0) new_number = 0;
    da8c:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
        if (new_number == count) new_number = 32; // Move from last user waveform to first library waveform
    da90:	4298      	cmp	r0, r3
    da92:	d009      	beq.n	daa8 <WaveformManager::GetNextWaveform(unsigned char, int)+0x24>
        if (new_number <= 31 && new_number >= count) new_number = count - 1; // Move from first library waveform to last user waveform
    da94:	2c1f      	cmp	r4, #31
    da96:	dc02      	bgt.n	da9e <WaveformManager::GetNextWaveform(unsigned char, int)+0x1a>
    da98:	4298      	cmp	r0, r3
    da9a:	dc00      	bgt.n	da9e <WaveformManager::GetNextWaveform(unsigned char, int)+0x1a>
    da9c:	1e43      	subs	r3, r0, #1
        if (new_number >= (HS::WAVEFORM_LIBRARY_COUNT + 32)) new_number = HS::WAVEFORM_LIBRARY_COUNT + 31;
        return new_number;
    da9e:	2b3f      	cmp	r3, #63	; 0x3f
    daa0:	bfa8      	it	ge
    daa2:	233f      	movge	r3, #63	; 0x3f
    }
    daa4:	b2d8      	uxtb	r0, r3
    daa6:	bd10      	pop	{r4, pc}
        if (new_number == count) new_number = 32; // Move from last user waveform to first library waveform
    daa8:	2320      	movs	r3, #32
    daaa:	e7f8      	b.n	da9e <WaveformManager::GetNextWaveform(unsigned char, int)+0x1a>

0000daac <WaveformManager::SegmentsRemaining()>:

    byte static SegmentsRemaining() {
        byte segment_count = 1; // Include validation segment
        for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
    daac:	4a0a      	ldr	r2, [pc, #40]	; (dad8 <WaveformManager::SegmentsRemaining()+0x2c>)
    byte static SegmentsRemaining() {
    daae:	b538      	push	{r3, r4, r5, lr}
    dab0:	2400      	movs	r4, #0
        byte segment_count = 1; // Include validation segment
    dab2:	2301      	movs	r3, #1
        {
            if (HS::user_waveforms[i].IsTOC()) {
    dab4:	7815      	ldrb	r5, [r2, #0]
    dab6:	7851      	ldrb	r1, [r2, #1]
    dab8:	4628      	mov	r0, r5
    daba:	f7f6 ff2e 	bl	491a <HS::VOSegment::IsTOC() [clone .isra.0]>
    dabe:	b108      	cbz	r0, dac4 <WaveformManager::SegmentsRemaining()+0x18>
                segment_count += HS::user_waveforms[i].Segments();
    dac0:	442b      	add	r3, r5
    dac2:	b2db      	uxtb	r3, r3
        for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
    dac4:	3401      	adds	r4, #1
    dac6:	2c40      	cmp	r4, #64	; 0x40
    dac8:	f102 0202 	add.w	r2, r2, #2
    dacc:	d1f2      	bne.n	dab4 <WaveformManager::SegmentsRemaining()+0x8>
            }
        }
        return (64 - segment_count);
    dace:	f1c3 0040 	rsb	r0, r3, #64	; 0x40
    }
    dad2:	b2c0      	uxtb	r0, r0
    dad4:	bd38      	pop	{r3, r4, r5, pc}
    dad6:	bf00      	nop
    dad8:	20003668 	.word	0x20003668

0000dadc <VectorOscillator::VectorOscillator()>:
class VectorOscillator {
    dadc:	2200      	movs	r2, #0
    dade:	2101      	movs	r1, #1
    dae0:	7602      	strb	r2, [r0, #24]
    dae2:	61c2      	str	r2, [r0, #28]
    dae4:	6202      	str	r2, [r0, #32]
    dae6:	6242      	str	r2, [r0, #36]	; 0x24
    dae8:	8501      	strh	r1, [r0, #40]	; 0x28
    daea:	f880 103c 	strb.w	r1, [r0, #60]	; 0x3c
    daee:	6402      	str	r2, [r0, #64]	; 0x40
    daf0:	f8a0 2044 	strh.w	r2, [r0, #68]	; 0x44
    daf4:	4770      	bx	lr
    daf6:	Address 0x000000000000daf6 is out of bounds.


0000daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>:

    VectorOscillator static VectorOscillatorFromWaveform(byte waveform_number) {
    daf8:	b5f0      	push	{r4, r5, r6, r7, lr}
    dafa:	460c      	mov	r4, r1
    dafc:	b093      	sub	sp, #76	; 0x4c
    dafe:	4606      	mov	r6, r0
        VectorOscillator osc;
    db00:	f7ff ffec 	bl	dadc <VectorOscillator::VectorOscillator()>
        if (waveform_number >= 32) { // Library waveforms start at 32
    db04:	2c1f      	cmp	r4, #31
    db06:	d935      	bls.n	db74 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x7c>
        }
        return osc;
    }

    VectorOscillator static VectorOscillatorFromLibrary(byte waveform_number) {
        waveform_number = waveform_number - 32; // Library waveforms start at 32
    db08:	3c20      	subs	r4, #32
    db0a:	b2e4      	uxtb	r4, r4
    db0c:	2c1f      	cmp	r4, #31
        if (waveform_number >= HS::WAVEFORM_LIBRARY_COUNT) waveform_number = HS::WAVEFORM_LIBRARY_COUNT - 1;
        VectorOscillator osc;
    db0e:	4668      	mov	r0, sp
    db10:	bf28      	it	cs
    db12:	241f      	movcs	r4, #31
    db14:	f7ff ffe2 	bl	dadc <VectorOscillator::VectorOscillator()>
        byte count = 0;
        for (byte i = 0; i < 255; i++)
    db18:	4b2a      	ldr	r3, [pc, #168]	; (dbc4 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0xcc>)
        VectorOscillator osc;
    db1a:	2500      	movs	r5, #0
        byte count = 0;
    db1c:	462a      	mov	r2, r5
    db1e:	461f      	mov	r7, r3
        {
            if (HS::library_waveforms[i].IsTOC()) {
    db20:	7859      	ldrb	r1, [r3, #1]
    db22:	7818      	ldrb	r0, [r3, #0]
    db24:	f7f6 fef9 	bl	491a <HS::VOSegment::IsTOC() [clone .isra.0]>
    db28:	b1f0      	cbz	r0, db68 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x70>
                if (count == waveform_number) {
    db2a:	4294      	cmp	r4, r2
    db2c:	d11a      	bne.n	db64 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x6c>
                    for (int s = 0; s < HS::library_waveforms[i].Segments(); s++)
    db2e:	2400      	movs	r4, #0
    db30:	e00c      	b.n	db4c <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x54>
                    {
                        osc.SetSegment(HS::library_waveforms[i + s + 1]);
    db32:	1963      	adds	r3, r4, r5
    db34:	3301      	adds	r3, #1
    db36:	4668      	mov	r0, sp
    db38:	f817 2013 	ldrb.w	r2, [r7, r3, lsl #1]
    db3c:	eb07 0343 	add.w	r3, r7, r3, lsl #1
                    for (int s = 0; s < HS::library_waveforms[i].Segments(); s++)
    db40:	3401      	adds	r4, #1
                        osc.SetSegment(HS::library_waveforms[i + s + 1]);
    db42:	7859      	ldrb	r1, [r3, #1]
    db44:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
    db48:	f7ff fc20 	bl	d38c <VectorOscillator::SetSegment(HS::VOSegment)>
                    for (int s = 0; s < HS::library_waveforms[i].Segments(); s++)
    db4c:	f817 3015 	ldrb.w	r3, [r7, r5, lsl #1]
    db50:	429c      	cmp	r4, r3
    db52:	dbee      	blt.n	db32 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x3a>
            osc = VectorOscillatorFromLibrary(waveform_number);
    db54:	2246      	movs	r2, #70	; 0x46
    db56:	4669      	mov	r1, sp
    db58:	4630      	mov	r0, r6
    db5a:	f00c fa49 	bl	19ff0 <memcpy>
    }
    db5e:	4630      	mov	r0, r6
    db60:	b013      	add	sp, #76	; 0x4c
    db62:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    }
                    break;
                }
                count++;
    db64:	3201      	adds	r2, #1
    db66:	b2d2      	uxtb	r2, r2
        for (byte i = 0; i < 255; i++)
    db68:	3501      	adds	r5, #1
    db6a:	2dff      	cmp	r5, #255	; 0xff
    db6c:	f103 0302 	add.w	r3, r3, #2
    db70:	d1d6      	bne.n	db20 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x28>
    db72:	e7ef      	b.n	db54 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x5c>
    db74:	4b14      	ldr	r3, [pc, #80]	; (dbc8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0xd0>)
        if (waveform_number >= 32) { // Library waveforms start at 32
    db76:	2500      	movs	r5, #0
            byte count = 0;
    db78:	462a      	mov	r2, r5
    db7a:	461f      	mov	r7, r3
                if (HS::user_waveforms[i].IsTOC()) {
    db7c:	7859      	ldrb	r1, [r3, #1]
    db7e:	7818      	ldrb	r0, [r3, #0]
    db80:	f7f6 fecb 	bl	491a <HS::VOSegment::IsTOC() [clone .isra.0]>
    db84:	b1b8      	cbz	r0, dbb6 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0xbe>
                    if (count == waveform_number) {
    db86:	4294      	cmp	r4, r2
    db88:	d113      	bne.n	dbb2 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0xba>
                        for (int s = 0; s < HS::user_waveforms[i].Segments(); s++)
    db8a:	2400      	movs	r4, #0
    db8c:	e00c      	b.n	dba8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0xb0>
                            osc.SetSegment(HS::user_waveforms[i + s + 1]);
    db8e:	1963      	adds	r3, r4, r5
    db90:	3301      	adds	r3, #1
    db92:	4630      	mov	r0, r6
    db94:	f817 2013 	ldrb.w	r2, [r7, r3, lsl #1]
    db98:	eb07 0343 	add.w	r3, r7, r3, lsl #1
                        for (int s = 0; s < HS::user_waveforms[i].Segments(); s++)
    db9c:	3401      	adds	r4, #1
                            osc.SetSegment(HS::user_waveforms[i + s + 1]);
    db9e:	7859      	ldrb	r1, [r3, #1]
    dba0:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
    dba4:	f7ff fbf2 	bl	d38c <VectorOscillator::SetSegment(HS::VOSegment)>
                        for (int s = 0; s < HS::user_waveforms[i].Segments(); s++)
    dba8:	f817 3015 	ldrb.w	r3, [r7, r5, lsl #1]
    dbac:	42a3      	cmp	r3, r4
    dbae:	dcee      	bgt.n	db8e <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x96>
    dbb0:	e7d5      	b.n	db5e <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x66>
                    count++;
    dbb2:	3201      	adds	r2, #1
    dbb4:	b2d2      	uxtb	r2, r2
            for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
    dbb6:	3501      	adds	r5, #1
    dbb8:	2d40      	cmp	r5, #64	; 0x40
    dbba:	f103 0302 	add.w	r3, r3, #2
    dbbe:	d1dd      	bne.n	db7c <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x84>
    dbc0:	e7cd      	b.n	db5e <WaveformManager::VectorOscillatorFromWaveform(unsigned char)+0x66>
    dbc2:	bf00      	nop
    dbc4:	1fff9be8 	.word	0x1fff9be8
    dbc8:	20003668 	.word	0x20003668

0000dbcc <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)>:
            }
        }
        return osc;
    }

    byte static GetSegmentIndex(byte waveform_number, byte segment_number, int8_t direction = 0) {
    dbcc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    dbd0:	4d12      	ldr	r5, [pc, #72]	; (dc1c <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)+0x50>)
    dbd2:	2300      	movs	r3, #0
    dbd4:	4682      	mov	sl, r0
    dbd6:	460e      	mov	r6, r1
        byte count = 0;
    dbd8:	4698      	mov	r8, r3
    dbda:	46a9      	mov	r9, r5
    dbdc:	782f      	ldrb	r7, [r5, #0]
        byte segment_index = 0; // Index from which to copy

        // Find the waveform that's the target of the add operation
        for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
        {
            if (HS::user_waveforms[i].IsTOC() && count++ == waveform_number) {
    dbde:	7869      	ldrb	r1, [r5, #1]
    dbe0:	4638      	mov	r0, r7
    dbe2:	b2dc      	uxtb	r4, r3
    dbe4:	f7f6 fe99 	bl	491a <HS::VOSegment::IsTOC() [clone .isra.0]>
    dbe8:	b188      	cbz	r0, dc0e <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)+0x42>
    dbea:	f108 0101 	add.w	r1, r8, #1
    dbee:	45c2      	cmp	sl, r8
    dbf0:	b2c9      	uxtb	r1, r1
    dbf2:	d10b      	bne.n	dc0c <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)+0x40>
                segment_index = i + segment_number + 1;
    dbf4:	3601      	adds	r6, #1
        time = 0xff;
    dbf6:	eb09 0143 	add.w	r1, r9, r3, lsl #1
                HS::user_waveforms[i].SetTOC(HS::user_waveforms[i].Segments() + direction);
    dbfa:	4417      	add	r7, r2
                segment_index = i + segment_number + 1;
    dbfc:	19a0      	adds	r0, r4, r6
        level = segments;
    dbfe:	f809 7013 	strb.w	r7, [r9, r3, lsl #1]
        time = 0xff;
    dc02:	24ff      	movs	r4, #255	; 0xff
    dc04:	b2c0      	uxtb	r0, r0
    dc06:	704c      	strb	r4, [r1, #1]
                break;
            }
        }

        return segment_index;
    }
    dc08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (HS::user_waveforms[i].IsTOC() && count++ == waveform_number) {
    dc0c:	4688      	mov	r8, r1
        for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
    dc0e:	3301      	adds	r3, #1
    dc10:	2b40      	cmp	r3, #64	; 0x40
    dc12:	f105 0502 	add.w	r5, r5, #2
    dc16:	d1e1      	bne.n	dbdc <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)+0x10>
        byte segment_index = 0; // Index from which to copy
    dc18:	2000      	movs	r0, #0
    dc1a:	e7f5      	b.n	dc08 <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)+0x3c>
    dc1c:	20003668 	.word	0x20003668

0000dc20 <WaveformManager::AddWaveform()>:
        }
    }

    void static AddWaveform() {
        byte ix = 1;
        for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
    dc20:	4a15      	ldr	r2, [pc, #84]	; (dc78 <WaveformManager::AddWaveform()+0x58>)
    void static AddWaveform() {
    dc22:	2301      	movs	r3, #1
    dc24:	b570      	push	{r4, r5, r6, lr}
        byte ix = 1;
    dc26:	461c      	mov	r4, r3
    dc28:	4615      	mov	r5, r2
        {
            if (HS::user_waveforms[i].IsTOC()) {
    dc2a:	7816      	ldrb	r6, [r2, #0]
    dc2c:	7851      	ldrb	r1, [r2, #1]
    dc2e:	4630      	mov	r0, r6
    dc30:	f7f6 fe73 	bl	491a <HS::VOSegment::IsTOC() [clone .isra.0]>
    dc34:	b2d9      	uxtb	r1, r3
    dc36:	b108      	cbz	r0, dc3c <WaveformManager::AddWaveform()+0x1c>
                ix = i + HS::user_waveforms[i].Segments() + 1;
    dc38:	4431      	add	r1, r6
    dc3a:	b2cc      	uxtb	r4, r1
        for (byte i = 0; i < HS::VO_SEGMENT_COUNT; i++)
    dc3c:	3301      	adds	r3, #1
    dc3e:	2b41      	cmp	r3, #65	; 0x41
    dc40:	f102 0202 	add.w	r2, r2, #2
    dc44:	d1f1      	bne.n	dc2a <WaveformManager::AddWaveform()+0xa>
            }
        }

        // If there's enough room, add a new triangle waveform
        if (ix < 61) {
    dc46:	2c3c      	cmp	r4, #60	; 0x3c
    dc48:	d814      	bhi.n	dc74 <WaveformManager::AddWaveform()+0x54>
            HS::user_waveforms[ix] = VOSegment {0x02, 0xff}; // TOC entry: 2 steps
    dc4a:	eb05 0044 	add.w	r0, r5, r4, lsl #1
    dc4e:	490b      	ldr	r1, [pc, #44]	; (dc7c <WaveformManager::AddWaveform()+0x5c>)
    dc50:	2202      	movs	r2, #2
    dc52:	f00c f9cd 	bl	19ff0 <memcpy>
            HS::user_waveforms[ix + 1] = VOSegment {0xff, 0x01}; // First segment of triangle
    dc56:	1c60      	adds	r0, r4, #1
    dc58:	eb05 0040 	add.w	r0, r5, r0, lsl #1
            HS::user_waveforms[ix + 2] = VOSegment {0x00, 0x01}; // Second segment of triangle
    dc5c:	3402      	adds	r4, #2
            HS::user_waveforms[ix + 1] = VOSegment {0xff, 0x01}; // First segment of triangle
    dc5e:	4908      	ldr	r1, [pc, #32]	; (dc80 <WaveformManager::AddWaveform()+0x60>)
    dc60:	2202      	movs	r2, #2
    dc62:	f00c f9c5 	bl	19ff0 <memcpy>
            HS::user_waveforms[ix + 2] = VOSegment {0x00, 0x01}; // Second segment of triangle
    dc66:	2300      	movs	r3, #0
    dc68:	f805 3014 	strb.w	r3, [r5, r4, lsl #1]
    dc6c:	eb05 0544 	add.w	r5, r5, r4, lsl #1
    dc70:	2301      	movs	r3, #1
    dc72:	706b      	strb	r3, [r5, #1]
        }
    }
    dc74:	bd70      	pop	{r4, r5, r6, pc}
    dc76:	bf00      	nop
    dc78:	20003668 	.word	0x20003668
    dc7c:	00022eea 	.word	0x00022eea
    dc80:	00022eec 	.word	0x00022eec

0000dc84 <WaveformManager::DeleteWaveform(unsigned char)>:

    void static DeleteWaveform(byte waveform_number) {
        // Index of first segment minus one is the TOC record
        byte ix = GetSegmentIndex(waveform_number, 0) - 1;
    dc84:	2200      	movs	r2, #0
    void static DeleteWaveform(byte waveform_number) {
    dc86:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        byte ix = GetSegmentIndex(waveform_number, 0) - 1;
    dc88:	4611      	mov	r1, r2
    dc8a:	f7ff ff9f 	bl	dbcc <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)>
    dc8e:	1e44      	subs	r4, r0, #1
        if (ix) {
    dc90:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    dc94:	d011      	beq.n	dcba <WaveformManager::DeleteWaveform(unsigned char)+0x36>
    byte Segments() {return level;}
    dc96:	4d12      	ldr	r5, [pc, #72]	; (dce0 <WaveformManager::DeleteWaveform(unsigned char)+0x5c>)
            byte offset = HS::user_waveforms[ix].Segments() + 1;
    dc98:	f815 6014 	ldrb.w	r6, [r5, r4, lsl #1]
    dc9c:	3601      	adds	r6, #1
    dc9e:	b2f6      	uxtb	r6, r6

            // Move the data downward to delete
            for (byte i = ix; i < HS::VO_SEGMENT_COUNT - offset; i++)
    dca0:	f1c6 0740 	rsb	r7, r6, #64	; 0x40
    dca4:	42bc      	cmp	r4, r7
    dca6:	db09      	blt.n	dcbc <WaveformManager::DeleteWaveform(unsigned char)+0x38>
            {
                memcpy(&HS::user_waveforms[i], &HS::user_waveforms[i + offset], sizeof(HS::user_waveforms[i + offset]));
            }

            // Fill in freed memory with empty segments
            for (byte i = HS::VO_SEGMENT_COUNT - offset; i < HS::VO_SEGMENT_COUNT; i++)
    dca8:	b2fb      	uxtb	r3, r7
    dcaa:	eb05 0543 	add.w	r5, r5, r3, lsl #1
            {
                HS::user_waveforms[i] = VOSegment {0x00, 0xff};
    dcae:	2200      	movs	r2, #0
    dcb0:	21ff      	movs	r1, #255	; 0xff
            for (byte i = HS::VO_SEGMENT_COUNT - offset; i < HS::VO_SEGMENT_COUNT; i++)
    dcb2:	2b3f      	cmp	r3, #63	; 0x3f
    dcb4:	f105 0502 	add.w	r5, r5, #2
    dcb8:	d90b      	bls.n	dcd2 <WaveformManager::DeleteWaveform(unsigned char)+0x4e>
            }
        }
    }
    dcba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                memcpy(&HS::user_waveforms[i], &HS::user_waveforms[i + offset], sizeof(HS::user_waveforms[i + offset]));
    dcbc:	19a1      	adds	r1, r4, r6
    dcbe:	eb05 0044 	add.w	r0, r5, r4, lsl #1
    dcc2:	2202      	movs	r2, #2
    dcc4:	eb05 0141 	add.w	r1, r5, r1, lsl #1
            for (byte i = ix; i < HS::VO_SEGMENT_COUNT - offset; i++)
    dcc8:	3401      	adds	r4, #1
                memcpy(&HS::user_waveforms[i], &HS::user_waveforms[i + offset], sizeof(HS::user_waveforms[i + offset]));
    dcca:	f00c f991 	bl	19ff0 <memcpy>
            for (byte i = ix; i < HS::VO_SEGMENT_COUNT - offset; i++)
    dcce:	b2e4      	uxtb	r4, r4
    dcd0:	e7e8      	b.n	dca4 <WaveformManager::DeleteWaveform(unsigned char)+0x20>
            for (byte i = HS::VO_SEGMENT_COUNT - offset; i < HS::VO_SEGMENT_COUNT; i++)
    dcd2:	3301      	adds	r3, #1
                HS::user_waveforms[i] = VOSegment {0x00, 0xff};
    dcd4:	f805 2c02 	strb.w	r2, [r5, #-2]
    dcd8:	f805 1c01 	strb.w	r1, [r5, #-1]
            for (byte i = HS::VO_SEGMENT_COUNT - offset; i < HS::VO_SEGMENT_COUNT; i++)
    dcdc:	b2db      	uxtb	r3, r3
    dcde:	e7e8      	b.n	dcb2 <WaveformManager::DeleteWaveform(unsigned char)+0x2e>
    dce0:	20003668 	.word	0x20003668

0000dce4 <WaveformEditor::OnRightEncoderMove(int)>:
        if (add_delete_confirm) {
    dce4:	f890 3089 	ldrb.w	r3, [r0, #137]	; 0x89
    void OnRightEncoderMove(int direction) {
    dce8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    dcec:	4605      	mov	r5, r0
    dcee:	460e      	mov	r6, r1
        if (add_delete_confirm) {
    dcf0:	b143      	cbz	r3, dd04 <WaveformEditor::OnRightEncoderMove(int)+0x20>
            add_waveform = 1 - add_waveform;
    dcf2:	f890 308a 	ldrb.w	r3, [r0, #138]	; 0x8a
    dcf6:	f083 0301 	eor.w	r3, r3, #1
    dcfa:	f880 308a 	strb.w	r3, [r0, #138]	; 0x8a
    }
    dcfe:	b003      	add	sp, #12
    dd00:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            VOSegment seg = osc.GetSegment(segment_number);
    dd04:	f890 9086 	ldrb.w	r9, [r0, #134]	; 0x86
    dd08:	f100 0890 	add.w	r8, r0, #144	; 0x90
    dd0c:	4649      	mov	r1, r9
    dd0e:	4640      	mov	r0, r8
    dd10:	f7ff fb74 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
            if (cursor == 0) { // Level
    dd14:	f895 3085 	ldrb.w	r3, [r5, #133]	; 0x85
            VOSegment seg = osc.GetSegment(segment_number);
    dd18:	b2c7      	uxtb	r7, r0
    dd1a:	f3c0 2407 	ubfx	r4, r0, #8, #8
            if (cursor == 0) { // Level
    dd1e:	2b00      	cmp	r3, #0
    dd20:	d13f      	bne.n	dda2 <WaveformEditor::OnRightEncoderMove(int)+0xbe>
                if (direction < 0 && seg.level > 0) seg.level = seg.level - 1;
    dd22:	2e00      	cmp	r6, #0
    dd24:	da38      	bge.n	dd98 <WaveformEditor::OnRightEncoderMove(int)+0xb4>
    dd26:	b10f      	cbz	r7, dd2c <WaveformEditor::OnRightEncoderMove(int)+0x48>
    dd28:	3f01      	subs	r7, #1
                if (direction > 0 && seg.level < 255) seg.level = seg.level + 1;
    dd2a:	b2ff      	uxtb	r7, r7
            osc.SetSegment(segment_number, seg);
    dd2c:	f88d 7004 	strb.w	r7, [sp, #4]
    dd30:	f88d 4005 	strb.w	r4, [sp, #5]
    dd34:	9a01      	ldr	r2, [sp, #4]
    dd36:	4649      	mov	r1, r9
    dd38:	4640      	mov	r0, r8
    dd3a:	f7ff fb3f 	bl	d3bc <VectorOscillator::SetSegment(unsigned char, HS::VOSegment)>
            if (osc.TotalTime() == 0) {
    dd3e:	f895 30ac 	ldrb.w	r3, [r5, #172]	; 0xac
    dd42:	b943      	cbnz	r3, dd56 <WaveformEditor::OnRightEncoderMove(int)+0x72>
                osc.SetSegment(segment_number, seg);
    dd44:	2401      	movs	r4, #1
    dd46:	f88d 4005 	strb.w	r4, [sp, #5]
    dd4a:	9a01      	ldr	r2, [sp, #4]
    dd4c:	f895 1086 	ldrb.w	r1, [r5, #134]	; 0x86
    dd50:	4640      	mov	r0, r8
    dd52:	f7ff fb33 	bl	d3bc <VectorOscillator::SetSegment(unsigned char, HS::VOSegment)>
    dd56:	f105 06d8 	add.w	r6, r5, #216	; 0xd8
    dd5a:	f505 78fc 	add.w	r8, r5, #504	; 0x1f8
            for (byte t = 0; t < 4; t++) test[t].SetSegment(segment_number, seg);
    dd5e:	f88d 7004 	strb.w	r7, [sp, #4]
    dd62:	f88d 4005 	strb.w	r4, [sp, #5]
    dd66:	4630      	mov	r0, r6
    dd68:	9a01      	ldr	r2, [sp, #4]
    dd6a:	f895 1086 	ldrb.w	r1, [r5, #134]	; 0x86
    dd6e:	3648      	adds	r6, #72	; 0x48
    dd70:	f7ff fb24 	bl	d3bc <VectorOscillator::SetSegment(unsigned char, HS::VOSegment)>
    dd74:	4546      	cmp	r6, r8
    dd76:	d1f2      	bne.n	dd5e <WaveformEditor::OnRightEncoderMove(int)+0x7a>
        byte ix = GetSegmentIndex(waveform_number, segment_number);
    dd78:	f895 1086 	ldrb.w	r1, [r5, #134]	; 0x86
    dd7c:	f895 008c 	ldrb.w	r0, [r5, #140]	; 0x8c
    dd80:	2200      	movs	r2, #0
    dd82:	f7ff ff23 	bl	dbcc <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)>
        if (ix) {
    dd86:	2800      	cmp	r0, #0
    dd88:	d0b9      	beq.n	dcfe <WaveformEditor::OnRightEncoderMove(int)+0x1a>
            HS::user_waveforms[ix].level = segment->level;
    dd8a:	4b0c      	ldr	r3, [pc, #48]	; (ddbc <WaveformEditor::OnRightEncoderMove(int)+0xd8>)
    dd8c:	f803 7010 	strb.w	r7, [r3, r0, lsl #1]
            HS::user_waveforms[ix].time = segment->time;
    dd90:	eb03 0340 	add.w	r3, r3, r0, lsl #1
    dd94:	705c      	strb	r4, [r3, #1]
    }
    dd96:	e7b2      	b.n	dcfe <WaveformEditor::OnRightEncoderMove(int)+0x1a>
                if (direction > 0 && seg.level < 255) seg.level = seg.level + 1;
    dd98:	d0c8      	beq.n	dd2c <WaveformEditor::OnRightEncoderMove(int)+0x48>
    dd9a:	2fff      	cmp	r7, #255	; 0xff
    dd9c:	d0c6      	beq.n	dd2c <WaveformEditor::OnRightEncoderMove(int)+0x48>
    dd9e:	3701      	adds	r7, #1
    dda0:	e7c3      	b.n	dd2a <WaveformEditor::OnRightEncoderMove(int)+0x46>
                if (direction < 0 && seg.time > 0) seg.time = seg.time - 1;
    dda2:	2e00      	cmp	r6, #0
    dda4:	da04      	bge.n	ddb0 <WaveformEditor::OnRightEncoderMove(int)+0xcc>
    dda6:	2c00      	cmp	r4, #0
    dda8:	d0c0      	beq.n	dd2c <WaveformEditor::OnRightEncoderMove(int)+0x48>
    ddaa:	3c01      	subs	r4, #1
                if (direction > 0 && seg.time < 9) seg.time = seg.time + 1;
    ddac:	b2e4      	uxtb	r4, r4
    ddae:	e7bd      	b.n	dd2c <WaveformEditor::OnRightEncoderMove(int)+0x48>
    ddb0:	d0bc      	beq.n	dd2c <WaveformEditor::OnRightEncoderMove(int)+0x48>
    ddb2:	2c08      	cmp	r4, #8
    ddb4:	d8ba      	bhi.n	dd2c <WaveformEditor::OnRightEncoderMove(int)+0x48>
    ddb6:	3401      	adds	r4, #1
    ddb8:	e7f8      	b.n	ddac <WaveformEditor::OnRightEncoderMove(int)+0xc8>
    ddba:	bf00      	nop
    ddbc:	20003668 	.word	0x20003668

0000ddc0 <WaveformEditor_handleEncoderEvent(UI::Event const&)>:
        if (event.type == UI::EVENT_BUTTON_PRESS) WaveformEditor_instance.OnDownButtonPress();
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) WaveformEditor_instance.OnDownButtonLongPress();
    }
}

void WaveformEditor_handleEncoderEvent(const UI::Event &event) {
    ddc0:	b508      	push	{r3, lr}
    // Left encoder turned
    if (event.control == OC::CONTROL_ENCODER_L) WaveformEditor_instance.OnLeftEncoderMove(event.value);
    ddc2:	8843      	ldrh	r3, [r0, #2]
    ddc4:	2b20      	cmp	r3, #32
    ddc6:	d121      	bne.n	de0c <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x4c>
        if (add_delete_confirm) {
    ddc8:	4b14      	ldr	r3, [pc, #80]	; (de1c <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x5c>)
    if (event.control == OC::CONTROL_ENCODER_L) WaveformEditor_instance.OnLeftEncoderMove(event.value);
    ddca:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
        if (add_delete_confirm) {
    ddce:	f893 1089 	ldrb.w	r1, [r3, #137]	; 0x89
    ddd2:	b131      	cbz	r1, dde2 <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x22>
            add_waveform = 1 - add_waveform;
    ddd4:	f893 208a 	ldrb.w	r2, [r3, #138]	; 0x8a
    ddd8:	f082 0201 	eor.w	r2, r2, #1
    dddc:	f883 208a 	strb.w	r2, [r3, #138]	; 0x8a

    // Right encoder turned
    if (event.control == OC::CONTROL_ENCODER_R) WaveformEditor_instance.OnRightEncoderMove(event.value);
}
    dde0:	bd08      	pop	{r3, pc}
            if (direction < 0 && segment_number > 0) --segment_number;
    dde2:	2a00      	cmp	r2, #0
    dde4:	da07      	bge.n	ddf6 <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x36>
    dde6:	f893 2086 	ldrb.w	r2, [r3, #134]	; 0x86
    ddea:	2a00      	cmp	r2, #0
    ddec:	d0f8      	beq.n	dde0 <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x20>
    ddee:	3a01      	subs	r2, #1
            if (direction > 0) segment_number = constrain(segment_number + 1, 0, osc.SegmentCount() - 1);
    ddf0:	f883 2086 	strb.w	r2, [r3, #134]	; 0x86
    }
    ddf4:	e7f4      	b.n	dde0 <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x20>
            if (direction > 0) segment_number = constrain(segment_number + 1, 0, osc.SegmentCount() - 1);
    ddf6:	d0f3      	beq.n	dde0 <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x20>
    ddf8:	f893 2086 	ldrb.w	r2, [r3, #134]	; 0x86
    ddfc:	f893 10a8 	ldrb.w	r1, [r3, #168]	; 0xa8
    de00:	3201      	adds	r2, #1
    de02:	3901      	subs	r1, #1
    de04:	428a      	cmp	r2, r1
    de06:	bfa8      	it	ge
    de08:	460a      	movge	r2, r1
    de0a:	e7f1      	b.n	ddf0 <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x30>
    if (event.control == OC::CONTROL_ENCODER_R) WaveformEditor_instance.OnRightEncoderMove(event.value);
    de0c:	2b40      	cmp	r3, #64	; 0x40
    de0e:	d1e7      	bne.n	dde0 <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x20>
    de10:	f9b0 1004 	ldrsh.w	r1, [r0, #4]
    de14:	4801      	ldr	r0, [pc, #4]	; (de1c <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x5c>)
    de16:	f7ff ff65 	bl	dce4 <WaveformEditor::OnRightEncoderMove(int)>
}
    de1a:	e7e1      	b.n	dde0 <WaveformEditor_handleEncoderEvent(UI::Event const&)+0x20>
    de1c:	20003450 	.word	0x20003450

0000de20 <WaveformEditor::DrawWaveform()>:
    void DrawWaveform() {
    de20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        VOSegment seg = osc.GetSegment(osc.SegmentCount() - 1);
    de24:	f890 10a8 	ldrb.w	r1, [r0, #168]	; 0xa8
    byte TotalTime() {return total_time;}
    de28:	f8d0 30ac 	ldr.w	r3, [r0, #172]	; 0xac
    void DrawWaveform() {
    de2c:	b087      	sub	sp, #28
        VOSegment seg = osc.GetSegment(osc.SegmentCount() - 1);
    de2e:	f100 0890 	add.w	r8, r0, #144	; 0x90
    de32:	3901      	subs	r1, #1
    void DrawWaveform() {
    de34:	4605      	mov	r5, r0
        VOSegment seg = osc.GetSegment(osc.SegmentCount() - 1);
    de36:	b2c9      	uxtb	r1, r1
    de38:	4640      	mov	r0, r8
    de3a:	9302      	str	r3, [sp, #8]
    de3c:	f7ff fade 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
        int scaled = simfloat2int(proportion * max_value);
    de40:	f04f 0a28 	mov.w	sl, #40	; 0x28
        byte prev_y = 63 - Proportion(seg.level, 255, 40);
    de44:	b2c2      	uxtb	r2, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    de46:	0392      	lsls	r2, r2, #14
    de48:	f04f 09ff 	mov.w	r9, #255	; 0xff
    de4c:	fbb2 f2f9 	udiv	r2, r2, r9
        int scaled = simfloat2int(proportion * max_value);
    de50:	fb0a f202 	mul.w	r2, sl, r2
    de54:	1392      	asrs	r2, r2, #14
    de56:	f1c2 023f 	rsb	r2, r2, #63	; 0x3f
        for (byte i = 0; i < osc.SegmentCount(); i++)
    de5a:	2600      	movs	r6, #0
        byte prev_y = 63 - Proportion(seg.level, 255, 40);
    de5c:	b2d2      	uxtb	r2, r2
        byte prev_x = 0; // Starting coordinates
    de5e:	4637      	mov	r7, r6
        for (byte i = 0; i < osc.SegmentCount(); i++)
    de60:	f895 30a8 	ldrb.w	r3, [r5, #168]	; 0xa8
    de64:	fa5f fb86 	uxtb.w	fp, r6
    de68:	455b      	cmp	r3, fp
    de6a:	d80b      	bhi.n	de84 <WaveformEditor::DrawWaveform()+0x64>
        graphics.drawLine(x, y, x2, y2, p);
    de6c:	222b      	movs	r2, #43	; 0x2b
    de6e:	2308      	movs	r3, #8
    de70:	9301      	str	r3, [sp, #4]
    de72:	481c      	ldr	r0, [pc, #112]	; (dee4 <WaveformEditor::DrawWaveform()+0xc4>)
    de74:	9200      	str	r2, [sp, #0]
    de76:	237f      	movs	r3, #127	; 0x7f
    de78:	2100      	movs	r1, #0
    de7a:	f00b fc2f 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
    }
    de7e:	b007      	add	sp, #28
    de80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            seg = osc.GetSegment(i);
    de84:	4659      	mov	r1, fp
    de86:	4640      	mov	r0, r8
    de88:	9203      	str	r2, [sp, #12]
    de8a:	f7ff fab7 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
            byte y = 63 - Proportion(seg.level, 255, 40);
    de8e:	b2c4      	uxtb	r4, r0
            byte seg_x = Proportion(seg.time, total_time, 128);
    de90:	f3c0 2307 	ubfx	r3, r0, #8, #8
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    de94:	f89d 1008 	ldrb.w	r1, [sp, #8]
        graphics.drawLine(x, y, x2, y2, p);
    de98:	9a03      	ldr	r2, [sp, #12]
    de9a:	4812      	ldr	r0, [pc, #72]	; (dee4 <WaveformEditor::DrawWaveform()+0xc4>)
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    de9c:	03a4      	lsls	r4, r4, #14
    de9e:	039b      	lsls	r3, r3, #14
    dea0:	fbb4 f4f9 	udiv	r4, r4, r9
    dea4:	fbb3 f3f1 	udiv	r3, r3, r1
        int scaled = simfloat2int(proportion * max_value);
    dea8:	fb0a f404 	mul.w	r4, sl, r4
            byte p = segment_number == i ? 1 : 2;
    deac:	f895 1086 	ldrb.w	r1, [r5, #134]	; 0x86
            byte x = prev_x + seg_x;
    deb0:	eb07 13e3 	add.w	r3, r7, r3, asr #7
    deb4:	b2db      	uxtb	r3, r3
    deb6:	13a4      	asrs	r4, r4, #14
            byte p = segment_number == i ? 1 : 2;
    deb8:	4559      	cmp	r1, fp
    deba:	bf14      	ite	ne
    debc:	2102      	movne	r1, #2
    debe:	2101      	moveq	r1, #1
            byte y = 63 - Proportion(seg.level, 255, 40);
    dec0:	f1c4 043f 	rsb	r4, r4, #63	; 0x3f
            x = constrain(x, 0, 127);
    dec4:	2b7f      	cmp	r3, #127	; 0x7f
            byte y = 63 - Proportion(seg.level, 255, 40);
    dec6:	b2e4      	uxtb	r4, r4
            x = constrain(x, 0, 127);
    dec8:	bfa8      	it	ge
    deca:	237f      	movge	r3, #127	; 0x7f
    decc:	fa5f fb83 	uxtb.w	fp, r3
        graphics.drawLine(x, y, x2, y2, p);
    ded0:	9101      	str	r1, [sp, #4]
            y = constrain(y, 0, 63);
    ded2:	9400      	str	r4, [sp, #0]
    ded4:	4639      	mov	r1, r7
    ded6:	f00b fc01 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
        for (byte i = 0; i < osc.SegmentCount(); i++)
    deda:	3601      	adds	r6, #1
            prev_y = y;
    dedc:	4622      	mov	r2, r4
            prev_x = x;
    dede:	465f      	mov	r7, fp
    dee0:	e7be      	b.n	de60 <WaveformEditor::DrawWaveform()+0x40>
    dee2:	bf00      	nop
    dee4:	200065e0 	.word	0x200065e0

0000dee8 <WaveformEditor::DrawInterface()>:
    void DrawInterface() {
    dee8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    deea:	4605      	mov	r5, r0
        gfxIcon(106, 0, SEGMENT_ICON);
    deec:	4a36      	ldr	r2, [pc, #216]	; (dfc8 <WaveformEditor::DrawInterface()+0xe0>)
  text_x_ = x;
    deee:	4c37      	ldr	r4, [pc, #220]	; (dfcc <WaveformEditor::DrawInterface()+0xe4>)
    def0:	2100      	movs	r1, #0
    def2:	206a      	movs	r0, #106	; 0x6a
    def4:	f7f6 fbd6 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxPrint(116 + pad(10, segments_remaining), 1, segments_remaining);
    def8:	f895 1088 	ldrb.w	r1, [r5, #136]	; 0x88
    defc:	200a      	movs	r0, #10
    defe:	f7f6 fe1f 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    df02:	3074      	adds	r0, #116	; 0x74
  text_y_ = y;
    df04:	2301      	movs	r3, #1
  text_x_ = x;
    df06:	6060      	str	r0, [r4, #4]
        graphics.print(num);
    df08:	4620      	mov	r0, r4
  text_y_ = y;
    df0a:	60a3      	str	r3, [r4, #8]
    df0c:	f00b fe57 	bl	19bbe <weegfx::Graphics::print(int)>
        VOSegment seg = osc.GetSegment(segment_number);
    df10:	f895 1086 	ldrb.w	r1, [r5, #134]	; 0x86
    df14:	f105 0090 	add.w	r0, r5, #144	; 0x90
    df18:	f7ff fa70 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
        gfxIcon(0, 15, WAVEFORM_ICON);
    df1c:	4a2c      	ldr	r2, [pc, #176]	; (dfd0 <WaveformEditor::DrawInterface()+0xe8>)
        VOSegment seg = osc.GetSegment(segment_number);
    df1e:	f8ad 0004 	strh.w	r0, [sp, #4]
    df22:	b2c7      	uxtb	r7, r0
        gfxIcon(0, 15, WAVEFORM_ICON);
    df24:	210f      	movs	r1, #15
    df26:	2000      	movs	r0, #0
    df28:	f7f6 fbbc 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxPrint(10 + pad(10, waveform_number + 1), 15, waveform_number + 1);
    df2c:	f8d5 108c 	ldr.w	r1, [r5, #140]	; 0x8c
    df30:	200a      	movs	r0, #10
    df32:	3101      	adds	r1, #1
    df34:	f7f6 fe04 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    df38:	300a      	adds	r0, #10
    df3a:	260f      	movs	r6, #15
  text_x_ = x;
    df3c:	6060      	str	r0, [r4, #4]
    df3e:	4620      	mov	r0, r4
  text_y_ = y;
    df40:	60a6      	str	r6, [r4, #8]
    df42:	f00b fe3c 	bl	19bbe <weegfx::Graphics::print(int)>
        gfxIcon(30, 15, SEGMENT_ICON);
    df46:	4a20      	ldr	r2, [pc, #128]	; (dfc8 <WaveformEditor::DrawInterface()+0xe0>)
    df48:	4631      	mov	r1, r6
    df4a:	201e      	movs	r0, #30
    df4c:	f7f6 fbaa 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxPrint(40 + pad(10, segment_number + 1), 15, segment_number + 1);
    df50:	f895 1086 	ldrb.w	r1, [r5, #134]	; 0x86
    df54:	200a      	movs	r0, #10
    df56:	3101      	adds	r1, #1
    df58:	f7f6 fdf2 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    df5c:	3028      	adds	r0, #40	; 0x28
  text_x_ = x;
    df5e:	6060      	str	r0, [r4, #4]
    df60:	4620      	mov	r0, r4
  text_y_ = y;
    df62:	60a6      	str	r6, [r4, #8]
    df64:	f00b fe2b 	bl	19bbe <weegfx::Graphics::print(int)>
        gfxIcon(64, 15, UP_DOWN_ICON);
    df68:	4a1a      	ldr	r2, [pc, #104]	; (dfd4 <WaveformEditor::DrawInterface()+0xec>)
    df6a:	4631      	mov	r1, r6
    df6c:	2040      	movs	r0, #64	; 0x40
    df6e:	f7f6 fb99 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxPrint(74 + pad(100, seg.level - 128), 15, seg.level - 128);
    df72:	f1a7 0180 	sub.w	r1, r7, #128	; 0x80
    df76:	2064      	movs	r0, #100	; 0x64
    df78:	f7f6 fde2 	bl	4b40 <HSApplication::pad(int, int) [clone .isra.0]>
    df7c:	304a      	adds	r0, #74	; 0x4a
  text_x_ = x;
    df7e:	6060      	str	r0, [r4, #4]
    df80:	4620      	mov	r0, r4
  text_y_ = y;
    df82:	60a6      	str	r6, [r4, #8]
    df84:	f00b fe1b 	bl	19bbe <weegfx::Graphics::print(int)>
        gfxIcon(112, 15, LEFT_RIGHT_ICON);
    df88:	4a13      	ldr	r2, [pc, #76]	; (dfd8 <WaveformEditor::DrawInterface()+0xf0>)
    df8a:	4631      	mov	r1, r6
    df8c:	2070      	movs	r0, #112	; 0x70
    df8e:	f7f6 fb89 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
  text_x_ = x;
    df92:	277a      	movs	r7, #122	; 0x7a
    df94:	f89d 1005 	ldrb.w	r1, [sp, #5]
    df98:	6067      	str	r7, [r4, #4]
    df9a:	4620      	mov	r0, r4
  text_y_ = y;
    df9c:	60a6      	str	r6, [r4, #8]
    df9e:	f00b fe0e 	bl	19bbe <weegfx::Graphics::print(int)>
        if (cursor == 0) gfxCursor(74, 23, 24);
    dfa2:	f895 3085 	ldrb.w	r3, [r5, #133]	; 0x85
    dfa6:	b953      	cbnz	r3, dfbe <WaveformEditor::DrawInterface()+0xd6>
    dfa8:	2318      	movs	r3, #24
    dfaa:	2217      	movs	r2, #23
    dfac:	214a      	movs	r1, #74	; 0x4a
        else gfxCursor(122, 23, 6);
    dfae:	6a68      	ldr	r0, [r5, #36]	; 0x24
    dfb0:	f7f6 fdfa 	bl	4ba8 <HSApplication::gfxCursor(int, int, int) [clone .isra.0]>
        DrawWaveform();
    dfb4:	4628      	mov	r0, r5
    dfb6:	f7ff ff33 	bl	de20 <WaveformEditor::DrawWaveform()>
    }
    dfba:	b003      	add	sp, #12
    dfbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else gfxCursor(122, 23, 6);
    dfbe:	2306      	movs	r3, #6
    dfc0:	2217      	movs	r2, #23
    dfc2:	4639      	mov	r1, r7
    dfc4:	e7f3      	b.n	dfae <WaveformEditor::DrawInterface()+0xc6>
    dfc6:	bf00      	nop
    dfc8:	00023d00 	.word	0x00023d00
    dfcc:	200065e0 	.word	0x200065e0
    dfd0:	00023e38 	.word	0x00023e38
    dfd4:	00023d08 	.word	0x00023d08
    dfd8:	00023ee0 	.word	0x00023ee0

0000dfdc <WaveformEditor::DrawAddDelete()>:
    void DrawAddDelete() {
    dfdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (segments_remaining > 2) {
    dfde:	f890 3088 	ldrb.w	r3, [r0, #136]	; 0x88
    dfe2:	4c2c      	ldr	r4, [pc, #176]	; (e094 <WaveformEditor::DrawAddDelete()+0xb8>)
    dfe4:	2b02      	cmp	r3, #2
    dfe6:	f04f 020c 	mov.w	r2, #12
    dfea:	f04f 030f 	mov.w	r3, #15
    void DrawAddDelete() {
    dfee:	4605      	mov	r5, r0
  text_x_ = x;
    dff0:	6062      	str	r2, [r4, #4]
  text_y_ = y;
    dff2:	60a3      	str	r3, [r4, #8]
        if (segments_remaining > 2) {
    dff4:	d943      	bls.n	e07e <WaveformEditor::DrawAddDelete()+0xa2>
        graphics.print(str);
    dff6:	4928      	ldr	r1, [pc, #160]	; (e098 <WaveformEditor::DrawAddDelete()+0xbc>)
    dff8:	4620      	mov	r0, r4
    dffa:	f00b fd6c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            gfxPrint(waveform_count + 1);
    dffe:	f895 1087 	ldrb.w	r1, [r5, #135]	; 0x87
        graphics.print(num);
    e002:	4620      	mov	r0, r4
    e004:	3101      	adds	r1, #1
    e006:	f00b fdda 	bl	19bbe <weegfx::Graphics::print(int)>
        if (waveform_count > 1) {
    e00a:	f895 3087 	ldrb.w	r3, [r5, #135]	; 0x87
    e00e:	220c      	movs	r2, #12
    e010:	2b01      	cmp	r3, #1
    e012:	f04f 0319 	mov.w	r3, #25
  text_x_ = x;
    e016:	6062      	str	r2, [r4, #4]
  text_y_ = y;
    e018:	60a3      	str	r3, [r4, #8]
    e01a:	d935      	bls.n	e088 <WaveformEditor::DrawAddDelete()+0xac>
        graphics.print(str);
    e01c:	491f      	ldr	r1, [pc, #124]	; (e09c <WaveformEditor::DrawAddDelete()+0xc0>)
    e01e:	481d      	ldr	r0, [pc, #116]	; (e094 <WaveformEditor::DrawAddDelete()+0xb8>)
    e020:	f00b fd59 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            gfxPrint(waveform_number + 1);
    e024:	f8d5 108c 	ldr.w	r1, [r5, #140]	; 0x8c
        graphics.print(num);
    e028:	481a      	ldr	r0, [pc, #104]	; (e094 <WaveformEditor::DrawAddDelete()+0xb8>)
    e02a:	3101      	adds	r1, #1
    e02c:	f00b fdc7 	bl	19bbe <weegfx::Graphics::print(int)>
        gfxIcon(1, 15, add_waveform ? CHECK_ON_ICON : CHECK_OFF_ICON);
    e030:	f895 208a 	ldrb.w	r2, [r5, #138]	; 0x8a
    e034:	4e1a      	ldr	r6, [pc, #104]	; (e0a0 <WaveformEditor::DrawAddDelete()+0xc4>)
    e036:	4f1b      	ldr	r7, [pc, #108]	; (e0a4 <WaveformEditor::DrawAddDelete()+0xc8>)
    e038:	210f      	movs	r1, #15
    e03a:	2a00      	cmp	r2, #0
    e03c:	bf14      	ite	ne
    e03e:	4632      	movne	r2, r6
    e040:	463a      	moveq	r2, r7
    e042:	2001      	movs	r0, #1
    e044:	f7f6 fb2e 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
        gfxIcon(1, 25, add_waveform ? CHECK_OFF_ICON : CHECK_ON_ICON);
    e048:	f895 208a 	ldrb.w	r2, [r5, #138]	; 0x8a
    e04c:	2119      	movs	r1, #25
    e04e:	2a00      	cmp	r2, #0
    e050:	bf14      	ite	ne
    e052:	463a      	movne	r2, r7
    e054:	4632      	moveq	r2, r6
    e056:	2001      	movs	r0, #1
    e058:	f7f6 fb24 	bl	46a4 <HSApplication::gfxIcon(int, int, unsigned char const*) [clone .constprop.0]>
    e05c:	2537      	movs	r5, #55	; 0x37
  text_x_ = x;
    e05e:	2300      	movs	r3, #0
        graphics.print(str);
    e060:	4911      	ldr	r1, [pc, #68]	; (e0a8 <WaveformEditor::DrawAddDelete()+0xcc>)
    e062:	480c      	ldr	r0, [pc, #48]	; (e094 <WaveformEditor::DrawAddDelete()+0xb8>)
    e064:	6063      	str	r3, [r4, #4]
  text_y_ = y;
    e066:	60a5      	str	r5, [r4, #8]
    e068:	f00b fd35 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
    e06c:	2368      	movs	r3, #104	; 0x68
    e06e:	6063      	str	r3, [r4, #4]
  text_y_ = y;
    e070:	60a5      	str	r5, [r4, #8]
    e072:	490e      	ldr	r1, [pc, #56]	; (e0ac <WaveformEditor::DrawAddDelete()+0xd0>)
    e074:	4807      	ldr	r0, [pc, #28]	; (e094 <WaveformEditor::DrawAddDelete()+0xb8>)
    }
    e076:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    e07a:	f00b bd2c 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    e07e:	490c      	ldr	r1, [pc, #48]	; (e0b0 <WaveformEditor::DrawAddDelete()+0xd4>)
    e080:	4620      	mov	r0, r4
    e082:	f00b fd28 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    }
    e086:	e7c0      	b.n	e00a <WaveformEditor::DrawAddDelete()+0x2e>
        graphics.print(str);
    e088:	490a      	ldr	r1, [pc, #40]	; (e0b4 <WaveformEditor::DrawAddDelete()+0xd8>)
    e08a:	4802      	ldr	r0, [pc, #8]	; (e094 <WaveformEditor::DrawAddDelete()+0xb8>)
    e08c:	f00b fd23 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    }
    e090:	e7ce      	b.n	e030 <WaveformEditor::DrawAddDelete()+0x54>
    e092:	bf00      	nop
    e094:	200065e0 	.word	0x200065e0
    e098:	00021211 	.word	0x00021211
    e09c:	0002122c 	.word	0x0002122c
    e0a0:	00023d38 	.word	0x00023d38
    e0a4:	00023ec0 	.word	0x00023ec0
    e0a8:	00020f47 	.word	0x00020f47
    e0ac:	00021397 	.word	0x00021397
    e0b0:	0002121f 	.word	0x0002121f
    e0b4:	0002123a 	.word	0x0002123a

0000e0b8 <WaveformEditor::View()>:
    void View() {
    e0b8:	b510      	push	{r4, lr}
    e0ba:	4604      	mov	r4, r0
        gfxHeader("Waveform Editor");
    e0bc:	4906      	ldr	r1, [pc, #24]	; (e0d8 <WaveformEditor::View()+0x20>)
    e0be:	f7f7 fe61 	bl	5d84 <HSApplication::gfxHeader(char const*)>
        if (add_delete_confirm) DrawAddDelete();
    e0c2:	f894 3089 	ldrb.w	r3, [r4, #137]	; 0x89
    e0c6:	4620      	mov	r0, r4
    e0c8:	b113      	cbz	r3, e0d0 <WaveformEditor::View()+0x18>
    e0ca:	f7ff ff87 	bl	dfdc <WaveformEditor::DrawAddDelete()>
    }
    e0ce:	bd10      	pop	{r4, pc}
        else DrawInterface();
    e0d0:	f7ff ff0a 	bl	dee8 <WaveformEditor::DrawInterface()>
    }
    e0d4:	e7fb      	b.n	e0ce <WaveformEditor::View()+0x16>
    e0d6:	bf00      	nop
    e0d8:	00021247 	.word	0x00021247

0000e0dc <WaveformEditor::SwitchWaveform(unsigned char)>:
    void SwitchWaveform(byte waveform_number_) {
    e0dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e0e0:	b093      	sub	sp, #76	; 0x4c
    e0e2:	4604      	mov	r4, r0
        waveform_number = waveform_number_;
    e0e4:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c
        osc = WaveformManager::VectorOscillatorFromWaveform(waveform_number);
    e0e8:	4668      	mov	r0, sp
    e0ea:	f7ff fd05 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
    e0ee:	2246      	movs	r2, #70	; 0x46
    e0f0:	4669      	mov	r1, sp
    e0f2:	f104 0090 	add.w	r0, r4, #144	; 0x90
    e0f6:	f00b ff7b 	bl	19ff0 <memcpy>
        segment_number = 0;
    e0fa:	f104 05d8 	add.w	r5, r4, #216	; 0xd8
    e0fe:	2300      	movs	r3, #0
    e100:	f884 3086 	strb.w	r3, [r4, #134]	; 0x86
        for (byte t = 0; t < 4; t++)
    e104:	f504 76fc 	add.w	r6, r4, #504	; 0x1f8
    e108:	f504 7802 	add.w	r8, r4, #520	; 0x208
    e10c:	462f      	mov	r7, r5
    void SetScale(uint16_t scale_) {scale = scale_;}
    e10e:	f44f 5990 	mov.w	r9, #4608	; 0x1200
            test[t] = WaveformManager::VectorOscillatorFromWaveform(waveform_number);
    e112:	f894 108c 	ldrb.w	r1, [r4, #140]	; 0x8c
    e116:	4668      	mov	r0, sp
    e118:	f7ff fcee 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
    e11c:	2246      	movs	r2, #70	; 0x46
    e11e:	4669      	mov	r1, sp
    e120:	4628      	mov	r0, r5
    e122:	f00b ff65 	bl	19ff0 <memcpy>
    e126:	f8a5 9034 	strh.w	r9, [r5, #52]	; 0x34
            test[t].SetFrequency(test_freq[t]);
    e12a:	f856 1f04 	ldr.w	r1, [r6, #4]!
    e12e:	4628      	mov	r0, r5
    e130:	f7ff fa6a 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
        for (byte t = 0; t < 4; t++)
    e134:	45b0      	cmp	r8, r6
    e136:	f105 0548 	add.w	r5, r5, #72	; 0x48
    e13a:	d1ea      	bne.n	e112 <WaveformEditor::SwitchWaveform(unsigned char)+0x36>
    void Cycle(bool cycle_ = 1) {cycle = cycle_;}
    e13c:	2300      	movs	r3, #0
    void Offset(int32_t offset_) {offset = offset_;}
    e13e:	f44f 6270 	mov.w	r2, #3840	; 0xf00
    void Cycle(bool cycle_ = 1) {cycle = cycle_;}
    e142:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4
    e146:	f884 31ec 	strb.w	r3, [r4, #492]	; 0x1ec
    void Sustain(bool sustain_ = 1) {sustain = sustain_;}
    e14a:	2301      	movs	r3, #1
    void Offset(int32_t offset_) {offset = offset_;}
    e14c:	f8c4 21f0 	str.w	r2, [r4, #496]	; 0x1f0
    void SetScale(uint16_t scale_) {scale = scale_;}
    e150:	f8a4 21e4 	strh.w	r2, [r4, #484]	; 0x1e4
    void Sustain(bool sustain_ = 1) {sustain = sustain_;}
    e154:	f884 31f4 	strb.w	r3, [r4, #500]	; 0x1f4
        for (byte t = 0; t < 4; t++) test[t].Reset();
    e158:	4638      	mov	r0, r7
    e15a:	f7ff fa5e 	bl	d61a <VectorOscillator::Reset()>
    e15e:	f504 7090 	add.w	r0, r4, #288	; 0x120
    e162:	f7ff fa5a 	bl	d61a <VectorOscillator::Reset()>
    e166:	f504 70b4 	add.w	r0, r4, #360	; 0x168
    e16a:	f7ff fa56 	bl	d61a <VectorOscillator::Reset()>
    e16e:	f504 70d8 	add.w	r0, r4, #432	; 0x1b0
    e172:	f7ff fa52 	bl	d61a <VectorOscillator::Reset()>
    }
    e176:	b013      	add	sp, #76	; 0x4c
    e178:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0000e17c <WaveformEditor::Resume()>:
        segment_number = 0;
    e17c:	2300      	movs	r3, #0
    void Resume() {
    e17e:	b510      	push	{r4, lr}
        segment_number = 0;
    e180:	f880 3086 	strb.w	r3, [r0, #134]	; 0x86
    void Resume() {
    e184:	4604      	mov	r4, r0
        waveform_count = WaveformManager::WaveformCount();
    e186:	f7ff fc69 	bl	da5c <WaveformManager::WaveformCount()>
    e18a:	f884 0087 	strb.w	r0, [r4, #135]	; 0x87
        segments_remaining = WaveformManager::SegmentsRemaining();
    e18e:	f7ff fc8d 	bl	daac <WaveformManager::SegmentsRemaining()>
        SwitchWaveform(waveform_number);
    e192:	f894 108c 	ldrb.w	r1, [r4, #140]	; 0x8c
        segments_remaining = WaveformManager::SegmentsRemaining();
    e196:	f884 0088 	strb.w	r0, [r4, #136]	; 0x88
        SwitchWaveform(waveform_number);
    e19a:	4620      	mov	r0, r4
    e19c:	f7ff ff9e 	bl	e0dc <WaveformEditor::SwitchWaveform(unsigned char)>
    }
    e1a0:	bd10      	pop	{r4, pc}
    e1a2:	Address 0x000000000000e1a2 is out of bounds.


0000e1a4 <WaveformEditor_handleAppEvent(OC::AppEvent)>:
    if (event ==  OC::APP_EVENT_RESUME) {
    e1a4:	2801      	cmp	r0, #1
void WaveformEditor_handleAppEvent(OC::AppEvent event) {
    e1a6:	b508      	push	{r3, lr}
    if (event ==  OC::APP_EVENT_RESUME) {
    e1a8:	d103      	bne.n	e1b2 <WaveformEditor_handleAppEvent(OC::AppEvent)+0xe>
        WaveformEditor_instance.Resume();
    e1aa:	4805      	ldr	r0, [pc, #20]	; (e1c0 <WaveformEditor_handleAppEvent(OC::AppEvent)+0x1c>)
    e1ac:	f7ff ffe6 	bl	e17c <WaveformEditor::Resume()>
}
    e1b0:	bd08      	pop	{r3, pc}
    if (event == OC::APP_EVENT_SUSPEND) {
    e1b2:	2800      	cmp	r0, #0
    e1b4:	d1fc      	bne.n	e1b0 <WaveformEditor_handleAppEvent(OC::AppEvent)+0xc>
        WaveformEditor_instance.OnSendSysEx();
    e1b6:	4802      	ldr	r0, [pc, #8]	; (e1c0 <WaveformEditor_handleAppEvent(OC::AppEvent)+0x1c>)
    e1b8:	f7f7 f992 	bl	54e0 <WaveformEditor::OnSendSysEx()>
}
    e1bc:	e7f8      	b.n	e1b0 <WaveformEditor_handleAppEvent(OC::AppEvent)+0xc>
    e1be:	bf00      	nop
    e1c0:	20003450 	.word	0x20003450

0000e1c4 <WaveformEditor::OnRightButtonPress()>:
        if (add_delete_confirm) {
    e1c4:	f890 3089 	ldrb.w	r3, [r0, #137]	; 0x89
    void OnRightButtonPress() {
    e1c8:	b510      	push	{r4, lr}
    e1ca:	4604      	mov	r4, r0
        if (add_delete_confirm) {
    e1cc:	b3c3      	cbz	r3, e240 <WaveformEditor::OnRightButtonPress()+0x7c>
        if (add_waveform) { // ADD
    e1ce:	f890 308a 	ldrb.w	r3, [r0, #138]	; 0x8a
    e1d2:	b1c3      	cbz	r3, e206 <WaveformEditor::OnRightButtonPress()+0x42>
            if (segments_remaining > 2) {
    e1d4:	f890 3088 	ldrb.w	r3, [r0, #136]	; 0x88
    e1d8:	2b02      	cmp	r3, #2
    e1da:	d910      	bls.n	e1fe <WaveformEditor::OnRightButtonPress()+0x3a>
                WaveformManager::AddWaveform();
    e1dc:	f7ff fd20 	bl	dc20 <WaveformManager::AddWaveform()>
                segments_remaining -= 3;
    e1e0:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
                waveform_number = waveform_count;
    e1e4:	f894 1087 	ldrb.w	r1, [r4, #135]	; 0x87
    e1e8:	f8c4 108c 	str.w	r1, [r4, #140]	; 0x8c
                segments_remaining -= 3;
    e1ec:	3b03      	subs	r3, #3
    e1ee:	f884 3088 	strb.w	r3, [r4, #136]	; 0x88
                waveform_count++;
    e1f2:	1c4b      	adds	r3, r1, #1
    e1f4:	f884 3087 	strb.w	r3, [r4, #135]	; 0x87
                SwitchWaveform(waveform_number);
    e1f8:	4620      	mov	r0, r4
    e1fa:	f7ff ff6f 	bl	e0dc <WaveformEditor::SwitchWaveform(unsigned char)>
            add_delete_confirm = 0;
    e1fe:	2300      	movs	r3, #0
    e200:	f884 3089 	strb.w	r3, [r4, #137]	; 0x89
    }
    e204:	bd10      	pop	{r4, pc}
            if (waveform_count > 1) {
    e206:	f890 3087 	ldrb.w	r3, [r0, #135]	; 0x87
    e20a:	2b01      	cmp	r3, #1
    e20c:	d9f7      	bls.n	e1fe <WaveformEditor::OnRightButtonPress()+0x3a>
                WaveformManager::DeleteWaveform(waveform_number);
    e20e:	f890 008c 	ldrb.w	r0, [r0, #140]	; 0x8c
    e212:	f7ff fd37 	bl	dc84 <WaveformManager::DeleteWaveform(unsigned char)>
                waveform_count--;
    e216:	f894 3087 	ldrb.w	r3, [r4, #135]	; 0x87
                if (waveform_number > waveform_count - 1) waveform_number = waveform_count - 1;
    e21a:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
                waveform_count--;
    e21e:	3b01      	subs	r3, #1
    e220:	b2db      	uxtb	r3, r3
                if (waveform_number > waveform_count - 1) waveform_number = waveform_count - 1;
    e222:	4293      	cmp	r3, r2
                waveform_count--;
    e224:	f884 3087 	strb.w	r3, [r4, #135]	; 0x87
                if (waveform_number > waveform_count - 1) waveform_number = waveform_count - 1;
    e228:	bfdc      	itt	le
    e22a:	f103 33ff 	addle.w	r3, r3, #4294967295	; 0xffffffff
    e22e:	f8c4 308c 	strle.w	r3, [r4, #140]	; 0x8c
                segments_remaining = WaveformManager::SegmentsRemaining();
    e232:	f7ff fc3b 	bl	daac <WaveformManager::SegmentsRemaining()>
                SwitchWaveform(waveform_number);
    e236:	f894 108c 	ldrb.w	r1, [r4, #140]	; 0x8c
                segments_remaining = WaveformManager::SegmentsRemaining();
    e23a:	f884 0088 	strb.w	r0, [r4, #136]	; 0x88
                SwitchWaveform(waveform_number);
    e23e:	e7db      	b.n	e1f8 <WaveformEditor::OnRightButtonPress()+0x34>
            cursor = 1 - cursor;
    e240:	f890 3085 	ldrb.w	r3, [r0, #133]	; 0x85
    e244:	f083 0301 	eor.w	r3, r3, #1
    e248:	f880 3085 	strb.w	r3, [r0, #133]	; 0x85
    }
    e24c:	e7da      	b.n	e204 <WaveformEditor::OnRightButtonPress()+0x40>
    e24e:	Address 0x000000000000e24e is out of bounds.


0000e250 <WaveformEditor_handleButtonEvent(UI::Event const&)>:
    if (event.control == OC::CONTROL_BUTTON_L) {
    e250:	8843      	ldrh	r3, [r0, #2]
    e252:	2b04      	cmp	r3, #4
void WaveformEditor_handleButtonEvent(const UI::Event &event) {
    e254:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    e258:	4605      	mov	r5, r0
    if (event.control == OC::CONTROL_BUTTON_L) {
    e25a:	d15b      	bne.n	e314 <WaveformEditor_handleButtonEvent(UI::Event const&)+0xc4>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) WaveformEditor_instance.OnLeftButtonLongPress();
    e25c:	7802      	ldrb	r2, [r0, #0]
        if (add_delete_confirm) {
    e25e:	4c68      	ldr	r4, [pc, #416]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) WaveformEditor_instance.OnLeftButtonLongPress();
    e260:	2a02      	cmp	r2, #2
        if (add_delete_confirm) {
    e262:	f894 3089 	ldrb.w	r3, [r4, #137]	; 0x89
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) WaveformEditor_instance.OnLeftButtonLongPress();
    e266:	f040 8089 	bne.w	e37c <WaveformEditor_handleButtonEvent(UI::Event const&)+0x12c>
        if (add_delete_confirm) {
    e26a:	b363      	cbz	r3, e2c6 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x76>
            add_delete_confirm = 0;
    e26c:	2300      	movs	r3, #0
    e26e:	f884 3089 	strb.w	r3, [r4, #137]	; 0x89
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
    e272:	886b      	ldrh	r3, [r5, #2]
    e274:	2b02      	cmp	r3, #2
    e276:	d123      	bne.n	e2c0 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x70>
        if (event.type == UI::EVENT_BUTTON_PRESS) WaveformEditor_instance.OnDownButtonPress();
    e278:	782b      	ldrb	r3, [r5, #0]
    e27a:	2b01      	cmp	r3, #1
    e27c:	d113      	bne.n	e2a6 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x56>
        byte old = waveform_number;
    e27e:	4a60      	ldr	r2, [pc, #384]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
    e280:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
        waveform_number = constrain(waveform_number - 1, 0, waveform_count - 1);
    e284:	f892 0087 	ldrb.w	r0, [r2, #135]	; 0x87
    e288:	1e59      	subs	r1, r3, #1
    e28a:	f100 80b6 	bmi.w	e3fa <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1aa>
    e28e:	4283      	cmp	r3, r0
    e290:	dd00      	ble.n	e294 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x44>
    e292:	1e41      	subs	r1, r0, #1
        if (old != waveform_number) SwitchWaveform(waveform_number);
    e294:	b2db      	uxtb	r3, r3
    e296:	4299      	cmp	r1, r3
        waveform_number = constrain(waveform_number - 1, 0, waveform_count - 1);
    e298:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
        if (old != waveform_number) SwitchWaveform(waveform_number);
    e29c:	d010      	beq.n	e2c0 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x70>
    e29e:	4858      	ldr	r0, [pc, #352]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
    e2a0:	b2c9      	uxtb	r1, r1
    e2a2:	f7ff ff1b 	bl	e0dc <WaveformEditor::SwitchWaveform(unsigned char)>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) WaveformEditor_instance.OnDownButtonLongPress();
    e2a6:	782b      	ldrb	r3, [r5, #0]
    e2a8:	2b02      	cmp	r3, #2
    e2aa:	d109      	bne.n	e2c0 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x70>
        add_delete_confirm = 1 - add_delete_confirm;
    e2ac:	4b54      	ldr	r3, [pc, #336]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
    e2ae:	f893 2089 	ldrb.w	r2, [r3, #137]	; 0x89
    e2b2:	f082 0201 	eor.w	r2, r2, #1
    e2b6:	f883 2089 	strb.w	r2, [r3, #137]	; 0x89
        add_waveform = 1; // Default to Add
    e2ba:	2201      	movs	r2, #1
    e2bc:	f883 208a 	strb.w	r2, [r3, #138]	; 0x8a
}
    e2c0:	b003      	add	sp, #12
    e2c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (osc.SegmentCount() > 2) { // The segment cannot be deleted if it's the only segment in the waveform...
    e2c6:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
    e2ca:	2b02      	cmp	r3, #2
    e2cc:	d9d1      	bls.n	e272 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x22>
            if (osc.GetSegment(segment_number).time != osc.TotalTime()) {  // ...or if deletion would result in a 0 total time
    e2ce:	f894 6086 	ldrb.w	r6, [r4, #134]	; 0x86
    e2d2:	f104 0090 	add.w	r0, r4, #144	; 0x90
    e2d6:	4631      	mov	r1, r6
    e2d8:	f7ff f890 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
    e2dc:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
    e2e0:	f3c0 2007 	ubfx	r0, r0, #8, #8
    e2e4:	4298      	cmp	r0, r3
    e2e6:	d0c4      	beq.n	e272 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x22>
                WaveformManager::DeleteSegmentFromWaveformAtSegmentIndex(waveform_number, segment_number);
    e2e8:	f894 708c 	ldrb.w	r7, [r4, #140]	; 0x8c
        byte delete_point = GetSegmentIndex(waveform_number, segment_number, -1);
    e2ec:	4631      	mov	r1, r6
    e2ee:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    e2f2:	4638      	mov	r0, r7
    e2f4:	f7ff fc6a 	bl	dbcc <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)>
        if (delete_point) {
    e2f8:	4606      	mov	r6, r0
    e2fa:	bb60      	cbnz	r0, e356 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x106>
                SwitchWaveform(waveform_number);
    e2fc:	4840      	ldr	r0, [pc, #256]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
                byte prev_segment_number = segment_number;
    e2fe:	f894 6086 	ldrb.w	r6, [r4, #134]	; 0x86
                SwitchWaveform(waveform_number);
    e302:	4639      	mov	r1, r7
    e304:	f7ff feea 	bl	e0dc <WaveformEditor::SwitchWaveform(unsigned char)>
                if (segment_number > osc.SegmentCount() - 1) segment_number--;
    e308:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
                segment_number = prev_segment_number;
    e30c:	f884 6086 	strb.w	r6, [r4, #134]	; 0x86
                if (segment_number > osc.SegmentCount() - 1) segment_number--;
    e310:	42b3      	cmp	r3, r6
    e312:	d92f      	bls.n	e374 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x124>
    if (event.control == OC::CONTROL_BUTTON_R && event.type == UI::EVENT_BUTTON_PRESS) WaveformEditor_instance.OnRightButtonPress();
    e314:	886b      	ldrh	r3, [r5, #2]
    e316:	2b08      	cmp	r3, #8
    e318:	d105      	bne.n	e326 <WaveformEditor_handleButtonEvent(UI::Event const&)+0xd6>
    e31a:	782b      	ldrb	r3, [r5, #0]
    e31c:	2b01      	cmp	r3, #1
    e31e:	d1cf      	bne.n	e2c0 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x70>
    e320:	4837      	ldr	r0, [pc, #220]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
    e322:	f7ff ff4f 	bl	e1c4 <WaveformEditor::OnRightButtonPress()>
    if (event.control == OC::CONTROL_BUTTON_UP) WaveformEditor_instance.OnUpButtonPress();
    e326:	886b      	ldrh	r3, [r5, #2]
    e328:	2b01      	cmp	r3, #1
    e32a:	d1a2      	bne.n	e272 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x22>
        byte old = waveform_number;
    e32c:	4a34      	ldr	r2, [pc, #208]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
    e32e:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
        waveform_number = constrain(waveform_number + 1, 0, waveform_count - 1);
    e332:	f892 1087 	ldrb.w	r1, [r2, #135]	; 0x87
    e336:	1c58      	adds	r0, r3, #1
    e338:	d45d      	bmi.n	e3f6 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1a6>
    e33a:	3901      	subs	r1, #1
    e33c:	4281      	cmp	r1, r0
    e33e:	bfa8      	it	ge
    e340:	4601      	movge	r1, r0
        if (old != waveform_number) SwitchWaveform(waveform_number);
    e342:	b2db      	uxtb	r3, r3
    e344:	4299      	cmp	r1, r3
        waveform_number = constrain(waveform_number + 1, 0, waveform_count - 1);
    e346:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
        if (old != waveform_number) SwitchWaveform(waveform_number);
    e34a:	d0b9      	beq.n	e2c0 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x70>
    e34c:	482c      	ldr	r0, [pc, #176]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
    e34e:	b2c9      	uxtb	r1, r1
    e350:	f7ff fec4 	bl	e0dc <WaveformEditor::SwitchWaveform(unsigned char)>
    e354:	e78d      	b.n	e272 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x22>
    e356:	b203      	sxth	r3, r0
    e358:	482a      	ldr	r0, [pc, #168]	; (e404 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b4>)
    e35a:	eb00 0043 	add.w	r0, r0, r3, lsl #1
            for (int i = delete_point; i < (HS::VO_SEGMENT_COUNT - 1); i++)
    e35e:	2e3e      	cmp	r6, #62	; 0x3e
    e360:	f100 0802 	add.w	r8, r0, #2
    e364:	dcca      	bgt.n	e2fc <WaveformEditor_handleButtonEvent(UI::Event const&)+0xac>
                memcpy(&HS::user_waveforms[i], &HS::user_waveforms[i + 1], sizeof(HS::user_waveforms[i + 1]));
    e366:	2202      	movs	r2, #2
    e368:	4641      	mov	r1, r8
    e36a:	f00b fe41 	bl	19ff0 <memcpy>
    e36e:	3601      	adds	r6, #1
    e370:	4640      	mov	r0, r8
    e372:	e7f4      	b.n	e35e <WaveformEditor_handleButtonEvent(UI::Event const&)+0x10e>
                if (segment_number > osc.SegmentCount() - 1) segment_number--;
    e374:	3e01      	subs	r6, #1
    e376:	f884 6086 	strb.w	r6, [r4, #134]	; 0x86
    e37a:	e7cb      	b.n	e314 <WaveformEditor_handleButtonEvent(UI::Event const&)+0xc4>
        if (add_delete_confirm) {
    e37c:	2b00      	cmp	r3, #0
    e37e:	f47f af75 	bne.w	e26c <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1c>
        if (segments_remaining < HS::VO_SEGMENT_COUNT && osc.SegmentCount() < HS::VO_MAX_SEGMENTS) {
    e382:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
    e386:	2b3f      	cmp	r3, #63	; 0x3f
    e388:	f63f af73 	bhi.w	e272 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x22>
    e38c:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
    e390:	2b0b      	cmp	r3, #11
    e392:	f63f af6e 	bhi.w	e272 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x22>
            WaveformManager::AddSegmentToWaveformAtSegmentIndex(waveform_number, segment_number);
    e396:	f894 708c 	ldrb.w	r7, [r4, #140]	; 0x8c
        byte insert_point = GetSegmentIndex(waveform_number, segment_number, 1);
    e39a:	f894 1086 	ldrb.w	r1, [r4, #134]	; 0x86
    e39e:	2201      	movs	r2, #1
    e3a0:	4638      	mov	r0, r7
    e3a2:	f7ff fc13 	bl	dbcc <WaveformManager::GetSegmentIndex(unsigned char, unsigned char, signed char)>
        if (insert_point) {
    e3a6:	4606      	mov	r6, r0
    e3a8:	b170      	cbz	r0, e3c8 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x178>
    e3aa:	4817      	ldr	r0, [pc, #92]	; (e408 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b8>)
            for (int i = (HS::VO_SEGMENT_COUNT - 1); i > insert_point ; i--)
    e3ac:	f04f 083f 	mov.w	r8, #63	; 0x3f
    e3b0:	45b0      	cmp	r8, r6
    e3b2:	f1a0 0902 	sub.w	r9, r0, #2
    e3b6:	dc16      	bgt.n	e3e6 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x196>
            if (HS::user_waveforms[insert_point + 1].time == 0) HS::user_waveforms[insert_point + 1].time = 1;
    e3b8:	4b12      	ldr	r3, [pc, #72]	; (e404 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b4>)
    e3ba:	3601      	adds	r6, #1
    e3bc:	eb03 0346 	add.w	r3, r3, r6, lsl #1
    e3c0:	785a      	ldrb	r2, [r3, #1]
    e3c2:	b90a      	cbnz	r2, e3c8 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x178>
    e3c4:	2201      	movs	r2, #1
    e3c6:	705a      	strb	r2, [r3, #1]
            SwitchWaveform(waveform_number);
    e3c8:	480d      	ldr	r0, [pc, #52]	; (e400 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x1b0>)
            byte prev_segment_number = segment_number;
    e3ca:	f894 6086 	ldrb.w	r6, [r4, #134]	; 0x86
            SwitchWaveform(waveform_number);
    e3ce:	4639      	mov	r1, r7
    e3d0:	f7ff fe84 	bl	e0dc <WaveformEditor::SwitchWaveform(unsigned char)>
            --segments_remaining;
    e3d4:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
            segment_number = prev_segment_number + 1;
    e3d8:	3601      	adds	r6, #1
            --segments_remaining;
    e3da:	3b01      	subs	r3, #1
            segment_number = prev_segment_number + 1;
    e3dc:	f884 6086 	strb.w	r6, [r4, #134]	; 0x86
            --segments_remaining;
    e3e0:	f884 3088 	strb.w	r3, [r4, #136]	; 0x88
    e3e4:	e796      	b.n	e314 <WaveformEditor_handleButtonEvent(UI::Event const&)+0xc4>
                memcpy(&HS::user_waveforms[i], &HS::user_waveforms[i - 1], sizeof(HS::user_waveforms[i - 1]));
    e3e6:	2202      	movs	r2, #2
    e3e8:	4649      	mov	r1, r9
    e3ea:	f00b fe01 	bl	19ff0 <memcpy>
    e3ee:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    e3f2:	4648      	mov	r0, r9
    e3f4:	e7dc      	b.n	e3b0 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x160>
        waveform_number = constrain(waveform_number + 1, 0, waveform_count - 1);
    e3f6:	2100      	movs	r1, #0
    e3f8:	e7a3      	b.n	e342 <WaveformEditor_handleButtonEvent(UI::Event const&)+0xf2>
        waveform_number = constrain(waveform_number - 1, 0, waveform_count - 1);
    e3fa:	2100      	movs	r1, #0
    e3fc:	e74a      	b.n	e294 <WaveformEditor_handleButtonEvent(UI::Event const&)+0x44>
    e3fe:	bf00      	nop
    e400:	20003450 	.word	0x20003450
    e404:	20003668 	.word	0x20003668
    e408:	200036e6 	.word	0x200036e6

0000e40c <ADEG::DrawIndicator()>:
    void DrawIndicator() {
    e40c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e410:	f8d0 408c 	ldr.w	r4, [r0, #140]	; 0x8c
    e414:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
    e418:	22ff      	movs	r2, #255	; 0xff
    e41a:	03a4      	lsls	r4, r4, #14
    e41c:	fb94 f4f2 	sdiv	r4, r4, r2
        int scaled = simfloat2int(proportion * max_value);
    e420:	ebc4 1444 	rsb	r4, r4, r4, lsl #5
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e424:	039b      	lsls	r3, r3, #14
        int scaled = simfloat2int(proportion * max_value);
    e426:	13a4      	asrs	r4, r4, #14
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e428:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    e42c:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
        int d_x = a_x + Proportion(decay, HEM_ADEG_MAX_VALUE, 31);
    e430:	eb04 34a3 	add.w	r4, r4, r3, asr #14
        if (d_x > 0) { // Stretch to use the whole viewport
    e434:	2c00      	cmp	r4, #0
    void DrawIndicator() {
    e436:	4605      	mov	r5, r0
    e438:	ea4f 36a3 	mov.w	r6, r3, asr #14
        if (d_x > 0) { // Stretch to use the whole viewport
    e43c:	dd07      	ble.n	e44e <ADEG::DrawIndicator()+0x42>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e43e:	f44f 2378 	mov.w	r3, #1015808	; 0xf8000
    e442:	fb93 f3f4 	sdiv	r3, r3, r4
        int scaled = simfloat2int(proportion * max_value);
    e446:	435e      	muls	r6, r3
    e448:	4363      	muls	r3, r4
    e44a:	13b6      	asrs	r6, r6, #14
    e44c:	139c      	asrs	r4, r3, #14
        gfxLine(0, 62, a_x, 33, cursor == 1);
    e44e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    e450:	69a8      	ldr	r0, [r5, #24]
    e452:	1e5a      	subs	r2, r3, #1
    e454:	4253      	negs	r3, r2
    e456:	4153      	adcs	r3, r2
    e458:	f04f 0821 	mov.w	r8, #33	; 0x21
    e45c:	9301      	str	r3, [sp, #4]
    e45e:	223e      	movs	r2, #62	; 0x3e
    e460:	4633      	mov	r3, r6
    e462:	2100      	movs	r1, #0
    e464:	f8cd 8000 	str.w	r8, [sp]
    e468:	f7f6 fab4 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        gfxLine(a_x, 33, d_x, 62, cursor == 0);
    e46c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    e46e:	69a8      	ldr	r0, [r5, #24]
    e470:	fab3 f383 	clz	r3, r3
    e474:	095b      	lsrs	r3, r3, #5
    e476:	273e      	movs	r7, #62	; 0x3e
    e478:	4642      	mov	r2, r8
    e47a:	9301      	str	r3, [sp, #4]
    e47c:	4631      	mov	r1, r6
    e47e:	4623      	mov	r3, r4
    e480:	9700      	str	r7, [sp, #0]
    e482:	f7f6 faa7 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        gfxRect(1, 15, ProportionCV(ViewOut(0), 62), 6);
    e486:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    e488:	4639      	mov	r1, r7
    e48a:	f7f6 f8eb 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
    e48e:	2206      	movs	r2, #6
    e490:	4603      	mov	r3, r0
    e492:	9200      	str	r2, [sp, #0]
    e494:	69a8      	ldr	r0, [r5, #24]
    e496:	220f      	movs	r2, #15
    e498:	2101      	movs	r1, #1
    e49a:	f7f6 fab1 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        if (OC::CORE::ticks - last_change_ticks < 20000) {
    e49e:	4b0c      	ldr	r3, [pc, #48]	; (e4d0 <ADEG::DrawIndicator()+0xc4>)
    e4a0:	6fea      	ldr	r2, [r5, #124]	; 0x7c
    e4a2:	681b      	ldr	r3, [r3, #0]
    e4a4:	1a9b      	subs	r3, r3, r2
    e4a6:	f644 621f 	movw	r2, #19999	; 0x4e1f
    e4aa:	4293      	cmp	r3, r2
    e4ac:	d80c      	bhi.n	e4c8 <ADEG::DrawIndicator()+0xbc>
            gfxPrint(15, 43, last_ms_value);
    e4ae:	69a8      	ldr	r0, [r5, #24]
    e4b0:	6fab      	ldr	r3, [r5, #120]	; 0x78
    e4b2:	222b      	movs	r2, #43	; 0x2b
    e4b4:	210f      	movs	r1, #15
    e4b6:	f7f6 fadb 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        graphics.print(str);
    e4ba:	4906      	ldr	r1, [pc, #24]	; (e4d4 <ADEG::DrawIndicator()+0xc8>)
    e4bc:	4806      	ldr	r0, [pc, #24]	; (e4d8 <ADEG::DrawIndicator()+0xcc>)
    }
    e4be:	b002      	add	sp, #8
    e4c0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    e4c4:	f00b bb07 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
    e4c8:	b002      	add	sp, #8
    e4ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e4ce:	bf00      	nop
    e4d0:	200046cc 	.word	0x200046cc
    e4d4:	0001f236 	.word	0x0001f236
    e4d8:	200065e0 	.word	0x200065e0

0000e4dc <ADEG::View()>:
        gfxHeader(applet_name());
    e4dc:	6803      	ldr	r3, [r0, #0]
    void View() {
    e4de:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    e4e0:	681b      	ldr	r3, [r3, #0]
    void View() {
    e4e2:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    e4e4:	4798      	blx	r3
    e4e6:	4601      	mov	r1, r0
    e4e8:	4620      	mov	r0, r4
    e4ea:	f7fa f888 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawIndicator();
    e4ee:	4620      	mov	r0, r4
    e4f0:	f7ff ff8c 	bl	e40c <ADEG::DrawIndicator()>
    }
    e4f4:	bd10      	pop	{r4, pc}

0000e4f6 <ADSREG::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
    e4f6:	b5f0      	push	{r4, r5, r6, r7, lr}
        attack = Unpack(data, PackLocation {0,8});
    e4f8:	2300      	movs	r3, #0
    e4fa:	2608      	movs	r6, #8
    void OnDataReceive(uint32_t data) {
    e4fc:	460d      	mov	r5, r1
    e4fe:	b089      	sub	sp, #36	; 0x24
    e500:	4604      	mov	r4, r0
        attack = Unpack(data, PackLocation {0,8});
    e502:	4619      	mov	r1, r3
    e504:	4632      	mov	r2, r6
    e506:	4628      	mov	r0, r5
    e508:	e9cd 3600 	strd	r3, r6, [sp]
    e50c:	f7f5 fc90 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        decay = Unpack(data, PackLocation {8,8});
    e510:	4632      	mov	r2, r6
        attack = Unpack(data, PackLocation {0,8});
    e512:	6720      	str	r0, [r4, #112]	; 0x70
        decay = Unpack(data, PackLocation {8,8});
    e514:	4631      	mov	r1, r6
        attack = Unpack(data, PackLocation {0,8});
    e516:	4607      	mov	r7, r0
        decay = Unpack(data, PackLocation {8,8});
    e518:	4628      	mov	r0, r5
    e51a:	e9cd 6602 	strd	r6, r6, [sp, #8]
    e51e:	f7f5 fc87 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        sustain = Unpack(data, PackLocation {16,8});
    e522:	2310      	movs	r3, #16
    e524:	4619      	mov	r1, r3
        decay = Unpack(data, PackLocation {8,8});
    e526:	6760      	str	r0, [r4, #116]	; 0x74
        sustain = Unpack(data, PackLocation {16,8});
    e528:	4632      	mov	r2, r6
    e52a:	4628      	mov	r0, r5
    e52c:	e9cd 3604 	strd	r3, r6, [sp, #16]
    e530:	f7f5 fc7e 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        release = Unpack(data, PackLocation {24,8});
    e534:	2318      	movs	r3, #24
    e536:	e9cd 3606 	strd	r3, r6, [sp, #24]
    e53a:	ab08      	add	r3, sp, #32
        sustain = Unpack(data, PackLocation {16,8});
    e53c:	67a0      	str	r0, [r4, #120]	; 0x78
        release = Unpack(data, PackLocation {24,8});
    e53e:	e913 0006 	ldmdb	r3, {r1, r2}
    e542:	4628      	mov	r0, r5
    e544:	f7f5 fc74 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    e548:	67e0      	str	r0, [r4, #124]	; 0x7c
        if (attack == 0) Start(); // If empty data, initialize
    e54a:	b937      	cbnz	r7, e55a <ADSREG::OnDataReceive(unsigned long)+0x64>
    e54c:	6823      	ldr	r3, [r4, #0]
    e54e:	685b      	ldr	r3, [r3, #4]
    e550:	4620      	mov	r0, r4
    }
    e552:	b009      	add	sp, #36	; 0x24
    e554:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        if (attack == 0) Start(); // If empty data, initialize
    e558:	4718      	bx	r3
    }
    e55a:	b009      	add	sp, #36	; 0x24
    e55c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e55e:	Address 0x000000000000e55e is out of bounds.


0000e560 <ADSREG_OnDataReceive(bool, unsigned long)>:

void ADSREG_OnDataReceive(bool hemisphere, uint32_t data) {
    e560:	b508      	push	{r3, lr}
    ADSREG_instance[hemisphere].OnDataReceive(data);
    e562:	4b03      	ldr	r3, [pc, #12]	; (e570 <ADSREG_OnDataReceive(bool, unsigned long)+0x10>)
    e564:	22a4      	movs	r2, #164	; 0xa4
    e566:	fb02 3000 	mla	r0, r2, r0, r3
    e56a:	f7ff ffc4 	bl	e4f6 <ADSREG::OnDataReceive(unsigned long)>
}
    e56e:	bd08      	pop	{r3, pc}
    e570:	1fffa9e8 	.word	0x1fffa9e8

0000e574 <ADSREG::DrawADSR()>:
    void DrawADSR() {
    e574:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        int length = attack + decay + release + HEM_SUSTAIN_CONST; // Sustain is constant because it's a level
    e578:	6f06      	ldr	r6, [r0, #112]	; 0x70
    e57a:	6f47      	ldr	r7, [r0, #116]	; 0x74
    e57c:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
    e57e:	4437      	add	r7, r6
    e580:	441f      	add	r7, r3
        gfxLine(x, BottomAlign(0), xA, BottomAlign(HEM_EG_DISPLAY_HEIGHT), edit_stage != HEM_EG_ATTACK);
    e582:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
        int scaled = simfloat2int(proportion * max_value);
    e584:	f04f 083e 	mov.w	r8, #62	; 0x3e
    e588:	3b00      	subs	r3, #0
        int length = attack + decay + release + HEM_SUSTAIN_CONST; // Sustain is constant because it's a level
    e58a:	f107 0723 	add.w	r7, r7, #35	; 0x23
        gfxLine(x, BottomAlign(0), xA, BottomAlign(HEM_EG_DISPLAY_HEIGHT), edit_stage != HEM_EG_ATTACK);
    e58e:	bf18      	it	ne
    e590:	2301      	movne	r3, #1
    e592:	f04f 0b20 	mov.w	fp, #32
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e596:	03b6      	lsls	r6, r6, #14
    e598:	fb96 f6f7 	sdiv	r6, r6, r7
        int scaled = simfloat2int(proportion * max_value);
    e59c:	fb08 f606 	mul.w	r6, r8, r6
    void DrawADSR() {
    e5a0:	4604      	mov	r4, r0
    e5a2:	13b6      	asrs	r6, r6, #14
        gfxLine(x, BottomAlign(0), xA, BottomAlign(HEM_EG_DISPLAY_HEIGHT), edit_stage != HEM_EG_ATTACK);
    e5a4:	9301      	str	r3, [sp, #4]
    e5a6:	f8cd b000 	str.w	fp, [sp]
    e5aa:	4633      	mov	r3, r6
    e5ac:	4642      	mov	r2, r8
    e5ae:	6980      	ldr	r0, [r0, #24]
    e5b0:	2100      	movs	r1, #0
    e5b2:	f7f6 fa0f 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        gfxLine(x, BottomAlign(HEM_EG_DISPLAY_HEIGHT), xD, BottomAlign(yS), edit_stage != HEM_EG_DECAY);
    e5b6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e5b8:	6f65      	ldr	r5, [r4, #116]	; 0x74
    e5ba:	69a0      	ldr	r0, [r4, #24]
    e5bc:	3b01      	subs	r3, #1
    e5be:	bf18      	it	ne
    e5c0:	2301      	movne	r3, #1
    e5c2:	9301      	str	r3, [sp, #4]
    e5c4:	6fa3      	ldr	r3, [r4, #120]	; 0x78
        int scaled = simfloat2int(proportion * max_value);
    e5c6:	f04f 091e 	mov.w	r9, #30
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e5ca:	f04f 0aff 	mov.w	sl, #255	; 0xff
    e5ce:	03ad      	lsls	r5, r5, #14
    e5d0:	039b      	lsls	r3, r3, #14
    e5d2:	fb95 f5f7 	sdiv	r5, r5, r7
    e5d6:	fb93 f3fa 	sdiv	r3, r3, sl
        int scaled = simfloat2int(proportion * max_value);
    e5da:	fb08 f505 	mul.w	r5, r8, r5
    e5de:	fb09 f303 	mul.w	r3, r9, r3
        int xD = x + Proportion(decay, length, 62);
    e5e2:	eb06 35a5 	add.w	r5, r6, r5, asr #14
    e5e6:	139b      	asrs	r3, r3, #14
    e5e8:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
        gfxLine(x, BottomAlign(HEM_EG_DISPLAY_HEIGHT), xD, BottomAlign(yS), edit_stage != HEM_EG_DECAY);
    e5ec:	eba8 0303 	sub.w	r3, r8, r3
    e5f0:	9300      	str	r3, [sp, #0]
    e5f2:	465a      	mov	r2, fp
    e5f4:	462b      	mov	r3, r5
    e5f6:	4631      	mov	r1, r6
    e5f8:	f7f6 f9ec 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e5fc:	6fa2      	ldr	r2, [r4, #120]	; 0x78
        gfxLine(x, BottomAlign(yS), xS, BottomAlign(yS), edit_stage != HEM_EG_SUSTAIN);
    e5fe:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    e600:	69a0      	ldr	r0, [r4, #24]
    e602:	0392      	lsls	r2, r2, #14
    e604:	fb92 f2fa 	sdiv	r2, r2, sl
        int scaled = simfloat2int(proportion * max_value);
    e608:	fb09 f202 	mul.w	r2, r9, r2
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e60c:	f44f 260c 	mov.w	r6, #573440	; 0x8c000
        int scaled = simfloat2int(proportion * max_value);
    e610:	1392      	asrs	r2, r2, #14
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e612:	fb96 f6f7 	sdiv	r6, r6, r7
        int scaled = simfloat2int(proportion * max_value);
    e616:	fb08 f606 	mul.w	r6, r8, r6
    e61a:	3b02      	subs	r3, #2
        int xS = x + Proportion(HEM_SUSTAIN_CONST, length, 62);
    e61c:	eb05 36a6 	add.w	r6, r5, r6, asr #14
        gfxLine(x, BottomAlign(yS), xS, BottomAlign(yS), edit_stage != HEM_EG_SUSTAIN);
    e620:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    e624:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
    e628:	eba8 0202 	sub.w	r2, r8, r2
    e62c:	bf18      	it	ne
    e62e:	2301      	movne	r3, #1
    e630:	e9cd 2300 	strd	r2, r3, [sp]
    e634:	4629      	mov	r1, r5
    e636:	4633      	mov	r3, r6
    e638:	f7f6 f9cc 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e63c:	6fa2      	ldr	r2, [r4, #120]	; 0x78
        gfxLine(x, BottomAlign(yS), xR, BottomAlign(0), edit_stage != HEM_EG_RELEASE);
    e63e:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    e640:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    e642:	69a0      	ldr	r0, [r4, #24]
    e644:	f8cd 8000 	str.w	r8, [sp]
    e648:	3903      	subs	r1, #3
    e64a:	ea4f 3282 	mov.w	r2, r2, lsl #14
    e64e:	fb92 f2fa 	sdiv	r2, r2, sl
        int scaled = simfloat2int(proportion * max_value);
    e652:	fb09 f202 	mul.w	r2, r9, r2
    e656:	bf18      	it	ne
    e658:	2101      	movne	r1, #1
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e65a:	039b      	lsls	r3, r3, #14
        int scaled = simfloat2int(proportion * max_value);
    e65c:	1392      	asrs	r2, r2, #14
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e65e:	fb93 f3f7 	sdiv	r3, r3, r7
        int scaled = simfloat2int(proportion * max_value);
    e662:	fb08 f303 	mul.w	r3, r8, r3
    e666:	9101      	str	r1, [sp, #4]
    e668:	eb06 33a3 	add.w	r3, r6, r3, asr #14
    e66c:	eba8 0202 	sub.w	r2, r8, r2
    e670:	4631      	mov	r1, r6
    e672:	f7f6 f9af 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
    }
    e676:	b003      	add	sp, #12
    e678:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000e67c <ADSREG::View()>:
        gfxHeader(applet_name());
    e67c:	6803      	ldr	r3, [r0, #0]
    void View() {
    e67e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        gfxHeader(applet_name());
    e682:	681b      	ldr	r3, [r3, #0]
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e684:	f8df 8058 	ldr.w	r8, [pc, #88]	; e6e0 <ADSREG::View()+0x64>
    void View() {
    e688:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    e68a:	4798      	blx	r3
    e68c:	4601      	mov	r1, r0
    e68e:	4620      	mov	r0, r4
    e690:	f7f9 ffb5 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
    e694:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
            gfxRect(0, 15 + (ch * 10), w, 6);
    e698:	69a0      	ldr	r0, [r4, #24]
        int scaled = simfloat2int(proportion * max_value);
    e69a:	263e      	movs	r6, #62	; 0x3e
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e69c:	f44f 57f0 	mov.w	r7, #7680	; 0x1e00
    e6a0:	2506      	movs	r5, #6
    e6a2:	ea03 0308 	and.w	r3, r3, r8
    e6a6:	fb93 f3f7 	sdiv	r3, r3, r7
        int scaled = simfloat2int(proportion * max_value);
    e6aa:	4373      	muls	r3, r6
    e6ac:	9500      	str	r5, [sp, #0]
    e6ae:	139b      	asrs	r3, r3, #14
    e6b0:	220f      	movs	r2, #15
    e6b2:	2100      	movs	r1, #0
    e6b4:	f7f6 f9a4 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e6b8:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    e6bc:	69a0      	ldr	r0, [r4, #24]
    e6be:	9500      	str	r5, [sp, #0]
    e6c0:	ea03 0308 	and.w	r3, r3, r8
    e6c4:	fb93 f3f7 	sdiv	r3, r3, r7
        int scaled = simfloat2int(proportion * max_value);
    e6c8:	4373      	muls	r3, r6
    e6ca:	139b      	asrs	r3, r3, #14
    e6cc:	2219      	movs	r2, #25
    e6ce:	2100      	movs	r1, #0
    e6d0:	f7f6 f996 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        DrawADSR();
    e6d4:	4620      	mov	r0, r4
    e6d6:	f7ff ff4d 	bl	e574 <ADSREG::DrawADSR()>
    }
    e6da:	b002      	add	sp, #8
    e6dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e6e0:	ffffc000 	.word	0xffffc000

0000e6e4 <ADSREG::AttackAmplitude(int)>:
        int effective_attack = constrain(attack + attack_mod, 1, HEM_EG_MAX_VALUE);
    e6e4:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
    e6e8:	6f03      	ldr	r3, [r0, #112]	; 0x70
    e6ea:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    e6ee:	4413      	add	r3, r2
        if (effective_attack == 1) ticks_remaining = 0;
    e6f0:	2b01      	cmp	r3, #1
        int ticks_remaining = total_stage_ticks - stage_ticks[ch];
    e6f2:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
        if (effective_attack == 1) ticks_remaining = 0;
    e6f6:	dd0d      	ble.n	e714 <ADSREG::AttackAmplitude(int)+0x30>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    e6f8:	2bff      	cmp	r3, #255	; 0xff
    e6fa:	bfa8      	it	ge
    e6fc:	23ff      	movge	r3, #255	; 0xff
    e6fe:	21ff      	movs	r1, #255	; 0xff
    e700:	039b      	lsls	r3, r3, #14
    e702:	fbb3 f3f1 	udiv	r3, r3, r1
        int scaled = simfloat2int(proportion * max_value);
    e706:	f248 2135 	movw	r1, #33333	; 0x8235
    e70a:	434b      	muls	r3, r1
        int ticks_remaining = total_stage_ticks - stage_ticks[ch];
    e70c:	ebc2 32a3 	rsb	r2, r2, r3, asr #14
        if (ticks_remaining <= 0) { // End of attack; move to decay
    e710:	2a00      	cmp	r2, #0
    e712:	dc0a      	bgt.n	e72a <ADSREG::AttackAmplitude(int)+0x46>
            stage[ch] = HEM_EG_DECAY;
    e714:	2301      	movs	r3, #1
    e716:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
            stage_ticks[ch] = 0;
    e71a:	2300      	movs	r3, #0
    e71c:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
            amplitude[ch] = int2simfloat(HEMISPHERE_MAX_CV);
    e720:	f04f 63f0 	mov.w	r3, #125829120	; 0x7800000
    e724:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    }
    e728:	4770      	bx	lr
            simfloat amplitude_remaining = int2simfloat(HEMISPHERE_MAX_CV) - amplitude[ch];
    e72a:	f8d0 109c 	ldr.w	r1, [r0, #156]	; 0x9c
    e72e:	f1c1 63f0 	rsb	r3, r1, #125829120	; 0x7800000
            simfloat increase = amplitude_remaining / ticks_remaining;
    e732:	fb93 f3f2 	sdiv	r3, r3, r2
            amplitude[ch] += increase;
    e736:	440b      	add	r3, r1
    e738:	e7f4      	b.n	e724 <ADSREG::AttackAmplitude(int)+0x40>
    e73a:	Address 0x000000000000e73a is out of bounds.


0000e73c <RingBufferManager::IsLinked(bool)>:
        uint32_t t = OC::CORE::ticks;
    e73c:	4b09      	ldr	r3, [pc, #36]	; (e764 <RingBufferManager::IsLinked(bool)+0x28>)
    bool IsLinked(bool hemisphere) {
    e73e:	4602      	mov	r2, r0
        uint32_t t = OC::CORE::ticks;
    e740:	681b      	ldr	r3, [r3, #0]
                && (t - registered[RIGHT_HEMISPHERE] < 160));
    e742:	4608      	mov	r0, r1
    e744:	b169      	cbz	r1, e762 <RingBufferManager::IsLinked(bool)+0x26>
                && (t - registered[LEFT_HEMISPHERE] < 160)
    e746:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    e74a:	1a59      	subs	r1, r3, r1
    e74c:	299f      	cmp	r1, #159	; 0x9f
    e74e:	d807      	bhi.n	e760 <RingBufferManager::IsLinked(bool)+0x24>
                && (t - registered[RIGHT_HEMISPHERE] < 160));
    e750:	f8d2 2408 	ldr.w	r2, [r2, #1032]	; 0x408
    e754:	1a9b      	subs	r3, r3, r2
    e756:	2b9f      	cmp	r3, #159	; 0x9f
    e758:	bf8c      	ite	hi
    e75a:	2000      	movhi	r0, #0
    e75c:	2001      	movls	r0, #1
    e75e:	4770      	bx	lr
    e760:	2000      	movs	r0, #0
    }
    e762:	4770      	bx	lr
    e764:	200046cc 	.word	0x200046cc

0000e768 <ASR::DrawInterface()>:
    void DrawInterface() {
    e768:	b537      	push	{r0, r1, r2, r4, r5, lr}
        if (buffer_m->IsLinked(hemisphere)) gfxIcon(56, 1, LINK_ICON);
    e76a:	7901      	ldrb	r1, [r0, #4]
    void DrawInterface() {
    e76c:	4604      	mov	r4, r0
        if (buffer_m->IsLinked(hemisphere)) gfxIcon(56, 1, LINK_ICON);
    e76e:	6f00      	ldr	r0, [r0, #112]	; 0x70
    e770:	f7ff ffe4 	bl	e73c <RingBufferManager::IsLinked(bool)>
    e774:	b128      	cbz	r0, e782 <ASR::DrawInterface()+0x1a>
    e776:	4b24      	ldr	r3, [pc, #144]	; (e808 <ASR::DrawInterface()+0xa0>)
    e778:	69a0      	ldr	r0, [r4, #24]
    e77a:	2201      	movs	r2, #1
    e77c:	2138      	movs	r1, #56	; 0x38
    e77e:	f7f6 f90f 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
    byte GetIndex() {return index;}
    e782:	6f22      	ldr	r2, [r4, #112]	; 0x70
        byte ix = buffer_m->GetIndex() + index_mod;
    e784:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    e788:	f892 5401 	ldrb.w	r5, [r2, #1025]	; 0x401
    e78c:	441d      	add	r5, r3
        gfxPrint(1, 15, "Index: ");
    e78e:	220f      	movs	r2, #15
    e790:	4b1e      	ldr	r3, [pc, #120]	; (e80c <ASR::DrawInterface()+0xa4>)
        byte ix = buffer_m->GetIndex() + index_mod;
    e792:	b2ed      	uxtb	r5, r5
        gfxPrint(1, 15, "Index: ");
    e794:	2101      	movs	r1, #1
    e796:	4620      	mov	r0, r4
    e798:	f7f9 fea6 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(pad(100, ix), ix);
    e79c:	4629      	mov	r1, r5
    e79e:	2064      	movs	r0, #100	; 0x64
    e7a0:	f7f5 ff6f 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    e7a4:	4629      	mov	r1, r5
    e7a6:	f7f6 f947 	bl	4a38 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]>
        if (index_mod != 0) gfxIcon(54, 26, CV_ICON);
    e7aa:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    e7ae:	b12b      	cbz	r3, e7bc <ASR::DrawInterface()+0x54>
    e7b0:	4b17      	ldr	r3, [pc, #92]	; (e810 <ASR::DrawInterface()+0xa8>)
    e7b2:	69a0      	ldr	r0, [r4, #24]
    e7b4:	221a      	movs	r2, #26
    e7b6:	2136      	movs	r1, #54	; 0x36
    e7b8:	f7f6 f8f2 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxBitmap(1, 24, 8, SCALE_ICON);
    e7bc:	4b15      	ldr	r3, [pc, #84]	; (e814 <ASR::DrawInterface()+0xac>)
    e7be:	69a0      	ldr	r0, [r4, #24]
    e7c0:	9300      	str	r3, [sp, #0]
    e7c2:	2218      	movs	r2, #24
    e7c4:	2308      	movs	r3, #8
    e7c6:	2101      	movs	r1, #1
    e7c8:	f7f6 f8e4 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(12, 25, OC::scale_names_short[scale]);
    e7cc:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
    e7d0:	4b11      	ldr	r3, [pc, #68]	; (e818 <ASR::DrawInterface()+0xb0>)
    e7d2:	210c      	movs	r1, #12
    e7d4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    e7d8:	4620      	mov	r0, r4
    e7da:	2219      	movs	r2, #25
    e7dc:	f7f9 fe84 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor == 0) gfxCursor(43, 23, 18); // Index Cursor
    e7e0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    e7e2:	b92b      	cbnz	r3, e7f0 <ASR::DrawInterface()+0x88>
    e7e4:	2312      	movs	r3, #18
    e7e6:	2217      	movs	r2, #23
    e7e8:	212b      	movs	r1, #43	; 0x2b
    e7ea:	4620      	mov	r0, r4
    e7ec:	f7f9 fe70 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 1) gfxCursor(13, 33, 30); // Scale Cursor
    e7f0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    e7f2:	2b01      	cmp	r3, #1
    e7f4:	d105      	bne.n	e802 <ASR::DrawInterface()+0x9a>
    e7f6:	231e      	movs	r3, #30
    e7f8:	2221      	movs	r2, #33	; 0x21
    e7fa:	210d      	movs	r1, #13
    e7fc:	4620      	mov	r0, r4
    e7fe:	f7f9 fe67 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
    e802:	b003      	add	sp, #12
    e804:	bd30      	pop	{r4, r5, pc}
    e806:	bf00      	nop
    e808:	00024208 	.word	0x00024208
    e80c:	00021257 	.word	0x00021257
    e810:	000241f0 	.word	0x000241f0
    e814:	00023c90 	.word	0x00023c90
    e818:	0001e600 	.word	0x0001e600

0000e81c <ASR::View()>:
        gfxHeader(applet_name());
    e81c:	6803      	ldr	r3, [r0, #0]
    void View() {
    e81e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        gfxHeader(applet_name());
    e822:	681b      	ldr	r3, [r3, #0]
    void View() {
    e824:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    e826:	4798      	blx	r3
    e828:	4601      	mov	r1, r0
    e82a:	4620      	mov	r0, r4
    e82c:	f7f9 fee7 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
    e830:	4620      	mov	r0, r4
    e832:	f7ff ff99 	bl	e768 <ASR::DrawInterface()>
    e836:	2700      	movs	r7, #0
        // If there are two instances, and this is the right hemisphere, show the
        // second 128 bytes. Otherwise, just show the first 128.
        byte offset = (IsLinked(hemisphere)) ? 64 : 0;
        byte ix = (x + offset + position + 64);
        int cv = buffer[ix] + HEMISPHERE_MAX_CV; // Force this positive
        int y = (((cv << 7) / (HEMISPHERE_MAX_CV * 2)) * 23) >> 7;
    e838:	f44f 5670 	mov.w	r6, #15360	; 0x3c00
    e83c:	2517      	movs	r5, #23
            int y = buffer_m->GetYAt(x, hemisphere) + 40;
    e83e:	f8d4 8070 	ldr.w	r8, [r4, #112]	; 0x70
        byte offset = (IsLinked(hemisphere)) ? 64 : 0;
    e842:	7921      	ldrb	r1, [r4, #4]
    e844:	4640      	mov	r0, r8
    e846:	f7ff ff79 	bl	e73c <RingBufferManager::IsLinked(bool)>
        byte ix = (x + offset + position + 64);
    e84a:	f898 3400 	ldrb.w	r3, [r8, #1024]	; 0x400
    e84e:	3340      	adds	r3, #64	; 0x40
    e850:	443b      	add	r3, r7
    e852:	eb03 1380 	add.w	r3, r3, r0, lsl #6
        int cv = buffer[ix] + HEMISPHERE_MAX_CV; // Force this positive
    e856:	b2db      	uxtb	r3, r3
            gfxPixel(x, y);
    e858:	4639      	mov	r1, r7
    e85a:	f858 2023 	ldr.w	r2, [r8, r3, lsl #2]
    e85e:	69a0      	ldr	r0, [r4, #24]
    e860:	f502 52f0 	add.w	r2, r2, #7680	; 0x1e00
        int y = (((cv << 7) / (HEMISPHERE_MAX_CV * 2)) * 23) >> 7;
    e864:	01d2      	lsls	r2, r2, #7
    e866:	fb92 f2f6 	sdiv	r2, r2, r6
    e86a:	436a      	muls	r2, r5
    e86c:	11d2      	asrs	r2, r2, #7
            int y = buffer_m->GetYAt(x, hemisphere) + 40;
    e86e:	2a17      	cmp	r2, #23
    e870:	bfa8      	it	ge
    e872:	2217      	movge	r2, #23
    e874:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
            gfxPixel(x, y);
    e878:	f1c2 023f 	rsb	r2, r2, #63	; 0x3f
        for (byte x = 0; x < 64; x++)
    e87c:	3701      	adds	r7, #1
            gfxPixel(x, y);
    e87e:	f7f6 f8cb 	bl	4a18 <HemisphereApplet::gfxPixel(int, int) [clone .isra.0]>
        for (byte x = 0; x < 64; x++)
    e882:	2f40      	cmp	r7, #64	; 0x40
    e884:	d1db      	bne.n	e83e <ASR::View()+0x22>
    }
    e886:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e88a:	Address 0x000000000000e88a is out of bounds.


0000e88c <AnnularFusion::DrawSteps()>:
    void DrawSteps() {
    e88c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
        if (last_clock && OC::CORE::ticks - last_clock < 166666) {
    e890:	4f29      	ldr	r7, [pc, #164]	; (e938 <AnnularFusion::DrawSteps()+0xac>)
    e892:	f8df 80a8 	ldr.w	r8, [pc, #168]	; e93c <AnnularFusion::DrawSteps()+0xb0>
    void DrawSteps() {
    e896:	4604      	mov	r4, r0
    e898:	f500 7682 	add.w	r6, r0, #260	; 0x104
        ForEachChannel(ch)
    e89c:	2500      	movs	r5, #0
        if (last_clock && OC::CORE::ticks - last_clock < 166666) {
    e89e:	f8d4 20fc 	ldr.w	r2, [r4, #252]	; 0xfc
    e8a2:	b30a      	cbz	r2, e8e8 <AnnularFusion::DrawSteps()+0x5c>
    e8a4:	683b      	ldr	r3, [r7, #0]
    e8a6:	1a9b      	subs	r3, r3, r2
    e8a8:	4543      	cmp	r3, r8
    e8aa:	d81d      	bhi.n	e8e8 <AnnularFusion::DrawSteps()+0x5c>
            int s1 = step % length[ch];
    e8ac:	6832      	ldr	r2, [r6, #0]
    e8ae:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    e8b0:	fb91 f3f2 	sdiv	r3, r1, r2
    e8b4:	fb02 1113 	mls	r1, r2, r3, r1
            int s2 = s1 + 1 == length[ch] ? 0 : s1 + 1;
    e8b8:	1c4b      	adds	r3, r1, #1
    e8ba:	4293      	cmp	r3, r2
    e8bc:	bf08      	it	eq
    e8be:	2300      	moveq	r3, #0
            AFStepCoord s1_c = disp_coord[ch][s1];
    e8c0:	eb03 1345 	add.w	r3, r3, r5, lsl #5
    e8c4:	eb04 0343 	add.w	r3, r4, r3, lsl #1
    e8c8:	eb01 1145 	add.w	r1, r1, r5, lsl #5
            gfxLine(s1_c.x, s1_c.y, s2_c.x, s2_c.y);
    e8cc:	f893 2075 	ldrb.w	r2, [r3, #117]	; 0x75
    e8d0:	9200      	str	r2, [sp, #0]
    e8d2:	eb04 0141 	add.w	r1, r4, r1, lsl #1
    e8d6:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
    e8da:	f891 2075 	ldrb.w	r2, [r1, #117]	; 0x75
    e8de:	69a0      	ldr	r0, [r4, #24]
    e8e0:	f891 1074 	ldrb.w	r1, [r1, #116]	; 0x74
    e8e4:	f7f6 f884 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
    e8e8:	eb04 1985 	add.w	r9, r4, r5, lsl #6
            int s2 = s1 + 1 == length[ch] ? 0 : s1 + 1;
    e8ec:	f04f 0a00 	mov.w	sl, #0
        for (int p = 0; p < length[ch]; p++)
    e8f0:	6833      	ldr	r3, [r6, #0]
    e8f2:	459a      	cmp	sl, r3
    e8f4:	db06      	blt.n	e904 <AnnularFusion::DrawSteps()+0x78>
        ForEachChannel(ch)
    e8f6:	3604      	adds	r6, #4
    e8f8:	b115      	cbz	r5, e900 <AnnularFusion::DrawSteps()+0x74>
    }
    e8fa:	b002      	add	sp, #8
    e8fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e900:	2501      	movs	r5, #1
    e902:	e7cc      	b.n	e89e <AnnularFusion::DrawSteps()+0x12>
            if ((pattern[ch] >> p) & 0x01) {
    e904:	f856 3c10 	ldr.w	r3, [r6, #-16]
    e908:	fa23 f30a 	lsr.w	r3, r3, sl
    e90c:	07db      	lsls	r3, r3, #31
    e90e:	d50e      	bpl.n	e92e <AnnularFusion::DrawSteps()+0xa2>
                gfxPixel(disp_coord[ch][p].x, disp_coord[ch][p].y);
    e910:	f899 2075 	ldrb.w	r2, [r9, #117]	; 0x75
    e914:	f899 1074 	ldrb.w	r1, [r9, #116]	; 0x74
    e918:	69a0      	ldr	r0, [r4, #24]
    e91a:	f7f6 f87d 	bl	4a18 <HemisphereApplet::gfxPixel(int, int) [clone .isra.0]>
                gfxPixel(disp_coord[ch][p].x + 1, disp_coord[ch][p].y);
    e91e:	f899 1074 	ldrb.w	r1, [r9, #116]	; 0x74
    e922:	f899 2075 	ldrb.w	r2, [r9, #117]	; 0x75
    e926:	69a0      	ldr	r0, [r4, #24]
    e928:	3101      	adds	r1, #1
    e92a:	f7f6 f875 	bl	4a18 <HemisphereApplet::gfxPixel(int, int) [clone .isra.0]>
        for (int p = 0; p < length[ch]; p++)
    e92e:	f10a 0a01 	add.w	sl, sl, #1
    e932:	f109 0902 	add.w	r9, r9, #2
    e936:	e7db      	b.n	e8f0 <AnnularFusion::DrawSteps()+0x64>
    e938:	200046cc 	.word	0x200046cc
    e93c:	00028b09 	.word	0x00028b09

0000e940 <AnnularFusion::DrawEditor()>:
    void DrawEditor() {
    e940:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        gfxBitmap(1, 15, 8, LOOP_ICON);
    e944:	4b2f      	ldr	r3, [pc, #188]	; (ea04 <AnnularFusion::DrawEditor()+0xc4>)
        int ch = cursor < 2 ? 0 : 1; // Cursor channel
    e946:	6f05      	ldr	r5, [r0, #112]	; 0x70
        gfxBitmap(1, 15, 8, LOOP_ICON);
    e948:	9300      	str	r3, [sp, #0]
        int f = cursor - (ch * 2); // Cursor function
    e94a:	2d01      	cmp	r5, #1
    void DrawEditor() {
    e94c:	4604      	mov	r4, r0
        gfxBitmap(1, 15, 8, LOOP_ICON);
    e94e:	f04f 0308 	mov.w	r3, #8
    e952:	f04f 020f 	mov.w	r2, #15
    e956:	6980      	ldr	r0, [r0, #24]
    e958:	f04f 0101 	mov.w	r1, #1
        int f = cursor - (ch * 2); // Cursor function
    e95c:	bfcc      	ite	gt
    e95e:	2602      	movgt	r6, #2
    e960:	2600      	movle	r6, #0
        gfxBitmap(1, 15, 8, LOOP_ICON);
    e962:	f7f6 f817 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
    e966:	2d01      	cmp	r5, #1
    e968:	bfcc      	ite	gt
    e96a:	2704      	movgt	r7, #4
    e96c:	2700      	movle	r7, #0
    e96e:	4427      	add	r7, r4
        gfxPrint(12 + pad(10, length[ch]), 15, length[ch]);
    e970:	200a      	movs	r0, #10
    e972:	f8d7 8104 	ldr.w	r8, [r7, #260]	; 0x104
    e976:	4641      	mov	r1, r8
    e978:	f7f5 fe83 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
        int f = cursor - (ch * 2); // Cursor function
    e97c:	1bae      	subs	r6, r5, r6
        gfxPrint(12 + pad(10, length[ch]), 15, length[ch]);
    e97e:	f100 010c 	add.w	r1, r0, #12
    e982:	4643      	mov	r3, r8
    e984:	69a0      	ldr	r0, [r4, #24]
    e986:	220f      	movs	r2, #15
    e988:	f7f6 f872 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (f == 0) gfxCursor(13, 23, 12);
    e98c:	b92e      	cbnz	r6, e99a <AnnularFusion::DrawEditor()+0x5a>
    e98e:	230c      	movs	r3, #12
    e990:	2217      	movs	r2, #23
    e992:	210d      	movs	r1, #13
    e994:	4620      	mov	r0, r4
    e996:	f7f9 fd9b 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        gfxBitmap(1, 25, 8, X_NOTE_ICON);
    e99a:	4b1b      	ldr	r3, [pc, #108]	; (ea08 <AnnularFusion::DrawEditor()+0xc8>)
    e99c:	69a0      	ldr	r0, [r4, #24]
    e99e:	9300      	str	r3, [sp, #0]
    e9a0:	2219      	movs	r2, #25
    e9a2:	2308      	movs	r3, #8
    e9a4:	2101      	movs	r1, #1
    e9a6:	f7f5 fff5 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(12 + pad(10, beats[ch]), 25, beats[ch]);
    e9aa:	f8d7 710c 	ldr.w	r7, [r7, #268]	; 0x10c
    e9ae:	200a      	movs	r0, #10
    e9b0:	4639      	mov	r1, r7
    e9b2:	f7f5 fe66 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    e9b6:	463b      	mov	r3, r7
    e9b8:	f100 010c 	add.w	r1, r0, #12
    e9bc:	2219      	movs	r2, #25
    e9be:	69a0      	ldr	r0, [r4, #24]
    e9c0:	f7f6 f856 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (f == 1) gfxCursor(13, 33, 12);
    e9c4:	2e01      	cmp	r6, #1
    e9c6:	d105      	bne.n	e9d4 <AnnularFusion::DrawEditor()+0x94>
    e9c8:	230c      	movs	r3, #12
    e9ca:	2221      	movs	r2, #33	; 0x21
    e9cc:	210d      	movs	r1, #13
    e9ce:	4620      	mov	r0, r4
    e9d0:	f7f9 fd7e 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        gfxCircle(8, 52, 8);
    e9d4:	2308      	movs	r3, #8
    e9d6:	69a0      	ldr	r0, [r4, #24]
    e9d8:	4619      	mov	r1, r3
    e9da:	2234      	movs	r2, #52	; 0x34
    e9dc:	f7f5 ffe8 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        gfxCircle(8, 52, 4);
    e9e0:	2304      	movs	r3, #4
    e9e2:	69a0      	ldr	r0, [r4, #24]
    e9e4:	2234      	movs	r2, #52	; 0x34
    e9e6:	2108      	movs	r1, #8
    e9e8:	f7f5 ffe2 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        if (ch == 0) gfxCircle(8, 52, 7);
    e9ec:	2d01      	cmp	r5, #1
        else gfxCircle(8, 52, 5);
    e9ee:	69a0      	ldr	r0, [r4, #24]
        if (ch == 0) gfxCircle(8, 52, 7);
    e9f0:	bfd4      	ite	le
    e9f2:	2307      	movle	r3, #7
        else gfxCircle(8, 52, 5);
    e9f4:	2305      	movgt	r3, #5
    e9f6:	2234      	movs	r2, #52	; 0x34
    e9f8:	2108      	movs	r1, #8
    }
    e9fa:	b002      	add	sp, #8
    e9fc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        else gfxCircle(8, 52, 5);
    ea00:	f7f5 bfd6 	b.w	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
    ea04:	00024218 	.word	0x00024218
    ea08:	00023ca8 	.word	0x00023ca8

0000ea0c <AnnularFusion::View()>:
        gfxHeader(applet_name());
    ea0c:	6803      	ldr	r3, [r0, #0]
    void View() {
    ea0e:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    ea10:	681b      	ldr	r3, [r3, #0]
    void View() {
    ea12:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    ea14:	4798      	blx	r3
    ea16:	4601      	mov	r1, r0
    ea18:	4620      	mov	r0, r4
    ea1a:	f7f9 fdf0 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSteps();
    ea1e:	4620      	mov	r0, r4
    ea20:	f7ff ff34 	bl	e88c <AnnularFusion::DrawSteps()>
        if (display_timeout > 0) DrawEditor();
    ea24:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    ea28:	b113      	cbz	r3, ea30 <AnnularFusion::View()+0x24>
    ea2a:	4620      	mov	r0, r4
    ea2c:	f7ff ff88 	bl	e940 <AnnularFusion::DrawEditor()>
    }
    ea30:	bd10      	pop	{r4, pc}

0000ea32 <AnnularFusion::SetDisplayPositions(int, int)>:
    void SetDisplayPositions(int ch, int r) {
    ea32:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        uint32_t pattern = EuclideanPattern(31, length[ch], 0);
    ea36:	eb00 0381 	add.w	r3, r0, r1, lsl #2
        int x_per_step = (r * 4) / 32;
    ea3a:	2a00      	cmp	r2, #0
    void SetDisplayPositions(int ch, int r) {
    ea3c:	4614      	mov	r4, r2
        int x_per_step = (r * 4) / 32;
    ea3e:	4615      	mov	r5, r2
    void SetDisplayPositions(int ch, int r) {
    ea40:	460e      	mov	r6, r1
        int x_per_step = (r * 4) / 32;
    ea42:	bfb8      	it	lt
    ea44:	1dd5      	addlt	r5, r2, #7
        uint32_t pattern = EuclideanPattern(31, length[ch], 0);
    ea46:	f893 1104 	ldrb.w	r1, [r3, #260]	; 0x104
    ea4a:	2200      	movs	r2, #0
    void SetDisplayPositions(int ch, int r) {
    ea4c:	4607      	mov	r7, r0
        uint32_t pattern = EuclideanPattern(31, length[ch], 0);
    ea4e:	201f      	movs	r0, #31
    ea50:	f7f2 fc68 	bl	1324 <EuclideanPattern(unsigned char, unsigned char, unsigned char)>
                if (rx * rx + ry * ry < r * r + 1) {
    ea54:	fb04 f204 	mul.w	r2, r4, r4
    ea58:	2400      	movs	r4, #0
        int x_per_step = (r * 4) / 32;
    ea5a:	10ed      	asrs	r5, r5, #3
        int c_count = 0; // Count of pixels along the circumference
    ea5c:	4623      	mov	r3, r4
        int di = 0; // Display index (positions actually used in the display)
    ea5e:	46a4      	mov	ip, r4
    ea60:	ea4f 1946 	mov.w	r9, r6, lsl #5
    ea64:	f1c4 0e1f 	rsb	lr, r4, #31
    ea68:	fa5f f884 	uxtb.w	r8, r4
                if (rx * rx + ry * ry < r * r + 1) {
    ea6c:	fb0e fe0e 	mul.w	lr, lr, lr
    ea70:	2100      	movs	r1, #0
    ea72:	f1c1 0b27 	rsb	fp, r1, #39	; 0x27
    ea76:	fb0b eb0b 	mla	fp, fp, fp, lr
    ea7a:	455a      	cmp	r2, fp
    ea7c:	fa5f fa81 	uxtb.w	sl, r1
    ea80:	db14      	blt.n	eaac <AnnularFusion::SetDisplayPositions(int, int)+0x7a>
                    if (c_count++ % x_per_step == 0) {
    ea82:	1c59      	adds	r1, r3, #1
    ea84:	fb93 fef5 	sdiv	lr, r3, r5
    ea88:	fb05 331e 	mls	r3, r5, lr, r3
    ea8c:	b963      	cbnz	r3, eaa8 <AnnularFusion::SetDisplayPositions(int, int)+0x76>
                        if (pattern & 0x01) disp_coord[ch][di++] = AFStepCoord {x, y};
    ea8e:	07c3      	lsls	r3, r0, #31
    ea90:	d509      	bpl.n	eaa6 <AnnularFusion::SetDisplayPositions(int, int)+0x74>
    ea92:	eb09 030c 	add.w	r3, r9, ip
    ea96:	eb07 0343 	add.w	r3, r7, r3, lsl #1
    ea9a:	f10c 0c01 	add.w	ip, ip, #1
    ea9e:	f883 8074 	strb.w	r8, [r3, #116]	; 0x74
    eaa2:	f883 a075 	strb.w	sl, [r3, #117]	; 0x75
                        pattern = pattern >> 0x01;
    eaa6:	0840      	lsrs	r0, r0, #1
                    if (c_count++ % x_per_step == 0) {
    eaa8:	460b      	mov	r3, r1
    eaaa:	e002      	b.n	eab2 <AnnularFusion::SetDisplayPositions(int, int)+0x80>
            for (uint8_t y = 0; y < 63; y++)
    eaac:	3101      	adds	r1, #1
    eaae:	293f      	cmp	r1, #63	; 0x3f
    eab0:	d1df      	bne.n	ea72 <AnnularFusion::SetDisplayPositions(int, int)+0x40>
        for (uint8_t x = 0; x < 63; x++)
    eab2:	3401      	adds	r4, #1
    eab4:	2c3f      	cmp	r4, #63	; 0x3f
    eab6:	d1d5      	bne.n	ea64 <AnnularFusion::SetDisplayPositions(int, int)+0x32>
    eab8:	f06f 041f 	mvn.w	r4, #31
    eabc:	0176      	lsls	r6, r6, #5
    eabe:	f1c4 0e1f 	rsb	lr, r4, #31
    eac2:	fa5f fe8e 	uxtb.w	lr, lr
                if (rx * rx + ry * ry < r * r + 1) {
    eac6:	fb04 f904 	mul.w	r9, r4, r4
    eaca:	f06f 0117 	mvn.w	r1, #23
    eace:	fb01 9a01 	mla	sl, r1, r1, r9
    ead2:	f1c1 0827 	rsb	r8, r1, #39	; 0x27
    ead6:	4552      	cmp	r2, sl
    ead8:	fa5f f888 	uxtb.w	r8, r8
    eadc:	db14      	blt.n	eb08 <AnnularFusion::SetDisplayPositions(int, int)+0xd6>
                    if (c_count++ % x_per_step == 0) {
    eade:	1c59      	adds	r1, r3, #1
    eae0:	fb93 f9f5 	sdiv	r9, r3, r5
    eae4:	fb05 3319 	mls	r3, r5, r9, r3
    eae8:	b963      	cbnz	r3, eb04 <AnnularFusion::SetDisplayPositions(int, int)+0xd2>
                        if (pattern & 0x01) disp_coord[ch][di++] = AFStepCoord {x, y};
    eaea:	07c3      	lsls	r3, r0, #31
    eaec:	d509      	bpl.n	eb02 <AnnularFusion::SetDisplayPositions(int, int)+0xd0>
    eaee:	eb06 030c 	add.w	r3, r6, ip
    eaf2:	eb07 0343 	add.w	r3, r7, r3, lsl #1
    eaf6:	f10c 0c01 	add.w	ip, ip, #1
    eafa:	f883 e074 	strb.w	lr, [r3, #116]	; 0x74
    eafe:	f883 8075 	strb.w	r8, [r3, #117]	; 0x75
                        pattern = pattern >> 0x01;
    eb02:	0840      	lsrs	r0, r0, #1
                    if (c_count++ % x_per_step == 0) {
    eb04:	460b      	mov	r3, r1
    eb06:	e002      	b.n	eb0e <AnnularFusion::SetDisplayPositions(int, int)+0xdc>
            for (uint8_t y = 63; y > 0; y--)
    eb08:	3101      	adds	r1, #1
    eb0a:	2927      	cmp	r1, #39	; 0x27
    eb0c:	d1df      	bne.n	eace <AnnularFusion::SetDisplayPositions(int, int)+0x9c>
        for (uint8_t x = 63; x > 0; x--)
    eb0e:	3401      	adds	r4, #1
    eb10:	2c1f      	cmp	r4, #31
    eb12:	d1d4      	bne.n	eabe <AnnularFusion::SetDisplayPositions(int, int)+0x8c>
    }
    eb14:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000eb18 <AnnularFusion::Start()>:
    void Start() {
    eb18:	b538      	push	{r3, r4, r5, lr}
            beats[ch] = 4 + (ch * 4);
    eb1a:	2104      	movs	r1, #4
        display_timeout = AF_DISPLAY_TIMEOUT;
    eb1c:	4b14      	ldr	r3, [pc, #80]	; (eb70 <AnnularFusion::Start()+0x58>)
    eb1e:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
            length[ch] = 16;
    eb22:	2510      	movs	r5, #16
    void Start() {
    eb24:	4604      	mov	r4, r0
            beats[ch] = 4 + (ch * 4);
    eb26:	f8c0 110c 	str.w	r1, [r0, #268]	; 0x10c
            length[ch] = 16;
    eb2a:	f8c0 5104 	str.w	r5, [r0, #260]	; 0x104
            pattern[ch] = EuclideanPattern(length[ch] - 1, beats[ch], 0);;
    eb2e:	2200      	movs	r2, #0
    eb30:	200f      	movs	r0, #15
    eb32:	f7f2 fbf7 	bl	1324 <EuclideanPattern(unsigned char, unsigned char, unsigned char)>
            beats[ch] = 4 + (ch * 4);
    eb36:	2108      	movs	r1, #8
            pattern[ch] = EuclideanPattern(length[ch] - 1, beats[ch], 0);;
    eb38:	f8c4 00f4 	str.w	r0, [r4, #244]	; 0xf4
            beats[ch] = 4 + (ch * 4);
    eb3c:	f8c4 1110 	str.w	r1, [r4, #272]	; 0x110
            pattern[ch] = EuclideanPattern(length[ch] - 1, beats[ch], 0);;
    eb40:	2200      	movs	r2, #0
            length[ch] = 16;
    eb42:	f8c4 5108 	str.w	r5, [r4, #264]	; 0x108
            pattern[ch] = EuclideanPattern(length[ch] - 1, beats[ch], 0);;
    eb46:	200f      	movs	r0, #15
    eb48:	f7f2 fbec 	bl	1324 <EuclideanPattern(unsigned char, unsigned char, unsigned char)>
        step = 0;
    eb4c:	2100      	movs	r1, #0
            pattern[ch] = EuclideanPattern(length[ch] - 1, beats[ch], 0);;
    eb4e:	f8c4 00f8 	str.w	r0, [r4, #248]	; 0xf8
        step = 0;
    eb52:	66e1      	str	r1, [r4, #108]	; 0x6c
        SetDisplayPositions(0, 24);
    eb54:	2218      	movs	r2, #24
    eb56:	4620      	mov	r0, r4
    eb58:	f7ff ff6b 	bl	ea32 <AnnularFusion::SetDisplayPositions(int, int)>
        SetDisplayPositions(1, 16);
    eb5c:	462a      	mov	r2, r5
    eb5e:	2101      	movs	r1, #1
    eb60:	4620      	mov	r0, r4
    eb62:	f7ff ff66 	bl	ea32 <AnnularFusion::SetDisplayPositions(int, int)>
        last_clock = OC::CORE::ticks;
    eb66:	4b03      	ldr	r3, [pc, #12]	; (eb74 <AnnularFusion::Start()+0x5c>)
    eb68:	681b      	ldr	r3, [r3, #0]
    eb6a:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    }
    eb6e:	bd38      	pop	{r3, r4, r5, pc}
    eb70:	00050910 	.word	0x00050910
    eb74:	200046cc 	.word	0x200046cc

0000eb78 <AnnularFusion_OnEncoderMove(bool, int)>:
void AnnularFusion_OnEncoderMove(bool hemisphere, int direction) {
    eb78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        display_timeout = AF_DISPLAY_TIMEOUT;
    eb7a:	4b27      	ldr	r3, [pc, #156]	; (ec18 <AnnularFusion_OnEncoderMove(bool, int)+0xa0>)
    eb7c:	f44f 728a 	mov.w	r2, #276	; 0x114
    eb80:	fb02 3200 	mla	r2, r2, r0, r3
void AnnularFusion_OnEncoderMove(bool hemisphere, int direction) {
    eb84:	460d      	mov	r5, r1
        display_timeout = AF_DISPLAY_TIMEOUT;
    eb86:	4925      	ldr	r1, [pc, #148]	; (ec1c <AnnularFusion_OnEncoderMove(bool, int)+0xa4>)
    eb88:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
        int ch = cursor < 2 ? 0 : 1;
    eb8c:	6f12      	ldr	r2, [r2, #112]	; 0x70
    eb8e:	2a01      	cmp	r2, #1
        int f = cursor - (ch * 2); // Cursor function
    eb90:	bfcb      	itete	gt
    eb92:	2402      	movgt	r4, #2
    eb94:	2400      	movle	r4, #0
        int ch = cursor < 2 ? 0 : 1;
    eb96:	2101      	movgt	r1, #1
    eb98:	2100      	movle	r1, #0
        if (f == 0) {
    eb9a:	1b12      	subs	r2, r2, r4
    eb9c:	d120      	bne.n	ebe0 <AnnularFusion_OnEncoderMove(bool, int)+0x68>
            length[ch] = constrain(length[ch] + direction, 3, 32);
    eb9e:	2245      	movs	r2, #69	; 0x45
    eba0:	fb02 1200 	mla	r2, r2, r0, r1
    eba4:	f102 0640 	add.w	r6, r2, #64	; 0x40
    eba8:	eb03 0686 	add.w	r6, r3, r6, lsl #2
            if (beats[ch] > length[ch]) beats[ch] = length[ch];
    ebac:	3242      	adds	r2, #66	; 0x42
            length[ch] = constrain(length[ch] + direction, 3, 32);
    ebae:	6874      	ldr	r4, [r6, #4]
    ebb0:	442c      	add	r4, r5
    ebb2:	2c20      	cmp	r4, #32
            if (beats[ch] > length[ch]) beats[ch] = length[ch];
    ebb4:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    ebb8:	bfa8      	it	ge
    ebba:	2420      	movge	r4, #32
    ebbc:	6855      	ldr	r5, [r2, #4]
    ebbe:	2c03      	cmp	r4, #3
    ebc0:	bfb8      	it	lt
    ebc2:	2403      	movlt	r4, #3
    ebc4:	42ac      	cmp	r4, r5
    ebc6:	bfb8      	it	lt
    ebc8:	6054      	strlt	r4, [r2, #4]
            length[ch] = constrain(length[ch] + direction, 3, 32);
    ebca:	6074      	str	r4, [r6, #4]
            SetDisplayPositions(ch, 24 - (8 * ch));
    ebcc:	f1c1 0203 	rsb	r2, r1, #3
    ebd0:	f44f 748a 	mov.w	r4, #276	; 0x114
    ebd4:	00d2      	lsls	r2, r2, #3
    ebd6:	fb04 3000 	mla	r0, r4, r0, r3
    ebda:	f7ff ff2a 	bl	ea32 <AnnularFusion::SetDisplayPositions(int, int)>
}
    ebde:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (f == 1) {
    ebe0:	2a01      	cmp	r2, #1
    ebe2:	d1fc      	bne.n	ebde <AnnularFusion_OnEncoderMove(bool, int)+0x66>
            beats[ch] = constrain(beats[ch] + direction, 1, length[ch]);
    ebe4:	2745      	movs	r7, #69	; 0x45
    ebe6:	fb07 1600 	mla	r6, r7, r0, r1
    ebea:	eb03 0486 	add.w	r4, r3, r6, lsl #2
    ebee:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    ebf2:	f8d4 410c 	ldr.w	r4, [r4, #268]	; 0x10c
    ebf6:	442c      	add	r4, r5
    ebf8:	2c00      	cmp	r4, #0
    ebfa:	f8d6 5104 	ldr.w	r5, [r6, #260]	; 0x104
    ebfe:	dd03      	ble.n	ec08 <AnnularFusion_OnEncoderMove(bool, int)+0x90>
    ec00:	42ac      	cmp	r4, r5
    ec02:	4622      	mov	r2, r4
    ec04:	bfa8      	it	ge
    ec06:	462a      	movge	r2, r5
    ec08:	fb07 1100 	mla	r1, r7, r0, r1
    ec0c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    ec10:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
}
    ec14:	e7e3      	b.n	ebde <AnnularFusion_OnEncoderMove(bool, int)+0x66>
    ec16:	bf00      	nop
    ec18:	1fffae98 	.word	0x1fffae98
    ec1c:	00050910 	.word	0x00050910

0000ec20 <AnnularFusion::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
    ec20:	b5f0      	push	{r4, r5, r6, r7, lr}
        length[0] = Unpack(data, PackLocation {0,4}) + 1;
    ec22:	2604      	movs	r6, #4
    void OnDataReceive(uint32_t data) {
    ec24:	460d      	mov	r5, r1
        length[0] = Unpack(data, PackLocation {0,4}) + 1;
    ec26:	2700      	movs	r7, #0
    void OnDataReceive(uint32_t data) {
    ec28:	b089      	sub	sp, #36	; 0x24
    ec2a:	4604      	mov	r4, r0
        length[0] = Unpack(data, PackLocation {0,4}) + 1;
    ec2c:	4632      	mov	r2, r6
    ec2e:	4639      	mov	r1, r7
    ec30:	4628      	mov	r0, r5
    ec32:	e9cd 7600 	strd	r7, r6, [sp]
    ec36:	f7f5 f8fb 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    ec3a:	3001      	adds	r0, #1
    ec3c:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
        beats[0] = Unpack(data, PackLocation {4,4}) + 1;
    ec40:	4632      	mov	r2, r6
    ec42:	4631      	mov	r1, r6
    ec44:	4628      	mov	r0, r5
    ec46:	e9cd 6602 	strd	r6, r6, [sp, #8]
    ec4a:	f7f5 f8f1 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        length[1] = Unpack(data, PackLocation {8,4}) + 1;
    ec4e:	2308      	movs	r3, #8
        beats[0] = Unpack(data, PackLocation {4,4}) + 1;
    ec50:	3001      	adds	r0, #1
    ec52:	f8c4 010c 	str.w	r0, [r4, #268]	; 0x10c
        length[1] = Unpack(data, PackLocation {8,4}) + 1;
    ec56:	4632      	mov	r2, r6
    ec58:	4619      	mov	r1, r3
    ec5a:	4628      	mov	r0, r5
    ec5c:	e9cd 3604 	strd	r3, r6, [sp, #16]
    ec60:	f7f5 f8e6 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        beats[1] = Unpack(data, PackLocation {12,4}) + 1;
    ec64:	230c      	movs	r3, #12
    ec66:	e9cd 3606 	strd	r3, r6, [sp, #24]
        length[1] = Unpack(data, PackLocation {8,4}) + 1;
    ec6a:	3001      	adds	r0, #1
        beats[1] = Unpack(data, PackLocation {12,4}) + 1;
    ec6c:	ab08      	add	r3, sp, #32
    ec6e:	e913 0006 	ldmdb	r3, {r1, r2}
        length[1] = Unpack(data, PackLocation {8,4}) + 1;
    ec72:	f8c4 0108 	str.w	r0, [r4, #264]	; 0x108
        beats[1] = Unpack(data, PackLocation {12,4}) + 1;
    ec76:	4628      	mov	r0, r5
    ec78:	f7f5 f8da 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    ec7c:	3001      	adds	r0, #1
    ec7e:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
        SetDisplayPositions(0, 24);
    ec82:	4639      	mov	r1, r7
    ec84:	4620      	mov	r0, r4
    ec86:	2218      	movs	r2, #24
    ec88:	f7ff fed3 	bl	ea32 <AnnularFusion::SetDisplayPositions(int, int)>
        SetDisplayPositions(1, 16);
    ec8c:	2210      	movs	r2, #16
    ec8e:	2101      	movs	r1, #1
    ec90:	4620      	mov	r0, r4
    ec92:	f7ff fece 	bl	ea32 <AnnularFusion::SetDisplayPositions(int, int)>
    }
    ec96:	b009      	add	sp, #36	; 0x24
    ec98:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ec9a:	Address 0x000000000000ec9a is out of bounds.


0000ec9c <AnnularFusion_OnDataReceive(bool, unsigned long)>:

void AnnularFusion_OnDataReceive(bool hemisphere, uint32_t data) {
    ec9c:	b508      	push	{r3, lr}
    AnnularFusion_instance[hemisphere].OnDataReceive(data);
    ec9e:	4b04      	ldr	r3, [pc, #16]	; (ecb0 <AnnularFusion_OnDataReceive(bool, unsigned long)+0x14>)
    eca0:	f44f 728a 	mov.w	r2, #276	; 0x114
    eca4:	fb02 3000 	mla	r0, r2, r0, r3
    eca8:	f7ff ffba 	bl	ec20 <AnnularFusion::OnDataReceive(unsigned long)>
}
    ecac:	bd08      	pop	{r3, pc}
    ecae:	bf00      	nop
    ecb0:	1fffae98 	.word	0x1fffae98

0000ecb4 <AttenuateOffset::DrawInterface()>:
            gfxPrint(0, 15 + (ch * 20), (hemisphere ? (ch ? "D " : "C ") : (ch ? "B " : "A ")));
    ecb4:	7901      	ldrb	r1, [r0, #4]
    ecb6:	4a2a      	ldr	r2, [pc, #168]	; (ed60 <AttenuateOffset::DrawInterface()+0xac>)
    ecb8:	4b2a      	ldr	r3, [pc, #168]	; (ed64 <AttenuateOffset::DrawInterface()+0xb0>)
    void DrawInterface() {
    ecba:	b570      	push	{r4, r5, r6, lr}
    ecbc:	4604      	mov	r4, r0
            gfxPrint(0, 15 + (ch * 20), (hemisphere ? (ch ? "D " : "C ") : (ch ? "B " : "A ")));
    ecbe:	2900      	cmp	r1, #0
    ecc0:	bf18      	it	ne
    ecc2:	4613      	movne	r3, r2
    ecc4:	220f      	movs	r2, #15
    ecc6:	2100      	movs	r1, #0
    ecc8:	f7f9 fc0e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            int cv = offset[ch] * ATTENOFF_INCREMENTS;
    eccc:	6fa1      	ldr	r1, [r4, #120]	; 0x78
            gfxPrintVoltage(cv);
    ecce:	4620      	mov	r0, r4
    ecd0:	01c9      	lsls	r1, r1, #7
    ecd2:	f7f9 fc17 	bl	8504 <HemisphereApplet::gfxPrintVoltage(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    ecd6:	6f23      	ldr	r3, [r4, #112]	; 0x70
            gfxPrint(16, 25 + (ch * 20), Proportion(level[ch], 63, 100));
    ecd8:	69a0      	ldr	r0, [r4, #24]
        int scaled = simfloat2int(proportion * max_value);
    ecda:	2564      	movs	r5, #100	; 0x64
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    ecdc:	263f      	movs	r6, #63	; 0x3f
    ecde:	039b      	lsls	r3, r3, #14
    ece0:	fb93 f3f6 	sdiv	r3, r3, r6
        int scaled = simfloat2int(proportion * max_value);
    ece4:	436b      	muls	r3, r5
    ece6:	139b      	asrs	r3, r3, #14
    ece8:	2219      	movs	r2, #25
    ecea:	2110      	movs	r1, #16
    ecec:	f7f5 fec0 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        graphics.print(str);
    ecf0:	491d      	ldr	r1, [pc, #116]	; (ed68 <AttenuateOffset::DrawInterface()+0xb4>)
    ecf2:	481e      	ldr	r0, [pc, #120]	; (ed6c <AttenuateOffset::DrawInterface()+0xb8>)
    ecf4:	f00a feef 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            gfxPrint(0, 15 + (ch * 20), (hemisphere ? (ch ? "D " : "C ") : (ch ? "B " : "A ")));
    ecf8:	7921      	ldrb	r1, [r4, #4]
    ecfa:	4a1d      	ldr	r2, [pc, #116]	; (ed70 <AttenuateOffset::DrawInterface()+0xbc>)
    ecfc:	4b1d      	ldr	r3, [pc, #116]	; (ed74 <AttenuateOffset::DrawInterface()+0xc0>)
    ecfe:	4620      	mov	r0, r4
    ed00:	2900      	cmp	r1, #0
    ed02:	bf18      	it	ne
    ed04:	4613      	movne	r3, r2
    ed06:	2223      	movs	r2, #35	; 0x23
    ed08:	2100      	movs	r1, #0
    ed0a:	f7f9 fbed 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            int cv = offset[ch] * ATTENOFF_INCREMENTS;
    ed0e:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
            gfxPrintVoltage(cv);
    ed10:	4620      	mov	r0, r4
    ed12:	01c9      	lsls	r1, r1, #7
    ed14:	f7f9 fbf6 	bl	8504 <HemisphereApplet::gfxPrintVoltage(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    ed18:	6f63      	ldr	r3, [r4, #116]	; 0x74
            gfxPrint(16, 25 + (ch * 20), Proportion(level[ch], 63, 100));
    ed1a:	69a0      	ldr	r0, [r4, #24]
    ed1c:	039b      	lsls	r3, r3, #14
    ed1e:	fb93 f3f6 	sdiv	r3, r3, r6
        int scaled = simfloat2int(proportion * max_value);
    ed22:	436b      	muls	r3, r5
    ed24:	139b      	asrs	r3, r3, #14
    ed26:	222d      	movs	r2, #45	; 0x2d
    ed28:	2110      	movs	r1, #16
    ed2a:	f7f5 fea1 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        graphics.print(str);
    ed2e:	490e      	ldr	r1, [pc, #56]	; (ed68 <AttenuateOffset::DrawInterface()+0xb4>)
    ed30:	480e      	ldr	r0, [pc, #56]	; (ed6c <AttenuateOffset::DrawInterface()+0xb8>)
    ed32:	f00a fed0 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        int ch = cursor / 2;
    ed36:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    ed38:	eb03 72d3 	add.w	r2, r3, r3, lsr #31
    ed3c:	1052      	asrs	r2, r2, #1
        if (cursor == 0 or cursor == 2) gfxCursor(13, 23 + (ch * 20), 36);
    ed3e:	f033 0302 	bics.w	r3, r3, #2
    ed42:	f04f 0314 	mov.w	r3, #20
    ed46:	fb03 f202 	mul.w	r2, r3, r2
    ed4a:	bf08      	it	eq
    ed4c:	3217      	addeq	r2, #23
    ed4e:	f04f 0324 	mov.w	r3, #36	; 0x24
        else gfxCursor(13, 33 + (ch * 20), 36);
    ed52:	bf18      	it	ne
    ed54:	3221      	addne	r2, #33	; 0x21
    ed56:	210d      	movs	r1, #13
    ed58:	4620      	mov	r0, r4
    ed5a:	f7f9 fbb9 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
    ed5e:	bd70      	pop	{r4, r5, r6, pc}
    ed60:	0001f297 	.word	0x0001f297
    ed64:	0001f2a3 	.word	0x0001f2a3
    ed68:	000204fb 	.word	0x000204fb
    ed6c:	200065e0 	.word	0x200065e0
    ed70:	0001f29a 	.word	0x0001f29a
    ed74:	0001f2a6 	.word	0x0001f2a6

0000ed78 <AttenuateOffset::View()>:
        gfxHeader(applet_name());
    ed78:	6803      	ldr	r3, [r0, #0]
    void View() {
    ed7a:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    ed7c:	681b      	ldr	r3, [r3, #0]
    void View() {
    ed7e:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    ed80:	4798      	blx	r3
    ed82:	4601      	mov	r1, r0
    ed84:	4620      	mov	r0, r4
    ed86:	f7f9 fc3a 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
    ed8a:	4620      	mov	r0, r4
    ed8c:	f7ff ff92 	bl	ecb4 <AttenuateOffset::DrawInterface()>
    }
    ed90:	bd10      	pop	{r4, pc}

0000ed92 <BootsNCat::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
    ed92:	b570      	push	{r4, r5, r6, lr}
        tone[0] = Unpack(data, PackLocation {0,6});
    ed94:	2300      	movs	r3, #0
    ed96:	2606      	movs	r6, #6
    void OnDataReceive(uint32_t data) {
    ed98:	460d      	mov	r5, r1
    ed9a:	b08a      	sub	sp, #40	; 0x28
    ed9c:	4604      	mov	r4, r0
        tone[0] = Unpack(data, PackLocation {0,6});
    ed9e:	4619      	mov	r1, r3
    eda0:	4632      	mov	r2, r6
    eda2:	4628      	mov	r0, r5
    eda4:	e9cd 3600 	strd	r3, r6, [sp]
    eda8:	f7f5 f842 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        decay[0] = Unpack(data, PackLocation {6,6});
    edac:	4632      	mov	r2, r6
        tone[0] = Unpack(data, PackLocation {0,6});
    edae:	f8c4 0158 	str.w	r0, [r4, #344]	; 0x158
        decay[0] = Unpack(data, PackLocation {6,6});
    edb2:	4631      	mov	r1, r6
    edb4:	4628      	mov	r0, r5
    edb6:	e9cd 6602 	strd	r6, r6, [sp, #8]
    edba:	f7f5 f839 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        tone[1] = Unpack(data, PackLocation {12,6});
    edbe:	230c      	movs	r3, #12
        decay[0] = Unpack(data, PackLocation {6,6});
    edc0:	f8c4 0160 	str.w	r0, [r4, #352]	; 0x160
        tone[1] = Unpack(data, PackLocation {12,6});
    edc4:	4632      	mov	r2, r6
    edc6:	4619      	mov	r1, r3
    edc8:	4628      	mov	r0, r5
    edca:	e9cd 3604 	strd	r3, r6, [sp, #16]
    edce:	f7f5 f82f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        decay[1] = Unpack(data, PackLocation {18,6});
    edd2:	2312      	movs	r3, #18
        tone[1] = Unpack(data, PackLocation {12,6});
    edd4:	f8c4 015c 	str.w	r0, [r4, #348]	; 0x15c
        decay[1] = Unpack(data, PackLocation {18,6});
    edd8:	4632      	mov	r2, r6
    edda:	4619      	mov	r1, r3
    eddc:	4628      	mov	r0, r5
    edde:	e9cd 3606 	strd	r3, r6, [sp, #24]
    ede2:	f7f5 f825 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        blend = Unpack(data, PackLocation {24,6});
    ede6:	2318      	movs	r3, #24
    ede8:	e9cd 3608 	strd	r3, r6, [sp, #32]
    edec:	ab0a      	add	r3, sp, #40	; 0x28
        decay[1] = Unpack(data, PackLocation {18,6});
    edee:	f8c4 0164 	str.w	r0, [r4, #356]	; 0x164
        blend = Unpack(data, PackLocation {24,6});
    edf2:	e913 0006 	ldmdb	r3, {r1, r2}
    edf6:	4628      	mov	r0, r5
    edf8:	f7f5 f81a 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    edfc:	f884 0168 	strb.w	r0, [r4, #360]	; 0x168
    }
    ee00:	b00a      	add	sp, #40	; 0x28
    ee02:	bd70      	pop	{r4, r5, r6, pc}

0000ee04 <BootsNCat_OnDataReceive(bool, unsigned long)>:
void BootsNCat_OnDataReceive(bool hemisphere, uint32_t data) {BootsNCat_instance[hemisphere].OnDataReceive(data);}
    ee04:	b508      	push	{r3, lr}
    ee06:	4b04      	ldr	r3, [pc, #16]	; (ee18 <BootsNCat_OnDataReceive(bool, unsigned long)+0x14>)
    ee08:	f44f 72b6 	mov.w	r2, #364	; 0x16c
    ee0c:	fb02 3000 	mla	r0, r2, r0, r3
    ee10:	f7ff ffbf 	bl	ed92 <BootsNCat::OnDataReceive(unsigned long)>
    ee14:	bd08      	pop	{r3, pc}
    ee16:	bf00      	nop
    ee18:	1fffb390 	.word	0x1fffb390

0000ee1c <BootsNCat::DrawKnobAt(unsigned char, unsigned char, bool)>:
    void DrawKnobAt(byte y, byte value, bool is_cursor) {
    ee1c:	b573      	push	{r0, r1, r4, r5, r6, lr}
        byte p = is_cursor ? 1 : 3;
    ee1e:	2b00      	cmp	r3, #0
    ee20:	bf14      	ite	ne
    ee22:	2301      	movne	r3, #1
    ee24:	2303      	moveq	r3, #3
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    ee26:	0394      	lsls	r4, r2, #14
    ee28:	223f      	movs	r2, #63	; 0x3f
    ee2a:	fbb4 f4f2 	udiv	r4, r4, r2
        gfxDottedLine(x, y + 4, 62, y + 4, p);
    ee2e:	1d0a      	adds	r2, r1, #4
    ee30:	e9cd 2300 	strd	r2, r3, [sp]
    void DrawKnobAt(byte y, byte value, bool is_cursor) {
    ee34:	4605      	mov	r5, r0
    ee36:	460e      	mov	r6, r1
        gfxDottedLine(x, y + 4, 62, y + 4, p);
    ee38:	6980      	ldr	r0, [r0, #24]
    ee3a:	233e      	movs	r3, #62	; 0x3e
    ee3c:	212d      	movs	r1, #45	; 0x2d
    ee3e:	f7f5 fdbd 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        int scaled = simfloat2int(proportion * max_value);
    ee42:	0aa4      	lsrs	r4, r4, #10
        gfxRect(x + w, y, 2, 7);
    ee44:	2307      	movs	r3, #7
    ee46:	9300      	str	r3, [sp, #0]
    ee48:	69a8      	ldr	r0, [r5, #24]
    ee4a:	2302      	movs	r3, #2
    ee4c:	4632      	mov	r2, r6
    ee4e:	f104 012d 	add.w	r1, r4, #45	; 0x2d
    ee52:	f7f5 fdd5 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
    }
    ee56:	b002      	add	sp, #8
    ee58:	bd70      	pop	{r4, r5, r6, pc}
    ee5a:	Address 0x000000000000ee5a is out of bounds.


0000ee5c <BootsNCat::DrawInterface()>:
    void DrawInterface() {
    ee5c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ee5e:	4604      	mov	r4, r0
        gfxPrint(1, 15, "BD Tone");
    ee60:	4b35      	ldr	r3, [pc, #212]	; (ef38 <BootsNCat::DrawInterface()+0xdc>)
        gfxPrint(1, 25, "  Decay");
    ee62:	4d36      	ldr	r5, [pc, #216]	; (ef3c <BootsNCat::DrawInterface()+0xe0>)
        gfxPrint(1, 15, "BD Tone");
    ee64:	220f      	movs	r2, #15
    ee66:	2101      	movs	r1, #1
    ee68:	f7f9 fb3e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        DrawKnobAt(15, tone[0], cursor == 0);
    ee6c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    ee6e:	f894 2158 	ldrb.w	r2, [r4, #344]	; 0x158
    ee72:	fab3 f383 	clz	r3, r3
    ee76:	4620      	mov	r0, r4
    ee78:	095b      	lsrs	r3, r3, #5
    ee7a:	210f      	movs	r1, #15
    ee7c:	f7ff ffce 	bl	ee1c <BootsNCat::DrawKnobAt(unsigned char, unsigned char, bool)>
        gfxPrint(1, 25, "  Decay");
    ee80:	462b      	mov	r3, r5
    ee82:	4620      	mov	r0, r4
    ee84:	2219      	movs	r2, #25
    ee86:	2101      	movs	r1, #1
    ee88:	f7f9 fb2e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        DrawKnobAt(25, decay[0], cursor == 1);
    ee8c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    ee8e:	1e5a      	subs	r2, r3, #1
    ee90:	4253      	negs	r3, r2
    ee92:	4153      	adcs	r3, r2
    ee94:	4620      	mov	r0, r4
    ee96:	f894 2160 	ldrb.w	r2, [r4, #352]	; 0x160
    ee9a:	2119      	movs	r1, #25
    ee9c:	f7ff ffbe 	bl	ee1c <BootsNCat::DrawKnobAt(unsigned char, unsigned char, bool)>
        gfxPrint(1, 35, "SD Tone");
    eea0:	4620      	mov	r0, r4
    eea2:	4b27      	ldr	r3, [pc, #156]	; (ef40 <BootsNCat::DrawInterface()+0xe4>)
    eea4:	2223      	movs	r2, #35	; 0x23
    eea6:	2101      	movs	r1, #1
    eea8:	f7f9 fb1e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        DrawKnobAt(35, tone[1], cursor == 2);
    eeac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    eeae:	f894 215c 	ldrb.w	r2, [r4, #348]	; 0x15c
    eeb2:	1e99      	subs	r1, r3, #2
    eeb4:	424b      	negs	r3, r1
    eeb6:	414b      	adcs	r3, r1
    eeb8:	4620      	mov	r0, r4
    eeba:	2123      	movs	r1, #35	; 0x23
    eebc:	f7ff ffae 	bl	ee1c <BootsNCat::DrawKnobAt(unsigned char, unsigned char, bool)>
        gfxPrint(1, 45, "  Decay");
    eec0:	462b      	mov	r3, r5
    eec2:	4620      	mov	r0, r4
    eec4:	222d      	movs	r2, #45	; 0x2d
    eec6:	2101      	movs	r1, #1
    eec8:	f7f9 fb0e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        DrawKnobAt(45, decay[1], cursor == 3);
    eecc:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    eece:	f894 2164 	ldrb.w	r2, [r4, #356]	; 0x164
    eed2:	1ed8      	subs	r0, r3, #3
    eed4:	4243      	negs	r3, r0
    eed6:	4143      	adcs	r3, r0
    eed8:	212d      	movs	r1, #45	; 0x2d
    eeda:	4620      	mov	r0, r4
    eedc:	f7ff ff9e 	bl	ee1c <BootsNCat::DrawKnobAt(unsigned char, unsigned char, bool)>
        gfxPrint(1, 55, "Blend");
    eee0:	4620      	mov	r0, r4
    eee2:	4b18      	ldr	r3, [pc, #96]	; (ef44 <BootsNCat::DrawInterface()+0xe8>)
    eee4:	2237      	movs	r2, #55	; 0x37
    eee6:	2101      	movs	r1, #1
    eee8:	f7f9 fafe 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        DrawKnobAt(55, blend, cursor == 4);
    eeec:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    eeee:	f894 2168 	ldrb.w	r2, [r4, #360]	; 0x168
    eef2:	1f1d      	subs	r5, r3, #4
    eef4:	426b      	negs	r3, r5
    eef6:	416b      	adcs	r3, r5
    eef8:	4620      	mov	r0, r4
    eefa:	2137      	movs	r1, #55	; 0x37
    eefc:	f7ff ff8e 	bl	ee1c <BootsNCat::DrawKnobAt(unsigned char, unsigned char, bool)>
        ForEachChannel(ch) gfxInvert(1, 14 + (20 * ch), ProportionCV(levels[ch], 42), 9);
    ef00:	f8d4 0150 	ldr.w	r0, [r4, #336]	; 0x150
    ef04:	212a      	movs	r1, #42	; 0x2a
    ef06:	f7f5 fbad 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
    ef0a:	2509      	movs	r5, #9
    ef0c:	4603      	mov	r3, r0
    ef0e:	220e      	movs	r2, #14
    ef10:	4620      	mov	r0, r4
    ef12:	9500      	str	r5, [sp, #0]
    ef14:	2101      	movs	r1, #1
    ef16:	f7f9 fb35 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
    ef1a:	f8d4 0154 	ldr.w	r0, [r4, #340]	; 0x154
    ef1e:	212a      	movs	r1, #42	; 0x2a
    ef20:	f7f5 fba0 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
    ef24:	9500      	str	r5, [sp, #0]
    ef26:	4603      	mov	r3, r0
    ef28:	2222      	movs	r2, #34	; 0x22
    ef2a:	2101      	movs	r1, #1
    ef2c:	4620      	mov	r0, r4
    ef2e:	f7f9 fb29 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
    }
    ef32:	b003      	add	sp, #12
    ef34:	bd30      	pop	{r4, r5, pc}
    ef36:	bf00      	nop
    ef38:	0002125f 	.word	0x0002125f
    ef3c:	00021267 	.word	0x00021267
    ef40:	0002126f 	.word	0x0002126f
    ef44:	00021277 	.word	0x00021277

0000ef48 <BootsNCat::View()>:
        gfxHeader(applet_name());
    ef48:	6803      	ldr	r3, [r0, #0]
    void View() {
    ef4a:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    ef4c:	681b      	ldr	r3, [r3, #0]
    void View() {
    ef4e:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    ef50:	4798      	blx	r3
    ef52:	4601      	mov	r1, r0
    ef54:	4620      	mov	r0, r4
    ef56:	f7f9 fb52 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
    ef5a:	4620      	mov	r0, r4
    ef5c:	f7ff ff7e 	bl	ee5c <BootsNCat::DrawInterface()>
    }
    ef60:	bd10      	pop	{r4, pc}

0000ef62 <BootsNCat::SetBDFreq()>:
    void SetBDFreq() {
    ef62:	b508      	push	{r3, lr}
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    ef64:	f8d0 3158 	ldr.w	r3, [r0, #344]	; 0x158
    ef68:	0399      	lsls	r1, r3, #14
    ef6a:	233f      	movs	r3, #63	; 0x3f
    ef6c:	fb91 f1f3 	sdiv	r1, r1, r3
        int scaled = simfloat2int(proportion * max_value);
    ef70:	f640 33b8 	movw	r3, #3000	; 0xbb8
    ef74:	4359      	muls	r1, r3
    ef76:	1389      	asrs	r1, r1, #14
        bass.SetFrequency(Proportion(tone[0], BNC_MAX_PARAM, 3000) + 3000);
    ef78:	4419      	add	r1, r3
    ef7a:	3070      	adds	r0, #112	; 0x70
    ef7c:	f7fe fb44 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
    }
    ef80:	bd08      	pop	{r3, pc}

0000ef82 <BootsNCat::SetEGFreq(unsigned char)>:
    void SetEGFreq(byte ch) {
    ef82:	b508      	push	{r3, lr}
        eg[ch].SetFrequency(1000 - Proportion(decay[ch], BNC_MAX_PARAM, 900));
    ef84:	f101 0358 	add.w	r3, r1, #88	; 0x58
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    ef88:	223f      	movs	r2, #63	; 0x3f
    ef8a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    ef8e:	039b      	lsls	r3, r3, #14
    ef90:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    ef94:	f44f 7261 	mov.w	r2, #900	; 0x384
    ef98:	4353      	muls	r3, r2
    ef9a:	2248      	movs	r2, #72	; 0x48
    ef9c:	fb02 0001 	mla	r0, r2, r1, r0
    efa0:	139b      	asrs	r3, r3, #14
    efa2:	f5c3 717a 	rsb	r1, r3, #1000	; 0x3e8
    efa6:	30b8      	adds	r0, #184	; 0xb8
    efa8:	f7fe fb2e 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
    }
    efac:	bd08      	pop	{r3, pc}

0000efae <BootsNCat::Start()>:
    void Start() {
    efae:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        tone[1] = 55; // Snare low limit
    efb2:	2337      	movs	r3, #55	; 0x37
    void Start() {
    efb4:	b092      	sub	sp, #72	; 0x48
        blend = 0;
    efb6:	2500      	movs	r5, #0
        tone[0] = 32; // Bass drum freq
    efb8:	2120      	movs	r1, #32
        tone[1] = 55; // Snare low limit
    efba:	f8c0 315c 	str.w	r3, [r0, #348]	; 0x15c
        noise_tone_countdown = 1;
    efbe:	f04f 0801 	mov.w	r8, #1
        decay[1] = 16; // Snare decay
    efc2:	2310      	movs	r3, #16
    void Start() {
    efc4:	4604      	mov	r4, r0
        decay[1] = 16; // Snare decay
    efc6:	f8c0 3164 	str.w	r3, [r0, #356]	; 0x164
        bass = WaveformManager::VectorOscillatorFromWaveform(HS::Triangle);
    efca:	2746      	movs	r7, #70	; 0x46
        tone[0] = 32; // Bass drum freq
    efcc:	f8c0 1158 	str.w	r1, [r0, #344]	; 0x158
        decay[0] = 32; // Bass drum decay
    efd0:	f8c0 1160 	str.w	r1, [r0, #352]	; 0x160
        noise_tone_countdown = 1;
    efd4:	f8c0 8148 	str.w	r8, [r0, #328]	; 0x148
        blend = 0;
    efd8:	f880 5168 	strb.w	r5, [r0, #360]	; 0x168
        bass = WaveformManager::VectorOscillatorFromWaveform(HS::Triangle);
    efdc:	4668      	mov	r0, sp
    efde:	f7fe fd8b 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
    efe2:	463a      	mov	r2, r7
    efe4:	4669      	mov	r1, sp
    efe6:	f104 0070 	add.w	r0, r4, #112	; 0x70
    efea:	f00b f801 	bl	19ff0 <memcpy>
    void SetScale(uint16_t scale_) {scale = scale_;}
    efee:	f44f 5690 	mov.w	r6, #4608	; 0x1200
        SetBDFreq();
    eff2:	4620      	mov	r0, r4
    eff4:	f7ff ffb5 	bl	ef62 <BootsNCat::SetBDFreq()>
            eg[ch] = WaveformManager::VectorOscillatorFromWaveform(HS::Sawtooth);
    eff8:	4668      	mov	r0, sp
    effa:	f8a4 60a4 	strh.w	r6, [r4, #164]	; 0xa4
            levels[ch] = 0;
    effe:	f8c4 5150 	str.w	r5, [r4, #336]	; 0x150
            eg[ch] = WaveformManager::VectorOscillatorFromWaveform(HS::Sawtooth);
    f002:	2121      	movs	r1, #33	; 0x21
    f004:	f7fe fd78 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
    f008:	f104 03b8 	add.w	r3, r4, #184	; 0xb8
    f00c:	463a      	mov	r2, r7
    f00e:	4669      	mov	r1, sp
    f010:	4618      	mov	r0, r3
    f012:	f00a ffed 	bl	19ff0 <memcpy>
            eg[ch].SetFrequency(decay[ch]);
    f016:	f8d4 1160 	ldr.w	r1, [r4, #352]	; 0x160
    f01a:	f7fe faf5 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
    f01e:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
    f022:	f8a4 30ec 	strh.w	r3, [r4, #236]	; 0xec
    void Offset(int32_t offset_) {offset = offset_;}
    f026:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
            SetEGFreq(ch);
    f02a:	4629      	mov	r1, r5
    f02c:	4620      	mov	r0, r4
    void Cycle(bool cycle_ = 1) {cycle = cycle_;}
    f02e:	f884 50f4 	strb.w	r5, [r4, #244]	; 0xf4
    f032:	f7ff ffa6 	bl	ef82 <BootsNCat::SetEGFreq(unsigned char)>
            eg[ch] = WaveformManager::VectorOscillatorFromWaveform(HS::Sawtooth);
    f036:	4668      	mov	r0, sp
            levels[ch] = 0;
    f038:	f8c4 5154 	str.w	r5, [r4, #340]	; 0x154
            eg[ch] = WaveformManager::VectorOscillatorFromWaveform(HS::Sawtooth);
    f03c:	2121      	movs	r1, #33	; 0x21
    f03e:	f7fe fd5b 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
    f042:	f504 7380 	add.w	r3, r4, #256	; 0x100
    f046:	463a      	mov	r2, r7
    f048:	4618      	mov	r0, r3
    f04a:	4669      	mov	r1, sp
    f04c:	f00a ffd0 	bl	19ff0 <memcpy>
            eg[ch].SetFrequency(decay[ch]);
    f050:	f8d4 1164 	ldr.w	r1, [r4, #356]	; 0x164
    f054:	f7fe fad8 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
    void SetScale(uint16_t scale_) {scale = scale_;}
    f058:	f8a4 6134 	strh.w	r6, [r4, #308]	; 0x134
    void Offset(int32_t offset_) {offset = offset_;}
    f05c:	f8c4 6140 	str.w	r6, [r4, #320]	; 0x140
    void Cycle(bool cycle_ = 1) {cycle = cycle_;}
    f060:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
            SetEGFreq(ch);
    f064:	4641      	mov	r1, r8
    f066:	4620      	mov	r0, r4
    f068:	f7ff ff8b 	bl	ef82 <BootsNCat::SetEGFreq(unsigned char)>
    }
    f06c:	b012      	add	sp, #72	; 0x48
    f06e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f072:	Address 0x000000000000f072 is out of bounds.


0000f074 <BootsNCat_OnEncoderMove(bool, int)>:
void BootsNCat_OnEncoderMove(bool hemisphere, int direction) {BootsNCat_instance[hemisphere].OnEncoderMove(direction);}
    f074:	b538      	push	{r3, r4, r5, lr}
    f076:	4603      	mov	r3, r0
    f078:	481e      	ldr	r0, [pc, #120]	; (f0f4 <BootsNCat_OnEncoderMove(bool, int)+0x80>)
    f07a:	f44f 74b6 	mov.w	r4, #364	; 0x16c
    f07e:	fb04 0403 	mla	r4, r4, r3, r0
    f082:	460d      	mov	r5, r1
        if (cursor == 4) { // Blend
    f084:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    f086:	2904      	cmp	r1, #4
    f088:	d10a      	bne.n	f0a0 <BootsNCat_OnEncoderMove(bool, int)+0x2c>
            blend = constrain(blend + direction, 0, BNC_MAX_PARAM);
    f08a:	f994 3168 	ldrsb.w	r3, [r4, #360]	; 0x168
    f08e:	442b      	add	r3, r5
    f090:	f383 0306 	usat	r3, #6, r3
    f094:	f884 3168 	strb.w	r3, [r4, #360]	; 0x168
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    f098:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    f09c:	64a3      	str	r3, [r4, #72]	; 0x48
void BootsNCat_OnEncoderMove(bool hemisphere, int direction) {BootsNCat_instance[hemisphere].OnEncoderMove(direction);}
    f09e:	bd38      	pop	{r3, r4, r5, pc}
            byte c = cursor;
    f0a0:	b2ca      	uxtb	r2, r1
            byte ch = cursor > 1 ? 1 : 0;
    f0a2:	2901      	cmp	r1, #1
            if (ch) c -= 2;
    f0a4:	bfc3      	ittte	gt
    f0a6:	3a02      	subgt	r2, #2
    f0a8:	b2d2      	uxtbgt	r2, r2
            byte ch = cursor > 1 ? 1 : 0;
    f0aa:	2101      	movgt	r1, #1
    f0ac:	2100      	movle	r1, #0
            if (c == 0) { // Tone
    f0ae:	b982      	cbnz	r2, f0d2 <BootsNCat_OnEncoderMove(bool, int)+0x5e>
                tone[ch] = constrain(tone[ch] + direction, 0, BNC_MAX_PARAM);
    f0b0:	225b      	movs	r2, #91	; 0x5b
    f0b2:	fb02 1303 	mla	r3, r2, r3, r1
    f0b6:	3356      	adds	r3, #86	; 0x56
    f0b8:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    f0bc:	442a      	add	r2, r5
    f0be:	f382 0206 	usat	r2, #6, r2
    f0c2:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
                if (ch == 0) SetBDFreq();
    f0c6:	2900      	cmp	r1, #0
    f0c8:	d1e6      	bne.n	f098 <BootsNCat_OnEncoderMove(bool, int)+0x24>
    f0ca:	4620      	mov	r0, r4
    f0cc:	f7ff ff49 	bl	ef62 <BootsNCat::SetBDFreq()>
    f0d0:	e7e2      	b.n	f098 <BootsNCat_OnEncoderMove(bool, int)+0x24>
            if (c == 1) { // Decay
    f0d2:	2a01      	cmp	r2, #1
    f0d4:	d1e0      	bne.n	f098 <BootsNCat_OnEncoderMove(bool, int)+0x24>
                decay[ch] = constrain(decay[ch] + direction, 0, BNC_MAX_PARAM);
    f0d6:	225b      	movs	r2, #91	; 0x5b
    f0d8:	fb02 1303 	mla	r3, r2, r3, r1
    f0dc:	3358      	adds	r3, #88	; 0x58
    f0de:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    f0e2:	442a      	add	r2, r5
    f0e4:	f382 0206 	usat	r2, #6, r2
    f0e8:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
                SetEGFreq(ch);
    f0ec:	4620      	mov	r0, r4
    f0ee:	f7ff ff48 	bl	ef82 <BootsNCat::SetEGFreq(unsigned char)>
    f0f2:	e7d1      	b.n	f098 <BootsNCat_OnEncoderMove(bool, int)+0x24>
    f0f4:	1fffb390 	.word	0x1fffb390

0000f0f8 <Brancher::DrawInterface()>:
	void DrawInterface() {
    f0f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    f0fa:	4604      	mov	r4, r0
        gfxPrint(1, 15, "p=");
    f0fc:	4b20      	ldr	r3, [pc, #128]	; (f180 <Brancher::DrawInterface()+0x88>)
    f0fe:	220f      	movs	r2, #15
    f100:	2101      	movs	r1, #1
    f102:	f7f9 f9f1 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(15 + pad(100, p), 15, p);
    f106:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    f108:	2064      	movs	r0, #100	; 0x64
    f10a:	4629      	mov	r1, r5
    f10c:	f7f5 fab9 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    f110:	220f      	movs	r2, #15
    f112:	1881      	adds	r1, r0, r2
    f114:	462b      	mov	r3, r5
    f116:	69a0      	ldr	r0, [r4, #24]
    f118:	f7f5 fcaa 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxPrint(33, 15, hemisphere ? "% C" : "% A");
    f11c:	7921      	ldrb	r1, [r4, #4]
    f11e:	4a19      	ldr	r2, [pc, #100]	; (f184 <Brancher::DrawInterface()+0x8c>)
    f120:	4b19      	ldr	r3, [pc, #100]	; (f188 <Brancher::DrawInterface()+0x90>)
    f122:	4620      	mov	r0, r4
    f124:	2900      	cmp	r1, #0
    f126:	bf08      	it	eq
    f128:	4613      	moveq	r3, r2
    f12a:	220f      	movs	r2, #15
    f12c:	2121      	movs	r1, #33	; 0x21
    f12e:	f7f9 f9db 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxCursor(15, 23, 18);
    f132:	4620      	mov	r0, r4
    f134:	2312      	movs	r3, #18
    f136:	2217      	movs	r2, #23
    f138:	210f      	movs	r1, #15
    f13a:	f7f9 f9c9 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        gfxPrint(12, 45, hemisphere ? "C" : "A");
    f13e:	7921      	ldrb	r1, [r4, #4]
    f140:	4a12      	ldr	r2, [pc, #72]	; (f18c <Brancher::DrawInterface()+0x94>)
    f142:	4b13      	ldr	r3, [pc, #76]	; (f190 <Brancher::DrawInterface()+0x98>)
    f144:	4620      	mov	r0, r4
    f146:	2900      	cmp	r1, #0
    f148:	bf08      	it	eq
    f14a:	4613      	moveq	r3, r2
    f14c:	222d      	movs	r2, #45	; 0x2d
    f14e:	210c      	movs	r1, #12
    f150:	f7f9 f9ca 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(44, 45, hemisphere ? "D" : "B");
    f154:	7921      	ldrb	r1, [r4, #4]
    f156:	4a0f      	ldr	r2, [pc, #60]	; (f194 <Brancher::DrawInterface()+0x9c>)
    f158:	4b0f      	ldr	r3, [pc, #60]	; (f198 <Brancher::DrawInterface()+0xa0>)
    f15a:	4620      	mov	r0, r4
    f15c:	2900      	cmp	r1, #0
    f15e:	bf08      	it	eq
    f160:	4613      	moveq	r3, r2
    f162:	222d      	movs	r2, #45	; 0x2d
    f164:	212c      	movs	r1, #44	; 0x2c
    f166:	f7f9 f9bf 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxFrame(9 + (32 * choice), 42, 13, 13);
    f16a:	6f21      	ldr	r1, [r4, #112]	; 0x70
    f16c:	69a0      	ldr	r0, [r4, #24]
    f16e:	230d      	movs	r3, #13
    f170:	0149      	lsls	r1, r1, #5
    f172:	9300      	str	r3, [sp, #0]
    f174:	222a      	movs	r2, #42	; 0x2a
    f176:	3109      	adds	r1, #9
    f178:	f7f5 fc48 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
	}
    f17c:	b003      	add	sp, #12
    f17e:	bd30      	pop	{r4, r5, pc}
    f180:	00020fc5 	.word	0x00020fc5
    f184:	00021281 	.word	0x00021281
    f188:	0002127d 	.word	0x0002127d
    f18c:	00021283 	.word	0x00021283
    f190:	0002127f 	.word	0x0002127f
    f194:	00021b62 	.word	0x00021b62
    f198:	00021b74 	.word	0x00021b74

0000f19c <Brancher::View()>:
    void View() {
    f19c:	b510      	push	{r4, lr}
        gfxHeader("Brancher");
    f19e:	4904      	ldr	r1, [pc, #16]	; (f1b0 <Brancher::View()+0x14>)
    void View() {
    f1a0:	4604      	mov	r4, r0
        gfxHeader("Brancher");
    f1a2:	f7f9 fa2c 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
    f1a6:	4620      	mov	r0, r4
    f1a8:	f7ff ffa6 	bl	f0f8 <Brancher::DrawInterface()>
    }
    f1ac:	bd10      	pop	{r4, pc}
    f1ae:	bf00      	nop
    f1b0:	00020576 	.word	0x00020576

0000f1b4 <Burst::get_effective_spacing()>:
    int get_effective_spacing() {
    f1b4:	4603      	mov	r3, r0
        int effective_spacing = spacing;
    f1b6:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
        if (clocked) {
    f1ba:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
    f1be:	b152      	cbz	r2, f1d6 <Burst::get_effective_spacing()+0x22>
            if (div > 1) effective_spacing *= div;
    f1c0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    f1c4:	2b01      	cmp	r3, #1
    f1c6:	dd01      	ble.n	f1cc <Burst::get_effective_spacing()+0x18>
    f1c8:	4358      	muls	r0, r3
            if (div < 0) effective_spacing /= -div;
    f1ca:	4770      	bx	lr
    f1cc:	2b00      	cmp	r3, #0
    f1ce:	bfbc      	itt	lt
    f1d0:	425b      	neglt	r3, r3
    f1d2:	fb90 f0f3 	sdivlt	r0, r0, r3
    }
    f1d6:	4770      	bx	lr

0000f1d8 <Burst::DrawSelector()>:
    void DrawSelector() {
    f1d8:	b513      	push	{r0, r1, r4, lr}
        gfxPrint(1, 15, number);
    f1da:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
    void DrawSelector() {
    f1de:	4604      	mov	r4, r0
        gfxPrint(1, 15, number);
    f1e0:	220f      	movs	r2, #15
    f1e2:	6980      	ldr	r0, [r0, #24]
    f1e4:	2101      	movs	r1, #1
    f1e6:	f7f5 fc43 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxPrint(28, 15, "bursts");
    f1ea:	4b29      	ldr	r3, [pc, #164]	; (f290 <Burst::DrawSelector()+0xb8>)
    f1ec:	220f      	movs	r2, #15
    f1ee:	211c      	movs	r1, #28
    f1f0:	4620      	mov	r0, r4
    f1f2:	f7f9 f979 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(1, 25, clocked ? get_effective_spacing() : spacing);
    f1f6:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    f1fa:	2b00      	cmp	r3, #0
    f1fc:	d044      	beq.n	f288 <Burst::DrawSelector()+0xb0>
    f1fe:	4620      	mov	r0, r4
    f200:	f7ff ffd8 	bl	f1b4 <Burst::get_effective_spacing()>
    f204:	4603      	mov	r3, r0
    f206:	69a0      	ldr	r0, [r4, #24]
    f208:	2219      	movs	r2, #25
    f20a:	2101      	movs	r1, #1
    f20c:	f7f5 fc30 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxPrint(28, 25, "ms");
    f210:	4b20      	ldr	r3, [pc, #128]	; (f294 <Burst::DrawSelector()+0xbc>)
    f212:	2219      	movs	r2, #25
    f214:	211c      	movs	r1, #28
    f216:	4620      	mov	r0, r4
    f218:	f7f9 f966 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (clocked) {
    f21c:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    f220:	b33b      	cbz	r3, f272 <Burst::DrawSelector()+0x9a>
            gfxBitmap(1, 35, 8, CLOCK_ICON);
    f222:	4b1d      	ldr	r3, [pc, #116]	; (f298 <Burst::DrawSelector()+0xc0>)
    f224:	69a0      	ldr	r0, [r4, #24]
    f226:	9300      	str	r3, [sp, #0]
    f228:	2223      	movs	r2, #35	; 0x23
    f22a:	2308      	movs	r3, #8
    f22c:	2101      	movs	r1, #1
    f22e:	f7f5 fbb1 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(11, 35, div < 0 ? "x" : "/");
    f232:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
    f236:	4a19      	ldr	r2, [pc, #100]	; (f29c <Burst::DrawSelector()+0xc4>)
    f238:	4b19      	ldr	r3, [pc, #100]	; (f2a0 <Burst::DrawSelector()+0xc8>)
    f23a:	4620      	mov	r0, r4
    f23c:	ea13 0321 	ands.w	r3, r3, r1, asr #32
    f240:	bf38      	it	cc
    f242:	4613      	movcc	r3, r2
    f244:	2223      	movs	r2, #35	; 0x23
    f246:	210b      	movs	r1, #11
    f248:	f7f9 f94e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(div < 0 ? -div : div);
    f24c:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
        graphics.print(num);
    f250:	4814      	ldr	r0, [pc, #80]	; (f2a4 <Burst::DrawSelector()+0xcc>)
    f252:	2900      	cmp	r1, #0
    f254:	bfb8      	it	lt
    f256:	4249      	neglt	r1, r1
    f258:	f00a fcb1 	bl	19bbe <weegfx::Graphics::print(int)>
            gfxPrint(div < 0 ? " Mult" : " Div");
    f25c:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
        graphics.print(str);
    f260:	4a11      	ldr	r2, [pc, #68]	; (f2a8 <Burst::DrawSelector()+0xd0>)
    f262:	4b12      	ldr	r3, [pc, #72]	; (f2ac <Burst::DrawSelector()+0xd4>)
    f264:	480f      	ldr	r0, [pc, #60]	; (f2a4 <Burst::DrawSelector()+0xcc>)
    f266:	ea12 0121 	ands.w	r1, r2, r1, asr #32
    f26a:	bf38      	it	cc
    f26c:	4619      	movcc	r1, r3
    f26e:	f00a fc32 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxCursor(1, 23 + (cursor * 10), 62);
    f272:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    f274:	230a      	movs	r3, #10
    f276:	435a      	muls	r2, r3
    f278:	3217      	adds	r2, #23
    f27a:	233e      	movs	r3, #62	; 0x3e
    f27c:	2101      	movs	r1, #1
    f27e:	4620      	mov	r0, r4
    f280:	f7f9 f926 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
    f284:	b002      	add	sp, #8
    f286:	bd10      	pop	{r4, pc}
        gfxPrint(1, 25, clocked ? get_effective_spacing() : spacing);
    f288:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    f28c:	e7bb      	b.n	f206 <Burst::DrawSelector()+0x2e>
    f28e:	bf00      	nop
    f290:	0002128b 	.word	0x0002128b
    f294:	0001f236 	.word	0x0001f236
    f298:	00023c28 	.word	0x00023c28
    f29c:	00021018 	.word	0x00021018
    f2a0:	00020ffe 	.word	0x00020ffe
    f2a4:	200065e0 	.word	0x200065e0
    f2a8:	00021285 	.word	0x00021285
    f2ac:	0002069a 	.word	0x0002069a

0000f2b0 <Burst::View()>:
        gfxHeader(applet_name());
    f2b0:	6803      	ldr	r3, [r0, #0]
    void View() {
    f2b2:	b573      	push	{r0, r1, r4, r5, r6, lr}
        gfxHeader(applet_name());
    f2b4:	681b      	ldr	r3, [r3, #0]
    void View() {
    f2b6:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    f2b8:	4798      	blx	r3
    f2ba:	4601      	mov	r1, r0
    f2bc:	4620      	mov	r0, r4
    f2be:	f7f9 f99e 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSelector();
    f2c2:	4620      	mov	r0, r4
    f2c4:	f7ff ff88 	bl	f1d8 <Burst::DrawSelector()>
        for (int i = 0; i < bursts_to_go; i++)
    f2c8:	2500      	movs	r5, #0
            gfxFrame(1 + (i * 5), 46, 4, 12);
    f2ca:	260c      	movs	r6, #12
        for (int i = 0; i < bursts_to_go; i++)
    f2cc:	6f63      	ldr	r3, [r4, #116]	; 0x74
    f2ce:	429d      	cmp	r5, r3
    f2d0:	db01      	blt.n	f2d6 <Burst::View()+0x26>
    }
    f2d2:	b002      	add	sp, #8
    f2d4:	bd70      	pop	{r4, r5, r6, pc}
            gfxFrame(1 + (i * 5), 46, 4, 12);
    f2d6:	eb05 0185 	add.w	r1, r5, r5, lsl #2
    f2da:	69a0      	ldr	r0, [r4, #24]
    f2dc:	9600      	str	r6, [sp, #0]
    f2de:	2304      	movs	r3, #4
    f2e0:	222e      	movs	r2, #46	; 0x2e
    f2e2:	3101      	adds	r1, #1
    f2e4:	f7f5 fb92 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
        for (int i = 0; i < bursts_to_go; i++)
    f2e8:	3501      	adds	r5, #1
    f2ea:	e7ef      	b.n	f2cc <Burst::View()+0x1c>

0000f2ec <Burst::Controller()>:
    void Controller() {
    f2ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        if (DetentedIn(0) > 0) {
    f2f0:	2100      	movs	r1, #0
    void Controller() {
    f2f2:	4604      	mov	r4, r0
        if (DetentedIn(0) > 0) {
    f2f4:	f7f9 fde6 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
    f2f8:	2800      	cmp	r0, #0
    f2fa:	4f4a      	ldr	r7, [pc, #296]	; (f424 <Burst::Controller()+0x138>)
    f2fc:	dd0e      	ble.n	f31c <Burst::Controller()+0x30>
            number = ProportionCV(In(0), HEM_BURST_NUMBER_MAX + 1);
    f2fe:	6a20      	ldr	r0, [r4, #32]
    f300:	210d      	movs	r1, #13
    f302:	f7f5 f9af 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
            number = constrain(number, 1, HEM_BURST_NUMBER_MAX);
    f306:	280c      	cmp	r0, #12
    f308:	bfa8      	it	ge
    f30a:	200c      	movge	r0, #12
    f30c:	2801      	cmp	r0, #1
            last_number_cv_tick = OC::CORE::ticks;
    f30e:	683b      	ldr	r3, [r7, #0]
    f310:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
            number = constrain(number, 1, HEM_BURST_NUMBER_MAX);
    f314:	bfb8      	it	lt
    f316:	2001      	movlt	r0, #1
    f318:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
        int spacing_mod = clocked ? 0 : Proportion(DetentedIn(1), HEMISPHERE_MAX_CV, 500);
    f31c:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    f320:	2b00      	cmp	r3, #0
    f322:	d169      	bne.n	f3f8 <Burst::Controller()+0x10c>
    f324:	2101      	movs	r1, #1
    f326:	4620      	mov	r0, r4
    f328:	f7f9 fdcc 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    f32c:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
    f330:	0383      	lsls	r3, r0, #14
    f332:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    f336:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    f33a:	4353      	muls	r3, r2
    f33c:	139d      	asrs	r5, r3, #14
        if (Clock(0)) {
    f33e:	2200      	movs	r2, #0
    f340:	4611      	mov	r1, r2
    f342:	4620      	mov	r0, r4
    f344:	f7fa f91e 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    f348:	b178      	cbz	r0, f36a <Burst::Controller()+0x7e>
            if (clocked) {
    f34a:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
                spacing = (ticks_since_clock / number) / 17;
    f34e:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
            if (clocked) {
    f350:	2a00      	cmp	r2, #0
    f352:	d053      	beq.n	f3fc <Burst::Controller()+0x110>
                spacing = (ticks_since_clock / number) / 17;
    f354:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
    f358:	fb93 f3f2 	sdiv	r3, r3, r2
    f35c:	2211      	movs	r2, #17
    f35e:	fb93 f3f2 	sdiv	r3, r3, r2
    f362:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
                ticks_since_clock = 0;
    f366:	2300      	movs	r3, #0
    f368:	67e3      	str	r3, [r4, #124]	; 0x7c
        ticks_since_clock++;
    f36a:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    f36c:	3301      	adds	r3, #1
    f36e:	67e3      	str	r3, [r4, #124]	; 0x7c
        int effective_spacing = get_effective_spacing();
    f370:	4620      	mov	r0, r4
    f372:	f7ff ff1f 	bl	f1b4 <Burst::get_effective_spacing()>
        if (bursts_to_go > 0) {
    f376:	f8d4 8074 	ldr.w	r8, [r4, #116]	; 0x74
    f37a:	f1b8 0f00 	cmp.w	r8, #0
        int effective_spacing = get_effective_spacing();
    f37e:	4606      	mov	r6, r0
        if (bursts_to_go > 0) {
    f380:	dd14      	ble.n	f3ac <Burst::Controller()+0xc0>
            if (--burst_countdown <= 0) {
    f382:	6f23      	ldr	r3, [r4, #112]	; 0x70
    f384:	3b01      	subs	r3, #1
    f386:	2b00      	cmp	r3, #0
    f388:	6723      	str	r3, [r4, #112]	; 0x70
    f38a:	dc0f      	bgt.n	f3ac <Burst::Controller()+0xc0>
                ClockOut(0);
    f38c:	2264      	movs	r2, #100	; 0x64
    f38e:	2100      	movs	r1, #0
    f390:	4620      	mov	r0, r4
    f392:	f7fa fac8 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
                if (--bursts_to_go > 0) burst_countdown = modded_spacing * 17; // Reset for next burst
    f396:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
    f39a:	6762      	str	r2, [r4, #116]	; 0x74
    f39c:	b392      	cbz	r2, f404 <Burst::Controller()+0x118>
                int modded_spacing = effective_spacing + spacing_mod;
    f39e:	19ab      	adds	r3, r5, r6
                if (--bursts_to_go > 0) burst_countdown = modded_spacing * 17; // Reset for next burst
    f3a0:	2b08      	cmp	r3, #8
    f3a2:	bfb8      	it	lt
    f3a4:	2308      	movlt	r3, #8
    f3a6:	eb03 1303 	add.w	r3, r3, r3, lsl #4
    f3aa:	6723      	str	r3, [r4, #112]	; 0x70
        bool number_is_changing = (OC::CORE::ticks - last_number_cv_tick < 80000);
    f3ac:	683d      	ldr	r5, [r7, #0]
    f3ae:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
        if (Clock(1) && number_is_changing) StartADCLag();
    f3b2:	2200      	movs	r2, #0
    f3b4:	2101      	movs	r1, #1
    f3b6:	4620      	mov	r0, r4
        bool number_is_changing = (OC::CORE::ticks - last_number_cv_tick < 80000);
    f3b8:	1aed      	subs	r5, r5, r3
        if (Clock(1) && number_is_changing) StartADCLag();
    f3ba:	f7fa f8e3 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    f3be:	b120      	cbz	r0, f3ca <Burst::Controller()+0xde>
    f3c0:	4b19      	ldr	r3, [pc, #100]	; (f428 <Burst::Controller()+0x13c>)
    f3c2:	429d      	cmp	r5, r3
        adc_lag_countdown[ch] = HEMISPHERE_ADC_LAG;
    f3c4:	bf9c      	itt	ls
    f3c6:	2321      	movls	r3, #33	; 0x21
    f3c8:	64e3      	strls	r3, [r4, #76]	; 0x4c
        return (--adc_lag_countdown[ch] == 0);
    f3ca:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    f3cc:	3b01      	subs	r3, #1
    f3ce:	64e3      	str	r3, [r4, #76]	; 0x4c
        if (EndOfADCLag() || (Clock(1) && !number_is_changing)) {
    f3d0:	b9eb      	cbnz	r3, f40e <Burst::Controller()+0x122>
            ClockOut(0);
    f3d2:	2264      	movs	r2, #100	; 0x64
    f3d4:	2100      	movs	r1, #0
    f3d6:	4620      	mov	r0, r4
    f3d8:	f7fa faa5 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
            GateOut(1, 1);
    f3dc:	2201      	movs	r2, #1
    f3de:	4611      	mov	r1, r2
    f3e0:	4620      	mov	r0, r4
    f3e2:	f7fa fd76 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
            bursts_to_go = number - 1;
    f3e6:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
            burst_countdown = effective_spacing * 17;
    f3ea:	eb06 1606 	add.w	r6, r6, r6, lsl #4
            bursts_to_go = number - 1;
    f3ee:	3b01      	subs	r3, #1
    f3f0:	6763      	str	r3, [r4, #116]	; 0x74
            burst_countdown = effective_spacing * 17;
    f3f2:	6726      	str	r6, [r4, #112]	; 0x70
    }
    f3f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        int spacing_mod = clocked ? 0 : Proportion(DetentedIn(1), HEMISPHERE_MAX_CV, 500);
    f3f8:	2500      	movs	r5, #0
    f3fa:	e7a0      	b.n	f33e <Burst::Controller()+0x52>
            } else clocked = 1;
    f3fc:	2301      	movs	r3, #1
    f3fe:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    f402:	e7b2      	b.n	f36a <Burst::Controller()+0x7e>
                else GateOut(1, 0); // Turn off the gate
    f404:	2101      	movs	r1, #1
    f406:	4620      	mov	r0, r4
    f408:	f7fa fd63 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
    f40c:	e7ce      	b.n	f3ac <Burst::Controller()+0xc0>
        if (EndOfADCLag() || (Clock(1) && !number_is_changing)) {
    f40e:	2200      	movs	r2, #0
    f410:	2101      	movs	r1, #1
    f412:	4620      	mov	r0, r4
    f414:	f7fa f8b6 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    f418:	2800      	cmp	r0, #0
    f41a:	d0eb      	beq.n	f3f4 <Burst::Controller()+0x108>
    f41c:	4b02      	ldr	r3, [pc, #8]	; (f428 <Burst::Controller()+0x13c>)
    f41e:	429d      	cmp	r5, r3
    f420:	d8d7      	bhi.n	f3d2 <Burst::Controller()+0xe6>
    f422:	e7e7      	b.n	f3f4 <Burst::Controller()+0x108>
    f424:	200046cc 	.word	0x200046cc
    f428:	0001387f 	.word	0x0001387f

0000f42c <CVRecV2::DrawInterface()>:
    void DrawInterface() {
    f42c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    f430:	4604      	mov	r4, r0
        gfxIcon(1, 15, LOOP_ICON);
    f432:	4b5e      	ldr	r3, [pc, #376]	; (f5ac <CVRecV2::DrawInterface()+0x180>)
    f434:	6980      	ldr	r0, [r0, #24]
    f436:	220f      	movs	r2, #15
    f438:	2101      	movs	r1, #1
    f43a:	f7f5 fab1 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(18 + pad(100, start + 1), 15, start + 1);
    f43e:	f9b4 56f4 	ldrsh.w	r5, [r4, #1780]	; 0x6f4
    f442:	3501      	adds	r5, #1
    f444:	4629      	mov	r1, r5
    f446:	2064      	movs	r0, #100	; 0x64
    f448:	f7f5 f91b 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    f44c:	462b      	mov	r3, r5
    f44e:	220f      	movs	r2, #15
    f450:	f100 0112 	add.w	r1, r0, #18
    f454:	69a0      	ldr	r0, [r4, #24]
    f456:	f7f5 fb0b 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        graphics.print(str);
    f45a:	4955      	ldr	r1, [pc, #340]	; (f5b0 <CVRecV2::DrawInterface()+0x184>)
    f45c:	4855      	ldr	r0, [pc, #340]	; (f5b4 <CVRecV2::DrawInterface()+0x188>)
    f45e:	f00a fb3a 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(pad(100, end + 1), end + 1);
    f462:	f9b4 56f6 	ldrsh.w	r5, [r4, #1782]	; 0x6f6
    f466:	3501      	adds	r5, #1
    f468:	4629      	mov	r1, r5
    f46a:	2064      	movs	r0, #100	; 0x64
    f46c:	f7f5 f909 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    f470:	4629      	mov	r1, r5
    f472:	f7f5 fae1 	bl	4a38 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]>
        gfxPrint(1, 25, "Smooth");
    f476:	4b50      	ldr	r3, [pc, #320]	; (f5b8 <CVRecV2::DrawInterface()+0x18c>)
    f478:	2219      	movs	r2, #25
    f47a:	2101      	movs	r1, #1
    f47c:	4620      	mov	r0, r4
    f47e:	f7f9 f833 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor != 2 || CursorBlink()) gfxIcon(54, 25, smooth ? CHECK_ON_ICON : CHECK_OFF_ICON);
    f482:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    f484:	2b02      	cmp	r3, #2
    f486:	d102      	bne.n	f48e <CVRecV2::DrawInterface()+0x62>
    f488:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    f48a:	2b00      	cmp	r3, #0
    f48c:	dd0b      	ble.n	f4a6 <CVRecV2::DrawInterface()+0x7a>
    f48e:	f894 16ec 	ldrb.w	r1, [r4, #1772]	; 0x6ec
    f492:	4a4a      	ldr	r2, [pc, #296]	; (f5bc <CVRecV2::DrawInterface()+0x190>)
    f494:	4b4a      	ldr	r3, [pc, #296]	; (f5c0 <CVRecV2::DrawInterface()+0x194>)
    f496:	69a0      	ldr	r0, [r4, #24]
    f498:	2900      	cmp	r1, #0
    f49a:	bf08      	it	eq
    f49c:	4613      	moveq	r3, r2
    f49e:	2219      	movs	r2, #25
    f4a0:	2136      	movs	r1, #54	; 0x36
    f4a2:	f7f5 fa7d 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(1, 35, CVRecV2_MODES[mode]);
    f4a6:	f8d4 26f0 	ldr.w	r2, [r4, #1776]	; 0x6f0
    f4aa:	4b46      	ldr	r3, [pc, #280]	; (f5c4 <CVRecV2::DrawInterface()+0x198>)
    f4ac:	2101      	movs	r1, #1
    f4ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    f4b2:	4620      	mov	r0, r4
    f4b4:	2223      	movs	r2, #35	; 0x23
    f4b6:	f7f9 f817 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor == 0) gfxCursor(19, 23, 18);
    f4ba:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    f4bc:	b92b      	cbnz	r3, f4ca <CVRecV2::DrawInterface()+0x9e>
    f4be:	2312      	movs	r3, #18
    f4c0:	2217      	movs	r2, #23
    f4c2:	2113      	movs	r1, #19
    f4c4:	4620      	mov	r0, r4
    f4c6:	f7f9 f803 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 1) gfxCursor(43, 23, 18);
    f4ca:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    f4cc:	2b01      	cmp	r3, #1
    f4ce:	d105      	bne.n	f4dc <CVRecV2::DrawInterface()+0xb0>
    f4d0:	2312      	movs	r3, #18
    f4d2:	2217      	movs	r2, #23
    f4d4:	212b      	movs	r1, #43	; 0x2b
    f4d6:	4620      	mov	r0, r4
    f4d8:	f7f8 fffa 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 3) gfxCursor(1, 43, 63);
    f4dc:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    f4de:	2b03      	cmp	r3, #3
    f4e0:	d105      	bne.n	f4ee <CVRecV2::DrawInterface()+0xc2>
    f4e2:	233f      	movs	r3, #63	; 0x3f
    f4e4:	222b      	movs	r2, #43	; 0x2b
    f4e6:	2101      	movs	r1, #1
    f4e8:	4620      	mov	r0, r4
    f4ea:	f7f8 fff1 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (mode > 0 && punch_out > 0) {
    f4ee:	f8d4 36f0 	ldr.w	r3, [r4, #1776]	; 0x6f0
    f4f2:	2b00      	cmp	r3, #0
    f4f4:	dd46      	ble.n	f584 <CVRecV2::DrawInterface()+0x158>
    f4f6:	f9b4 36fa 	ldrsh.w	r3, [r4, #1786]	; 0x6fa
    f4fa:	2b00      	cmp	r3, #0
    f4fc:	dd42      	ble.n	f584 <CVRecV2::DrawInterface()+0x158>
            if (!CursorBlink()) gfxIcon(54, 35, RECORD_ICON);
    f4fe:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    f500:	2b00      	cmp	r3, #0
    f502:	dc05      	bgt.n	f510 <CVRecV2::DrawInterface()+0xe4>
    f504:	4b30      	ldr	r3, [pc, #192]	; (f5c8 <CVRecV2::DrawInterface()+0x19c>)
        else gfxIcon(54, 35, PLAY_ICON);
    f506:	69a0      	ldr	r0, [r4, #24]
    f508:	2223      	movs	r2, #35	; 0x23
    f50a:	2136      	movs	r1, #54	; 0x36
    f50c:	f7f5 fa48 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        if (punch_out > 0) gfxInvert(0, 34, punch_out / 6, 9);
    f510:	f9b4 36fa 	ldrsh.w	r3, [r4, #1786]	; 0x6fa
    f514:	2b00      	cmp	r3, #0
    f516:	dd09      	ble.n	f52c <CVRecV2::DrawInterface()+0x100>
    f518:	2209      	movs	r2, #9
    f51a:	9200      	str	r2, [sp, #0]
    f51c:	2100      	movs	r1, #0
    f51e:	2206      	movs	r2, #6
    f520:	4620      	mov	r0, r4
    f522:	fb93 f3f2 	sdiv	r3, r3, r2
    f526:	2222      	movs	r2, #34	; 0x22
    f528:	f7f9 f82c 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
        segment.PrintWhole(hemisphere * 64, 50, step + 1, 100);
    f52c:	7921      	ldrb	r1, [r4, #4]
    f52e:	f9b4 36f8 	ldrsh.w	r3, [r4, #1784]	; 0x6f8
    f532:	2264      	movs	r2, #100	; 0x64
    f534:	0189      	lsls	r1, r1, #6
    f536:	9200      	str	r2, [sp, #0]
    f538:	3301      	adds	r3, #1
    f53a:	2232      	movs	r2, #50	; 0x32
    f53c:	f001 01c0 	and.w	r1, r1, #192	; 0xc0
    f540:	f104 0070 	add.w	r0, r4, #112	; 0x70
    f544:	f7fd f83a 	bl	c5bc <SegmentDisplay::PrintWhole(unsigned char, unsigned char, int, int)>
        ForEachChannel(ch)
    f548:	f104 0524 	add.w	r5, r4, #36	; 0x24
        segment.PrintWhole(hemisphere * 64, 50, step + 1, 100);
    f54c:	f04f 0832 	mov.w	r8, #50	; 0x32
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    f550:	f44f 57f0 	mov.w	r7, #7680	; 0x1e00
            if (w < 0) gfxFrame(32, (ch * 6) + 50, -w, 4);
    f554:	2604      	movs	r6, #4
    f556:	f855 3f04 	ldr.w	r3, [r5, #4]!
    f55a:	039b      	lsls	r3, r3, #14
    f55c:	fb93 f3f7 	sdiv	r3, r3, r7
        int scaled = simfloat2int(proportion * max_value);
    f560:	f343 2351 	sbfx	r3, r3, #9, #18
            w = constrain(w, -32, 32);
    f564:	f113 0f20 	cmn.w	r3, #32
    f568:	db1d      	blt.n	f5a6 <CVRecV2::DrawInterface()+0x17a>
    f56a:	2b20      	cmp	r3, #32
    f56c:	dc0c      	bgt.n	f588 <CVRecV2::DrawInterface()+0x15c>
            if (w > 0) gfxRect(32, (ch * 6) + 50, w, 4);
    f56e:	2b00      	cmp	r3, #0
    f570:	dc0b      	bgt.n	f58a <CVRecV2::DrawInterface()+0x15e>
            if (w < 0) gfxFrame(32, (ch * 6) + 50, -w, 4);
    f572:	d010      	beq.n	f596 <CVRecV2::DrawInterface()+0x16a>
    f574:	69a0      	ldr	r0, [r4, #24]
    f576:	9600      	str	r6, [sp, #0]
    f578:	425b      	negs	r3, r3
    f57a:	4642      	mov	r2, r8
    f57c:	2120      	movs	r1, #32
    f57e:	f7f5 fa45 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    f582:	e008      	b.n	f596 <CVRecV2::DrawInterface()+0x16a>
        else gfxIcon(54, 35, PLAY_ICON);
    f584:	4b11      	ldr	r3, [pc, #68]	; (f5cc <CVRecV2::DrawInterface()+0x1a0>)
    f586:	e7be      	b.n	f506 <CVRecV2::DrawInterface()+0xda>
            w = constrain(w, -32, 32);
    f588:	2320      	movs	r3, #32
            if (w > 0) gfxRect(32, (ch * 6) + 50, w, 4);
    f58a:	69a0      	ldr	r0, [r4, #24]
    f58c:	9600      	str	r6, [sp, #0]
    f58e:	4642      	mov	r2, r8
    f590:	2120      	movs	r1, #32
    f592:	f7f5 fa35 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        ForEachChannel(ch)
    f596:	f108 0806 	add.w	r8, r8, #6
    f59a:	f1b8 0f3e 	cmp.w	r8, #62	; 0x3e
    f59e:	d1da      	bne.n	f556 <CVRecV2::DrawInterface()+0x12a>
    }
    f5a0:	b002      	add	sp, #8
    f5a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            w = constrain(w, -32, 32);
    f5a6:	f06f 031f 	mvn.w	r3, #31
    f5aa:	e7e3      	b.n	f574 <CVRecV2::DrawInterface()+0x148>
    f5ac:	00024218 	.word	0x00024218
    f5b0:	0001f2ef 	.word	0x0001f2ef
    f5b4:	200065e0 	.word	0x200065e0
    f5b8:	00021292 	.word	0x00021292
    f5bc:	00023ec0 	.word	0x00023ec0
    f5c0:	00023d38 	.word	0x00023d38
    f5c4:	00023d40 	.word	0x00023d40
    f5c8:	00023c98 	.word	0x00023c98
    f5cc:	00024230 	.word	0x00024230

0000f5d0 <CVRecV2::View()>:
        gfxHeader(applet_name());
    f5d0:	6803      	ldr	r3, [r0, #0]
    void View() {
    f5d2:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    f5d4:	681b      	ldr	r3, [r3, #0]
    void View() {
    f5d6:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    f5d8:	4798      	blx	r3
    f5da:	4601      	mov	r1, r0
    f5dc:	4620      	mov	r0, r4
    f5de:	f7f9 f80e 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
    f5e2:	4620      	mov	r0, r4
    f5e4:	f7ff ff22 	bl	f42c <CVRecV2::DrawInterface()>
    }
    f5e8:	bd10      	pop	{r4, pc}
    f5ea:	Address 0x000000000000f5ea is out of bounds.


0000f5ec <Calculate::DrawSelector()>:
    void DrawSelector()
    f5ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            if (operation[ch] == 6 && rand_clocked[ch]) gfxIcon(20 + 31 * ch, 15, CLOCK_ICON);
    f5f0:	f8df 805c 	ldr.w	r8, [pc, #92]	; f650 <Calculate::DrawSelector()+0x64>
    void DrawSelector()
    f5f4:	4604      	mov	r4, r0
    f5f6:	f100 06a8 	add.w	r6, r0, #168	; 0xa8
        ForEachChannel(ch)
    f5fa:	2500      	movs	r5, #0
            gfxPrint(31 * ch, 15, op_name[operation[ch]]);
    f5fc:	f856 3f04 	ldr.w	r3, [r6, #4]!
    f600:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    f604:	ebc5 1745 	rsb	r7, r5, r5, lsl #5
    f608:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    f60a:	220f      	movs	r2, #15
    f60c:	4639      	mov	r1, r7
    f60e:	4620      	mov	r0, r4
    f610:	f7f8 ff6a 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            if (ch == selected) gfxCursor(0 + (31 * ch), 23, 30);
    f614:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    f618:	42ab      	cmp	r3, r5
    f61a:	d105      	bne.n	f628 <Calculate::DrawSelector()+0x3c>
    f61c:	231e      	movs	r3, #30
    f61e:	2217      	movs	r2, #23
    f620:	4639      	mov	r1, r7
    f622:	4620      	mov	r0, r4
    f624:	f7f8 ff54 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            if (operation[ch] == 6 && rand_clocked[ch]) gfxIcon(20 + 31 * ch, 15, CLOCK_ICON);
    f628:	6833      	ldr	r3, [r6, #0]
    f62a:	2b06      	cmp	r3, #6
    f62c:	d10a      	bne.n	f644 <Calculate::DrawSelector()+0x58>
    f62e:	f104 03b8 	add.w	r3, r4, #184	; 0xb8
    f632:	5d5b      	ldrb	r3, [r3, r5]
    f634:	b133      	cbz	r3, f644 <Calculate::DrawSelector()+0x58>
    f636:	69a0      	ldr	r0, [r4, #24]
    f638:	4643      	mov	r3, r8
    f63a:	220f      	movs	r2, #15
    f63c:	f107 0114 	add.w	r1, r7, #20
    f640:	f7f5 f9ae 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        ForEachChannel(ch)
    f644:	b10d      	cbz	r5, f64a <Calculate::DrawSelector()+0x5e>
    }
    f646:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f64a:	2501      	movs	r5, #1
    f64c:	e7d6      	b.n	f5fc <Calculate::DrawSelector()+0x10>
    f64e:	bf00      	nop
    f650:	00023c28 	.word	0x00023c28

0000f654 <Calculate::View()>:
        gfxHeader(applet_name());
    f654:	6803      	ldr	r3, [r0, #0]
    void View() {
    f656:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    f658:	681b      	ldr	r3, [r3, #0]
    void View() {
    f65a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    f65c:	4798      	blx	r3
    f65e:	4601      	mov	r1, r0
    f660:	4620      	mov	r0, r4
    f662:	f7f8 ffcc 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSelector();
    f666:	4620      	mov	r0, r4
    f668:	f7ff ffc0 	bl	f5ec <Calculate::DrawSelector()>
        gfxSkyline();
    f66c:	4620      	mov	r0, r4
    f66e:	f7f8 ff91 	bl	8594 <HemisphereApplet::gfxSkyline()>
    }
    f672:	bd10      	pop	{r4, pc}

0000f674 <Carpeggio::DrawSelector()>:
        gfxPrint(0, 15, Arp_Chords[chord].chord_name);
    f674:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    f678:	223c      	movs	r2, #60	; 0x3c
    f67a:	4353      	muls	r3, r2
    f67c:	4a2e      	ldr	r2, [pc, #184]	; (f738 <Carpeggio::DrawSelector()+0xc4>)
    void DrawSelector() {
    f67e:	b513      	push	{r0, r1, r4, lr}
    f680:	4604      	mov	r4, r0
        gfxPrint(0, 15, Arp_Chords[chord].chord_name);
    f682:	58d3      	ldr	r3, [r2, r3]
    f684:	2100      	movs	r1, #0
    f686:	220f      	movs	r2, #15
    f688:	f7f8 ff2e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor == 1) {
    f68c:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    f68e:	2901      	cmp	r1, #1
    f690:	d114      	bne.n	f6bc <Carpeggio::DrawSelector()+0x48>
            gfxCursor(1, 23, 53);
    f692:	2335      	movs	r3, #53	; 0x35
    f694:	2217      	movs	r2, #23
    f696:	4620      	mov	r0, r4
    f698:	f7f8 ff1a 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            gfxBitmap(55, 14, 8, chord == sel_chord ? CHECK_ON_ICON : CHECK_OFF_ICON);
    f69c:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
    f6a0:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
    f6a4:	4a25      	ldr	r2, [pc, #148]	; (f73c <Carpeggio::DrawSelector()+0xc8>)
    f6a6:	4b26      	ldr	r3, [pc, #152]	; (f740 <Carpeggio::DrawSelector()+0xcc>)
    f6a8:	4288      	cmp	r0, r1
    f6aa:	bf18      	it	ne
    f6ac:	4613      	movne	r3, r2
    f6ae:	9300      	str	r3, [sp, #0]
    f6b0:	69a0      	ldr	r0, [r4, #24]
    f6b2:	2308      	movs	r3, #8
    f6b4:	220e      	movs	r2, #14
    f6b6:	2137      	movs	r1, #55	; 0x37
    f6b8:	f7f5 f96c 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(32, 25, "Tr");
    f6bc:	4b21      	ldr	r3, [pc, #132]	; (f744 <Carpeggio::DrawSelector()+0xd0>)
    f6be:	2219      	movs	r2, #25
    f6c0:	2120      	movs	r1, #32
    f6c2:	4620      	mov	r0, r4
    f6c4:	f7f8 ff10 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        graphics.print(str);
    f6c8:	4b1f      	ldr	r3, [pc, #124]	; (f748 <Carpeggio::DrawSelector()+0xd4>)
    f6ca:	4a20      	ldr	r2, [pc, #128]	; (f74c <Carpeggio::DrawSelector()+0xd8>)
        gfxPrint(transpose < 0 ? "" : "+");
    f6cc:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
    f6d0:	481f      	ldr	r0, [pc, #124]	; (f750 <Carpeggio::DrawSelector()+0xdc>)
    f6d2:	ea12 0121 	ands.w	r1, r2, r1, asr #32
    f6d6:	bf38      	it	cc
    f6d8:	4619      	movcc	r1, r3
    f6da:	f00a f9fc 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
    f6de:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
    f6e2:	481b      	ldr	r0, [pc, #108]	; (f750 <Carpeggio::DrawSelector()+0xdc>)
    f6e4:	f00a fa6b 	bl	19bbe <weegfx::Graphics::print(int)>
        if (cursor == 2) gfxCursor(32, 33, 30);
    f6e8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    f6ea:	2b02      	cmp	r3, #2
    f6ec:	d105      	bne.n	f6fa <Carpeggio::DrawSelector()+0x86>
    f6ee:	231e      	movs	r3, #30
    f6f0:	2221      	movs	r2, #33	; 0x21
    f6f2:	2120      	movs	r1, #32
    f6f4:	4620      	mov	r0, r4
    f6f6:	f7f8 feeb 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        uint8_t midi_note = constrain(sequence[step] + 36 + transpose, 0, 127);
    f6fa:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    f6fe:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    f702:	eb04 0343 	add.w	r3, r4, r3, lsl #1
        gfxPrint(38, 50, midi_note_numbers[midi_note]);
    f706:	2126      	movs	r1, #38	; 0x26
        uint8_t midi_note = constrain(sequence[step] + 36 + transpose, 0, 127);
    f708:	f9b3 3072 	ldrsh.w	r3, [r3, #114]	; 0x72
    f70c:	3324      	adds	r3, #36	; 0x24
    f70e:	4413      	add	r3, r2
        gfxPrint(38, 50, midi_note_numbers[midi_note]);
    f710:	f383 0307 	usat	r3, #7, r3
    f714:	4a0f      	ldr	r2, [pc, #60]	; (f754 <Carpeggio::DrawSelector()+0xe0>)
    f716:	4620      	mov	r0, r4
    f718:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f71c:	2232      	movs	r2, #50	; 0x32
    f71e:	f7f8 fee3 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor == 0) gfxCursor(32, 58, 30);
    f722:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    f724:	b92b      	cbnz	r3, f732 <Carpeggio::DrawSelector()+0xbe>
    f726:	231e      	movs	r3, #30
    f728:	223a      	movs	r2, #58	; 0x3a
    f72a:	2120      	movs	r1, #32
    f72c:	4620      	mov	r0, r4
    f72e:	f7f8 fecf 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
    f732:	b002      	add	sp, #8
    f734:	bd10      	pop	{r4, pc}
    f736:	bf00      	nop
    f738:	00022f44 	.word	0x00022f44
    f73c:	00023ec0 	.word	0x00023ec0
    f740:	00023d38 	.word	0x00023d38
    f744:	00020a4e 	.word	0x00020a4e
    f748:	0001e41c 	.word	0x0001e41c
    f74c:	000211c8 	.word	0x000211c8
    f750:	200065e0 	.word	0x200065e0
    f754:	00023f34 	.word	0x00023f34

0000f758 <Carpeggio::DrawGrid()>:
    void DrawGrid() {
    f758:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    f75c:	4604      	mov	r4, r0
        for (int s = 0; s < 16; s++) gfxFrame(1 + (8 * (s % 4)), 26 + (8 * (s / 4)), 5, 5);
    f75e:	2500      	movs	r5, #0
    f760:	2705      	movs	r7, #5
    f762:	10aa      	asrs	r2, r5, #2
    f764:	f005 0103 	and.w	r1, r5, #3
    f768:	00d2      	lsls	r2, r2, #3
    f76a:	00c9      	lsls	r1, r1, #3
    f76c:	69a0      	ldr	r0, [r4, #24]
    f76e:	9700      	str	r7, [sp, #0]
    f770:	2305      	movs	r3, #5
    f772:	321a      	adds	r2, #26
    f774:	3101      	adds	r1, #1
    f776:	3501      	adds	r5, #1
    f778:	f7f5 f948 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    f77c:	2d10      	cmp	r5, #16
    f77e:	d1f0      	bne.n	f762 <Carpeggio::DrawGrid()+0xa>
        int cxy = step / 4;
    f780:	f894 5070 	ldrb.w	r5, [r4, #112]	; 0x70
        gfxDottedLine(3 + (8 * cxx), 26, 3 + (8 * cxx), 58, 2);
    f784:	69a0      	ldr	r0, [r4, #24]
    f786:	f005 0603 	and.w	r6, r5, #3
    f78a:	00f6      	lsls	r6, r6, #3
    f78c:	f04f 0802 	mov.w	r8, #2
    f790:	1cf3      	adds	r3, r6, #3
    f792:	223a      	movs	r2, #58	; 0x3a
        gfxDottedLine(1, 28 + (8 * cxy), 32, 28 + (8 * cxy), 2);
    f794:	fa25 f508 	lsr.w	r5, r5, r8
        gfxDottedLine(3 + (8 * cxx), 26, 3 + (8 * cxx), 58, 2);
    f798:	4619      	mov	r1, r3
    f79a:	9200      	str	r2, [sp, #0]
        gfxDottedLine(1, 28 + (8 * cxy), 32, 28 + (8 * cxy), 2);
    f79c:	00ed      	lsls	r5, r5, #3
        gfxDottedLine(3 + (8 * cxx), 26, 3 + (8 * cxx), 58, 2);
    f79e:	221a      	movs	r2, #26
    f7a0:	f8cd 8004 	str.w	r8, [sp, #4]
    f7a4:	f7f5 f90a 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        gfxDottedLine(1, 28 + (8 * cxy), 32, 28 + (8 * cxy), 2);
    f7a8:	f105 021c 	add.w	r2, r5, #28
    f7ac:	e9cd 2800 	strd	r2, r8, [sp]
    f7b0:	69a0      	ldr	r0, [r4, #24]
    f7b2:	2320      	movs	r3, #32
    f7b4:	2101      	movs	r1, #1
    f7b6:	f7f5 f901 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        gfxRect(1 + (8 * cxx), 26 + (8 * cxy), 5, 5);
    f7ba:	1c71      	adds	r1, r6, #1
    f7bc:	69a0      	ldr	r0, [r4, #24]
    f7be:	9700      	str	r7, [sp, #0]
    f7c0:	2305      	movs	r3, #5
    f7c2:	f105 021a 	add.w	r2, r5, #26
    f7c6:	f7f5 f91b 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        if (confirm_animation_position > -1) {
    f7ca:	f8d4 60a4 	ldr.w	r6, [r4, #164]	; 0xa4
    f7ce:	2e00      	cmp	r6, #0
    f7d0:	db05      	blt.n	f7de <Carpeggio::DrawGrid()+0x86>
            int progress = 16 - confirm_animation_position;
    f7d2:	f1c6 0610 	rsb	r6, r6, #16
            for (int s = 0; s < progress; s++)
    f7d6:	2500      	movs	r5, #0
                gfxRect(1 + (8 * (s / 4)), 26 + (8 * (s % 4)), 7, 7);
    f7d8:	2707      	movs	r7, #7
            for (int s = 0; s < progress; s++)
    f7da:	42b5      	cmp	r5, r6
    f7dc:	db02      	blt.n	f7e4 <Carpeggio::DrawGrid()+0x8c>
    }
    f7de:	b002      	add	sp, #8
    f7e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                gfxRect(1 + (8 * (s / 4)), 26 + (8 * (s % 4)), 7, 7);
    f7e4:	f005 0203 	and.w	r2, r5, #3
    f7e8:	10a9      	asrs	r1, r5, #2
    f7ea:	00d2      	lsls	r2, r2, #3
    f7ec:	00c9      	lsls	r1, r1, #3
    f7ee:	69a0      	ldr	r0, [r4, #24]
    f7f0:	9700      	str	r7, [sp, #0]
    f7f2:	2307      	movs	r3, #7
    f7f4:	321a      	adds	r2, #26
    f7f6:	3101      	adds	r1, #1
    f7f8:	f7f5 f902 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
            for (int s = 0; s < progress; s++)
    f7fc:	3501      	adds	r5, #1
    f7fe:	e7ec      	b.n	f7da <Carpeggio::DrawGrid()+0x82>

0000f800 <Carpeggio::View()>:
        gfxHeader(applet_name());
    f800:	6803      	ldr	r3, [r0, #0]
    void View() {
    f802:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    f804:	681b      	ldr	r3, [r3, #0]
    void View() {
    f806:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    f808:	4798      	blx	r3
    f80a:	4601      	mov	r1, r0
    f80c:	4620      	mov	r0, r4
    f80e:	f7f8 fef6 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSelector();
    f812:	4620      	mov	r0, r4
    f814:	f7ff ff2e 	bl	f674 <Carpeggio::DrawSelector()>
        DrawGrid();
    f818:	4620      	mov	r0, r4
    f81a:	f7ff ff9d 	bl	f758 <Carpeggio::DrawGrid()>
    }
    f81e:	bd10      	pop	{r4, pc}

0000f820 <Carpeggio::ImprintChord(int)>:
    void ImprintChord(int new_chord) {
    f820:	b5f0      	push	{r4, r5, r6, r7, lr}
        int num = Arp_Chords[new_chord].nr_notes;
    f822:	4e17      	ldr	r6, [pc, #92]	; (f880 <Carpeggio::ImprintChord(int)+0x60>)
    f824:	233c      	movs	r3, #60	; 0x3c
    f826:	fb03 6301 	mla	r3, r3, r1, r6
    f82a:	f100 0570 	add.w	r5, r0, #112	; 0x70
    f82e:	6b5f      	ldr	r7, [r3, #52]	; 0x34
        for (int s = 0; s < 16; s++)
    f830:	2200      	movs	r2, #0
            sequence[s] = Arp_Chords[new_chord].chord_tones[tone] + (12 * oct);
    f832:	ebc1 1c01 	rsb	ip, r1, r1, lsl #4
            int oct = (s / num) % 4; // Increase one octave each time this cycle repeats to a max of 4
    f836:	fb92 f3f7 	sdiv	r3, r2, r7
    f83a:	f1d3 0e00 	rsbs	lr, r3, #0
    f83e:	f003 0403 	and.w	r4, r3, #3
            int tone = s % num;
    f842:	fb07 2313 	mls	r3, r7, r3, r2
            sequence[s] = Arp_Chords[new_chord].chord_tones[tone] + (12 * oct);
    f846:	4463      	add	r3, ip
    f848:	eb06 0383 	add.w	r3, r6, r3, lsl #2
            int oct = (s / num) % 4; // Increase one octave each time this cycle repeats to a max of 4
    f84c:	f00e 0e03 	and.w	lr, lr, #3
    f850:	bf58      	it	pl
    f852:	f1ce 0400 	rsbpl	r4, lr, #0
            sequence[s] = Arp_Chords[new_chord].chord_tones[tone] + (12 * oct);
    f856:	685b      	ldr	r3, [r3, #4]
    f858:	eb04 0444 	add.w	r4, r4, r4, lsl #1
        for (int s = 0; s < 16; s++)
    f85c:	3201      	adds	r2, #1
            sequence[s] = Arp_Chords[new_chord].chord_tones[tone] + (12 * oct);
    f85e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
        for (int s = 0; s < 16; s++)
    f862:	2a10      	cmp	r2, #16
            sequence[s] = Arp_Chords[new_chord].chord_tones[tone] + (12 * oct);
    f864:	f825 3f02 	strh.w	r3, [r5, #2]!
        for (int s = 0; s < 16; s++)
    f868:	d1e5      	bne.n	f836 <Carpeggio::ImprintChord(int)+0x16>
        confirm_animation_countdown = HEM_CARPEGGIO_ANIMATION_SPEED;
    f86a:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
        sel_chord = new_chord;
    f86e:	f8c0 1098 	str.w	r1, [r0, #152]	; 0x98
        chord = new_chord;
    f872:	f8c0 1094 	str.w	r1, [r0, #148]	; 0x94
        confirm_animation_position = 16;
    f876:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
        confirm_animation_countdown = HEM_CARPEGGIO_ANIMATION_SPEED;
    f87a:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
    }
    f87e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f880:	00022f44 	.word	0x00022f44

0000f884 <Carpeggio::Start()>:
    void Start() {
    f884:	b508      	push	{r3, lr}
        step = 0;
    f886:	2200      	movs	r2, #0
    f888:	f880 2070 	strb.w	r2, [r0, #112]	; 0x70
        replay = 0;
    f88c:	f880 2092 	strb.w	r2, [r0, #146]	; 0x92
        transpose = 0;
    f890:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
        ImprintChord(2);
    f894:	2102      	movs	r1, #2
    f896:	f7ff ffc3 	bl	f820 <Carpeggio::ImprintChord(int)>
    }
    f89a:	bd08      	pop	{r3, pc}

0000f89c <Carpeggio_OnButtonPress(bool)>:
void Carpeggio_OnButtonPress(bool hemisphere) {
    f89c:	b570      	push	{r4, r5, r6, lr}
    Carpeggio_instance[hemisphere].OnButtonPress();
    f89e:	4d10      	ldr	r5, [pc, #64]	; (f8e0 <Carpeggio_OnButtonPress(bool)+0x44>)
    f8a0:	24a8      	movs	r4, #168	; 0xa8
    f8a2:	fb04 5400 	mla	r4, r4, r0, r5
void Carpeggio_OnButtonPress(bool hemisphere) {
    f8a6:	4606      	mov	r6, r0
        if (cursor == 1 && chord != sel_chord) {
    f8a8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    f8aa:	2b01      	cmp	r3, #1
    f8ac:	d10a      	bne.n	f8c4 <Carpeggio_OnButtonPress(bool)+0x28>
    f8ae:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
    f8b2:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    f8b6:	4299      	cmp	r1, r3
    f8b8:	d004      	beq.n	f8c4 <Carpeggio_OnButtonPress(bool)+0x28>
            cursor = 0; // Don't advance cursor when chord is changed
    f8ba:	2300      	movs	r3, #0
    f8bc:	66e3      	str	r3, [r4, #108]	; 0x6c
            ImprintChord(chord);
    f8be:	4620      	mov	r0, r4
    f8c0:	f7ff ffae 	bl	f820 <Carpeggio::ImprintChord(int)>
        if (++cursor > 2) cursor = 0;
    f8c4:	23a8      	movs	r3, #168	; 0xa8
    f8c6:	fb03 5506 	mla	r5, r3, r6, r5
    f8ca:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
    f8cc:	3301      	adds	r3, #1
    f8ce:	2b03      	cmp	r3, #3
    f8d0:	bfa8      	it	ge
    f8d2:	2300      	movge	r3, #0
    f8d4:	66eb      	str	r3, [r5, #108]	; 0x6c
        cursor_countdown = HEMISPHERE_CURSOR_TICKS;
    f8d6:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    f8da:	64a3      	str	r3, [r4, #72]	; 0x48
}
    f8dc:	bd70      	pop	{r4, r5, r6, pc}
    f8de:	bf00      	nop
    f8e0:	1fffc7e8 	.word	0x1fffc7e8

0000f8e4 <Carpeggio_OnDataReceive(bool, unsigned long)>:

void Carpeggio_OnDataReceive(bool hemisphere, uint32_t data) {
    f8e4:	b5f0      	push	{r4, r5, r6, r7, lr}
        ImprintChord(Unpack(data, PackLocation {0,8}));
    f8e6:	2300      	movs	r3, #0
void Carpeggio_OnDataReceive(bool hemisphere, uint32_t data) {
    f8e8:	b085      	sub	sp, #20
        ImprintChord(Unpack(data, PackLocation {0,8}));
    f8ea:	2608      	movs	r6, #8
    f8ec:	e9cd 3602 	strd	r3, r6, [sp, #8]
void Carpeggio_OnDataReceive(bool hemisphere, uint32_t data) {
    f8f0:	460d      	mov	r5, r1
        ImprintChord(Unpack(data, PackLocation {0,8}));
    f8f2:	ab04      	add	r3, sp, #16
    f8f4:	e913 0006 	ldmdb	r3, {r1, r2}
void Carpeggio_OnDataReceive(bool hemisphere, uint32_t data) {
    f8f8:	4607      	mov	r7, r0
        ImprintChord(Unpack(data, PackLocation {0,8}));
    f8fa:	4628      	mov	r0, r5
    f8fc:	f7f4 fa98 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    Carpeggio_instance[hemisphere].OnDataReceive(data);
    f900:	4c09      	ldr	r4, [pc, #36]	; (f928 <Carpeggio_OnDataReceive(bool, unsigned long)+0x44>)
    f902:	23a8      	movs	r3, #168	; 0xa8
    f904:	fb03 4407 	mla	r4, r3, r7, r4
        ImprintChord(Unpack(data, PackLocation {0,8}));
    f908:	4601      	mov	r1, r0
    f90a:	4620      	mov	r0, r4
    f90c:	f7ff ff88 	bl	f820 <Carpeggio::ImprintChord(int)>
        transpose = Unpack(data, PackLocation {8,8}) - 24;
    f910:	4632      	mov	r2, r6
    f912:	4631      	mov	r1, r6
    f914:	4628      	mov	r0, r5
    f916:	e9cd 6600 	strd	r6, r6, [sp]
    f91a:	f7f4 fa89 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
    f91e:	3818      	subs	r0, #24
    f920:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
}
    f924:	b005      	add	sp, #20
    f926:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f928:	1fffc7e8 	.word	0x1fffc7e8

0000f92c <Carpeggio::pitch_out_for_step()>:
    void pitch_out_for_step() {
    f92c:	b510      	push	{r4, lr}
        int note = sequence[step];
    f92e:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
    f932:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    void pitch_out_for_step() {
    f936:	4604      	mov	r4, r0
        Out(0, MIDIQuantizer::CV(note + 36, transpose));
    f938:	f8b3 0072 	ldrh.w	r0, [r3, #114]	; 0x72
    f93c:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
    f940:	3024      	adds	r0, #36	; 0x24
    f942:	b2c0      	uxtb	r0, r0
    f944:	f7f6 f82f 	bl	59a6 <MIDIQuantizer::CV(unsigned char, int)>
    f948:	2300      	movs	r3, #0
    f94a:	4602      	mov	r2, r0
    f94c:	4619      	mov	r1, r3
    f94e:	4620      	mov	r0, r4
    f950:	f7f9 fac1 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
    f954:	bd10      	pop	{r4, pc}

0000f956 <Carpeggio::Controller()>:
    void Controller() {
    f956:	b538      	push	{r3, r4, r5, lr}
        if (Clock(1)) step = 0; // Reset
    f958:	2200      	movs	r2, #0
    f95a:	2101      	movs	r1, #1
    void Controller() {
    f95c:	4604      	mov	r4, r0
        if (Clock(1)) step = 0; // Reset
    f95e:	f7f9 fe11 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    f962:	b110      	cbz	r0, f96a <Carpeggio::Controller()+0x14>
    f964:	2300      	movs	r3, #0
    f966:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
        if (Clock(0)) {
    f96a:	2200      	movs	r2, #0
    f96c:	4611      	mov	r1, r2
    f96e:	4620      	mov	r0, r4
    f970:	f7f9 fe08 	bl	9584 <HemisphereApplet::Clock(int, bool)>
    f974:	4605      	mov	r5, r0
    f976:	2800      	cmp	r0, #0
    f978:	d04e      	beq.n	fa18 <Carpeggio::Controller()+0xc2>
            if (DetentedIn(0) || DetentedIn(1)) {
    f97a:	2100      	movs	r1, #0
    f97c:	4620      	mov	r0, r4
    f97e:	f7f9 faa1 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
    f982:	b928      	cbnz	r0, f990 <Carpeggio::Controller()+0x3a>
    f984:	2101      	movs	r1, #1
    f986:	4620      	mov	r0, r4
    f988:	f7f9 fa9c 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
    f98c:	4605      	mov	r5, r0
    f98e:	b3a8      	cbz	r0, f9fc <Carpeggio::Controller()+0xa6>
                int x = ProportionCV(In(0), 4);
    f990:	2104      	movs	r1, #4
    f992:	6a20      	ldr	r0, [r4, #32]
    f994:	f7f4 fe66 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
                int y = ProportionCV(In(1), 4);
    f998:	2104      	movs	r1, #4
                int x = ProportionCV(In(0), 4);
    f99a:	4605      	mov	r5, r0
                int y = ProportionCV(In(1), 4);
    f99c:	6a60      	ldr	r0, [r4, #36]	; 0x24
    f99e:	f7f4 fe61 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
                step = (y * 4) + x;
    f9a2:	2803      	cmp	r0, #3
    f9a4:	bfa8      	it	ge
    f9a6:	2003      	movge	r0, #3
    f9a8:	2d03      	cmp	r5, #3
    f9aa:	bfa8      	it	ge
    f9ac:	2503      	movge	r5, #3
    f9ae:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    f9b2:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
                pitch_out_for_step();
    f9b6:	4620      	mov	r0, r4
    f9b8:	f7ff ffb8 	bl	f92c <Carpeggio::pitch_out_for_step()>
            replay = 0;
    f9bc:	2300      	movs	r3, #0
    f9be:	f884 3092 	strb.w	r3, [r4, #146]	; 0x92
        int xy = (In(0) * In(1)) / HEMISPHERE_MAX_CV;
    f9c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    f9c4:	6a22      	ldr	r2, [r4, #32]
        Out(1, xy);
    f9c6:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
        int xy = (In(0) * In(1)) / HEMISPHERE_MAX_CV;
    f9ca:	435a      	muls	r2, r3
        Out(1, xy);
    f9cc:	4620      	mov	r0, r4
    f9ce:	2300      	movs	r3, #0
    f9d0:	fb92 f2f1 	sdiv	r2, r2, r1
    f9d4:	2101      	movs	r1, #1
    f9d6:	f7f9 fa7e 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        if (--confirm_animation_countdown < 0) {
    f9da:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    f9de:	3b01      	subs	r3, #1
    f9e0:	2b00      	cmp	r3, #0
    f9e2:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    f9e6:	da08      	bge.n	f9fa <Carpeggio::Controller()+0xa4>
            confirm_animation_position--;
    f9e8:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
    f9ec:	3b01      	subs	r3, #1
    f9ee:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
            confirm_animation_countdown = HEM_CARPEGGIO_ANIMATION_SPEED;
    f9f2:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    f9f6:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    }
    f9fa:	bd38      	pop	{r3, r4, r5, pc}
                pitch_out_for_step();
    f9fc:	4620      	mov	r0, r4
    f9fe:	f7ff ff95 	bl	f92c <Carpeggio::pitch_out_for_step()>
                if (++step > 15) step = 0;
    fa02:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    fa06:	3301      	adds	r3, #1
    fa08:	b2db      	uxtb	r3, r3
    fa0a:	2b0f      	cmp	r3, #15
    fa0c:	bf94      	ite	ls
    fa0e:	f884 3070 	strbls.w	r3, [r4, #112]	; 0x70
    fa12:	f884 5070 	strbhi.w	r5, [r4, #112]	; 0x70
    fa16:	e7d1      	b.n	f9bc <Carpeggio::Controller()+0x66>
        } else if (replay) {
    fa18:	f894 3092 	ldrb.w	r3, [r4, #146]	; 0x92
    fa1c:	2b00      	cmp	r3, #0
    fa1e:	d0d0      	beq.n	f9c2 <Carpeggio::Controller()+0x6c>
            pitch_out_for_step();
    fa20:	4620      	mov	r0, r4
    fa22:	f7ff ff83 	bl	f92c <Carpeggio::pitch_out_for_step()>
            replay = 0;
    fa26:	f884 5092 	strb.w	r5, [r4, #146]	; 0x92
    fa2a:	e7ca      	b.n	f9c2 <Carpeggio::Controller()+0x6c>

0000fa2c <ClockDivider::DrawSelector()>:
    void DrawSelector() {
    fa2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                gfxPrint(1, y, "/");
    fa30:	f8df 9084 	ldr.w	r9, [pc, #132]	; fab8 <ClockDivider::DrawSelector()+0x8c>
        graphics.print(num);
    fa34:	4f21      	ldr	r7, [pc, #132]	; (fabc <ClockDivider::DrawSelector()+0x90>)
        graphics.print(str);
    fa36:	f8df a088 	ldr.w	sl, [pc, #136]	; fac0 <ClockDivider::DrawSelector()+0x94>
    void DrawSelector() {
    fa3a:	4604      	mov	r4, r0
    fa3c:	f100 056c 	add.w	r5, r0, #108	; 0x6c
    fa40:	260f      	movs	r6, #15
        ForEachChannel(ch)
    fa42:	f04f 0800 	mov.w	r8, #0
            if (ch == cursor) gfxCursor(0, y + 8, 63);
    fa46:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    fa4a:	4543      	cmp	r3, r8
    fa4c:	d106      	bne.n	fa5c <ClockDivider::DrawSelector()+0x30>
    fa4e:	233f      	movs	r3, #63	; 0x3f
    fa50:	f106 0208 	add.w	r2, r6, #8
    fa54:	2100      	movs	r1, #0
    fa56:	4620      	mov	r0, r4
    fa58:	f7f8 fd3a 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            if (div[ch] > 0) {
    fa5c:	682b      	ldr	r3, [r5, #0]
    fa5e:	2b00      	cmp	r3, #0
    fa60:	dd0d      	ble.n	fa7e <ClockDivider::DrawSelector()+0x52>
                gfxPrint(1, y, "/");
    fa62:	464b      	mov	r3, r9
    fa64:	4632      	mov	r2, r6
    fa66:	2101      	movs	r1, #1
    fa68:	4620      	mov	r0, r4
    fa6a:	f7f8 fd3d 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        graphics.print(num);
    fa6e:	6829      	ldr	r1, [r5, #0]
    fa70:	4638      	mov	r0, r7
    fa72:	f00a f8a4 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    fa76:	4651      	mov	r1, sl
    fa78:	4638      	mov	r0, r7
    fa7a:	f00a f82c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (div[ch] < 0) {
    fa7e:	682b      	ldr	r3, [r5, #0]
    fa80:	2b00      	cmp	r3, #0
    fa82:	da0e      	bge.n	faa2 <ClockDivider::DrawSelector()+0x76>
                gfxPrint(1, y, "x");
    fa84:	4b0f      	ldr	r3, [pc, #60]	; (fac4 <ClockDivider::DrawSelector()+0x98>)
    fa86:	4632      	mov	r2, r6
    fa88:	2101      	movs	r1, #1
    fa8a:	4620      	mov	r0, r4
    fa8c:	f7f8 fd2c 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
                gfxPrint(-div[ch]);
    fa90:	6829      	ldr	r1, [r5, #0]
        graphics.print(num);
    fa92:	4638      	mov	r0, r7
    fa94:	4249      	negs	r1, r1
    fa96:	f00a f892 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
    fa9a:	490b      	ldr	r1, [pc, #44]	; (fac8 <ClockDivider::DrawSelector()+0x9c>)
    fa9c:	4638      	mov	r0, r7
    fa9e:	f00a f81a 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        ForEachChannel(ch)
    faa2:	3619      	adds	r6, #25
    faa4:	3504      	adds	r5, #4
    faa6:	f1b8 0f00 	cmp.w	r8, #0
    faaa:	d001      	beq.n	fab0 <ClockDivider::DrawSelector()+0x84>
    }
    faac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fab0:	f04f 0801 	mov.w	r8, #1
    fab4:	e7c7      	b.n	fa46 <ClockDivider::DrawSelector()+0x1a>
    fab6:	bf00      	nop
    fab8:	00021018 	.word	0x00021018
    fabc:	200065e0 	.word	0x200065e0
    fac0:	0002069a 	.word	0x0002069a
    fac4:	00020ffe 	.word	0x00020ffe
    fac8:	00021285 	.word	0x00021285

0000facc <ClockDivider::View()>:
        gfxHeader(applet_name());
    facc:	6803      	ldr	r3, [r0, #0]
    void View() {
    face:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    fad0:	681b      	ldr	r3, [r3, #0]
    void View() {
    fad2:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    fad4:	4798      	blx	r3
    fad6:	4601      	mov	r1, r0
    fad8:	4620      	mov	r0, r4
    fada:	f7f8 fd90 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSelector();
    fade:	4620      	mov	r0, r4
    fae0:	f7ff ffa4 	bl	fa2c <ClockDivider::DrawSelector()>
    }
    fae4:	bd10      	pop	{r4, pc}
    fae6:	Address 0x000000000000fae6 is out of bounds.


0000fae8 <ClockSetup::DrawInterface()>:
    void DrawInterface() {
    fae8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  text_x_ = x;
    faec:	4d46      	ldr	r5, [pc, #280]	; (fc08 <ClockSetup::DrawInterface()+0x120>)
        graphics.print("Clock Setup");
    faee:	4947      	ldr	r1, [pc, #284]	; (fc0c <ClockSetup::DrawInterface()+0x124>)
    void DrawInterface() {
    faf0:	4604      	mov	r4, r0
        gfxLine(0, 10, 62, 10);
    faf2:	f04f 080a 	mov.w	r8, #10
  text_y_ = y;
    faf6:	2302      	movs	r3, #2
        graphics.print("Clock Setup");
    faf8:	4628      	mov	r0, r5
  text_x_ = x;
    fafa:	2601      	movs	r6, #1
        gfxLine(0, 12, 62, 12);
    fafc:	270c      	movs	r7, #12
  text_y_ = y;
    fafe:	60ab      	str	r3, [r5, #8]
  text_x_ = x;
    fb00:	606e      	str	r6, [r5, #4]
        graphics.print("Clock Setup");
    fb02:	f009 ffe8 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxLine(0, 10, 62, 10);
    fb06:	69a0      	ldr	r0, [r4, #24]
    fb08:	f8cd 8000 	str.w	r8, [sp]
    fb0c:	233e      	movs	r3, #62	; 0x3e
    fb0e:	4642      	mov	r2, r8
    fb10:	2100      	movs	r1, #0
    fb12:	f7f4 ff6d 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(0, 12, 62, 12);
    fb16:	69a0      	ldr	r0, [r4, #24]
    fb18:	9700      	str	r7, [sp, #0]
    fb1a:	233e      	movs	r3, #62	; 0x3e
    fb1c:	463a      	mov	r2, r7
    fb1e:	2100      	movs	r1, #0
    fb20:	f7f4 ff66 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        graphics.drawLine(0, 10, 127, 10);
    fb24:	4628      	mov	r0, r5
    fb26:	237f      	movs	r3, #127	; 0x7f
    fb28:	4642      	mov	r2, r8
    fb2a:	2100      	movs	r1, #0
    fb2c:	f8cd 8000 	str.w	r8, [sp]
    fb30:	f009 fe5e 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        graphics.drawLine(0, 12, 127, 12);
    fb34:	4628      	mov	r0, r5
    fb36:	9700      	str	r7, [sp, #0]
    fb38:	237f      	movs	r3, #127	; 0x7f
    fb3a:	463a      	mov	r2, r7
    fb3c:	2100      	movs	r1, #0
    fb3e:	f009 fe57 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
        if (clock_m->IsRunning()) {
    fb42:	6f25      	ldr	r5, [r4, #112]	; 0x70
    fb44:	4628      	mov	r0, r5
    fb46:	f7f8 f9c9 	bl	7edc <ClockManager::IsRunning()>
    fb4a:	2800      	cmp	r0, #0
    fb4c:	d04d      	beq.n	fbea <ClockSetup::DrawInterface()+0x102>
            gfxIcon(1, 15, PLAY_ICON);
    fb4e:	4b30      	ldr	r3, [pc, #192]	; (fc10 <ClockSetup::DrawInterface()+0x128>)
    fb50:	69a0      	ldr	r0, [r4, #24]
    fb52:	220f      	movs	r2, #15
    fb54:	4631      	mov	r1, r6
            gfxIcon(1, 15, PAUSE_ICON);
    fb56:	f7f4 ff23 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(16, 15, "Internal");
    fb5a:	4b2e      	ldr	r3, [pc, #184]	; (fc14 <ClockSetup::DrawInterface()+0x12c>)
            gfxPrint(16, 15, "Forward");
    fb5c:	220f      	movs	r2, #15
    fb5e:	2110      	movs	r1, #16
    fb60:	4620      	mov	r0, r4
    fb62:	f7f8 fcc1 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxIcon(1, 25, NOTE4_ICON);
    fb66:	4b2c      	ldr	r3, [pc, #176]	; (fc18 <ClockSetup::DrawInterface()+0x130>)
    fb68:	69a0      	ldr	r0, [r4, #24]
    fb6a:	2219      	movs	r2, #25
    fb6c:	2101      	movs	r1, #1
    fb6e:	f7f4 ff17 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(9, 25, "= ");
    fb72:	2219      	movs	r2, #25
    fb74:	4b29      	ldr	r3, [pc, #164]	; (fc1c <ClockSetup::DrawInterface()+0x134>)
    fb76:	2109      	movs	r1, #9
    fb78:	4620      	mov	r0, r4
    fb7a:	f7f8 fcb5 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
    uint16_t GetTempo() {return tempo;}
    fb7e:	6f23      	ldr	r3, [r4, #112]	; 0x70
        gfxPrint(pad(100, clock_m->GetTempo()), clock_m->GetTempo());
    fb80:	89dd      	ldrh	r5, [r3, #14]
    fb82:	2064      	movs	r0, #100	; 0x64
    fb84:	4629      	mov	r1, r5
    fb86:	f7f4 fd7c 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    fb8a:	4629      	mov	r1, r5
    fb8c:	f7f4 ff54 	bl	4a38 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]>
    fb90:	4923      	ldr	r1, [pc, #140]	; (fc20 <ClockSetup::DrawInterface()+0x138>)
    fb92:	481d      	ldr	r0, [pc, #116]	; (fc08 <ClockSetup::DrawInterface()+0x120>)
    fb94:	f009 ff9f 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(1, 35, "x");
    fb98:	4b22      	ldr	r3, [pc, #136]	; (fc24 <ClockSetup::DrawInterface()+0x13c>)
    fb9a:	2223      	movs	r2, #35	; 0x23
    fb9c:	2101      	movs	r1, #1
    fb9e:	4620      	mov	r0, r4
    fba0:	f7f8 fca2 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
    int8_t GetMultiply() {return tocks_per_beat;}
    fba4:	6f23      	ldr	r3, [r4, #112]	; 0x70
        graphics.print(num);
    fba6:	4818      	ldr	r0, [pc, #96]	; (fc08 <ClockSetup::DrawInterface()+0x120>)
    fba8:	f993 1012 	ldrsb.w	r1, [r3, #18]
    fbac:	f00a f807 	bl	19bbe <weegfx::Graphics::print(int)>
        if (cursor == 0) gfxCursor(16, 23, 46);
    fbb0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    fbb2:	b92b      	cbnz	r3, fbc0 <ClockSetup::DrawInterface()+0xd8>
    fbb4:	232e      	movs	r3, #46	; 0x2e
    fbb6:	2217      	movs	r2, #23
    fbb8:	2110      	movs	r1, #16
    fbba:	4620      	mov	r0, r4
    fbbc:	f7f8 fc88 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 1) gfxCursor(23, 33, 18);
    fbc0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    fbc2:	2b01      	cmp	r3, #1
    fbc4:	d105      	bne.n	fbd2 <ClockSetup::DrawInterface()+0xea>
    fbc6:	2312      	movs	r3, #18
    fbc8:	2221      	movs	r2, #33	; 0x21
    fbca:	2117      	movs	r1, #23
    fbcc:	4620      	mov	r0, r4
    fbce:	f7f8 fc7f 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 2) gfxCursor(8, 43, 12);
    fbd2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    fbd4:	2b02      	cmp	r3, #2
    fbd6:	d105      	bne.n	fbe4 <ClockSetup::DrawInterface()+0xfc>
    fbd8:	230c      	movs	r3, #12
    fbda:	222b      	movs	r2, #43	; 0x2b
    fbdc:	2108      	movs	r1, #8
    fbde:	4620      	mov	r0, r4
    fbe0:	f7f8 fc76 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
    fbe4:	b002      	add	sp, #8
    fbe6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        } else if (clock_m->IsPaused()) {
    fbea:	7c6b      	ldrb	r3, [r5, #17]
    fbec:	69a0      	ldr	r0, [r4, #24]
    fbee:	b11b      	cbz	r3, fbf8 <ClockSetup::DrawInterface()+0x110>
            gfxIcon(1, 15, PAUSE_ICON);
    fbf0:	4b0d      	ldr	r3, [pc, #52]	; (fc28 <ClockSetup::DrawInterface()+0x140>)
    fbf2:	220f      	movs	r2, #15
    fbf4:	4631      	mov	r1, r6
    fbf6:	e7ae      	b.n	fb56 <ClockSetup::DrawInterface()+0x6e>
            gfxIcon(1, 15, CLOCK_ICON);
    fbf8:	4b0c      	ldr	r3, [pc, #48]	; (fc2c <ClockSetup::DrawInterface()+0x144>)
    fbfa:	220f      	movs	r2, #15
    fbfc:	4631      	mov	r1, r6
    fbfe:	f7f4 fecf 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(16, 15, "Forward");
    fc02:	4b0b      	ldr	r3, [pc, #44]	; (fc30 <ClockSetup::DrawInterface()+0x148>)
    fc04:	e7aa      	b.n	fb5c <ClockSetup::DrawInterface()+0x74>
    fc06:	bf00      	nop
    fc08:	200065e0 	.word	0x200065e0
    fc0c:	00021299 	.word	0x00021299
    fc10:	00024230 	.word	0x00024230
    fc14:	000212a5 	.word	0x000212a5
    fc18:	00023c78 	.word	0x00023c78
    fc1c:	000212f6 	.word	0x000212f6
    fc20:	000212b6 	.word	0x000212b6
    fc24:	00020ffe 	.word	0x00020ffe
    fc28:	00023c80 	.word	0x00023c80
    fc2c:	00023c28 	.word	0x00023c28
    fc30:	000212ae 	.word	0x000212ae

0000fc34 <ClockSetup::View()>:
    void View() {
    fc34:	b508      	push	{r3, lr}
        DrawInterface();
    fc36:	f7ff ff57 	bl	fae8 <ClockSetup::DrawInterface()>
    }
    fc3a:	bd08      	pop	{r3, pc}

0000fc3c <Compare::DrawInterface()>:
    void DrawInterface() {
    fc3c:	b573      	push	{r0, r1, r4, r5, r6, lr}
        gfxFrame(1, 15, 62, 6);
    fc3e:	2506      	movs	r5, #6
    void DrawInterface() {
    fc40:	4604      	mov	r4, r0
        gfxFrame(1, 15, 62, 6);
    fc42:	9500      	str	r5, [sp, #0]
    fc44:	6980      	ldr	r0, [r0, #24]
    fc46:	233e      	movs	r3, #62	; 0x3e
    fc48:	220f      	movs	r2, #15
    fc4a:	2101      	movs	r1, #1
    fc4c:	f7f4 fede 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    fc50:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
        gfxLine(x, 15, x, 20);
    fc52:	69a0      	ldr	r0, [r4, #24]
        int scaled = simfloat2int(proportion * max_value);
    fc54:	263e      	movs	r6, #62	; 0x3e
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    fc56:	22ff      	movs	r2, #255	; 0xff
    fc58:	039b      	lsls	r3, r3, #14
    fc5a:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    fc5e:	4373      	muls	r3, r6
    fc60:	139b      	asrs	r3, r3, #14
    fc62:	2214      	movs	r2, #20
    fc64:	4619      	mov	r1, r3
    fc66:	9200      	str	r2, [sp, #0]
    fc68:	220f      	movs	r2, #15
    fc6a:	f7f4 fec1 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        if (in_greater) gfxRect(1, 35, ProportionCV(ViewIn(0), 62), 6);
    fc6e:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
    fc72:	6a20      	ldr	r0, [r4, #32]
    fc74:	4631      	mov	r1, r6
    fc76:	b1cb      	cbz	r3, fcac <Compare::DrawInterface()+0x70>
    fc78:	f7f4 fcf4 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
    fc7c:	9500      	str	r5, [sp, #0]
    fc7e:	4603      	mov	r3, r0
    fc80:	2223      	movs	r2, #35	; 0x23
    fc82:	69a0      	ldr	r0, [r4, #24]
    fc84:	2101      	movs	r1, #1
    fc86:	f7f4 febb 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        if (!in_greater) gfxRect(1, 45, ProportionCV(mod_cv, 62), 6);
    fc8a:	213e      	movs	r1, #62	; 0x3e
    fc8c:	6f20      	ldr	r0, [r4, #112]	; 0x70
    fc8e:	f7f4 fce9 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
    fc92:	f894 1074 	ldrb.w	r1, [r4, #116]	; 0x74
    fc96:	2206      	movs	r2, #6
    fc98:	4603      	mov	r3, r0
    fc9a:	9200      	str	r2, [sp, #0]
    fc9c:	69a0      	ldr	r0, [r4, #24]
    fc9e:	222d      	movs	r2, #45	; 0x2d
    fca0:	b971      	cbnz	r1, fcc0 <Compare::DrawInterface()+0x84>
    fca2:	2101      	movs	r1, #1
    fca4:	f7f4 feac 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
    }
    fca8:	b002      	add	sp, #8
    fcaa:	bd70      	pop	{r4, r5, r6, pc}
        else gfxFrame(1, 35, ProportionCV(ViewIn(0), 62), 6);
    fcac:	f7f4 fcda 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
    fcb0:	9500      	str	r5, [sp, #0]
    fcb2:	4603      	mov	r3, r0
    fcb4:	2223      	movs	r2, #35	; 0x23
    fcb6:	69a0      	ldr	r0, [r4, #24]
    fcb8:	2101      	movs	r1, #1
    fcba:	f7f4 fea7 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    fcbe:	e7e4      	b.n	fc8a <Compare::DrawInterface()+0x4e>
        else gfxFrame(1, 45, ProportionCV(mod_cv, 62), 6);
    fcc0:	2101      	movs	r1, #1
    fcc2:	f7f4 fea3 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    }
    fcc6:	e7ef      	b.n	fca8 <Compare::DrawInterface()+0x6c>

0000fcc8 <Compare::View()>:
        gfxHeader(applet_name());
    fcc8:	6803      	ldr	r3, [r0, #0]
    void View() {
    fcca:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    fccc:	681b      	ldr	r3, [r3, #0]
    void View() {
    fcce:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    fcd0:	4798      	blx	r3
    fcd2:	4601      	mov	r1, r0
    fcd4:	4620      	mov	r0, r4
    fcd6:	f7f8 fc92 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
    fcda:	4620      	mov	r0, r4
    fcdc:	f7ff ffae 	bl	fc3c <Compare::DrawInterface()>
    }
    fce0:	bd10      	pop	{r4, pc}
    fce2:	Address 0x000000000000fce2 is out of bounds.


0000fce4 <DrCrusher::DrawInterface()>:
    void DrawInterface() {
    fce4:	b537      	push	{r0, r1, r2, r4, r5, lr}
        gfxPrint(1, 15, crusher_rate[rate]);
    fce6:	4b28      	ldr	r3, [pc, #160]	; (fd88 <DrCrusher::DrawInterface()+0xa4>)
    fce8:	6f02      	ldr	r2, [r0, #112]	; 0x70
    void DrawInterface() {
    fcea:	4604      	mov	r4, r0
        gfxPrint(1, 15, crusher_rate[rate]);
    fcec:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    fcf0:	2101      	movs	r1, #1
    fcf2:	220f      	movs	r2, #15
    fcf4:	f7f8 fbf8 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        graphics.print(str);
    fcf8:	4924      	ldr	r1, [pc, #144]	; (fd8c <DrCrusher::DrawInterface()+0xa8>)
    fcfa:	4825      	ldr	r0, [pc, #148]	; (fd90 <DrCrusher::DrawInterface()+0xac>)
    fcfc:	f009 feeb 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(1 + pad(10, depth + 1), 25, depth + 1);
    fd00:	6f65      	ldr	r5, [r4, #116]	; 0x74
    fd02:	3501      	adds	r5, #1
    fd04:	4629      	mov	r1, r5
    fd06:	200a      	movs	r0, #10
    fd08:	f7f4 fcbb 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    fd0c:	462b      	mov	r3, r5
    fd0e:	1c41      	adds	r1, r0, #1
    fd10:	2219      	movs	r2, #25
    fd12:	69a0      	ldr	r0, [r4, #24]
    fd14:	f7f4 feac 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
    fd18:	491e      	ldr	r1, [pc, #120]	; (fd94 <DrCrusher::DrawInterface()+0xb0>)
    fd1a:	481d      	ldr	r0, [pc, #116]	; (fd90 <DrCrusher::DrawInterface()+0xac>)
    fd1c:	f009 fedb 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (cursor == 0) gfxCursor(2, 23, 62);
    fd20:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    fd22:	b9fb      	cbnz	r3, fd64 <DrCrusher::DrawInterface()+0x80>
    fd24:	233e      	movs	r3, #62	; 0x3e
    fd26:	2217      	movs	r2, #23
        else gfxCursor(2, 33, 62);
    fd28:	2102      	movs	r1, #2
    fd2a:	4620      	mov	r0, r4
    fd2c:	f7f8 fbd0 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
    fd30:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    fd32:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
    fd36:	039b      	lsls	r3, r3, #14
    fd38:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
    fd3c:	221e      	movs	r2, #30
    fd3e:	4353      	muls	r3, r2
        w = constrain(w, -30, 30);
    fd40:	f513 2ff0 	cmn.w	r3, #491520	; 0x78000
    fd44:	ea4f 31a3 	mov.w	r1, r3, asr #14
    fd48:	db1a      	blt.n	fd80 <DrCrusher::DrawInterface()+0x9c>
    fd4a:	4291      	cmp	r1, r2
    fd4c:	dc0d      	bgt.n	fd6a <DrCrusher::DrawInterface()+0x86>
        if (w > 0) gfxRect(32, 45, w, 10);
    fd4e:	2900      	cmp	r1, #0
    fd50:	dc0c      	bgt.n	fd6c <DrCrusher::DrawInterface()+0x88>
        else gfxFrame(32 + w, 45, -w, 10);
    fd52:	230a      	movs	r3, #10
    fd54:	9300      	str	r3, [sp, #0]
    fd56:	69a0      	ldr	r0, [r4, #24]
    fd58:	424b      	negs	r3, r1
    fd5a:	222d      	movs	r2, #45	; 0x2d
    fd5c:	3120      	adds	r1, #32
    fd5e:	f7f4 fe55 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    }
    fd62:	e00b      	b.n	fd7c <DrCrusher::DrawInterface()+0x98>
        else gfxCursor(2, 33, 62);
    fd64:	233e      	movs	r3, #62	; 0x3e
    fd66:	2221      	movs	r2, #33	; 0x21
    fd68:	e7de      	b.n	fd28 <DrCrusher::DrawInterface()+0x44>
        w = constrain(w, -30, 30);
    fd6a:	4611      	mov	r1, r2
        if (w > 0) gfxRect(32, 45, w, 10);
    fd6c:	230a      	movs	r3, #10
    fd6e:	9300      	str	r3, [sp, #0]
    fd70:	69a0      	ldr	r0, [r4, #24]
    fd72:	460b      	mov	r3, r1
    fd74:	222d      	movs	r2, #45	; 0x2d
    fd76:	2120      	movs	r1, #32
    fd78:	f7f4 fe42 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
    }
    fd7c:	b003      	add	sp, #12
    fd7e:	bd30      	pop	{r4, r5, pc}
        w = constrain(w, -30, 30);
    fd80:	f06f 011d 	mvn.w	r1, #29
    fd84:	e7e5      	b.n	fd52 <DrCrusher::DrawInterface()+0x6e>
    fd86:	bf00      	nop
    fd88:	00023d10 	.word	0x00023d10
    fd8c:	000212bb 	.word	0x000212bb
    fd90:	200065e0 	.word	0x200065e0
    fd94:	000212bf 	.word	0x000212bf

0000fd98 <DrCrusher::View()>:
        gfxHeader(applet_name());
    fd98:	6803      	ldr	r3, [r0, #0]
    void View() {
    fd9a:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    fd9c:	681b      	ldr	r3, [r3, #0]
    void View() {
    fd9e:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    fda0:	4798      	blx	r3
    fda2:	4601      	mov	r1, r0
    fda4:	4620      	mov	r0, r4
    fda6:	f7f8 fc2a 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
    fdaa:	4620      	mov	r0, r4
    fdac:	f7ff ff9a 	bl	fce4 <DrCrusher::DrawInterface()>
    }
    fdb0:	bd10      	pop	{r4, pc}

0000fdb2 <DualQuant::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
    fdb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        scale[0] = Unpack(data, PackLocation {0,8});
    fdb6:	2300      	movs	r3, #0
    void OnDataReceive(uint32_t data) {
    fdb8:	460e      	mov	r6, r1
        scale[0] = Unpack(data, PackLocation {0,8});
    fdba:	2508      	movs	r5, #8
    void OnDataReceive(uint32_t data) {
    fdbc:	b088      	sub	sp, #32
    fdbe:	4604      	mov	r4, r0
        scale[0] = Unpack(data, PackLocation {0,8});
    fdc0:	4619      	mov	r1, r3
    fdc2:	462a      	mov	r2, r5
    fdc4:	4630      	mov	r0, r6
    fdc6:	e9cd 3500 	strd	r3, r5, [sp]
    fdca:	f7f4 f831 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        scale[1] = Unpack(data, PackLocation {8,8});
    fdce:	462a      	mov	r2, r5
        scale[0] = Unpack(data, PackLocation {0,8});
    fdd0:	4607      	mov	r7, r0
    fdd2:	f8c4 02ec 	str.w	r0, [r4, #748]	; 0x2ec
        scale[1] = Unpack(data, PackLocation {8,8});
    fdd6:	4629      	mov	r1, r5
    fdd8:	4630      	mov	r0, r6
    fdda:	e9cd 5502 	strd	r5, r5, [sp, #8]
    fdde:	f7f4 f827 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        root[0] = Unpack(data, PackLocation {16,4});
    fde2:	f04f 0804 	mov.w	r8, #4
    fde6:	2310      	movs	r3, #16
        scale[1] = Unpack(data, PackLocation {8,8});
    fde8:	f8c4 02f0 	str.w	r0, [r4, #752]	; 0x2f0
        root[0] = Unpack(data, PackLocation {16,4});
    fdec:	4642      	mov	r2, r8
    fdee:	4619      	mov	r1, r3
    fdf0:	4630      	mov	r0, r6
    fdf2:	e9cd 3804 	strd	r3, r8, [sp, #16]
    fdf6:	f7f4 f81b 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        root[1] = Unpack(data, PackLocation {20,4});
    fdfa:	2314      	movs	r3, #20
    fdfc:	e9cd 3806 	strd	r3, r8, [sp, #24]
    fe00:	ab08      	add	r3, sp, #32
    fe02:	e913 0006 	ldmdb	r3, {r1, r2}
        root[0] = Unpack(data, PackLocation {16,4});
    fe06:	4605      	mov	r5, r0
        root[1] = Unpack(data, PackLocation {20,4});
    fe08:	4630      	mov	r0, r6
    fe0a:	f7f4 f811 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
            root[0] = constrain(root[0], 0, 11);
    fe0e:	b2eb      	uxtb	r3, r5
    fe10:	2b0b      	cmp	r3, #11
    fe12:	bfa8      	it	ge
    fe14:	230b      	movge	r3, #11
    fe16:	f884 32f4 	strb.w	r3, [r4, #756]	; 0x2f4
        root[1] = Unpack(data, PackLocation {20,4});
    fe1a:	f884 02f5 	strb.w	r0, [r4, #757]	; 0x2f5
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    fe1e:	4638      	mov	r0, r7
    fe20:	f7f1 f8a8 	bl	f74 <OC::Scales::GetScale(int)>
    fe24:	f64f 72ff 	movw	r2, #65535	; 0xffff
    fe28:	4601      	mov	r1, r0
    fe2a:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    fe2e:	f7f6 f8e5 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
            root[0] = constrain(root[0], 0, 11);
    fe32:	f894 32f4 	ldrb.w	r3, [r4, #756]	; 0x2f4
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    fe36:	f8d4 02f0 	ldr.w	r0, [r4, #752]	; 0x2f0
            root[0] = constrain(root[0], 0, 11);
    fe3a:	2b0b      	cmp	r3, #11
    fe3c:	bfa8      	it	ge
    fe3e:	230b      	movge	r3, #11
    fe40:	f884 32f4 	strb.w	r3, [r4, #756]	; 0x2f4
            quantizer[ch].Configure(OC::Scales::GetScale(scale[ch]), 0xffff);
    fe44:	f7f1 f896 	bl	f74 <OC::Scales::GetScale(int)>
    fe48:	f64f 72ff 	movw	r2, #65535	; 0xffff
    fe4c:	4601      	mov	r1, r0
    fe4e:	f504 70d2 	add.w	r0, r4, #420	; 0x1a4
    fe52:	f7f6 f8d3 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    }
    fe56:	b008      	add	sp, #32
    fe58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000fe5c <DualQuant_OnDataReceive(bool, unsigned long)>:

void DualQuant_OnDataReceive(bool hemisphere, uint32_t data) {
    fe5c:	b508      	push	{r3, lr}
    DualQuant_instance[hemisphere].OnDataReceive(data);
    fe5e:	4b04      	ldr	r3, [pc, #16]	; (fe70 <DualQuant_OnDataReceive(bool, unsigned long)+0x14>)
    fe60:	f44f 723e 	mov.w	r2, #760	; 0x2f8
    fe64:	fb02 3000 	mla	r0, r2, r0, r3
    fe68:	f7ff ffa3 	bl	fdb2 <DualQuant::OnDataReceive(unsigned long)>
}
    fe6c:	bd08      	pop	{r3, pc}
    fe6e:	bf00      	nop
    fe70:	1fffcda4 	.word	0x1fffcda4

0000fe74 <DualQuant::DrawSelector()>:
    void DrawSelector()
    fe74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fe78:	b087      	sub	sp, #28
    fe7a:	4604      	mov	r4, r0
        const uint8_t notes[2][8] = {{0xc0, 0xe0, 0xe0, 0xe0, 0x7f, 0x02, 0x14, 0x08},
    fe7c:	4936      	ldr	r1, [pc, #216]	; (ff58 <DualQuant::DrawSelector()+0xe4>)
            gfxPrint((31 * ch), 15, OC::scale_names_short[scale[ch]]);
    fe7e:	f8df 90dc 	ldr.w	r9, [pc, #220]	; ff5c <DualQuant::DrawSelector()+0xe8>
        const uint8_t notes[2][8] = {{0xc0, 0xe0, 0xe0, 0xe0, 0x7f, 0x02, 0x14, 0x08},
    fe82:	2210      	movs	r2, #16
    fe84:	a802      	add	r0, sp, #8
    fe86:	f00a f8b3 	bl	19ff0 <memcpy>
        ForEachChannel(ch)
    fe8a:	f504 7736 	add.w	r7, r4, #728	; 0x2d8
    fe8e:	f204 26e3 	addw	r6, r4, #739	; 0x2e3
    fe92:	2500      	movs	r5, #0
            gfxPrint((31 * ch), 15, OC::scale_names_short[scale[ch]]);
    fe94:	697b      	ldr	r3, [r7, #20]
    fe96:	ebc5 1a45 	rsb	sl, r5, r5, lsl #5
    fe9a:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
    fe9e:	220f      	movs	r2, #15
    fea0:	4651      	mov	r1, sl
    fea2:	4620      	mov	r0, r4
    fea4:	f7f8 fb20 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxBitmap(0 + (31 * ch), 25, 8, notes[ch]);
    fea8:	ab02      	add	r3, sp, #8
    feaa:	eb03 08c5 	add.w	r8, r3, r5, lsl #3
    feae:	69a0      	ldr	r0, [r4, #24]
    feb0:	f8cd 8000 	str.w	r8, [sp]
    feb4:	2308      	movs	r3, #8
    feb6:	2219      	movs	r2, #25
    feb8:	4651      	mov	r1, sl
    feba:	f7f4 fd6b 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10 + (31 * ch), 25, OC::Strings::note_names_unpadded[root[ch]]);
    febe:	7c72      	ldrb	r2, [r6, #17]
    fec0:	4b27      	ldr	r3, [pc, #156]	; (ff60 <DualQuant::DrawSelector()+0xec>)
    fec2:	f10a 0b0a 	add.w	fp, sl, #10
    fec6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    feca:	4659      	mov	r1, fp
    fecc:	2219      	movs	r2, #25
    fece:	4620      	mov	r0, r4
    fed0:	f7f8 fb0a 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            int cursor_ch = cursor / 2;
    fed4:	f8d4 32e8 	ldr.w	r3, [r4, #744]	; 0x2e8
    fed8:	eb03 72d3 	add.w	r2, r3, r3, lsr #31
            if (ch == cursor_ch) {
    fedc:	ebb5 0f62 	cmp.w	r5, r2, asr #1
    fee0:	d10c      	bne.n	fefc <DualQuant::DrawSelector()+0x88>
                if (cursor == 0 || cursor == 2) gfxCursor(0 + (31 * ch), 23, 30);
    fee2:	f033 0302 	bics.w	r3, r3, #2
    fee6:	bf03      	ittte	eq
    fee8:	231e      	moveq	r3, #30
    feea:	2217      	moveq	r2, #23
    feec:	4651      	moveq	r1, sl
                else gfxCursor(10 + (31 * ch), 33, 12);
    feee:	230c      	movne	r3, #12
    fef0:	bf1c      	itt	ne
    fef2:	2221      	movne	r2, #33	; 0x21
    fef4:	4659      	movne	r1, fp
    fef6:	4620      	mov	r0, r4
    fef8:	f7f8 faea 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            if (!continuous[ch]) gfxBitmap(1, 41 + (10 * ch),  8, CLOCK_ICON); // Display icon if clocked
    fefc:	f04f 0a0a 	mov.w	sl, #10
    ff00:	f816 3f01 	ldrb.w	r3, [r6, #1]!
    ff04:	fb0a fa05 	mul.w	sl, sl, r5
    ff08:	f10a 0a29 	add.w	sl, sl, #41	; 0x29
    ff0c:	b93b      	cbnz	r3, ff1e <DualQuant::DrawSelector()+0xaa>
    ff0e:	4b15      	ldr	r3, [pc, #84]	; (ff64 <DualQuant::DrawSelector()+0xf0>)
    ff10:	9300      	str	r3, [sp, #0]
    ff12:	69a0      	ldr	r0, [r4, #24]
    ff14:	2308      	movs	r3, #8
    ff16:	4652      	mov	r2, sl
    ff18:	2101      	movs	r1, #1
    ff1a:	f7f4 fd3b 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            int semitone = (last_note[ch] / 128) % 12;
    ff1e:	f857 1f04 	ldr.w	r1, [r7, #4]!
            gfxBitmap(10 + note_x, 41 + (10 * ch), 8, notes[ch]);
    ff22:	69a0      	ldr	r0, [r4, #24]
    ff24:	f8cd 8000 	str.w	r8, [sp]
            int semitone = (last_note[ch] / 128) % 12;
    ff28:	2900      	cmp	r1, #0
    ff2a:	bfb8      	it	lt
    ff2c:	317f      	addlt	r1, #127	; 0x7f
    ff2e:	230c      	movs	r3, #12
    ff30:	11c9      	asrs	r1, r1, #7
    ff32:	fb91 f2f3 	sdiv	r2, r1, r3
    ff36:	fb03 1112 	mls	r1, r3, r2, r1
            int note_x = semitone * 4; // 4 pixels per semitone
    ff3a:	0089      	lsls	r1, r1, #2
            gfxBitmap(10 + note_x, 41 + (10 * ch), 8, notes[ch]);
    ff3c:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
    ff40:	2308      	movs	r3, #8
    ff42:	4652      	mov	r2, sl
    ff44:	310a      	adds	r1, #10
    ff46:	f7f4 fd25 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        ForEachChannel(ch)
    ff4a:	b115      	cbz	r5, ff52 <DualQuant::DrawSelector()+0xde>
    }
    ff4c:	b007      	add	sp, #28
    ff4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ff52:	2501      	movs	r5, #1
    ff54:	e79e      	b.n	fe94 <DualQuant::DrawSelector()+0x20>
    ff56:	bf00      	nop
    ff58:	00022eee 	.word	0x00022eee
    ff5c:	0001e600 	.word	0x0001e600
    ff60:	0001f374 	.word	0x0001f374
    ff64:	00023c28 	.word	0x00023c28

0000ff68 <DualQuant::View()>:
        gfxHeader(applet_name());
    ff68:	6803      	ldr	r3, [r0, #0]
    void View() {
    ff6a:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
    ff6c:	681b      	ldr	r3, [r3, #0]
    void View() {
    ff6e:	4604      	mov	r4, r0
        gfxHeader(applet_name());
    ff70:	4798      	blx	r3
    ff72:	4601      	mov	r1, r0
    ff74:	4620      	mov	r0, r4
    ff76:	f7f8 fb42 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSelector();
    ff7a:	4620      	mov	r0, r4
    ff7c:	f7ff ff7a 	bl	fe74 <DualQuant::DrawSelector()>
    }
    ff80:	bd10      	pop	{r4, pc}
    ff82:	Address 0x000000000000ff82 is out of bounds.


0000ff84 <EnigmaJr::DrawInterface()>:
    void DrawInterface() {
    ff84:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ff86:	4604      	mov	r4, r0
        HS::TuringMachine::SetName(name, tm_state.GetTMIndex());
    ff88:	f890 1304 	ldrb.w	r1, [r0, #772]	; 0x304
    ff8c:	a801      	add	r0, sp, #4
    ff8e:	f7f5 ff45 	bl	5e1c <HS::TuringMachine::SetName(char*, unsigned char)>
        gfxPrint(1, 15, name);
    ff92:	ab01      	add	r3, sp, #4
    ff94:	220f      	movs	r2, #15
    ff96:	2101      	movs	r1, #1
    ff98:	4620      	mov	r0, r4
    ff9a:	f7f8 faa5 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (tm_state.IsFavorite()) gfxIcon(20, 15, FAVORITE_ICON);
    ff9e:	f894 3309 	ldrb.w	r3, [r4, #777]	; 0x309
    ffa2:	b12b      	cbz	r3, ffb0 <EnigmaJr::DrawInterface()+0x2c>
    ffa4:	4b49      	ldr	r3, [pc, #292]	; (100cc <EnigmaJr::DrawInterface()+0x148>)
    ffa6:	69a0      	ldr	r0, [r4, #24]
    ffa8:	220f      	movs	r2, #15
    ffaa:	2114      	movs	r1, #20
    ffac:	f7f4 fcf8 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        if (cursor == 0) {
    ffb0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    ffb2:	2b00      	cmp	r3, #0
    ffb4:	d17a      	bne.n	100ac <EnigmaJr::DrawInterface()+0x128>
    byte GetLength() {return len;}
    ffb6:	f894 5308 	ldrb.w	r5, [r4, #776]	; 0x308
            if (length > 0) {
    ffba:	2d00      	cmp	r5, #0
    ffbc:	d071      	beq.n	100a2 <EnigmaJr::DrawInterface()+0x11e>
                gfxIcon(42, 15, LOOP_ICON);
    ffbe:	4b44      	ldr	r3, [pc, #272]	; (100d0 <EnigmaJr::DrawInterface()+0x14c>)
    ffc0:	69a0      	ldr	r0, [r4, #24]
    ffc2:	220f      	movs	r2, #15
    ffc4:	212a      	movs	r1, #42	; 0x2a
    ffc6:	f7f4 fceb 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
                gfxPrint(52 + pad(10, length), 15, length);
    ffca:	4629      	mov	r1, r5
    ffcc:	200a      	movs	r0, #10
    ffce:	f7f4 fb58 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
    ffd2:	462b      	mov	r3, r5
    ffd4:	f100 0134 	add.w	r1, r0, #52	; 0x34
    ffd8:	220f      	movs	r2, #15
    ffda:	69a0      	ldr	r0, [r4, #24]
    ffdc:	f7f4 fd48 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
            if (hemisphere) o += 2;
    ffe0:	7923      	ldrb	r3, [r4, #4]
            gfxPrint(enigma_type_short_names[output[ch].type()]);
    ffe2:	4d3c      	ldr	r5, [pc, #240]	; (100d4 <EnigmaJr::DrawInterface()+0x150>)
            if (hemisphere) o += 2;
    ffe4:	2b00      	cmp	r3, #0
    ffe6:	bf0c      	ite	eq
    ffe8:	2341      	moveq	r3, #65	; 0x41
    ffea:	2343      	movne	r3, #67	; 0x43
            char out_name[3] = {o, ':', '\0'};
    ffec:	2700      	movs	r7, #0
            gfxPrint(1, 25 + (ch * 10), out_name);
    ffee:	2219      	movs	r2, #25
            char out_name[3] = {o, ':', '\0'};
    fff0:	263a      	movs	r6, #58	; 0x3a
    fff2:	f88d 3000 	strb.w	r3, [sp]
            gfxPrint(1, 25 + (ch * 10), out_name);
    fff6:	2101      	movs	r1, #1
    fff8:	466b      	mov	r3, sp
    fffa:	4620      	mov	r0, r4
            char out_name[3] = {o, ':', '\0'};
    fffc:	f88d 7002 	strb.w	r7, [sp, #2]
   10000:	f88d 6001 	strb.w	r6, [sp, #1]
            gfxPrint(1, 25 + (ch * 10), out_name);
   10004:	f7f8 fa70 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(enigma_type_short_names[output[ch].type()]);
   10008:	f894 31b9 	ldrb.w	r3, [r4, #441]	; 0x1b9
        graphics.print(str);
   1000c:	4832      	ldr	r0, [pc, #200]	; (100d8 <EnigmaJr::DrawInterface()+0x154>)
   1000e:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
   10012:	f009 fd60 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (hemisphere) o += 2;
   10016:	7923      	ldrb	r3, [r4, #4]
            char out_name[3] = {o, ':', '\0'};
   10018:	f88d 7002 	strb.w	r7, [sp, #2]
            if (hemisphere) o += 2;
   1001c:	42bb      	cmp	r3, r7
   1001e:	bf0c      	ite	eq
   10020:	2342      	moveq	r3, #66	; 0x42
   10022:	2344      	movne	r3, #68	; 0x44
            char out_name[3] = {o, ':', '\0'};
   10024:	f88d 3000 	strb.w	r3, [sp]
            gfxPrint(1, 25 + (ch * 10), out_name);
   10028:	2223      	movs	r2, #35	; 0x23
   1002a:	466b      	mov	r3, sp
   1002c:	2101      	movs	r1, #1
   1002e:	4620      	mov	r0, r4
            char out_name[3] = {o, ':', '\0'};
   10030:	f88d 6001 	strb.w	r6, [sp, #1]
            gfxPrint(1, 25 + (ch * 10), out_name);
   10034:	f7f8 fa58 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(enigma_type_short_names[output[ch].type()]);
   10038:	f894 3301 	ldrb.w	r3, [r4, #769]	; 0x301
   1003c:	4826      	ldr	r0, [pc, #152]	; (100d8 <EnigmaJr::DrawInterface()+0x154>)
   1003e:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
   10042:	f009 fd48 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (cursor == 0) gfxCursor(1, 23, 18);
   10046:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   10048:	b92b      	cbnz	r3, 10056 <EnigmaJr::DrawInterface()+0xd2>
   1004a:	2312      	movs	r3, #18
   1004c:	2217      	movs	r2, #23
   1004e:	2101      	movs	r1, #1
   10050:	4620      	mov	r0, r4
   10052:	f7f8 fa3d 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 1) gfxCursor(46, 23, 18);
   10056:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   10058:	2b01      	cmp	r3, #1
   1005a:	d105      	bne.n	10068 <EnigmaJr::DrawInterface()+0xe4>
   1005c:	2312      	movs	r3, #18
   1005e:	2217      	movs	r2, #23
   10060:	212e      	movs	r1, #46	; 0x2e
   10062:	4620      	mov	r0, r4
   10064:	f7f8 fa34 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 2) gfxCursor(13, 33, 44);
   10068:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   1006a:	2b02      	cmp	r3, #2
   1006c:	d105      	bne.n	1007a <EnigmaJr::DrawInterface()+0xf6>
   1006e:	232c      	movs	r3, #44	; 0x2c
   10070:	2221      	movs	r2, #33	; 0x21
   10072:	210d      	movs	r1, #13
   10074:	4620      	mov	r0, r4
   10076:	f7f8 fa2b 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 3) gfxCursor(13, 43, 44);
   1007a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   1007c:	2b03      	cmp	r3, #3
   1007e:	d105      	bne.n	1008c <EnigmaJr::DrawInterface()+0x108>
   10080:	232c      	movs	r3, #44	; 0x2c
   10082:	222b      	movs	r2, #43	; 0x2b
   10084:	210d      	movs	r1, #13
   10086:	4620      	mov	r0, r4
   10088:	f7f8 fa22 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        tm_state.DrawAt(hemisphere * 64, 45);
   1008c:	7921      	ldrb	r1, [r4, #4]
   1008e:	0189      	lsls	r1, r1, #6
   10090:	222d      	movs	r2, #45	; 0x2d
   10092:	f001 01c0 	and.w	r1, r1, #192	; 0xc0
   10096:	f504 7041 	add.w	r0, r4, #772	; 0x304
   1009a:	f7f5 ff1b 	bl	5ed4 <TuringMachineState::DrawAt(unsigned char, unsigned char)>
    }
   1009e:	b003      	add	sp, #12
   100a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   100a2:	490e      	ldr	r1, [pc, #56]	; (100dc <EnigmaJr::DrawInterface()+0x158>)
   100a4:	480c      	ldr	r0, [pc, #48]	; (100d8 <EnigmaJr::DrawInterface()+0x154>)
   100a6:	f009 fd16 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    }
   100aa:	e799      	b.n	ffe0 <EnigmaJr::DrawInterface()+0x5c>
            gfxPrint(34, 15, "p=");
   100ac:	4b0c      	ldr	r3, [pc, #48]	; (100e0 <EnigmaJr::DrawInterface()+0x15c>)
   100ae:	220f      	movs	r2, #15
   100b0:	4620      	mov	r0, r4
   100b2:	2122      	movs	r1, #34	; 0x22
   100b4:	f7f8 fa18 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(pad(100, p), p);
   100b8:	f994 5071 	ldrsb.w	r5, [r4, #113]	; 0x71
   100bc:	2064      	movs	r0, #100	; 0x64
   100be:	4629      	mov	r1, r5
   100c0:	f7f4 fadf 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   100c4:	4629      	mov	r1, r5
   100c6:	f7f4 fcb7 	bl	4a38 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]>
   100ca:	e789      	b.n	ffe0 <EnigmaJr::DrawInterface()+0x5c>
   100cc:	00023d58 	.word	0x00023d58
   100d0:	00024218 	.word	0x00024218
   100d4:	1fffa08c 	.word	0x1fffa08c
   100d8:	200065e0 	.word	0x200065e0
   100dc:	00021123 	.word	0x00021123
   100e0:	00020fc5 	.word	0x00020fc5

000100e4 <EnigmaJr::View()>:
        gfxHeader(applet_name());
   100e4:	6803      	ldr	r3, [r0, #0]
    void View() {
   100e6:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   100e8:	681b      	ldr	r3, [r3, #0]
    void View() {
   100ea:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   100ec:	4798      	blx	r3
   100ee:	4601      	mov	r1, r0
   100f0:	4620      	mov	r0, r4
   100f2:	f7f8 fa84 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   100f6:	4620      	mov	r0, r4
   100f8:	f7ff ff44 	bl	ff84 <EnigmaJr::DrawInterface()>
    }
   100fc:	bd10      	pop	{r4, pc}

000100fe <EnigmaJr::SwitchTuringMachine(unsigned char)>:
    void SwitchTuringMachine(byte ix) {
   100fe:	b510      	push	{r4, lr}
   10100:	4604      	mov	r4, r0
        tm_state.Init(ix);
   10102:	f500 7041 	add.w	r0, r0, #772	; 0x304
   10106:	f7f5 fe95 	bl	5e34 <TuringMachineState::Init(unsigned char)>
    void SetWriteMode(bool write_) {write = write_;}
   1010a:	2300      	movs	r3, #0
   1010c:	f884 330a 	strb.w	r3, [r4, #778]	; 0x30a
        length = tm_state.GetLength();
   10110:	f894 3308 	ldrb.w	r3, [r4, #776]	; 0x308
   10114:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
    }
   10118:	bd10      	pop	{r4, pc}

0001011a <EnigmaJr::Start()>:
    void Start() {
   1011a:	b510      	push	{r4, lr}
            output[ch].InitAs(ch);
   1011c:	2100      	movs	r1, #0
    void Start() {
   1011e:	4604      	mov	r4, r0
            output[ch].InitAs(ch);
   10120:	3074      	adds	r0, #116	; 0x74
   10122:	f7f6 f99f 	bl	6464 <EnigmaOutput::InitAs(unsigned char)>
   10126:	f504 70de 	add.w	r0, r4, #444	; 0x1bc
   1012a:	2101      	movs	r1, #1
   1012c:	f7f6 f99a 	bl	6464 <EnigmaOutput::InitAs(unsigned char)>
        SwitchTuringMachine(0);
   10130:	2100      	movs	r1, #0
   10132:	4620      	mov	r0, r4
   10134:	f7ff ffe3 	bl	100fe <EnigmaJr::SwitchTuringMachine(unsigned char)>
    }
   10138:	bd10      	pop	{r4, pc}
   1013a:	Address 0x000000000001013a is out of bounds.


0001013c <EnigmaJr_OnEncoderMove(bool, int)>:
void EnigmaJr_OnEncoderMove(bool hemisphere, int direction) {EnigmaJr_instance[hemisphere].OnEncoderMove(direction);}
   1013c:	b570      	push	{r4, r5, r6, lr}
        if (cursor == 0) { // Switch TM
   1013e:	4d1e      	ldr	r5, [pc, #120]	; (101b8 <EnigmaJr_OnEncoderMove(bool, int)+0x7c>)
   10140:	f44f 7443 	mov.w	r4, #780	; 0x30c
   10144:	4344      	muls	r4, r0
void EnigmaJr_OnEncoderMove(bool hemisphere, int direction) {EnigmaJr_instance[hemisphere].OnEncoderMove(direction);}
   10146:	4602      	mov	r2, r0
        if (cursor == 0) { // Switch TM
   10148:	1928      	adds	r0, r5, r4
   1014a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
   1014c:	b96b      	cbnz	r3, 1016a <EnigmaJr_OnEncoderMove(bool, int)+0x2e>
    byte GetTMIndex() {return ix;}
   1014e:	f890 3304 	ldrb.w	r3, [r0, #772]	; 0x304
            byte new_tm = constrain(prev_tm + direction, 0, HS::TURING_MACHINE_COUNT - 1);
   10152:	4419      	add	r1, r3
   10154:	2927      	cmp	r1, #39	; 0x27
   10156:	bfa8      	it	ge
   10158:	2127      	movge	r1, #39	; 0x27
   1015a:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   1015e:	b2c9      	uxtb	r1, r1
            if (prev_tm != new_tm) SwitchTuringMachine(new_tm);
   10160:	428b      	cmp	r3, r1
   10162:	d001      	beq.n	10168 <EnigmaJr_OnEncoderMove(bool, int)+0x2c>
   10164:	f7ff ffcb 	bl	100fe <EnigmaJr::SwitchTuringMachine(unsigned char)>
void EnigmaJr_OnEncoderMove(bool hemisphere, int direction) {EnigmaJr_instance[hemisphere].OnEncoderMove(direction);}
   10168:	bd70      	pop	{r4, r5, r6, pc}
        } else if (cursor ==1) { // Probability
   1016a:	2b01      	cmp	r3, #1
   1016c:	d10a      	bne.n	10184 <EnigmaJr_OnEncoderMove(bool, int)+0x48>
            p = constrain(p + direction, 0, 100);
   1016e:	f990 3071 	ldrsb.w	r3, [r0, #113]	; 0x71
   10172:	440b      	add	r3, r1
   10174:	2b64      	cmp	r3, #100	; 0x64
   10176:	bfa8      	it	ge
   10178:	2364      	movge	r3, #100	; 0x64
   1017a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   1017e:	f880 3071 	strb.w	r3, [r0, #113]	; 0x71
    }
   10182:	e7f1      	b.n	10168 <EnigmaJr_OnEncoderMove(bool, int)+0x2c>
            byte o = cursor - 2; // Which output
   10184:	3b02      	subs	r3, #2
            if (output[o].type() > 0 || direction > 0)
   10186:	b2d8      	uxtb	r0, r3
   10188:	f44f 76a4 	mov.w	r6, #328	; 0x148
   1018c:	fb06 4400 	mla	r4, r6, r0, r4
   10190:	442c      	add	r4, r5
   10192:	f894 31b9 	ldrb.w	r3, [r4, #441]	; 0x1b9
   10196:	b90b      	cbnz	r3, 1019c <EnigmaJr_OnEncoderMove(bool, int)+0x60>
   10198:	2900      	cmp	r1, #0
   1019a:	dde5      	ble.n	10168 <EnigmaJr_OnEncoderMove(bool, int)+0x2c>
    void set_type(byte type_) {ty = constrain(type_, 0, EnigmaOutputType::GATE);}
   1019c:	f44f 7443 	mov.w	r4, #780	; 0x30c
   101a0:	4362      	muls	r2, r4
                output[o].set_type(output[o].type() + direction);
   101a2:	440b      	add	r3, r1
   101a4:	b2db      	uxtb	r3, r3
   101a6:	fb06 2200 	mla	r2, r6, r0, r2
   101aa:	4415      	add	r5, r2
   101ac:	2b08      	cmp	r3, #8
   101ae:	bf28      	it	cs
   101b0:	2308      	movcs	r3, #8
   101b2:	f885 31b9 	strb.w	r3, [r5, #441]	; 0x1b9
void EnigmaJr_OnEncoderMove(bool hemisphere, int direction) {EnigmaJr_instance[hemisphere].OnEncoderMove(direction);}
   101b6:	e7d7      	b.n	10168 <EnigmaJr_OnEncoderMove(bool, int)+0x2c>
   101b8:	1fffd394 	.word	0x1fffd394

000101bc <EnigmaJr::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   101bc:	b570      	push	{r4, r5, r6, lr}
        p = Unpack(data, PackLocation {0,7});
   101be:	2300      	movs	r3, #0
    void OnDataReceive(uint32_t data) {
   101c0:	460d      	mov	r5, r1
        p = Unpack(data, PackLocation {0,7});
   101c2:	2607      	movs	r6, #7
    void OnDataReceive(uint32_t data) {
   101c4:	b088      	sub	sp, #32
   101c6:	4604      	mov	r4, r0
        p = Unpack(data, PackLocation {0,7});
   101c8:	4619      	mov	r1, r3
   101ca:	4632      	mov	r2, r6
   101cc:	4628      	mov	r0, r5
   101ce:	e9cd 3600 	strd	r3, r6, [sp]
   101d2:	f7f3 fe2d 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        output[0].set_type(Unpack(data, PackLocation {7,4}));
   101d6:	9602      	str	r6, [sp, #8]
   101d8:	2604      	movs	r6, #4
        p = Unpack(data, PackLocation {0,7});
   101da:	f884 0071 	strb.w	r0, [r4, #113]	; 0x71
        output[0].set_type(Unpack(data, PackLocation {7,4}));
   101de:	4632      	mov	r2, r6
   101e0:	2107      	movs	r1, #7
   101e2:	4628      	mov	r0, r5
   101e4:	9603      	str	r6, [sp, #12]
   101e6:	f7f3 fe23 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   101ea:	b2c0      	uxtb	r0, r0
   101ec:	2808      	cmp	r0, #8
   101ee:	bf28      	it	cs
   101f0:	2008      	movcs	r0, #8
        output[1].set_type(Unpack(data, PackLocation {11,4}));
   101f2:	230b      	movs	r3, #11
   101f4:	f884 01b9 	strb.w	r0, [r4, #441]	; 0x1b9
   101f8:	4632      	mov	r2, r6
   101fa:	4619      	mov	r1, r3
   101fc:	4628      	mov	r0, r5
   101fe:	e9cd 3604 	strd	r3, r6, [sp, #16]
   10202:	f7f3 fe15 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        SwitchTuringMachine(Unpack(data, PackLocation {15,16}));
   10206:	220f      	movs	r2, #15
   10208:	2310      	movs	r3, #16
   1020a:	e9cd 2306 	strd	r2, r3, [sp, #24]
   1020e:	b2c0      	uxtb	r0, r0
   10210:	2808      	cmp	r0, #8
   10212:	bf28      	it	cs
   10214:	2008      	movcs	r0, #8
   10216:	ab08      	add	r3, sp, #32
   10218:	e913 0006 	ldmdb	r3, {r1, r2}
   1021c:	f884 0301 	strb.w	r0, [r4, #769]	; 0x301
   10220:	4628      	mov	r0, r5
   10222:	f7f3 fe05 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   10226:	b2c1      	uxtb	r1, r0
   10228:	4620      	mov	r0, r4
   1022a:	f7ff ff68 	bl	100fe <EnigmaJr::SwitchTuringMachine(unsigned char)>
    }
   1022e:	b008      	add	sp, #32
   10230:	bd70      	pop	{r4, r5, r6, pc}
   10232:	Address 0x0000000000010232 is out of bounds.


00010234 <EnigmaJr_OnDataReceive(bool, unsigned long)>:
void EnigmaJr_OnDataReceive(bool hemisphere, uint32_t data) {EnigmaJr_instance[hemisphere].OnDataReceive(data);}
   10234:	b508      	push	{r3, lr}
   10236:	4b04      	ldr	r3, [pc, #16]	; (10248 <EnigmaJr_OnDataReceive(bool, unsigned long)+0x14>)
   10238:	f44f 7243 	mov.w	r2, #780	; 0x30c
   1023c:	fb02 3000 	mla	r0, r2, r0, r3
   10240:	f7ff ffbc 	bl	101bc <EnigmaJr::OnDataReceive(unsigned long)>
   10244:	bd08      	pop	{r3, pc}
   10246:	bf00      	nop
   10248:	1fffd394 	.word	0x1fffd394

0001024c <EnigmaJr::Organize(int)>:
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1024c:	f5b1 5ff0 	cmp.w	r1, #7680	; 0x1e00
   10250:	bfa8      	it	ge
   10252:	f44f 51f0 	movge.w	r1, #7680	; 0x1e00
   10256:	038b      	lsls	r3, r1, #14
        int scaled = simfloat2int(proportion * max_value);
   10258:	2127      	movs	r1, #39	; 0x27
    void Organize(int cv) {
   1025a:	b570      	push	{r4, r5, r6, lr}
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1025c:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
        byte next_tm = Proportion(cv, HEMISPHERE_MAX_CV, HS::TURING_MACHINE_COUNT - 1);
   10260:	2400      	movs	r4, #0
   10262:	fb93 f3f2 	sdiv	r3, r3, r2
        for (byte i = 0; i < HS::TURING_MACHINE_COUNT; i++) favorites += HS::user_turing_machines[i].favorite;
   10266:	4d17      	ldr	r5, [pc, #92]	; (102c4 <EnigmaJr::Organize(int)+0x78>)
        int scaled = simfloat2int(proportion * max_value);
   10268:	4359      	muls	r1, r3
        byte next_tm = Proportion(cv, HEMISPHERE_MAX_CV, HS::TURING_MACHINE_COUNT - 1);
   1026a:	f3c1 3187 	ubfx	r1, r1, #14, #8
        byte favorites = 0;
   1026e:	4622      	mov	r2, r4
        for (byte i = 0; i < HS::TURING_MACHINE_COUNT; i++) favorites += HS::user_turing_machines[i].favorite;
   10270:	eb05 0684 	add.w	r6, r5, r4, lsl #2
   10274:	3401      	adds	r4, #1
   10276:	78f6      	ldrb	r6, [r6, #3]
   10278:	2c28      	cmp	r4, #40	; 0x28
   1027a:	4432      	add	r2, r6
   1027c:	b2d2      	uxtb	r2, r2
   1027e:	d1f7      	bne.n	10270 <EnigmaJr::Organize(int)+0x24>
        if (favorites > 0) {
   10280:	b1b2      	cbz	r2, 102b0 <EnigmaJr::Organize(int)+0x64>
   10282:	4353      	muls	r3, r2
   10284:	139b      	asrs	r3, r3, #14
            byte pick = Proportion(cv, HEMISPHERE_MAX_CV, favorites) + 1;
   10286:	3301      	adds	r3, #1
            pick = constrain(pick, 1, favorites);
   10288:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   1028c:	d017      	beq.n	102be <EnigmaJr::Organize(int)+0x72>
   1028e:	4293      	cmp	r3, r2
   10290:	bf28      	it	cs
   10292:	4613      	movcs	r3, r2
            for (int i = 0; i < HS::TURING_MACHINE_COUNT; i++)
   10294:	2200      	movs	r2, #0
            favorites = 0;
   10296:	4614      	mov	r4, r2
                if (HS::user_turing_machines[i].favorite) {
   10298:	eb05 0682 	add.w	r6, r5, r2, lsl #2
   1029c:	78f6      	ldrb	r6, [r6, #3]
   1029e:	b126      	cbz	r6, 102aa <EnigmaJr::Organize(int)+0x5e>
                    if (++favorites == pick) {
   102a0:	3401      	adds	r4, #1
   102a2:	b2e4      	uxtb	r4, r4
   102a4:	42a3      	cmp	r3, r4
   102a6:	b2d1      	uxtb	r1, r2
   102a8:	d002      	beq.n	102b0 <EnigmaJr::Organize(int)+0x64>
            for (int i = 0; i < HS::TURING_MACHINE_COUNT; i++)
   102aa:	3201      	adds	r2, #1
   102ac:	2a28      	cmp	r2, #40	; 0x28
   102ae:	d1f3      	bne.n	10298 <EnigmaJr::Organize(int)+0x4c>
        if (tm_state.GetTMIndex() != next_tm) SwitchTuringMachine(next_tm);
   102b0:	f890 3304 	ldrb.w	r3, [r0, #772]	; 0x304
   102b4:	428b      	cmp	r3, r1
   102b6:	d001      	beq.n	102bc <EnigmaJr::Organize(int)+0x70>
   102b8:	f7ff ff21 	bl	100fe <EnigmaJr::SwitchTuringMachine(unsigned char)>
    }
   102bc:	bd70      	pop	{r4, r5, r6, pc}
   102be:	2301      	movs	r3, #1
   102c0:	e7e8      	b.n	10294 <EnigmaJr::Organize(int)+0x48>
   102c2:	bf00      	nop
   102c4:	200036e8 	.word	0x200036e8

000102c8 <EnigmaJr::Controller()>:
    void Controller() {
   102c8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if (Clock(1)) {
   102cc:	2200      	movs	r2, #0
   102ce:	2101      	movs	r1, #1
    void Controller() {
   102d0:	4604      	mov	r4, r0
        if (Clock(1)) {
   102d2:	f7f9 f957 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   102d6:	b150      	cbz	r0, 102ee <EnigmaJr::Controller()+0x26>
        reg = HS::user_turing_machines[ix].reg;
   102d8:	f894 2304 	ldrb.w	r2, [r4, #772]	; 0x304
   102dc:	4b47      	ldr	r3, [pc, #284]	; (103fc <EnigmaJr::Controller()+0x134>)
   102de:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
   102e2:	f8a4 3306 	strh.w	r3, [r4, #774]	; 0x306
            length = tm_state.GetLength();
   102e6:	f894 3308 	ldrb.w	r3, [r4, #776]	; 0x308
   102ea:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
        if (Clock(0)) {
   102ee:	2200      	movs	r2, #0
   102f0:	4611      	mov	r1, r2
   102f2:	4620      	mov	r0, r4
   102f4:	f7f9 f946 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   102f8:	2800      	cmp	r0, #0
   102fa:	d076      	beq.n	103ea <EnigmaJr::Controller()+0x122>
    uint16_t GetRegister() {return reg;}
   102fc:	f8b4 6306 	ldrh.w	r6, [r4, #774]	; 0x306
            app->Out(out, (reg & 0x00ff) * 6);
   10300:	f894 7306 	ldrb.w	r7, [r4, #774]	; 0x306
   10304:	2306      	movs	r3, #6
            for (byte s = 0; s < bits; s++) mask |= (0x01 << s);
   10306:	f04f 0801 	mov.w	r8, #1
            app->Out(out, (reg & 0x00ff) * 6);
   1030a:	435f      	muls	r7, r3
        bool clock = reg & 0x0001;
   1030c:	ea06 0308 	and.w	r3, r6, r8
   10310:	f104 0578 	add.w	r5, r4, #120	; 0x78
   10314:	f504 7942 	add.w	r9, r4, #776	; 0x308
   10318:	9300      	str	r3, [sp, #0]
            app->GateOut(out, clock);
   1031a:	469a      	mov	sl, r3
        if (ty <= EnigmaOutputType::NOTE7) {
   1031c:	f895 1141 	ldrb.w	r1, [r5, #321]	; 0x141
   10320:	2904      	cmp	r1, #4
   10322:	d825      	bhi.n	10370 <EnigmaJr::Controller()+0xa8>
            byte bits = ty + 3; // Number of bits
   10324:	1cc8      	adds	r0, r1, #3
   10326:	2200      	movs	r2, #0
   10328:	b2c0      	uxtb	r0, r0
            uint8_t mask = 0;
   1032a:	4613      	mov	r3, r2
            for (byte s = 0; s < bits; s++) mask |= (0x01 << s);
   1032c:	fa08 fc02 	lsl.w	ip, r8, r2
   10330:	3201      	adds	r2, #1
   10332:	ea43 030c 	orr.w	r3, r3, ip
   10336:	fa5f fc82 	uxtb.w	ip, r2
   1033a:	4560      	cmp	r0, ip
   1033c:	b2db      	uxtb	r3, r3
   1033e:	d8f5      	bhi.n	1032c <EnigmaJr::Controller()+0x64>
            int note_shift = ty == EnigmaOutputType::NOTE7 ? 0 : 64; // Note types under 7-bit start at Middle C
   10340:	1f08      	subs	r0, r1, #4
   10342:	bf18      	it	ne
   10344:	2001      	movne	r0, #1
            int note_number = (reg & mask) + note_shift;
   10346:	ea06 0103 	and.w	r1, r6, r3
   1034a:	eb01 1180 	add.w	r1, r1, r0, lsl #6
            app->Out(out, quantizer.Lookup(note_number) + transpose);
   1034e:	297f      	cmp	r1, #127	; 0x7f
        return inputs[ch];
   10350:	6a22      	ldr	r2, [r4, #32]
   10352:	f815 bc04 	ldrb.w	fp, [r5, #-4]
   10356:	9201      	str	r2, [sp, #4]
   10358:	bfa8      	it	ge
   1035a:	217f      	movge	r1, #127	; 0x7f
   1035c:	4628      	mov	r0, r5
   1035e:	f7f1 f891 	bl	1484 <braids::Quantizer::Lookup(long) const>
   10362:	9a01      	ldr	r2, [sp, #4]
   10364:	2300      	movs	r3, #0
   10366:	4402      	add	r2, r0
   10368:	4659      	mov	r1, fp
   1036a:	4620      	mov	r0, r4
   1036c:	f7f8 fdb3 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        if (ty == EnigmaOutputType::MODULATION || ty == EnigmaOutputType::EXPRESSION) {
   10370:	f895 3141 	ldrb.w	r3, [r5, #321]	; 0x141
   10374:	3b05      	subs	r3, #5
   10376:	2b01      	cmp	r3, #1
   10378:	d806      	bhi.n	10388 <EnigmaJr::Controller()+0xc0>
            app->Out(out, (reg & 0x00ff) * 6);
   1037a:	f815 1c04 	ldrb.w	r1, [r5, #-4]
   1037e:	2300      	movs	r3, #0
   10380:	463a      	mov	r2, r7
   10382:	4620      	mov	r0, r4
   10384:	f7f8 fda7 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        if (ty == EnigmaOutputType::TRIGGER && clock) {
   10388:	f895 3141 	ldrb.w	r3, [r5, #321]	; 0x141
   1038c:	2b07      	cmp	r3, #7
   1038e:	d107      	bne.n	103a0 <EnigmaJr::Controller()+0xd8>
   10390:	9b00      	ldr	r3, [sp, #0]
   10392:	b17b      	cbz	r3, 103b4 <EnigmaJr::Controller()+0xec>
            app->ClockOut(out);
   10394:	f815 1c04 	ldrb.w	r1, [r5, #-4]
   10398:	2264      	movs	r2, #100	; 0x64
   1039a:	4620      	mov	r0, r4
   1039c:	f7f9 fac3 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
        if (ty == EnigmaOutputType::GATE) {
   103a0:	f895 3141 	ldrb.w	r3, [r5, #321]	; 0x141
   103a4:	2b08      	cmp	r3, #8
   103a6:	d105      	bne.n	103b4 <EnigmaJr::Controller()+0xec>
            app->GateOut(out, clock);
   103a8:	f815 1c04 	ldrb.w	r1, [r5, #-4]
   103ac:	4652      	mov	r2, sl
   103ae:	4620      	mov	r0, r4
   103b0:	f7f9 fd8f 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
            ForEachChannel(ch)
   103b4:	f505 75a4 	add.w	r5, r5, #328	; 0x148
   103b8:	454d      	cmp	r5, r9
   103ba:	d1af      	bne.n	1031c <EnigmaJr::Controller()+0x54>
            tm_state.Advance(p);
   103bc:	f894 1071 	ldrb.w	r1, [r4, #113]	; 0x71
   103c0:	f504 7041 	add.w	r0, r4, #772	; 0x304
   103c4:	f7f5 fd64 	bl	5e90 <TuringMachineState::Advance(unsigned char)>
            if (--length == 0) {
   103c8:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   103cc:	3b01      	subs	r3, #1
   103ce:	b2db      	uxtb	r3, r3
   103d0:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
   103d4:	b94b      	cbnz	r3, 103ea <EnigmaJr::Controller()+0x122>
                if (DetentedIn(1) > 0) Organize(In(1));
   103d6:	2101      	movs	r1, #1
   103d8:	4620      	mov	r0, r4
   103da:	f7f8 fd73 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
   103de:	2800      	cmp	r0, #0
   103e0:	dd06      	ble.n	103f0 <EnigmaJr::Controller()+0x128>
   103e2:	6a61      	ldr	r1, [r4, #36]	; 0x24
   103e4:	4620      	mov	r0, r4
   103e6:	f7ff ff31 	bl	1024c <EnigmaJr::Organize(int)>
    }
   103ea:	b003      	add	sp, #12
   103ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                else length = tm_state.GetLength();
   103f0:	f894 3308 	ldrb.w	r3, [r4, #776]	; 0x308
   103f4:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
    }
   103f8:	e7f7      	b.n	103ea <EnigmaJr::Controller()+0x122>
   103fa:	bf00      	nop
   103fc:	200036e8 	.word	0x200036e8

00010400 <EnvFollow::DrawInterface()>:
    void DrawInterface() {
   10400:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            gfxPrint(1 + (38 * ch), 15, duck[ch] ? "Duck" : "Foll");
   10404:	f8df 8088 	ldr.w	r8, [pc, #136]	; 10490 <EnvFollow::DrawInterface()+0x90>
   10408:	f8df 9088 	ldr.w	r9, [pc, #136]	; 10494 <EnvFollow::DrawInterface()+0x94>
    void DrawInterface() {
   1040c:	4604      	mov	r4, r0
   1040e:	f100 068d 	add.w	r6, r0, #141	; 0x8d
        ForEachChannel(ch)
   10412:	2500      	movs	r5, #0
   10414:	2726      	movs	r7, #38	; 0x26
            gfxPrint(1 + (38 * ch), 15, duck[ch] ? "Duck" : "Foll");
   10416:	f816 3f01 	ldrb.w	r3, [r6, #1]!
   1041a:	fb07 f105 	mul.w	r1, r7, r5
   1041e:	2b00      	cmp	r3, #0
   10420:	bf14      	ite	ne
   10422:	4643      	movne	r3, r8
   10424:	464b      	moveq	r3, r9
   10426:	220f      	movs	r2, #15
   10428:	3101      	adds	r1, #1
   1042a:	4620      	mov	r0, r4
            gfxFrame(32 * ch, 25, gain[ch], 3);
   1042c:	ea4f 1a45 	mov.w	sl, r5, lsl #5
   10430:	f04f 0b03 	mov.w	fp, #3
            gfxPrint(1 + (38 * ch), 15, duck[ch] ? "Duck" : "Foll");
   10434:	f7f8 f858 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxFrame(32 * ch, 25, gain[ch], 3);
   10438:	f816 3c02 	ldrb.w	r3, [r6, #-2]
   1043c:	69a0      	ldr	r0, [r4, #24]
   1043e:	f8cd b000 	str.w	fp, [sp]
   10442:	2219      	movs	r2, #25
   10444:	4651      	mov	r1, sl
   10446:	f7f4 fae1 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
            if (cursor == ch && CursorBlink()) gfxRect(32 * ch, 25, gain[ch], 3);
   1044a:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
   1044e:	42ab      	cmp	r3, r5
   10450:	d10b      	bne.n	1046a <EnvFollow::DrawInterface()+0x6a>
   10452:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   10454:	2b00      	cmp	r3, #0
   10456:	dd08      	ble.n	1046a <EnvFollow::DrawInterface()+0x6a>
   10458:	f816 3c02 	ldrb.w	r3, [r6, #-2]
   1045c:	69a0      	ldr	r0, [r4, #24]
   1045e:	f8cd b000 	str.w	fp, [sp]
   10462:	2219      	movs	r2, #25
   10464:	4651      	mov	r1, sl
   10466:	f7f4 facb 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        ForEachChannel(ch)
   1046a:	b17d      	cbz	r5, 1048c <EnvFollow::DrawInterface()+0x8c>
        if (cursor > 1) gfxCursor(1 + (38 * (cursor - 2)), 23, 24);
   1046c:	f894 106c 	ldrb.w	r1, [r4, #108]	; 0x6c
   10470:	2901      	cmp	r1, #1
   10472:	d908      	bls.n	10486 <EnvFollow::DrawInterface()+0x86>
   10474:	2326      	movs	r3, #38	; 0x26
   10476:	3902      	subs	r1, #2
   10478:	4359      	muls	r1, r3
   1047a:	2217      	movs	r2, #23
   1047c:	2318      	movs	r3, #24
   1047e:	3101      	adds	r1, #1
   10480:	4620      	mov	r0, r4
   10482:	f7f8 f825 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   10486:	b003      	add	sp, #12
   10488:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1048c:	2501      	movs	r5, #1
   1048e:	e7c2      	b.n	10416 <EnvFollow::DrawInterface()+0x16>
   10490:	000207f4 	.word	0x000207f4
   10494:	000212c4 	.word	0x000212c4

00010498 <EnvFollow::View()>:
        gfxHeader(applet_name());
   10498:	6803      	ldr	r3, [r0, #0]
    void View() {
   1049a:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   1049c:	681b      	ldr	r3, [r3, #0]
    void View() {
   1049e:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   104a0:	4798      	blx	r3
   104a2:	4601      	mov	r1, r0
   104a4:	4620      	mov	r0, r4
   104a6:	f7f8 f8aa 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   104aa:	4620      	mov	r0, r4
   104ac:	f7ff ffa8 	bl	10400 <EnvFollow::DrawInterface()>
        gfxSkyline();
   104b0:	4620      	mov	r0, r4
   104b2:	f7f8 f86f 	bl	8594 <HemisphereApplet::gfxSkyline()>
    }
   104b6:	bd10      	pop	{r4, pc}

000104b8 <GateDelay::DrawInterface()>:
    void DrawInterface() {
   104b8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
        graphics.print(str);
   104bc:	f8df 906c 	ldr.w	r9, [pc, #108]	; 1052c <GateDelay::DrawInterface()+0x74>
   104c0:	f8df a06c 	ldr.w	sl, [pc, #108]	; 10530 <GateDelay::DrawInterface()+0x78>
            if (OC::CORE::ticks - last_gate[ch] < 1667) gfxBitmap(54, y, 8, CLOCK_ICON);
   104c4:	f8df 806c 	ldr.w	r8, [pc, #108]	; 10534 <GateDelay::DrawInterface()+0x7c>
    void DrawInterface() {
   104c8:	4604      	mov	r4, r0
   104ca:	f500 771a 	add.w	r7, r0, #616	; 0x268
   104ce:	250f      	movs	r5, #15
        ForEachChannel(ch)
   104d0:	2600      	movs	r6, #0
            if (ch == cursor) gfxCursor(0, y + 8, 63);
   104d2:	f894 3280 	ldrb.w	r3, [r4, #640]	; 0x280
   104d6:	42b3      	cmp	r3, r6
   104d8:	d106      	bne.n	104e8 <GateDelay::DrawInterface()+0x30>
   104da:	233f      	movs	r3, #63	; 0x3f
   104dc:	f105 0208 	add.w	r2, r5, #8
   104e0:	2100      	movs	r1, #0
   104e2:	4620      	mov	r0, r4
   104e4:	f7f7 fff4 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            gfxPrint(1, y, time[ch]);
   104e8:	f857 3f04 	ldr.w	r3, [r7, #4]!
   104ec:	69a0      	ldr	r0, [r4, #24]
   104ee:	462a      	mov	r2, r5
   104f0:	2101      	movs	r1, #1
   104f2:	f7f4 fabd 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
   104f6:	4649      	mov	r1, r9
   104f8:	4650      	mov	r0, sl
   104fa:	f009 faec 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (OC::CORE::ticks - last_gate[ch] < 1667) gfxBitmap(54, y, 8, CLOCK_ICON);
   104fe:	68fa      	ldr	r2, [r7, #12]
   10500:	f8d8 3000 	ldr.w	r3, [r8]
   10504:	1a9b      	subs	r3, r3, r2
   10506:	f240 6282 	movw	r2, #1666	; 0x682
   1050a:	4293      	cmp	r3, r2
   1050c:	d807      	bhi.n	1051e <GateDelay::DrawInterface()+0x66>
   1050e:	4b0a      	ldr	r3, [pc, #40]	; (10538 <GateDelay::DrawInterface()+0x80>)
   10510:	9300      	str	r3, [sp, #0]
   10512:	69a0      	ldr	r0, [r4, #24]
   10514:	2308      	movs	r3, #8
   10516:	462a      	mov	r2, r5
   10518:	2136      	movs	r1, #54	; 0x36
   1051a:	f7f4 fa3b 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        ForEachChannel(ch)
   1051e:	3519      	adds	r5, #25
   10520:	b116      	cbz	r6, 10528 <GateDelay::DrawInterface()+0x70>
    }
   10522:	b002      	add	sp, #8
   10524:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10528:	2601      	movs	r6, #1
   1052a:	e7d2      	b.n	104d2 <GateDelay::DrawInterface()+0x1a>
   1052c:	0001f236 	.word	0x0001f236
   10530:	200065e0 	.word	0x200065e0
   10534:	200046cc 	.word	0x200046cc
   10538:	00023c28 	.word	0x00023c28

0001053c <GateDelay::View()>:
        gfxHeader(applet_name());
   1053c:	6803      	ldr	r3, [r0, #0]
    void View() {
   1053e:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   10540:	681b      	ldr	r3, [r3, #0]
    void View() {
   10542:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   10544:	4798      	blx	r3
   10546:	4601      	mov	r1, r0
   10548:	4620      	mov	r0, r4
   1054a:	f7f8 f858 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   1054e:	4620      	mov	r0, r4
   10550:	f7ff ffb2 	bl	104b8 <GateDelay::DrawInterface()>
    }
   10554:	bd10      	pop	{r4, pc}

00010556 <LoFiPCM::DrawWaveform()>:
    void DrawWaveform() {
   10556:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1055a:	4605      	mov	r5, r0
        int pos = head - (inc * 15) - random(1,3); // Try to center the head
   1055c:	f8d0 0870 	ldr.w	r0, [r0, #2160]	; 0x870
    void DrawWaveform() {
   10560:	b0a3      	sub	sp, #140	; 0x8c
        int pos = head - (inc * 15) - random(1,3); // Try to center the head
   10562:	f1a0 0478 	sub.w	r4, r0, #120	; 0x78
   10566:	2103      	movs	r1, #3
   10568:	2001      	movs	r0, #1
   1056a:	f009 fcc0 	bl	19eee <random(long, long)>
        if (head < 0) head += length;
   1056e:	f8d5 2870 	ldr.w	r2, [r5, #2160]	; 0x870
   10572:	2a00      	cmp	r2, #0
   10574:	bfb8      	it	lt
   10576:	f8d5 3878 	ldrlt.w	r3, [r5, #2168]	; 0x878
   1057a:	af02      	add	r7, sp, #8
   1057c:	bfb8      	it	lt
   1057e:	189b      	addlt	r3, r3, r2
        int pos = head - (inc * 15) - random(1,3); // Try to center the head
   10580:	eba4 0000 	sub.w	r0, r4, r0
        if (head < 0) head += length;
   10584:	bfb8      	it	lt
   10586:	f8c5 3870 	strlt.w	r3, [r5, #2160]	; 0x870
    void DrawWaveform() {
   1058a:	4639      	mov	r1, r7
   1058c:	2200      	movs	r2, #0
   1058e:	2601      	movs	r6, #1
            int v = (int)pcm[pos] - 127;
   10590:	182b      	adds	r3, r5, r0
            pos += inc;
   10592:	3008      	adds	r0, #8
            int v = (int)pcm[pos] - 127;
   10594:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
   10598:	3b7f      	subs	r3, #127	; 0x7f
   1059a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
            if (v > high) high = v;
   1059e:	429e      	cmp	r6, r3
   105a0:	bfb8      	it	lt
   105a2:	461e      	movlt	r6, r3
            if (pos >= HEM_LOFI_PCM_BUFFER_SIZE) pos -= length;
   105a4:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
   105a8:	bfa8      	it	ge
   105aa:	f8d5 4878 	ldrge.w	r4, [r5, #2168]	; 0x878
            disp[i] = v;
   105ae:	f841 3b04 	str.w	r3, [r1], #4
        for (int i = 0; i < 32; i++)
   105b2:	f102 0201 	add.w	r2, r2, #1
            if (pos >= HEM_LOFI_PCM_BUFFER_SIZE) pos -= length;
   105b6:	bfa8      	it	ge
   105b8:	1b00      	subge	r0, r0, r4
        for (int i = 0; i < 32; i++)
   105ba:	2a20      	cmp	r2, #32
   105bc:	d1e8      	bne.n	10590 <LoFiPCM::DrawWaveform()+0x3a>
   105be:	f04f 0900 	mov.w	r9, #0
        int scaled = simfloat2int(proportion * max_value);
   105c2:	f04f 081e 	mov.w	r8, #30
            int height = Proportion(disp[x], high, 30);
   105c6:	f857 4b04 	ldr.w	r4, [r7], #4
            gfxLine(x * 2, 30 + margin, x * 2, height + 30 + margin);
   105ca:	69a8      	ldr	r0, [r5, #24]
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   105cc:	03a4      	lsls	r4, r4, #14
   105ce:	fb94 f4f6 	sdiv	r4, r4, r6
        int scaled = simfloat2int(proportion * max_value);
   105d2:	fb08 f404 	mul.w	r4, r8, r4
   105d6:	13a4      	asrs	r4, r4, #14
            int margin = (32 - height) / 2;
   105d8:	f1c4 0320 	rsb	r3, r4, #32
   105dc:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
            gfxLine(x * 2, 30 + margin, x * 2, height + 30 + margin);
   105e0:	341e      	adds	r4, #30
            int margin = (32 - height) / 2;
   105e2:	105a      	asrs	r2, r3, #1
            gfxLine(x * 2, 30 + margin, x * 2, height + 30 + margin);
   105e4:	eb04 0463 	add.w	r4, r4, r3, asr #1
   105e8:	4649      	mov	r1, r9
   105ea:	464b      	mov	r3, r9
   105ec:	9400      	str	r4, [sp, #0]
   105ee:	321e      	adds	r2, #30
        for (int x = 0; x < 32; x++)
   105f0:	f109 0902 	add.w	r9, r9, #2
            gfxLine(x * 2, 30 + margin, x * 2, height + 30 + margin);
   105f4:	f7f4 f9fc 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        for (int x = 0; x < 32; x++)
   105f8:	f1b9 0f40 	cmp.w	r9, #64	; 0x40
   105fc:	d1e3      	bne.n	105c6 <LoFiPCM::DrawWaveform()+0x70>
    }
   105fe:	b023      	add	sp, #140	; 0x8c
   10600:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00010604 <LoFiPCM::View()>:
        gfxHeader(applet_name());
   10604:	6803      	ldr	r3, [r0, #0]
    void View() {
   10606:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        gfxHeader(applet_name());
   10608:	681b      	ldr	r3, [r3, #0]
    void View() {
   1060a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   1060c:	4798      	blx	r3
   1060e:	4601      	mov	r1, r0
   10610:	4620      	mov	r0, r4
   10612:	f7f7 fff4 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        if (record || play || gated_record) gfxFrame(x, y, 11, 11);
   10616:	f894 386c 	ldrb.w	r3, [r4, #2156]	; 0x86c
   1061a:	b92b      	cbnz	r3, 10628 <LoFiPCM::View()+0x24>
   1061c:	f894 386e 	ldrb.w	r3, [r4, #2158]	; 0x86e
   10620:	b913      	cbnz	r3, 10628 <LoFiPCM::View()+0x24>
   10622:	f894 386d 	ldrb.w	r3, [r4, #2157]	; 0x86d
   10626:	b3a3      	cbz	r3, 10692 <LoFiPCM::View()+0x8e>
   10628:	230b      	movs	r3, #11
   1062a:	69a0      	ldr	r0, [r4, #24]
   1062c:	9300      	str	r3, [sp, #0]
   1062e:	220f      	movs	r2, #15
   10630:	2103      	movs	r1, #3
   10632:	f7f4 f9eb 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
        if (play) {
   10636:	f894 386e 	ldrb.w	r3, [r4, #2158]	; 0x86e
   1063a:	69a0      	ldr	r0, [r4, #24]
   1063c:	b38b      	cbz	r3, 106a2 <LoFiPCM::View()+0x9e>
            for (int i = 0; i < 11; i += 2)
   1063e:	2500      	movs	r5, #0
                gfxLine(x + i, y + i/2, x + i, y + 10 - i/2);
   10640:	106e      	asrs	r6, r5, #1
   10642:	f105 031a 	add.w	r3, r5, #26
   10646:	f106 070f 	add.w	r7, r6, #15
   1064a:	f1c6 0619 	rsb	r6, r6, #25
   1064e:	4619      	mov	r1, r3
   10650:	69a0      	ldr	r0, [r4, #24]
   10652:	9600      	str	r6, [sp, #0]
   10654:	463a      	mov	r2, r7
   10656:	f7f4 f9cb 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                gfxLine(x + i + 1, y + i/2, x + i + 1, y + 10 - i/2);
   1065a:	f105 031b 	add.w	r3, r5, #27
   1065e:	69a0      	ldr	r0, [r4, #24]
   10660:	9600      	str	r6, [sp, #0]
   10662:	463a      	mov	r2, r7
   10664:	4619      	mov	r1, r3
            for (int i = 0; i < 11; i += 2)
   10666:	3502      	adds	r5, #2
                gfxLine(x + i + 1, y + i/2, x + i + 1, y + 10 - i/2);
   10668:	f7f4 f9c2 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
            for (int i = 0; i < 11; i += 2)
   1066c:	2d0c      	cmp	r5, #12
   1066e:	d1e7      	bne.n	10640 <LoFiPCM::View()+0x3c>
        gfxCircle(x + 5, y + 5, 5);
   10670:	2305      	movs	r3, #5
   10672:	69a0      	ldr	r0, [r4, #24]
   10674:	2214      	movs	r2, #20
   10676:	2137      	movs	r1, #55	; 0x37
   10678:	f7f4 f99a 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        if (record || gated_record) {
   1067c:	f894 386c 	ldrb.w	r3, [r4, #2156]	; 0x86c
   10680:	bb33      	cbnz	r3, 106d0 <LoFiPCM::View()+0xcc>
   10682:	f894 386d 	ldrb.w	r3, [r4, #2157]	; 0x86d
   10686:	bb1b      	cbnz	r3, 106d0 <LoFiPCM::View()+0xcc>
        DrawWaveform();
   10688:	4620      	mov	r0, r4
   1068a:	f7ff ff64 	bl	10556 <LoFiPCM::DrawWaveform()>
    }
   1068e:	b003      	add	sp, #12
   10690:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else gfxRect(x, y, 11, 11);
   10692:	230b      	movs	r3, #11
   10694:	69a0      	ldr	r0, [r4, #24]
   10696:	9300      	str	r3, [sp, #0]
   10698:	220f      	movs	r2, #15
   1069a:	2103      	movs	r1, #3
   1069c:	f7f4 f9b0 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
    }
   106a0:	e7c9      	b.n	10636 <LoFiPCM::View()+0x32>
            gfxLine(x, y, x, y + 10);
   106a2:	2519      	movs	r5, #25
   106a4:	231a      	movs	r3, #26
   106a6:	4619      	mov	r1, r3
            gfxLine(x, y, x + 10, y + 5);
   106a8:	2614      	movs	r6, #20
            gfxLine(x, y, x, y + 10);
   106aa:	9500      	str	r5, [sp, #0]
   106ac:	220f      	movs	r2, #15
   106ae:	f7f4 f99f 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
            gfxLine(x, y, x + 10, y + 5);
   106b2:	69a0      	ldr	r0, [r4, #24]
   106b4:	9600      	str	r6, [sp, #0]
   106b6:	2324      	movs	r3, #36	; 0x24
   106b8:	220f      	movs	r2, #15
   106ba:	211a      	movs	r1, #26
   106bc:	f7f4 f998 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
            gfxLine(x, y + 10, x + 10, y + 5);
   106c0:	69a0      	ldr	r0, [r4, #24]
   106c2:	9600      	str	r6, [sp, #0]
   106c4:	2324      	movs	r3, #36	; 0x24
   106c6:	462a      	mov	r2, r5
   106c8:	211a      	movs	r1, #26
   106ca:	f7f4 f991 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
    }
   106ce:	e7cf      	b.n	10670 <LoFiPCM::View()+0x6c>
   106d0:	2501      	movs	r5, #1
                gfxCircle(x + 5, y + 5, r);
   106d2:	462b      	mov	r3, r5
   106d4:	69a0      	ldr	r0, [r4, #24]
   106d6:	2214      	movs	r2, #20
   106d8:	2137      	movs	r1, #55	; 0x37
            for (int r = 1; r < 5; r++)
   106da:	3501      	adds	r5, #1
                gfxCircle(x + 5, y + 5, r);
   106dc:	f7f4 f968 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
            for (int r = 1; r < 5; r++)
   106e0:	2d05      	cmp	r5, #5
   106e2:	d1f6      	bne.n	106d2 <LoFiPCM::View()+0xce>
   106e4:	e7d0      	b.n	10688 <LoFiPCM::View()+0x84>
   106e6:	Address 0x00000000000106e6 is out of bounds.


000106e8 <LowerRenz::DrawEditor()>:
    void DrawEditor() {
   106e8:	b510      	push	{r4, lr}
   106ea:	4604      	mov	r4, r0
        gfxPrint(1, 15, "Freq");
   106ec:	4b15      	ldr	r3, [pc, #84]	; (10744 <LowerRenz::DrawEditor()+0x5c>)
   106ee:	220f      	movs	r2, #15
   106f0:	2101      	movs	r1, #1
   106f2:	f7f7 fef9 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(1, 24, freq);
   106f6:	6f23      	ldr	r3, [r4, #112]	; 0x70
   106f8:	69a0      	ldr	r0, [r4, #24]
   106fa:	2218      	movs	r2, #24
   106fc:	2101      	movs	r1, #1
   106fe:	f7f4 f9b7 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (cursor == 0) gfxCursor(1, 32, 30);
   10702:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   10704:	b92b      	cbnz	r3, 10712 <LowerRenz::DrawEditor()+0x2a>
   10706:	231e      	movs	r3, #30
   10708:	2220      	movs	r2, #32
   1070a:	2101      	movs	r1, #1
   1070c:	4620      	mov	r0, r4
   1070e:	f7f7 fedf 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        gfxPrint(45, 15, "Rho");
   10712:	212d      	movs	r1, #45	; 0x2d
   10714:	4b0c      	ldr	r3, [pc, #48]	; (10748 <LowerRenz::DrawEditor()+0x60>)
   10716:	220f      	movs	r2, #15
   10718:	4620      	mov	r0, r4
   1071a:	f7f7 fee5 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(45 + (rho > 99 ? 0 : 6), 24, rho);
   1071e:	6f63      	ldr	r3, [r4, #116]	; 0x74
   10720:	69a0      	ldr	r0, [r4, #24]
   10722:	2b63      	cmp	r3, #99	; 0x63
   10724:	bfcc      	ite	gt
   10726:	212d      	movgt	r1, #45	; 0x2d
   10728:	2133      	movle	r1, #51	; 0x33
   1072a:	2218      	movs	r2, #24
   1072c:	f7f4 f9a0 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (cursor == 1) gfxCursor(32, 32, 31);
   10730:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   10732:	2b01      	cmp	r3, #1
   10734:	d105      	bne.n	10742 <LowerRenz::DrawEditor()+0x5a>
   10736:	2220      	movs	r2, #32
   10738:	231f      	movs	r3, #31
   1073a:	4611      	mov	r1, r2
   1073c:	4620      	mov	r0, r4
   1073e:	f7f7 fec7 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   10742:	bd10      	pop	{r4, pc}
   10744:	000212c9 	.word	0x000212c9
   10748:	00020938 	.word	0x00020938

0001074c <LowerRenz::DrawOutput()>:
    void DrawOutput() {
   1074c:	b537      	push	{r0, r1, r2, r4, r5, lr}
        gfxPrint(1, 38, "x");
   1074e:	4b12      	ldr	r3, [pc, #72]	; (10798 <LowerRenz::DrawOutput()+0x4c>)
    void DrawOutput() {
   10750:	4604      	mov	r4, r0
        gfxPrint(1, 38, "x");
   10752:	2226      	movs	r2, #38	; 0x26
   10754:	2101      	movs	r1, #1
   10756:	f7f7 fec7 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(1, 50, "y");
   1075a:	4b10      	ldr	r3, [pc, #64]	; (1079c <LowerRenz::DrawOutput()+0x50>)
   1075c:	2232      	movs	r2, #50	; 0x32
   1075e:	4620      	mov	r0, r4
   10760:	2101      	movs	r1, #1
   10762:	f7f7 fec1 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            int w = ProportionCV(ViewOut(ch), 62);
   10766:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   10768:	213e      	movs	r1, #62	; 0x3e
   1076a:	f7f3 ff7b 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
            gfxInvert(1, 38 + (12 * ch), w, 10);
   1076e:	250a      	movs	r5, #10
            int w = ProportionCV(ViewOut(ch), 62);
   10770:	4603      	mov	r3, r0
            gfxInvert(1, 38 + (12 * ch), w, 10);
   10772:	2226      	movs	r2, #38	; 0x26
   10774:	4620      	mov	r0, r4
   10776:	9500      	str	r5, [sp, #0]
   10778:	2101      	movs	r1, #1
   1077a:	f7f7 ff03 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
            int w = ProportionCV(ViewOut(ch), 62);
   1077e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   10780:	213e      	movs	r1, #62	; 0x3e
   10782:	f7f3 ff6f 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
            gfxInvert(1, 38 + (12 * ch), w, 10);
   10786:	9500      	str	r5, [sp, #0]
            int w = ProportionCV(ViewOut(ch), 62);
   10788:	4603      	mov	r3, r0
            gfxInvert(1, 38 + (12 * ch), w, 10);
   1078a:	2232      	movs	r2, #50	; 0x32
   1078c:	2101      	movs	r1, #1
   1078e:	4620      	mov	r0, r4
   10790:	f7f7 fef8 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
    }
   10794:	b003      	add	sp, #12
   10796:	bd30      	pop	{r4, r5, pc}
   10798:	00020ffe 	.word	0x00020ffe
   1079c:	00020931 	.word	0x00020931

000107a0 <LowerRenz::View()>:
        gfxHeader(applet_name());
   107a0:	6803      	ldr	r3, [r0, #0]
    void View() {
   107a2:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   107a4:	681b      	ldr	r3, [r3, #0]
    void View() {
   107a6:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   107a8:	4798      	blx	r3
   107aa:	4601      	mov	r1, r0
   107ac:	4620      	mov	r0, r4
   107ae:	f7f7 ff26 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawEditor();
   107b2:	4620      	mov	r0, r4
   107b4:	f7ff ff98 	bl	106e8 <LowerRenz::DrawEditor()>
        DrawOutput();
   107b8:	4620      	mov	r0, r4
   107ba:	f7ff ffc7 	bl	1074c <LowerRenz::DrawOutput()>
    }
   107be:	bd10      	pop	{r4, pc}

000107c0 <Metronome::DrawMetronome()>:
    void DrawMetronome() {
   107c0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        gfxLine(20,60,38,63); // Bottom Front
   107c4:	273f      	movs	r7, #63	; 0x3f
    void DrawMetronome() {
   107c6:	4604      	mov	r4, r0
        gfxLine(20,60,38,63); // Bottom Front
   107c8:	9700      	str	r7, [sp, #0]
        gfxLine(38,62,44,55); // Bottom Right
   107ca:	2537      	movs	r5, #55	; 0x37
        gfxLine(20,60,38,63); // Bottom Front
   107cc:	6980      	ldr	r0, [r0, #24]
   107ce:	2326      	movs	r3, #38	; 0x26
   107d0:	223c      	movs	r2, #60	; 0x3c
   107d2:	2114      	movs	r1, #20
        gfxLine(44,55,36,27); // Rear right edge
   107d4:	261b      	movs	r6, #27
        gfxLine(20,60,38,63); // Bottom Front
   107d6:	f7f4 f90b 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(38,62,44,55); // Bottom Right
   107da:	69a0      	ldr	r0, [r4, #24]
   107dc:	9500      	str	r5, [sp, #0]
   107de:	232c      	movs	r3, #44	; 0x2c
   107e0:	223e      	movs	r2, #62	; 0x3e
   107e2:	2126      	movs	r1, #38	; 0x26
   107e4:	f7f4 f904 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(44,55,36,27); // Rear right edge
   107e8:	462a      	mov	r2, r5
   107ea:	69a0      	ldr	r0, [r4, #24]
   107ec:	9600      	str	r6, [sp, #0]
        gfxLine(38,63,33,29); // Front right edge
   107ee:	251d      	movs	r5, #29
        gfxLine(44,55,36,27); // Rear right edge
   107f0:	2324      	movs	r3, #36	; 0x24
   107f2:	212c      	movs	r1, #44	; 0x2c
   107f4:	f7f4 f8fc 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(38,63,33,29); // Front right edge
   107f8:	463a      	mov	r2, r7
   107fa:	69a0      	ldr	r0, [r4, #24]
   107fc:	9500      	str	r5, [sp, #0]
   107fe:	2321      	movs	r3, #33	; 0x21
   10800:	2126      	movs	r1, #38	; 0x26
   10802:	f7f4 f8f5 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(22,49,36,51); // Front ledge
   10806:	f04f 0833 	mov.w	r8, #51	; 0x33
        gfxLine(20,60,29,27); // Front left edge
   1080a:	69a0      	ldr	r0, [r4, #24]
   1080c:	9600      	str	r6, [sp, #0]
   1080e:	462b      	mov	r3, r5
   10810:	223c      	movs	r2, #60	; 0x3c
   10812:	2114      	movs	r1, #20
   10814:	f7f4 f8ec 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(29,27,31,25); // Point: front left
   10818:	2719      	movs	r7, #25
        gfxLine(22,49,36,51); // Front ledge
   1081a:	69a0      	ldr	r0, [r4, #24]
   1081c:	f8cd 8000 	str.w	r8, [sp]
   10820:	2324      	movs	r3, #36	; 0x24
   10822:	2231      	movs	r2, #49	; 0x31
   10824:	2116      	movs	r1, #22
   10826:	f7f4 f8e3 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(29,27,31,25); // Point: front left
   1082a:	4632      	mov	r2, r6
   1082c:	69a0      	ldr	r0, [r4, #24]
   1082e:	9700      	str	r7, [sp, #0]
   10830:	231f      	movs	r3, #31
   10832:	4629      	mov	r1, r5
   10834:	f7f4 f8dc 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(33,29,31,25); // Point: front right
   10838:	69a0      	ldr	r0, [r4, #24]
   1083a:	9700      	str	r7, [sp, #0]
   1083c:	231f      	movs	r3, #31
   1083e:	462a      	mov	r2, r5
   10840:	2121      	movs	r1, #33	; 0x21
   10842:	f7f4 f8d5 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(36,27,31,25); // Point: rear right
   10846:	4632      	mov	r2, r6
   10848:	69a0      	ldr	r0, [r4, #24]
   1084a:	9700      	str	r7, [sp, #0]
   1084c:	231f      	movs	r3, #31
   1084e:	2124      	movs	r1, #36	; 0x24
   10850:	f7f4 f8ce 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(29,27,33,29); // Point base: front
   10854:	4632      	mov	r2, r6
   10856:	69a0      	ldr	r0, [r4, #24]
   10858:	9500      	str	r5, [sp, #0]
   1085a:	2321      	movs	r3, #33	; 0x21
   1085c:	4629      	mov	r1, r5
   1085e:	f7f4 f8c7 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxDottedLine(29,50,31,28,3); // Tempo scale
   10862:	2703      	movs	r7, #3
        gfxLine(33,29,36,27); // Point base: right
   10864:	69a0      	ldr	r0, [r4, #24]
   10866:	9600      	str	r6, [sp, #0]
   10868:	2324      	movs	r3, #36	; 0x24
   1086a:	462a      	mov	r2, r5
   1086c:	2121      	movs	r1, #33	; 0x21
        gfxDottedLine(29,50,31,28,3); // Tempo scale
   1086e:	261c      	movs	r6, #28
        gfxLine(33,29,36,27); // Point base: right
   10870:	f7f4 f8be 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxDottedLine(29,50,31,28,3); // Tempo scale
   10874:	69a0      	ldr	r0, [r4, #24]
   10876:	9701      	str	r7, [sp, #4]
   10878:	231f      	movs	r3, #31
   1087a:	2232      	movs	r2, #50	; 0x32
   1087c:	4629      	mov	r1, r5
   1087e:	9600      	str	r6, [sp, #0]
   10880:	f7f4 f89c 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        gfxDottedLine(30,50,32,28,3); // Tempo scale
   10884:	69a0      	ldr	r0, [r4, #24]
   10886:	2320      	movs	r3, #32
   10888:	2232      	movs	r2, #50	; 0x32
   1088a:	211e      	movs	r1, #30
   1088c:	e9cd 6700 	strd	r6, r7, [sp]
   10890:	f7f4 f894 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        gfxCircle(40,51,1); // Winder
   10894:	2301      	movs	r3, #1
   10896:	69a0      	ldr	r0, [r4, #24]
   10898:	4642      	mov	r2, r8
   1089a:	2128      	movs	r1, #40	; 0x28
   1089c:	f7f4 f888 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>

    bool EndOfBeat() {return count == 0;}

    bool Cycle() {return cycle;}
   108a0:	6f23      	ldr	r3, [r4, #112]	; 0x70
        if (clock_m->Cycle()) gfxLine(29,50,21,31);
   108a2:	7cdb      	ldrb	r3, [r3, #19]
   108a4:	b153      	cbz	r3, 108bc <Metronome::DrawMetronome()+0xfc>
   108a6:	231f      	movs	r3, #31
   108a8:	9300      	str	r3, [sp, #0]
   108aa:	2315      	movs	r3, #21
        else gfxLine(29,50,37,32);
   108ac:	69a0      	ldr	r0, [r4, #24]
   108ae:	2232      	movs	r2, #50	; 0x32
   108b0:	4629      	mov	r1, r5
   108b2:	f7f4 f89d 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
    }
   108b6:	b002      	add	sp, #8
   108b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        else gfxLine(29,50,37,32);
   108bc:	2320      	movs	r3, #32
   108be:	9300      	str	r3, [sp, #0]
   108c0:	2325      	movs	r3, #37	; 0x25
   108c2:	e7f3      	b.n	108ac <Metronome::DrawMetronome()+0xec>

000108c4 <Metronome::DrawInterface()>:
    void DrawInterface() {
   108c4:	b538      	push	{r3, r4, r5, lr}
        gfxIcon(1, 15, NOTE4_ICON);
   108c6:	220f      	movs	r2, #15
    void DrawInterface() {
   108c8:	4604      	mov	r4, r0
        gfxIcon(1, 15, NOTE4_ICON);
   108ca:	4b0e      	ldr	r3, [pc, #56]	; (10904 <Metronome::DrawInterface()+0x40>)
   108cc:	6980      	ldr	r0, [r0, #24]
   108ce:	2101      	movs	r1, #1
   108d0:	f7f4 f866 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(9, 15, "= ");
   108d4:	220f      	movs	r2, #15
   108d6:	4620      	mov	r0, r4
   108d8:	4b0b      	ldr	r3, [pc, #44]	; (10908 <Metronome::DrawInterface()+0x44>)
   108da:	2109      	movs	r1, #9
   108dc:	f7f7 fe04 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
    uint16_t GetTempo() {return tempo;}
   108e0:	6f23      	ldr	r3, [r4, #112]	; 0x70
        gfxPrint(pad(100, clock_m->GetTempo()), clock_m->GetTempo());
   108e2:	89dd      	ldrh	r5, [r3, #14]
   108e4:	2064      	movs	r0, #100	; 0x64
   108e6:	4629      	mov	r1, r5
   108e8:	f7f3 fecb 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   108ec:	4629      	mov	r1, r5
   108ee:	f7f4 f8a3 	bl	4a38 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]>
        graphics.print(str);
   108f2:	4906      	ldr	r1, [pc, #24]	; (1090c <Metronome::DrawInterface()+0x48>)
   108f4:	4806      	ldr	r0, [pc, #24]	; (10910 <Metronome::DrawInterface()+0x4c>)
   108f6:	f009 f8ee 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        DrawMetronome();
   108fa:	4620      	mov	r0, r4
   108fc:	f7ff ff60 	bl	107c0 <Metronome::DrawMetronome()>
    }
   10900:	bd38      	pop	{r3, r4, r5, pc}
   10902:	bf00      	nop
   10904:	00023c78 	.word	0x00023c78
   10908:	000212f6 	.word	0x000212f6
   1090c:	000212b6 	.word	0x000212b6
   10910:	200065e0 	.word	0x200065e0

00010914 <Metronome::View()>:
        gfxHeader(applet_name());
   10914:	6803      	ldr	r3, [r0, #0]
    void View() {
   10916:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   10918:	681b      	ldr	r3, [r3, #0]
    void View() {
   1091a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   1091c:	4798      	blx	r3
   1091e:	4601      	mov	r1, r0
   10920:	4620      	mov	r0, r4
   10922:	f7f7 fe6c 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   10926:	4620      	mov	r0, r4
   10928:	f7ff ffcc 	bl	108c4 <Metronome::DrawInterface()>
    }
   1092c:	bd10      	pop	{r4, pc}
   1092e:	Address 0x000000000001092e is out of bounds.


00010930 <Palimpsest::DrawControls()>:
    void DrawControls() {
   10930:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   10932:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4
   10936:	f8d0 50b0 	ldr.w	r5, [r0, #176]	; 0xb0
        int scaled = simfloat2int(proportion * max_value);
   1093a:	261e      	movs	r6, #30
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1093c:	2264      	movs	r2, #100	; 0x64
        gfxFrame(30 - decomp_w, 15, decomp_w, 7);
   1093e:	2707      	movs	r7, #7
   10940:	039b      	lsls	r3, r3, #14
   10942:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   10946:	4373      	muls	r3, r6
    void DrawControls() {
   10948:	4604      	mov	r4, r0
   1094a:	139b      	asrs	r3, r3, #14
        gfxFrame(30 - decomp_w, 15, decomp_w, 7);
   1094c:	9700      	str	r7, [sp, #0]
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1094e:	03ad      	lsls	r5, r5, #14
   10950:	fb95 f5f2 	sdiv	r5, r5, r2
        int scaled = simfloat2int(proportion * max_value);
   10954:	4375      	muls	r5, r6
   10956:	1af1      	subs	r1, r6, r3
   10958:	6980      	ldr	r0, [r0, #24]
   1095a:	220f      	movs	r2, #15
   1095c:	13ad      	asrs	r5, r5, #14
   1095e:	f7f4 f855 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
        gfxRect(32, 15, comp_w, 7);
   10962:	462b      	mov	r3, r5
   10964:	69a0      	ldr	r0, [r4, #24]
   10966:	9700      	str	r7, [sp, #0]
   10968:	220f      	movs	r2, #15
   1096a:	2120      	movs	r1, #32
   1096c:	f7f4 f848 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        if (cursor == 0) gfxCursor(32, 23, 30);
   10970:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
   10974:	b92b      	cbnz	r3, 10982 <Palimpsest::DrawControls()+0x52>
   10976:	4633      	mov	r3, r6
   10978:	2217      	movs	r2, #23
   1097a:	2120      	movs	r1, #32
   1097c:	4620      	mov	r0, r4
   1097e:	f7f7 fda7 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 1) gfxCursor(1, 23, 30);
   10982:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
   10986:	2901      	cmp	r1, #1
   10988:	d104      	bne.n	10994 <Palimpsest::DrawControls()+0x64>
   1098a:	231e      	movs	r3, #30
   1098c:	2217      	movs	r2, #23
   1098e:	4620      	mov	r0, r4
   10990:	f7f7 fd9e 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 2) {
   10994:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
   10998:	2b02      	cmp	r3, #2
   1099a:	d127      	bne.n	109ec <Palimpsest::DrawControls()+0xbc>
            gfxBitmap(28, 26, 8, LOCK_ICON);
   1099c:	4b14      	ldr	r3, [pc, #80]	; (109f0 <Palimpsest::DrawControls()+0xc0>)
   1099e:	9300      	str	r3, [sp, #0]
   109a0:	69a0      	ldr	r0, [r4, #24]
   109a2:	2308      	movs	r3, #8
   109a4:	221a      	movs	r2, #26
   109a6:	211c      	movs	r1, #28
   109a8:	f7f3 fff4 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            if (CursorBlink()) {
   109ac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   109ae:	2b00      	cmp	r3, #0
   109b0:	dd1c      	ble.n	109ec <Palimpsest::DrawControls()+0xbc>
                gfxLine(0, 24, (length - 1) * 4 + 1, 24);
   109b2:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
   109b6:	69a0      	ldr	r0, [r4, #24]
   109b8:	2518      	movs	r5, #24
   109ba:	009b      	lsls	r3, r3, #2
   109bc:	3b03      	subs	r3, #3
   109be:	462a      	mov	r2, r5
   109c0:	2100      	movs	r1, #0
   109c2:	9500      	str	r5, [sp, #0]
   109c4:	f7f4 f814 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                gfxLine((length - 1) * 4 + 1, 24, (length - 1) * 4 + 1, 28);
   109c8:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
   109cc:	69a0      	ldr	r0, [r4, #24]
   109ce:	009b      	lsls	r3, r3, #2
   109d0:	3b03      	subs	r3, #3
   109d2:	261c      	movs	r6, #28
   109d4:	4619      	mov	r1, r3
   109d6:	462a      	mov	r2, r5
   109d8:	9600      	str	r6, [sp, #0]
   109da:	f7f4 f809 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                gfxLine(0, 24, 0, 28);
   109de:	2300      	movs	r3, #0
   109e0:	69a0      	ldr	r0, [r4, #24]
   109e2:	9600      	str	r6, [sp, #0]
   109e4:	462a      	mov	r2, r5
   109e6:	4619      	mov	r1, r3
   109e8:	f7f4 f802 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
    }
   109ec:	b003      	add	sp, #12
   109ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
   109f0:	00024210 	.word	0x00024210

000109f4 <Palimpsest::DrawSequence()>:
    void DrawSequence() {
   109f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   109f6:	4605      	mov	r5, r0
        for (int s = 0; s < length; s++)
   109f8:	2400      	movs	r4, #0
            else gfxLine(s * 4 + 1, BottomAlign(h), s * 4 + 1, 62);
   109fa:	263e      	movs	r6, #62	; 0x3e
        for (int s = 0; s < length; s++)
   109fc:	f8d5 20c0 	ldr.w	r2, [r5, #192]	; 0xc0
   10a00:	42a2      	cmp	r2, r4
   10a02:	dc01      	bgt.n	10a08 <Palimpsest::DrawSequence()+0x14>
    }
   10a04:	b002      	add	sp, #8
   10a06:	bd70      	pop	{r4, r5, r6, pc}
            int index = s + step;
   10a08:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
   10a0c:	4423      	add	r3, r4
            if (index > length) index -= length;
   10a0e:	429a      	cmp	r2, r3
   10a10:	bfb8      	it	lt
   10a12:	1a9b      	sublt	r3, r3, r2
            int h = ProportionCV(accent[index], 33);
   10a14:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   10a18:	2121      	movs	r1, #33	; 0x21
   10a1a:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
   10a1c:	f7f3 fe22 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
   10a20:	4603      	mov	r3, r0
            if (s == 0 && brush) gfxRect(s * 4 + 0, BottomAlign(h), 3, h);
   10a22:	f1c0 023e 	rsb	r2, r0, #62	; 0x3e
   10a26:	69a8      	ldr	r0, [r5, #24]
   10a28:	b94c      	cbnz	r4, 10a3e <Palimpsest::DrawSequence()+0x4a>
   10a2a:	f895 10bc 	ldrb.w	r1, [r5, #188]	; 0xbc
   10a2e:	b131      	cbz	r1, 10a3e <Palimpsest::DrawSequence()+0x4a>
   10a30:	9300      	str	r3, [sp, #0]
   10a32:	4621      	mov	r1, r4
   10a34:	2303      	movs	r3, #3
   10a36:	f7f3 ffe3 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        for (int s = 0; s < length; s++)
   10a3a:	3401      	adds	r4, #1
   10a3c:	e7de      	b.n	109fc <Palimpsest::DrawSequence()+0x8>
            else gfxLine(s * 4 + 1, BottomAlign(h), s * 4 + 1, 62);
   10a3e:	00a3      	lsls	r3, r4, #2
   10a40:	3301      	adds	r3, #1
   10a42:	9600      	str	r6, [sp, #0]
   10a44:	4619      	mov	r1, r3
   10a46:	f7f3 ffd3 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
   10a4a:	e7f6      	b.n	10a3a <Palimpsest::DrawSequence()+0x46>

00010a4c <Palimpsest::View()>:
        gfxHeader(applet_name());
   10a4c:	6803      	ldr	r3, [r0, #0]
    void View() {
   10a4e:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   10a50:	681b      	ldr	r3, [r3, #0]
    void View() {
   10a52:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   10a54:	4798      	blx	r3
   10a56:	4601      	mov	r1, r0
   10a58:	4620      	mov	r0, r4
   10a5a:	f7f7 fdd0 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawControls();
   10a5e:	4620      	mov	r0, r4
   10a60:	f7ff ff66 	bl	10930 <Palimpsest::DrawControls()>
        DrawSequence();
   10a64:	4620      	mov	r0, r4
   10a66:	f7ff ffc5 	bl	109f4 <Palimpsest::DrawSequence()>
    }
   10a6a:	bd10      	pop	{r4, pc}

00010a6c <ScaleDuet::DrawKeyboard()>:
    void DrawKeyboard() {
   10a6c:	b573      	push	{r0, r1, r4, r5, r6, lr}
        gfxFrame(0, 27, 63, 32);
   10a6e:	2320      	movs	r3, #32
   10a70:	9300      	str	r3, [sp, #0]
    void DrawKeyboard() {
   10a72:	4604      	mov	r4, r0
        gfxFrame(0, 27, 63, 32);
   10a74:	233f      	movs	r3, #63	; 0x3f
   10a76:	6980      	ldr	r0, [r0, #24]
   10a78:	221b      	movs	r2, #27
   10a7a:	2100      	movs	r1, #0
   10a7c:	f7f3 ffc6 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
   10a80:	2500      	movs	r5, #0
            gfxLine(x * 8, 27, x * 8, 58);
   10a82:	263a      	movs	r6, #58	; 0x3a
   10a84:	462b      	mov	r3, r5
   10a86:	4629      	mov	r1, r5
   10a88:	69a0      	ldr	r0, [r4, #24]
   10a8a:	9600      	str	r6, [sp, #0]
   10a8c:	221b      	movs	r2, #27
        for (uint8_t x = 0; x < 8; x++)
   10a8e:	3508      	adds	r5, #8
            gfxLine(x * 8, 27, x * 8, 58);
   10a90:	f7f3 ffae 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        for (uint8_t x = 0; x < 8; x++)
   10a94:	2d40      	cmp	r5, #64	; 0x40
   10a96:	d1f5      	bne.n	10a84 <ScaleDuet::DrawKeyboard()+0x18>
   10a98:	2500      	movs	r5, #0
                gfxRect(x, 27, 5, 16);
   10a9a:	2610      	movs	r6, #16
            if (i != 2) { // Skip the third position
   10a9c:	2d02      	cmp	r5, #2
   10a9e:	d007      	beq.n	10ab0 <ScaleDuet::DrawKeyboard()+0x44>
                gfxRect(x, 27, 5, 16);
   10aa0:	00e9      	lsls	r1, r5, #3
   10aa2:	69a0      	ldr	r0, [r4, #24]
   10aa4:	9600      	str	r6, [sp, #0]
   10aa6:	2305      	movs	r3, #5
   10aa8:	221b      	movs	r2, #27
   10aaa:	3106      	adds	r1, #6
   10aac:	f7f3 ffa8 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        for (uint8_t i = 0; i < 6; i++)
   10ab0:	3501      	adds	r5, #1
   10ab2:	2d06      	cmp	r5, #6
   10ab4:	d1f2      	bne.n	10a9c <ScaleDuet::DrawKeyboard()+0x30>
        gfxPrint(10, 15, "Scale ");
   10ab6:	210a      	movs	r1, #10
   10ab8:	4620      	mov	r0, r4
   10aba:	4b08      	ldr	r3, [pc, #32]	; (10adc <ScaleDuet::DrawKeyboard()+0x70>)
   10abc:	220f      	movs	r2, #15
   10abe:	f7f7 fd13 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(cursor < 12 ? 1 : 2);
   10ac2:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
        graphics.print(num);
   10ac6:	4806      	ldr	r0, [pc, #24]	; (10ae0 <ScaleDuet::DrawKeyboard()+0x74>)
   10ac8:	2b0c      	cmp	r3, #12
   10aca:	bf34      	ite	cc
   10acc:	2101      	movcc	r1, #1
   10ace:	2102      	movcs	r1, #2
    }
   10ad0:	b002      	add	sp, #8
   10ad2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10ad6:	f009 b872 	b.w	19bbe <weegfx::Graphics::print(int)>
   10ada:	bf00      	nop
   10adc:	000212ce 	.word	0x000212ce
   10ae0:	200065e0 	.word	0x200065e0

00010ae4 <ScaleDuet::DrawMaskIndicators()>:
    void DrawMaskIndicators() {
   10ae4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10ae8:	b088      	sub	sp, #32
        uint8_t scale = cursor < 12 ? 0 : 1;
   10aea:	f890 91a8 	ldrb.w	r9, [r0, #424]	; 0x1a8
        uint8_t x[12] = {2, 7, 10, 15, 18, 26, 31, 34, 39, 42, 47, 50};
   10aee:	492b      	ldr	r1, [pc, #172]	; (10b9c <ScaleDuet::DrawMaskIndicators()+0xb8>)
   10af0:	af02      	add	r7, sp, #8
        uint8_t scale = cursor < 12 ? 0 : 1;
   10af2:	f1b9 0f0b 	cmp.w	r9, #11
    void DrawMaskIndicators() {
   10af6:	4604      	mov	r4, r0
        uint8_t x[12] = {2, 7, 10, 15, 18, 26, 31, 34, 39, 42, 47, 50};
   10af8:	f04f 020c 	mov.w	r2, #12
   10afc:	4638      	mov	r0, r7
        uint8_t p[12] = {0, 1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0};
   10afe:	f10d 0814 	add.w	r8, sp, #20
        uint8_t scale = cursor < 12 ? 0 : 1;
   10b02:	bf94      	ite	ls
   10b04:	2600      	movls	r6, #0
   10b06:	2601      	movhi	r6, #1
        uint8_t x[12] = {2, 7, 10, 15, 18, 26, 31, 34, 39, 42, 47, 50};
   10b08:	f009 fa72 	bl	19ff0 <memcpy>
        uint8_t p[12] = {0, 1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0};
   10b0c:	4924      	ldr	r1, [pc, #144]	; (10ba0 <ScaleDuet::DrawMaskIndicators()+0xbc>)
   10b0e:	220c      	movs	r2, #12
   10b10:	4640      	mov	r0, r8
   10b12:	f009 fa6d 	bl	19ff0 <memcpy>
            if ((mask[scale] >> i) & 0x01) gfxInvert(x[i], (p[i] ? 37 : 51), 4 - p[i], 4 - p[i]);
   10b16:	36d0      	adds	r6, #208	; 0xd0
        uint8_t p[12] = {0, 1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0};
   10b18:	2500      	movs	r5, #0
            if ((mask[scale] >> i) & 0x01) gfxInvert(x[i], (p[i] ? 37 : 51), 4 - p[i], 4 - p[i]);
   10b1a:	eb04 0a46 	add.w	sl, r4, r6, lsl #1
   10b1e:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   10b22:	412b      	asrs	r3, r5
   10b24:	07d9      	lsls	r1, r3, #31
   10b26:	d50c      	bpl.n	10b42 <ScaleDuet::DrawMaskIndicators()+0x5e>
   10b28:	f818 3005 	ldrb.w	r3, [r8, r5]
   10b2c:	2b00      	cmp	r3, #0
   10b2e:	f1c3 0304 	rsb	r3, r3, #4
   10b32:	9300      	str	r3, [sp, #0]
   10b34:	5d79      	ldrb	r1, [r7, r5]
   10b36:	bf14      	ite	ne
   10b38:	2225      	movne	r2, #37	; 0x25
   10b3a:	2233      	moveq	r2, #51	; 0x33
   10b3c:	4620      	mov	r0, r4
   10b3e:	f7f7 fd21 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
            if (i == (cursor - (scale * 12))) gfxCursor(x[i] - 1, p[i] ? 25 : 60, 6);
   10b42:	f1b9 0f0b 	cmp.w	r9, #11
   10b46:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   10b4a:	bf8c      	ite	hi
   10b4c:	f06f 020b 	mvnhi.w	r2, #11
   10b50:	2200      	movls	r2, #0
   10b52:	4413      	add	r3, r2
   10b54:	429d      	cmp	r5, r3
   10b56:	d10d      	bne.n	10b74 <ScaleDuet::DrawMaskIndicators()+0x90>
   10b58:	f818 3005 	ldrb.w	r3, [r8, r5]
   10b5c:	5d79      	ldrb	r1, [r7, r5]
   10b5e:	2b00      	cmp	r3, #0
   10b60:	bf18      	it	ne
   10b62:	2219      	movne	r2, #25
   10b64:	f04f 0306 	mov.w	r3, #6
   10b68:	bf08      	it	eq
   10b6a:	223c      	moveq	r2, #60	; 0x3c
   10b6c:	3901      	subs	r1, #1
   10b6e:	4620      	mov	r0, r4
   10b70:	f7f7 fcae 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        for (uint8_t i = 0; i < 12; i++)
   10b74:	3501      	adds	r5, #1
   10b76:	2d0c      	cmp	r5, #12
   10b78:	d1d1      	bne.n	10b1e <ScaleDuet::DrawMaskIndicators()+0x3a>
        if (mask[scale] & 0x01) gfxInvert(58, 51, 3, 4);
   10b7a:	eb04 0646 	add.w	r6, r4, r6, lsl #1
   10b7e:	88b3      	ldrh	r3, [r6, #4]
   10b80:	07db      	lsls	r3, r3, #31
   10b82:	d507      	bpl.n	10b94 <ScaleDuet::DrawMaskIndicators()+0xb0>
   10b84:	2304      	movs	r3, #4
   10b86:	9300      	str	r3, [sp, #0]
   10b88:	2233      	movs	r2, #51	; 0x33
   10b8a:	2303      	movs	r3, #3
   10b8c:	213a      	movs	r1, #58	; 0x3a
   10b8e:	4620      	mov	r0, r4
   10b90:	f7f7 fcf8 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
    }
   10b94:	b008      	add	sp, #32
   10b96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10b9a:	bf00      	nop
   10b9c:	000212d5 	.word	0x000212d5
   10ba0:	00022efe 	.word	0x00022efe

00010ba4 <ScaleDuet::View()>:
        gfxHeader(applet_name());
   10ba4:	6803      	ldr	r3, [r0, #0]
    void View() {
   10ba6:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   10ba8:	681b      	ldr	r3, [r3, #0]
    void View() {
   10baa:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   10bac:	4798      	blx	r3
   10bae:	4601      	mov	r1, r0
   10bb0:	4620      	mov	r0, r4
   10bb2:	f7f7 fd24 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawKeyboard();
   10bb6:	4620      	mov	r0, r4
   10bb8:	f7ff ff58 	bl	10a6c <ScaleDuet::DrawKeyboard()>
        DrawMaskIndicators();
   10bbc:	4620      	mov	r0, r4
   10bbe:	f7ff ff91 	bl	10ae4 <ScaleDuet::DrawMaskIndicators()>
    }
   10bc2:	bd10      	pop	{r4, pc}

00010bc4 <Schmitt::DrawSchmittTriggerAtPositionWithState(unsigned char, unsigned char, bool)>:
    void DrawSchmittTriggerAtPositionWithState(uint8_t x, uint8_t y, bool state) {
   10bc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10bc8:	b085      	sub	sp, #20
   10bca:	4604      	mov	r4, r0
   10bcc:	460e      	mov	r6, r1
        gfxCircle(x, y + 7, 2); // Input point
   10bce:	1dd7      	adds	r7, r2, #7
    void DrawSchmittTriggerAtPositionWithState(uint8_t x, uint8_t y, bool state) {
   10bd0:	4615      	mov	r5, r2
        gfxLine(x + 2, y + 7, x + 10, y + 7); // Input line
   10bd2:	f106 080a 	add.w	r8, r6, #10
        gfxCircle(x, y + 7, 2); // Input point
   10bd6:	6980      	ldr	r0, [r0, #24]
    void DrawSchmittTriggerAtPositionWithState(uint8_t x, uint8_t y, bool state) {
   10bd8:	9303      	str	r3, [sp, #12]
        gfxCircle(x, y + 7, 2); // Input point
   10bda:	463a      	mov	r2, r7
   10bdc:	2302      	movs	r3, #2
   10bde:	f7f3 fee7 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        gfxLine(x + 10, y, x + 10, y + 14); // Base of triangle
   10be2:	f105 0a0e 	add.w	sl, r5, #14
        gfxLine(x + 2, y + 7, x + 10, y + 7); // Input line
   10be6:	4643      	mov	r3, r8
   10be8:	69a0      	ldr	r0, [r4, #24]
   10bea:	9700      	str	r7, [sp, #0]
   10bec:	463a      	mov	r2, r7
   10bee:	1cb1      	adds	r1, r6, #2
   10bf0:	f7f3 fefe 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(x + 10, y, x + 32, y + 7); // Top angle
   10bf4:	f106 0920 	add.w	r9, r6, #32
        gfxLine(x + 10, y, x + 10, y + 14); // Base of triangle
   10bf8:	4643      	mov	r3, r8
   10bfa:	462a      	mov	r2, r5
   10bfc:	4641      	mov	r1, r8
   10bfe:	69a0      	ldr	r0, [r4, #24]
   10c00:	f8cd a000 	str.w	sl, [sp]
   10c04:	f7f3 fef4 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(x + 10, y, x + 32, y + 7); // Top angle
   10c08:	464b      	mov	r3, r9
   10c0a:	462a      	mov	r2, r5
   10c0c:	4641      	mov	r1, r8
   10c0e:	69a0      	ldr	r0, [r4, #24]
   10c10:	9700      	str	r7, [sp, #0]
   10c12:	f7f3 feed 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(x + 10, y + 14, x + 32, y + 7); // Bottom angle
   10c16:	464b      	mov	r3, r9
   10c18:	4652      	mov	r2, sl
   10c1a:	4641      	mov	r1, r8
   10c1c:	69a0      	ldr	r0, [r4, #24]
   10c1e:	9700      	str	r7, [sp, #0]
   10c20:	f7f3 fee6 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(x + 32, y + 7, x + 40, y + 7); // Output line
   10c24:	4649      	mov	r1, r9
   10c26:	69a0      	ldr	r0, [r4, #24]
   10c28:	9700      	str	r7, [sp, #0]
   10c2a:	f106 0328 	add.w	r3, r6, #40	; 0x28
   10c2e:	463a      	mov	r2, r7
        gfxCircle(x + 42, y + 7, 2); // Output point
   10c30:	f106 092a 	add.w	r9, r6, #42	; 0x2a
        gfxLine(x + 32, y + 7, x + 40, y + 7); // Output line
   10c34:	f7f3 fedc 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(x + 15, y + 5, x + 21, y + 5); // Schmitt symbol, top
   10c38:	f105 0805 	add.w	r8, r5, #5
   10c3c:	f106 0b0f 	add.w	fp, r6, #15
        gfxCircle(x + 42, y + 7, 2); // Output point
   10c40:	69a0      	ldr	r0, [r4, #24]
   10c42:	2302      	movs	r3, #2
   10c44:	463a      	mov	r2, r7
   10c46:	4649      	mov	r1, r9
   10c48:	f7f3 feb2 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        gfxLine(x + 12, y + 9, x + 18, y + 9); // Schmitt symbol, bottom
   10c4c:	3509      	adds	r5, #9
   10c4e:	f106 0a12 	add.w	sl, r6, #18
        gfxLine(x + 15, y + 5, x + 21, y + 5); // Schmitt symbol, top
   10c52:	69a0      	ldr	r0, [r4, #24]
   10c54:	f8cd 8000 	str.w	r8, [sp]
   10c58:	f106 0315 	add.w	r3, r6, #21
   10c5c:	4642      	mov	r2, r8
   10c5e:	4659      	mov	r1, fp
   10c60:	f7f3 fec6 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(x + 12, y + 9, x + 18, y + 9); // Schmitt symbol, bottom
   10c64:	69a0      	ldr	r0, [r4, #24]
   10c66:	9500      	str	r5, [sp, #0]
   10c68:	4653      	mov	r3, sl
   10c6a:	462a      	mov	r2, r5
   10c6c:	f106 010c 	add.w	r1, r6, #12
   10c70:	f7f3 febe 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(x + 15, y + 5, x + 15, y + 9); // Scmitt symbol, left
   10c74:	69a0      	ldr	r0, [r4, #24]
   10c76:	9500      	str	r5, [sp, #0]
   10c78:	465b      	mov	r3, fp
   10c7a:	4642      	mov	r2, r8
   10c7c:	4659      	mov	r1, fp
   10c7e:	f7f3 feb7 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(x + 18, y + 5, x + 18, y + 9); // Schmitt symbol, right
   10c82:	4653      	mov	r3, sl
   10c84:	69a0      	ldr	r0, [r4, #24]
   10c86:	9500      	str	r5, [sp, #0]
   10c88:	4642      	mov	r2, r8
   10c8a:	4651      	mov	r1, sl
   10c8c:	f7f3 feb0 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        if (state) {
   10c90:	9b03      	ldr	r3, [sp, #12]
   10c92:	b163      	cbz	r3, 10cae <Schmitt::DrawSchmittTriggerAtPositionWithState(unsigned char, unsigned char, bool)+0xea>
            if (gate_countdown > 0) gfxCircle(x + 42, y + 7, 1);
   10c94:	6f63      	ldr	r3, [r4, #116]	; 0x74
   10c96:	69a0      	ldr	r0, [r4, #24]
   10c98:	2b00      	cmp	r3, #0
   10c9a:	bfcc      	ite	gt
   10c9c:	2301      	movgt	r3, #1
            else gfxCircle(x + 42, y + 7, 4);
   10c9e:	2304      	movle	r3, #4
   10ca0:	463a      	mov	r2, r7
   10ca2:	4649      	mov	r1, r9
    }
   10ca4:	b005      	add	sp, #20
   10ca6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            else gfxCircle(x + 42, y + 7, 4);
   10caa:	f7f3 be81 	b.w	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
    }
   10cae:	b005      	add	sp, #20
   10cb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00010cb4 <Schmitt::DrawInterface()>:
    void DrawInterface() {
   10cb4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   10cb8:	4604      	mov	r4, r0
   10cba:	f100 076f 	add.w	r7, r0, #111	; 0x6f
   10cbe:	f100 061c 	add.w	r6, r0, #28
        ForEachChannel(ch)
   10cc2:	2500      	movs	r5, #0
   10cc4:	f04f 0826 	mov.w	r8, #38	; 0x26
            DrawSchmittTriggerAtPositionWithState(x, y, state[ch]);
   10cc8:	ebc5 01c5 	rsb	r1, r5, r5, lsl #3
   10ccc:	0049      	lsls	r1, r1, #1
   10cce:	012a      	lsls	r2, r5, #4
   10cd0:	3103      	adds	r1, #3
   10cd2:	f817 3f01 	ldrb.w	r3, [r7, #1]!
   10cd6:	321a      	adds	r2, #26
   10cd8:	b2c9      	uxtb	r1, r1
   10cda:	4620      	mov	r0, r4
   10cdc:	f7ff ff72 	bl	10bc4 <Schmitt::DrawSchmittTriggerAtPositionWithState(unsigned char, unsigned char, bool)>
            gfxLine(3, 22 + (38 * ch), ProportionCV(ViewIn(ch), 58) + 3, 22 + (38 * ch));
   10ce0:	f856 0f04 	ldr.w	r0, [r6, #4]!
   10ce4:	213a      	movs	r1, #58	; 0x3a
   10ce6:	f7f3 fcbd 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
   10cea:	fb08 f905 	mul.w	r9, r8, r5
   10cee:	f109 0916 	add.w	r9, r9, #22
   10cf2:	1cc3      	adds	r3, r0, #3
   10cf4:	f8cd 9000 	str.w	r9, [sp]
   10cf8:	69a0      	ldr	r0, [r4, #24]
   10cfa:	464a      	mov	r2, r9
   10cfc:	2103      	movs	r1, #3
   10cfe:	f04f 0a02 	mov.w	sl, #2
   10d02:	f7f3 fe75 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
            if (ch == 0) gfxDottedLine(3, 32, 3, 23, 2);
   10d06:	f8cd a004 	str.w	sl, [sp, #4]
   10d0a:	b94d      	cbnz	r5, 10d20 <Schmitt::DrawInterface()+0x6c>
   10d0c:	2317      	movs	r3, #23
   10d0e:	9300      	str	r3, [sp, #0]
   10d10:	2303      	movs	r3, #3
   10d12:	69a0      	ldr	r0, [r4, #24]
   10d14:	2220      	movs	r2, #32
   10d16:	4619      	mov	r1, r3
   10d18:	f7f3 fe50 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
   10d1c:	2501      	movs	r5, #1
   10d1e:	e7d3      	b.n	10cc8 <Schmitt::DrawInterface()+0x14>
                gfxDottedLine(15, 49, 3, 49, 2);
   10d20:	f04f 0931 	mov.w	r9, #49	; 0x31
   10d24:	69a0      	ldr	r0, [r4, #24]
   10d26:	f8cd 9000 	str.w	r9, [sp]
   10d2a:	2303      	movs	r3, #3
   10d2c:	464a      	mov	r2, r9
   10d2e:	210f      	movs	r1, #15
   10d30:	f7f3 fe44 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
                gfxDottedLine(3, 49, 3, 59, 2);
   10d34:	233b      	movs	r3, #59	; 0x3b
   10d36:	9300      	str	r3, [sp, #0]
   10d38:	2303      	movs	r3, #3
   10d3a:	69a0      	ldr	r0, [r4, #24]
   10d3c:	f8cd a004 	str.w	sl, [sp, #4]
   10d40:	464a      	mov	r2, r9
   10d42:	4619      	mov	r1, r3
   10d44:	f7f3 fe3a 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        ForEachChannel(ch)
   10d48:	2d00      	cmp	r5, #0
   10d4a:	d0e7      	beq.n	10d1c <Schmitt::DrawInterface()+0x68>
        int lx = ProportionCV(low, 58) + 3;
   10d4c:	f8b4 0078 	ldrh.w	r0, [r4, #120]	; 0x78
   10d50:	213a      	movs	r1, #58	; 0x3a
   10d52:	f7f3 fc87 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
        int hx = ProportionCV(high, 58) + 3;
   10d56:	213a      	movs	r1, #58	; 0x3a
        int lx = ProportionCV(low, 58) + 3;
   10d58:	1cc6      	adds	r6, r0, #3
        int hx = ProportionCV(high, 58) + 3;
   10d5a:	f8b4 007a 	ldrh.w	r0, [r4, #122]	; 0x7a
   10d5e:	f7f3 fc81 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
        gfxLine(lx, 15, hx, 15);
   10d62:	220f      	movs	r2, #15
        int hx = ProportionCV(high, 58) + 3;
   10d64:	1cc5      	adds	r5, r0, #3
        gfxLine(lx, 15, hx, 15);
   10d66:	462b      	mov	r3, r5
   10d68:	69a0      	ldr	r0, [r4, #24]
   10d6a:	9200      	str	r2, [sp, #0]
   10d6c:	4631      	mov	r1, r6
   10d6e:	f7f3 fe3f 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        if (cursor != 1 || CursorBlink()) gfxLine(lx, 15, lx, 18);
   10d72:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   10d74:	2b01      	cmp	r3, #1
   10d76:	d10d      	bne.n	10d94 <Schmitt::DrawInterface()+0xe0>
   10d78:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   10d7a:	2b00      	cmp	r3, #0
   10d7c:	dc0a      	bgt.n	10d94 <Schmitt::DrawInterface()+0xe0>
        if (cursor != 2 || CursorBlink()) gfxLine(hx, 15, hx, 18);
   10d7e:	2312      	movs	r3, #18
   10d80:	9300      	str	r3, [sp, #0]
   10d82:	69a0      	ldr	r0, [r4, #24]
   10d84:	462b      	mov	r3, r5
   10d86:	220f      	movs	r2, #15
   10d88:	4629      	mov	r1, r5
   10d8a:	f7f3 fe31 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
    }
   10d8e:	b002      	add	sp, #8
   10d90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (cursor != 1 || CursorBlink()) gfxLine(lx, 15, lx, 18);
   10d94:	2312      	movs	r3, #18
   10d96:	9300      	str	r3, [sp, #0]
   10d98:	69a0      	ldr	r0, [r4, #24]
   10d9a:	4633      	mov	r3, r6
   10d9c:	220f      	movs	r2, #15
   10d9e:	4631      	mov	r1, r6
   10da0:	f7f3 fe26 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        if (cursor != 2 || CursorBlink()) gfxLine(hx, 15, hx, 18);
   10da4:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   10da6:	2b02      	cmp	r3, #2
   10da8:	d1e9      	bne.n	10d7e <Schmitt::DrawInterface()+0xca>
   10daa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   10dac:	2b00      	cmp	r3, #0
   10dae:	dce6      	bgt.n	10d7e <Schmitt::DrawInterface()+0xca>
   10db0:	e7ed      	b.n	10d8e <Schmitt::DrawInterface()+0xda>

00010db2 <Schmitt::View()>:
        gfxHeader(applet_name());
   10db2:	6803      	ldr	r3, [r0, #0]
    void View() {
   10db4:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   10db6:	681b      	ldr	r3, [r3, #0]
    void View() {
   10db8:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   10dba:	4798      	blx	r3
   10dbc:	4601      	mov	r1, r0
   10dbe:	4620      	mov	r0, r4
   10dc0:	f7f7 fc1d 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   10dc4:	4620      	mov	r0, r4
   10dc6:	f7ff ff75 	bl	10cb4 <Schmitt::DrawInterface()>
    }
   10dca:	bd10      	pop	{r4, pc}

00010dcc <Sequence5::DrawPanel()>:
    void DrawPanel() {
   10dcc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10dd0:	4604      	mov	r4, r0
   10dd2:	f100 0774 	add.w	r7, r0, #116	; 0x74
   10dd6:	2507      	movs	r5, #7
        for (int s = 0; s < 5; s++)
   10dd8:	2600      	movs	r6, #0
                gfxLine(x, 25, x, 63);
   10dda:	f04f 083f 	mov.w	r8, #63	; 0x3f
                if (s == step) {gfxCircle(x, 20, 3);}
   10dde:	f04f 0a03 	mov.w	sl, #3
        return (muted & (0x01 << step));
   10de2:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   10de6:	4133      	asrs	r3, r6
            if (!step_is_muted(s)) {
   10de8:	07db      	lsls	r3, r3, #31
   10dea:	f105 39ff 	add.w	r9, r5, #4294967295	; 0xffffffff
   10dee:	d43d      	bmi.n	10e6c <Sequence5::DrawPanel()+0xa0>
                gfxLine(x, 25, x, 63);
   10df0:	464b      	mov	r3, r9
   10df2:	69a0      	ldr	r0, [r4, #24]
   10df4:	f8cd 8000 	str.w	r8, [sp]
   10df8:	2219      	movs	r2, #25
   10dfa:	4649      	mov	r1, r9
   10dfc:	f7f3 fdf8 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                if (s == cursor) {
   10e00:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   10e02:	42b3      	cmp	r3, r6
   10e04:	f1a5 0b05 	sub.w	fp, r5, #5
   10e08:	d125      	bne.n	10e56 <Sequence5::DrawPanel()+0x8a>
                    gfxLine(x + 1, 25, x + 1, 63);
   10e0a:	69a0      	ldr	r0, [r4, #24]
   10e0c:	f8cd 8000 	str.w	r8, [sp]
   10e10:	462b      	mov	r3, r5
   10e12:	2219      	movs	r2, #25
   10e14:	4629      	mov	r1, r5
   10e16:	f7f3 fdeb 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                    gfxRect(x - 4, BottomAlign(note[s]), 9, 3);
   10e1a:	683a      	ldr	r2, [r7, #0]
   10e1c:	69a0      	ldr	r0, [r4, #24]
   10e1e:	f8cd a000 	str.w	sl, [sp]
   10e22:	2309      	movs	r3, #9
   10e24:	f1c2 023e 	rsb	r2, r2, #62	; 0x3e
   10e28:	4659      	mov	r1, fp
   10e2a:	f7f3 fde9 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
                if (s == step) {gfxCircle(x, 20, 3);}
   10e2e:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   10e32:	42b3      	cmp	r3, r6
   10e34:	d105      	bne.n	10e42 <Sequence5::DrawPanel()+0x76>
   10e36:	69a0      	ldr	r0, [r4, #24]
   10e38:	2303      	movs	r3, #3
   10e3a:	2214      	movs	r2, #20
   10e3c:	4649      	mov	r1, r9
   10e3e:	f7f3 fdb7 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        for (int s = 0; s < 5; s++)
   10e42:	3601      	adds	r6, #1
   10e44:	2e05      	cmp	r6, #5
   10e46:	f105 050c 	add.w	r5, r5, #12
   10e4a:	f107 0704 	add.w	r7, r7, #4
   10e4e:	d1c8      	bne.n	10de2 <Sequence5::DrawPanel()+0x16>
    }
   10e50:	b003      	add	sp, #12
   10e52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                } else gfxFrame(x - 4, BottomAlign(note[s]), 9, 3);
   10e56:	683a      	ldr	r2, [r7, #0]
   10e58:	69a0      	ldr	r0, [r4, #24]
   10e5a:	f8cd a000 	str.w	sl, [sp]
   10e5e:	2309      	movs	r3, #9
   10e60:	f1c2 023e 	rsb	r2, r2, #62	; 0x3e
   10e64:	4659      	mov	r1, fp
   10e66:	f7f3 fdd1 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
   10e6a:	e7e0      	b.n	10e2e <Sequence5::DrawPanel()+0x62>
            } else if (s == cursor) {
   10e6c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   10e6e:	42b3      	cmp	r3, r6
   10e70:	d1e7      	bne.n	10e42 <Sequence5::DrawPanel()+0x76>
                gfxLine(x, 25, x, 63);
   10e72:	69a0      	ldr	r0, [r4, #24]
   10e74:	f8cd 8000 	str.w	r8, [sp]
   10e78:	464b      	mov	r3, r9
   10e7a:	4649      	mov	r1, r9
   10e7c:	2219      	movs	r2, #25
   10e7e:	f7f3 fdb7 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                gfxLine(x + 1, 25, x + 1, 63);
   10e82:	69a0      	ldr	r0, [r4, #24]
   10e84:	f8cd 8000 	str.w	r8, [sp]
   10e88:	462b      	mov	r3, r5
   10e8a:	2219      	movs	r2, #25
   10e8c:	4629      	mov	r1, r5
   10e8e:	f7f3 fdaf 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
   10e92:	e7d6      	b.n	10e42 <Sequence5::DrawPanel()+0x76>

00010e94 <Sequence5::View()>:
        gfxHeader(applet_name());
   10e94:	6803      	ldr	r3, [r0, #0]
    void View() {
   10e96:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   10e98:	681b      	ldr	r3, [r3, #0]
    void View() {
   10e9a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   10e9c:	4798      	blx	r3
   10e9e:	4601      	mov	r1, r0
   10ea0:	4620      	mov	r0, r4
   10ea2:	f7f7 fbac 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawPanel();
   10ea6:	4620      	mov	r0, r4
   10ea8:	f7ff ff90 	bl	10dcc <Sequence5::DrawPanel()>
    }
   10eac:	bd10      	pop	{r4, pc}

00010eae <ShiftGate::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   10eae:	b570      	push	{r4, r5, r6, lr}
        length[0] = Unpack(data, PackLocation {0,4}) + 1;
   10eb0:	2300      	movs	r3, #0
    void OnDataReceive(uint32_t data) {
   10eb2:	460d      	mov	r5, r1
        length[0] = Unpack(data, PackLocation {0,4}) + 1;
   10eb4:	2604      	movs	r6, #4
    void OnDataReceive(uint32_t data) {
   10eb6:	b08a      	sub	sp, #40	; 0x28
   10eb8:	4604      	mov	r4, r0
        length[0] = Unpack(data, PackLocation {0,4}) + 1;
   10eba:	4619      	mov	r1, r3
   10ebc:	4632      	mov	r2, r6
   10ebe:	4628      	mov	r0, r5
   10ec0:	e9cd 3600 	strd	r3, r6, [sp]
   10ec4:	f7f2 ffb4 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   10ec8:	3001      	adds	r0, #1
   10eca:	f884 0074 	strb.w	r0, [r4, #116]	; 0x74
        length[1] = Unpack(data, PackLocation {4,4}) + 1;
   10ece:	4632      	mov	r2, r6
   10ed0:	4631      	mov	r1, r6
   10ed2:	4628      	mov	r0, r5
   10ed4:	e9cd 6602 	strd	r6, r6, [sp, #8]
   10ed8:	f7f2 ffaa 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        trigger[0] = Unpack(data, PackLocation {8,1});
   10edc:	2601      	movs	r6, #1
   10ede:	2308      	movs	r3, #8
        length[1] = Unpack(data, PackLocation {4,4}) + 1;
   10ee0:	3001      	adds	r0, #1
   10ee2:	f884 0075 	strb.w	r0, [r4, #117]	; 0x75
        trigger[0] = Unpack(data, PackLocation {8,1});
   10ee6:	4632      	mov	r2, r6
   10ee8:	4619      	mov	r1, r3
   10eea:	4628      	mov	r0, r5
   10eec:	e9cd 3604 	strd	r3, r6, [sp, #16]
   10ef0:	f7f2 ff9e 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   10ef4:	3800      	subs	r0, #0
   10ef6:	bf18      	it	ne
   10ef8:	2001      	movne	r0, #1
        trigger[1] = Unpack(data, PackLocation {9,1});
   10efa:	2309      	movs	r3, #9
        trigger[0] = Unpack(data, PackLocation {8,1});
   10efc:	f884 0076 	strb.w	r0, [r4, #118]	; 0x76
        trigger[1] = Unpack(data, PackLocation {9,1});
   10f00:	4632      	mov	r2, r6
   10f02:	4619      	mov	r1, r3
   10f04:	4628      	mov	r0, r5
   10f06:	e9cd 3606 	strd	r3, r6, [sp, #24]
   10f0a:	f7f2 ff91 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        reg[0] = Unpack(data, PackLocation {16,16});
   10f0e:	2310      	movs	r3, #16
   10f10:	e9cd 3308 	strd	r3, r3, [sp, #32]
        trigger[1] = Unpack(data, PackLocation {9,1});
   10f14:	3800      	subs	r0, #0
   10f16:	bf18      	it	ne
   10f18:	2001      	movne	r0, #1
        reg[0] = Unpack(data, PackLocation {16,16});
   10f1a:	ab0a      	add	r3, sp, #40	; 0x28
        trigger[1] = Unpack(data, PackLocation {9,1});
   10f1c:	f884 0077 	strb.w	r0, [r4, #119]	; 0x77
        reg[0] = Unpack(data, PackLocation {16,16});
   10f20:	e913 0006 	ldmdb	r3, {r1, r2}
   10f24:	4628      	mov	r0, r5
   10f26:	f7f2 ff83 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   10f2a:	f8a4 0070 	strh.w	r0, [r4, #112]	; 0x70
    }
   10f2e:	b00a      	add	sp, #40	; 0x28
   10f30:	bd70      	pop	{r4, r5, r6, pc}
   10f32:	Address 0x0000000000010f32 is out of bounds.


00010f34 <ShiftGate_OnDataReceive(bool, unsigned long)>:
void ShiftGate_OnDataReceive(bool hemisphere, uint32_t data) {ShiftGate_instance[hemisphere].OnDataReceive(data);}
   10f34:	b508      	push	{r3, lr}
   10f36:	4b03      	ldr	r3, [pc, #12]	; (10f44 <ShiftGate_OnDataReceive(bool, unsigned long)+0x10>)
   10f38:	2278      	movs	r2, #120	; 0x78
   10f3a:	fb02 3000 	mla	r0, r2, r0, r3
   10f3e:	f7ff ffb6 	bl	10eae <ShiftGate::OnDataReceive(unsigned long)>
   10f42:	bd08      	pop	{r3, pc}
   10f44:	20001744 	.word	0x20001744

00010f48 <ShiftGate::DrawInterface()>:
    void DrawInterface() {
   10f48:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10f4c:	4604      	mov	r4, r0
        gfxIcon(1, 14, LOOP_ICON);
   10f4e:	4b4c      	ldr	r3, [pc, #304]	; (11080 <ShiftGate::DrawInterface()+0x138>)
   10f50:	6980      	ldr	r0, [r0, #24]
        gfxPrint(12, 25, trigger[0] ? "Trg" : "Gte");
   10f52:	4e4c      	ldr	r6, [pc, #304]	; (11084 <ShiftGate::DrawInterface()+0x13c>)
        gfxIcon(1, 14, LOOP_ICON);
   10f54:	220e      	movs	r2, #14
   10f56:	2101      	movs	r1, #1
   10f58:	f7f3 fd22 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxIcon(35, 14, LOOP_ICON);
   10f5c:	4b48      	ldr	r3, [pc, #288]	; (11080 <ShiftGate::DrawInterface()+0x138>)
   10f5e:	69a0      	ldr	r0, [r4, #24]
   10f60:	220e      	movs	r2, #14
   10f62:	2123      	movs	r1, #35	; 0x23
   10f64:	f7f3 fd1c 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(12 + pad(10, length[0]), 15, length[0]);
   10f68:	f994 5074 	ldrsb.w	r5, [r4, #116]	; 0x74
   10f6c:	200a      	movs	r0, #10
   10f6e:	4629      	mov	r1, r5
   10f70:	f7f3 fb87 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   10f74:	462b      	mov	r3, r5
   10f76:	220f      	movs	r2, #15
   10f78:	f100 010c 	add.w	r1, r0, #12
   10f7c:	69a0      	ldr	r0, [r4, #24]
   10f7e:	f7f3 fd77 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxPrint(45 + pad(10, length[1]), 15, length[1]);
   10f82:	f994 5075 	ldrsb.w	r5, [r4, #117]	; 0x75
   10f86:	200a      	movs	r0, #10
   10f88:	4629      	mov	r1, r5
   10f8a:	f7f3 fb7a 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   10f8e:	462b      	mov	r3, r5
   10f90:	f100 012d 	add.w	r1, r0, #45	; 0x2d
   10f94:	220f      	movs	r2, #15
   10f96:	69a0      	ldr	r0, [r4, #24]
        gfxPrint(12, 25, trigger[0] ? "Trg" : "Gte");
   10f98:	4d3b      	ldr	r5, [pc, #236]	; (11088 <ShiftGate::DrawInterface()+0x140>)
        gfxPrint(45 + pad(10, length[1]), 15, length[1]);
   10f9a:	f7f3 fd69 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxIcon(1, 25, X_NOTE_ICON);
   10f9e:	4b3b      	ldr	r3, [pc, #236]	; (1108c <ShiftGate::DrawInterface()+0x144>)
   10fa0:	69a0      	ldr	r0, [r4, #24]
   10fa2:	2219      	movs	r2, #25
   10fa4:	2101      	movs	r1, #1
   10fa6:	f7f3 fcfb 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxIcon(35, 25, X_NOTE_ICON);
   10faa:	4b38      	ldr	r3, [pc, #224]	; (1108c <ShiftGate::DrawInterface()+0x144>)
   10fac:	69a0      	ldr	r0, [r4, #24]
   10fae:	2219      	movs	r2, #25
   10fb0:	2123      	movs	r1, #35	; 0x23
   10fb2:	f7f3 fcf5 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(12, 25, trigger[0] ? "Trg" : "Gte");
   10fb6:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
   10fba:	2219      	movs	r2, #25
   10fbc:	2b00      	cmp	r3, #0
   10fbe:	bf14      	ite	ne
   10fc0:	4633      	movne	r3, r6
   10fc2:	462b      	moveq	r3, r5
   10fc4:	210c      	movs	r1, #12
   10fc6:	4620      	mov	r0, r4
   10fc8:	f7f7 fa8e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(45, 25, trigger[1] ? "Trg" : "Gte");
   10fcc:	f894 3077 	ldrb.w	r3, [r4, #119]	; 0x77
   10fd0:	2219      	movs	r2, #25
   10fd2:	2b00      	cmp	r3, #0
   10fd4:	bf14      	ite	ne
   10fd6:	4633      	movne	r3, r6
   10fd8:	462b      	moveq	r3, r5
   10fda:	212d      	movs	r1, #45	; 0x2d
   10fdc:	4620      	mov	r0, r4
   10fde:	f7f7 fa83 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        byte x = cursor > 1 ? 1 : 0;
   10fe2:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
   10fe4:	2a01      	cmp	r2, #1
   10fe6:	dc02      	bgt.n	10fee <ShiftGate::DrawInterface()+0xa6>
        byte y = cursor > 1 ? cursor - 2 : cursor;
   10fe8:	b2d2      	uxtb	r2, r2
        byte x = cursor > 1 ? 1 : 0;
   10fea:	2000      	movs	r0, #0
   10fec:	e002      	b.n	10ff4 <ShiftGate::DrawInterface()+0xac>
        byte y = cursor > 1 ? cursor - 2 : cursor;
   10fee:	3a02      	subs	r2, #2
   10ff0:	b2d2      	uxtb	r2, r2
        byte x = cursor > 1 ? 1 : 0;
   10ff2:	2001      	movs	r0, #1
        gfxCursor(12 + (33 * x), 23 + (10 * y), 18);
   10ff4:	250a      	movs	r5, #10
   10ff6:	2117      	movs	r1, #23
   10ff8:	fb05 1202 	mla	r2, r5, r2, r1
   10ffc:	2521      	movs	r5, #33	; 0x21
   10ffe:	210c      	movs	r1, #12
   11000:	fb05 1100 	mla	r1, r5, r0, r1
   11004:	2312      	movs	r3, #18
   11006:	4620      	mov	r0, r4
   11008:	f7f7 fa62 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        ForEachChannel(ch)
   1100c:	f104 0870 	add.w	r8, r4, #112	; 0x70
        gfxCursor(12 + (33 * x), 23 + (10 * y), 18);
   11010:	2600      	movs	r6, #0
   11012:	272d      	movs	r7, #45	; 0x2d
                if (b == 0 && (reg[ch] & 0x01)) gfxLine(x, 40, x, 60);
   11014:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
            for (int b = 0; b < 16; b++)
   11018:	0075      	lsls	r5, r6, #1
   1101a:	351f      	adds	r5, #31
   1101c:	46b9      	mov	r9, r7
   1101e:	b2ed      	uxtb	r5, r5
   11020:	3705      	adds	r7, #5
   11022:	f04f 0b00 	mov.w	fp, #0
                if ((reg[ch] >> b) & 0x01) gfxLine(x, 45 + (ch * 5), x, 50 + (ch * 5));
   11026:	f8b8 3000 	ldrh.w	r3, [r8]
   1102a:	fa43 f30b 	asr.w	r3, r3, fp
   1102e:	07da      	lsls	r2, r3, #31
   11030:	d506      	bpl.n	11040 <ShiftGate::DrawInterface()+0xf8>
   11032:	69a0      	ldr	r0, [r4, #24]
   11034:	9700      	str	r7, [sp, #0]
   11036:	462b      	mov	r3, r5
   11038:	464a      	mov	r2, r9
   1103a:	4629      	mov	r1, r5
   1103c:	f7f3 fcd8 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                if (b == 0 && (reg[ch] & 0x01)) gfxLine(x, 40, x, 60);
   11040:	f1bb 0f00 	cmp.w	fp, #0
   11044:	d10b      	bne.n	1105e <ShiftGate::DrawInterface()+0x116>
   11046:	f8b8 3000 	ldrh.w	r3, [r8]
   1104a:	07db      	lsls	r3, r3, #31
   1104c:	d507      	bpl.n	1105e <ShiftGate::DrawInterface()+0x116>
   1104e:	69a0      	ldr	r0, [r4, #24]
   11050:	f8cd a000 	str.w	sl, [sp]
   11054:	462b      	mov	r3, r5
   11056:	2228      	movs	r2, #40	; 0x28
   11058:	4629      	mov	r1, r5
   1105a:	f7f3 fcc9 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
            for (int b = 0; b < 16; b++)
   1105e:	f10b 0b01 	add.w	fp, fp, #1
   11062:	3d02      	subs	r5, #2
   11064:	f1bb 0f10 	cmp.w	fp, #16
   11068:	b2ed      	uxtb	r5, r5
   1106a:	d1dc      	bne.n	11026 <ShiftGate::DrawInterface()+0xde>
        ForEachChannel(ch)
   1106c:	3610      	adds	r6, #16
   1106e:	b2f6      	uxtb	r6, r6
   11070:	2e20      	cmp	r6, #32
   11072:	f108 0802 	add.w	r8, r8, #2
   11076:	d1cf      	bne.n	11018 <ShiftGate::DrawInterface()+0xd0>
    }
   11078:	b003      	add	sp, #12
   1107a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1107e:	bf00      	nop
   11080:	00024218 	.word	0x00024218
   11084:	000208cb 	.word	0x000208cb
   11088:	000212e2 	.word	0x000212e2
   1108c:	00023ca8 	.word	0x00023ca8

00011090 <ShiftGate::View()>:
        gfxHeader(applet_name());
   11090:	6803      	ldr	r3, [r0, #0]
    void View() {
   11092:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   11094:	681b      	ldr	r3, [r3, #0]
    void View() {
   11096:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   11098:	4798      	blx	r3
   1109a:	4601      	mov	r1, r0
   1109c:	4620      	mov	r0, r4
   1109e:	f7f7 faae 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   110a2:	4620      	mov	r0, r4
   110a4:	f7ff ff50 	bl	10f48 <ShiftGate::DrawInterface()>
    }
   110a8:	bd10      	pop	{r4, pc}
   110aa:	Address 0x00000000000110aa is out of bounds.


000110ac <Shuffle::DrawSelector()>:
    void DrawSelector() {
   110ac:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        graphics.print(str);
   110b0:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 11198 <Shuffle::DrawSelector()+0xec>
   110b4:	f8df b0e4 	ldr.w	fp, [pc, #228]	; 1119c <Shuffle::DrawSelector()+0xf0>
   110b8:	4605      	mov	r5, r0
   110ba:	f100 087e 	add.w	r8, r0, #126	; 0x7e
   110be:	2717      	movs	r7, #23
        for (int i = 0; i < 2; i++)
   110c0:	2600      	movs	r6, #0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   110c2:	f44f 59f0 	mov.w	r9, #7680	; 0x1e00
            int16_t d = delay[i] + Proportion(DetentedIn(i), HEMISPHERE_MAX_CV, 100);
   110c6:	4631      	mov	r1, r6
   110c8:	4628      	mov	r0, r5
   110ca:	f7f7 fefb 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
   110ce:	f838 4f02 	ldrh.w	r4, [r8, #2]!
        int scaled = simfloat2int(proportion * max_value);
   110d2:	2364      	movs	r3, #100	; 0x64
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   110d4:	0380      	lsls	r0, r0, #14
   110d6:	fb90 f0f9 	sdiv	r0, r0, r9
        int scaled = simfloat2int(proportion * max_value);
   110da:	4358      	muls	r0, r3
   110dc:	eb04 34a0 	add.w	r4, r4, r0, asr #14
   110e0:	b224      	sxth	r4, r4
            d = constrain(d, 0, 100);
   110e2:	2c00      	cmp	r4, #0
   110e4:	db55      	blt.n	11192 <Shuffle::DrawSelector()+0xe6>
   110e6:	429c      	cmp	r4, r3
   110e8:	bfa8      	it	ge
   110ea:	461c      	movge	r4, r3
            gfxPrint(32 + pad(10, d), 15 + (i * 10), d);
   110ec:	4621      	mov	r1, r4
   110ee:	200a      	movs	r0, #10
   110f0:	f7f3 fac7 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   110f4:	4623      	mov	r3, r4
   110f6:	f100 0120 	add.w	r1, r0, #32
   110fa:	f1a7 0208 	sub.w	r2, r7, #8
   110fe:	69a8      	ldr	r0, [r5, #24]
   11100:	f7f3 fcb6 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        graphics.print(str);
   11104:	4651      	mov	r1, sl
   11106:	4658      	mov	r0, fp
   11108:	f008 fce5 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (cursor == i) gfxCursor(32, 23 + (i * 10), 18);
   1110c:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
   1110e:	42b3      	cmp	r3, r6
   11110:	d105      	bne.n	1111e <Shuffle::DrawSelector()+0x72>
   11112:	2312      	movs	r3, #18
   11114:	463a      	mov	r2, r7
   11116:	2120      	movs	r1, #32
   11118:	4628      	mov	r0, r5
   1111a:	f7f7 f9d9 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        for (int i = 0; i < 2; i++)
   1111e:	370a      	adds	r7, #10
   11120:	b3ae      	cbz	r6, 1118e <Shuffle::DrawSelector()+0xe2>
        int x = Proportion(delay[0], 100, 20) + 8;
   11122:	f9b5 4080 	ldrsh.w	r4, [r5, #128]	; 0x80
        gfxDottedLine(x, 41, x, 19, 3);
   11126:	69a8      	ldr	r0, [r5, #24]
        int scaled = simfloat2int(proportion * max_value);
   11128:	2614      	movs	r6, #20
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1112a:	2764      	movs	r7, #100	; 0x64
   1112c:	03a4      	lsls	r4, r4, #14
   1112e:	fb94 f4f7 	sdiv	r4, r4, r7
        int scaled = simfloat2int(proportion * max_value);
   11132:	4374      	muls	r4, r6
   11134:	13a4      	asrs	r4, r4, #14
        int x = Proportion(delay[0], 100, 20) + 8;
   11136:	3408      	adds	r4, #8
        gfxDottedLine(x, 41, x, 19, 3);
   11138:	f04f 0803 	mov.w	r8, #3
   1113c:	f04f 0913 	mov.w	r9, #19
   11140:	4623      	mov	r3, r4
   11142:	4621      	mov	r1, r4
   11144:	f8cd 8004 	str.w	r8, [sp, #4]
   11148:	f8cd 9000 	str.w	r9, [sp]
   1114c:	2229      	movs	r2, #41	; 0x29
   1114e:	f7f3 fc35 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        gfxDottedLine(x, 19, 30, 19, 3);
   11152:	69a8      	ldr	r0, [r5, #24]
   11154:	f8cd 8004 	str.w	r8, [sp, #4]
   11158:	464a      	mov	r2, r9
   1115a:	4621      	mov	r1, r4
   1115c:	f8cd 9000 	str.w	r9, [sp]
   11160:	231e      	movs	r3, #30
   11162:	f7f3 fc2b 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        gfxDottedLine(Proportion(delay[1], 100, 20) + 28, 45, 41, 33, 3);
   11166:	f9b5 1082 	ldrsh.w	r1, [r5, #130]	; 0x82
   1116a:	69a8      	ldr	r0, [r5, #24]
   1116c:	f8cd 8004 	str.w	r8, [sp, #4]
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   11170:	0389      	lsls	r1, r1, #14
   11172:	fb91 f1f7 	sdiv	r1, r1, r7
        int scaled = simfloat2int(proportion * max_value);
   11176:	4371      	muls	r1, r6
   11178:	2321      	movs	r3, #33	; 0x21
   1117a:	1389      	asrs	r1, r1, #14
   1117c:	9300      	str	r3, [sp, #0]
   1117e:	222d      	movs	r2, #45	; 0x2d
   11180:	2329      	movs	r3, #41	; 0x29
   11182:	311c      	adds	r1, #28
   11184:	f7f3 fc1a 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
    }
   11188:	b003      	add	sp, #12
   1118a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1118e:	2601      	movs	r6, #1
   11190:	e799      	b.n	110c6 <Shuffle::DrawSelector()+0x1a>
            d = constrain(d, 0, 100);
   11192:	2400      	movs	r4, #0
   11194:	e7aa      	b.n	110ec <Shuffle::DrawSelector()+0x40>
   11196:	bf00      	nop
   11198:	000204fb 	.word	0x000204fb
   1119c:	200065e0 	.word	0x200065e0

000111a0 <Shuffle::DrawIndicator()>:
    void DrawIndicator() {
   111a0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
        gfxLine(1, 40, 1, 62);
   111a4:	253e      	movs	r5, #62	; 0x3e
   111a6:	9500      	str	r5, [sp, #0]
   111a8:	2301      	movs	r3, #1
    void DrawIndicator() {
   111aa:	4604      	mov	r4, r0
        gfxLine(1, 40, 1, 62);
   111ac:	4619      	mov	r1, r3
   111ae:	6980      	ldr	r0, [r0, #24]
            gfxBitmap(x, 48 - (which == n ? 3 : 0), 8, which == n ? NOTE_ICON : X_NOTE_ICON);
   111b0:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 112b0 <Shuffle::DrawIndicator()+0x110>
        gfxLine(1, 40, 1, 62);
   111b4:	2228      	movs	r2, #40	; 0x28
   111b6:	f7f3 fc1b 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(57, 40, 57, 62);
   111ba:	2339      	movs	r3, #57	; 0x39
   111bc:	4619      	mov	r1, r3
   111be:	69a0      	ldr	r0, [r4, #24]
   111c0:	9500      	str	r5, [sp, #0]
   111c2:	2228      	movs	r2, #40	; 0x28
   111c4:	f7f3 fc14 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(60, 40, 60, 62);
   111c8:	233c      	movs	r3, #60	; 0x3c
   111ca:	4619      	mov	r1, r3
   111cc:	69a0      	ldr	r0, [r4, #24]
   111ce:	9500      	str	r5, [sp, #0]
   111d0:	2228      	movs	r2, #40	; 0x28
   111d2:	f7f3 fc0d 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(61, 40, 61, 62);
   111d6:	233d      	movs	r3, #61	; 0x3d
   111d8:	4619      	mov	r1, r3
   111da:	69a0      	ldr	r0, [r4, #24]
   111dc:	9500      	str	r5, [sp, #0]
   111de:	2228      	movs	r2, #40	; 0x28
   111e0:	f7f3 fc06 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxCircle(53, 47, 1);
   111e4:	69a0      	ldr	r0, [r4, #24]
   111e6:	2301      	movs	r3, #1
   111e8:	222f      	movs	r2, #47	; 0x2f
   111ea:	2135      	movs	r1, #53	; 0x35
   111ec:	f7f3 fbe0 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        gfxCircle(53, 55, 1);
   111f0:	69a0      	ldr	r0, [r4, #24]
   111f2:	2301      	movs	r3, #1
   111f4:	2237      	movs	r2, #55	; 0x37
   111f6:	2135      	movs	r1, #53	; 0x35
   111f8:	f7f3 fbda 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        for (int n = 0; n < 2; n++)
   111fc:	f104 077e 	add.w	r7, r4, #126	; 0x7e
   11200:	2500      	movs	r5, #0
   11202:	2664      	movs	r6, #100	; 0x64
            int16_t d = delay[n] + Proportion(DetentedIn(n), HEMISPHERE_MAX_CV, 100);
   11204:	4629      	mov	r1, r5
   11206:	4620      	mov	r0, r4
   11208:	f7f7 fe5c 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1120c:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   11210:	0380      	lsls	r0, r0, #14
   11212:	fb90 f0f3 	sdiv	r0, r0, r3
   11216:	f837 3f02 	ldrh.w	r3, [r7, #2]!
        int scaled = simfloat2int(proportion * max_value);
   1121a:	4370      	muls	r0, r6
   1121c:	eb03 33a0 	add.w	r3, r3, r0, asr #14
   11220:	b21b      	sxth	r3, r3
            d = constrain(d, 0, 100);
   11222:	2b00      	cmp	r3, #0
   11224:	db42      	blt.n	112ac <Shuffle::DrawIndicator()+0x10c>
   11226:	2b64      	cmp	r3, #100	; 0x64
   11228:	bfa8      	it	ge
   1122a:	2364      	movge	r3, #100	; 0x64
   1122c:	f04f 0914 	mov.w	r9, #20
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   11230:	039b      	lsls	r3, r3, #14
            int x = Proportion(d, 100, 20) + (n * 20) + 4;
   11232:	fb09 f105 	mul.w	r1, r9, r5
   11236:	fbb3 f3f6 	udiv	r3, r3, r6
        int scaled = simfloat2int(proportion * max_value);
   1123a:	fb09 f303 	mul.w	r3, r9, r3
   1123e:	eb01 31a3 	add.w	r1, r1, r3, asr #14
            gfxBitmap(x, 48 - (which == n ? 3 : 0), 8, which == n ? NOTE_ICON : X_NOTE_ICON);
   11242:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   11246:	69a0      	ldr	r0, [r4, #24]
   11248:	42ab      	cmp	r3, r5
   1124a:	4b1a      	ldr	r3, [pc, #104]	; (112b4 <Shuffle::DrawIndicator()+0x114>)
   1124c:	bf08      	it	eq
   1124e:	4643      	moveq	r3, r8
   11250:	9300      	str	r3, [sp, #0]
   11252:	bf0c      	ite	eq
   11254:	222d      	moveq	r2, #45	; 0x2d
   11256:	2230      	movne	r2, #48	; 0x30
   11258:	2308      	movs	r3, #8
   1125a:	3104      	adds	r1, #4
   1125c:	f7f3 fb9a 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        for (int n = 0; n < 2; n++)
   11260:	b315      	cbz	r5, 112a8 <Shuffle::DrawIndicator()+0x108>
        int lx = Proportion(OC::CORE::ticks - last_tick, tempo, 20) + (which * 20) + 4;
   11262:	4b15      	ldr	r3, [pc, #84]	; (112b8 <Shuffle::DrawIndicator()+0x118>)
   11264:	681a      	ldr	r2, [r3, #0]
   11266:	6f63      	ldr	r3, [r4, #116]	; 0x74
   11268:	1ad2      	subs	r2, r2, r3
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1126a:	0392      	lsls	r2, r2, #14
   1126c:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
   1126e:	fb92 f2f3 	sdiv	r2, r2, r3
   11272:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
        int scaled = simfloat2int(proportion * max_value);
   11276:	fb09 f202 	mul.w	r2, r9, r2
   1127a:	fb09 f303 	mul.w	r3, r9, r3
   1127e:	eb03 33a2 	add.w	r3, r3, r2, asr #14
   11282:	3304      	adds	r3, #4
   11284:	2b36      	cmp	r3, #54	; 0x36
   11286:	bfa8      	it	ge
   11288:	2336      	movge	r3, #54	; 0x36
   1128a:	2b01      	cmp	r3, #1
   1128c:	bfb8      	it	lt
   1128e:	2301      	movlt	r3, #1
        gfxDottedLine(lx, 42, lx, 60, 2);
   11290:	203c      	movs	r0, #60	; 0x3c
   11292:	2202      	movs	r2, #2
   11294:	e9cd 0200 	strd	r0, r2, [sp]
   11298:	4619      	mov	r1, r3
   1129a:	69a0      	ldr	r0, [r4, #24]
   1129c:	222a      	movs	r2, #42	; 0x2a
   1129e:	f7f3 fb8d 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
    }
   112a2:	b003      	add	sp, #12
   112a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   112a8:	2501      	movs	r5, #1
   112aa:	e7ab      	b.n	11204 <Shuffle::DrawIndicator()+0x64>
            d = constrain(d, 0, 100);
   112ac:	2300      	movs	r3, #0
   112ae:	e7bd      	b.n	1122c <Shuffle::DrawIndicator()+0x8c>
   112b0:	00024228 	.word	0x00024228
   112b4:	00023ca8 	.word	0x00023ca8
   112b8:	200046cc 	.word	0x200046cc

000112bc <Shuffle::View()>:
        gfxHeader(applet_name());
   112bc:	6803      	ldr	r3, [r0, #0]
    void View() {
   112be:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   112c0:	681b      	ldr	r3, [r3, #0]
    void View() {
   112c2:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   112c4:	4798      	blx	r3
   112c6:	4601      	mov	r1, r0
   112c8:	4620      	mov	r0, r4
   112ca:	f7f7 f998 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSelector();
   112ce:	4620      	mov	r0, r4
   112d0:	f7ff feec 	bl	110ac <Shuffle::DrawSelector()>
        DrawIndicator();
   112d4:	4620      	mov	r0, r4
   112d6:	f7ff ff63 	bl	111a0 <Shuffle::DrawIndicator()>
    }
   112da:	bd10      	pop	{r4, pc}

000112dc <SkewedLFO::DrawSkewedWaveform()>:
    void DrawSkewedWaveform() {
   112dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   112de:	6f04      	ldr	r4, [r0, #112]	; 0x70
   112e0:	2378      	movs	r3, #120	; 0x78
   112e2:	03a4      	lsls	r4, r4, #14
   112e4:	fb94 f4f3 	sdiv	r4, r4, r3
        gfxLine(0, 62, x, 33, cursor == 0);
   112e8:	6f43      	ldr	r3, [r0, #116]	; 0x74
        int scaled = simfloat2int(proportion * max_value);
   112ea:	263e      	movs	r6, #62	; 0x3e
   112ec:	fab3 f383 	clz	r3, r3
   112f0:	2721      	movs	r7, #33	; 0x21
   112f2:	4374      	muls	r4, r6
   112f4:	095b      	lsrs	r3, r3, #5
    void DrawSkewedWaveform() {
   112f6:	4605      	mov	r5, r0
        gfxLine(0, 62, x, 33, cursor == 0);
   112f8:	9301      	str	r3, [sp, #4]
   112fa:	13a4      	asrs	r4, r4, #14
   112fc:	9700      	str	r7, [sp, #0]
   112fe:	4623      	mov	r3, r4
   11300:	4632      	mov	r2, r6
   11302:	6980      	ldr	r0, [r0, #24]
   11304:	2100      	movs	r1, #0
   11306:	f7f3 fb65 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        gfxLine(x, 33, 62, 62, cursor == 0);
   1130a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
   1130c:	69a8      	ldr	r0, [r5, #24]
   1130e:	9600      	str	r6, [sp, #0]
   11310:	fab3 f383 	clz	r3, r3
   11314:	095b      	lsrs	r3, r3, #5
   11316:	9301      	str	r3, [sp, #4]
   11318:	463a      	mov	r2, r7
   1131a:	4633      	mov	r3, r6
   1131c:	4621      	mov	r1, r4
   1131e:	f7f3 fb59 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        gfxDottedLine(0, 48, 63, 48, 5);
   11322:	2230      	movs	r2, #48	; 0x30
   11324:	2305      	movs	r3, #5
   11326:	9301      	str	r3, [sp, #4]
   11328:	69a8      	ldr	r0, [r5, #24]
   1132a:	9200      	str	r2, [sp, #0]
   1132c:	233f      	movs	r3, #63	; 0x3f
   1132e:	2100      	movs	r1, #0
   11330:	f7f3 fb44 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
    }
   11334:	b003      	add	sp, #12
   11336:	bdf0      	pop	{r4, r5, r6, r7, pc}

00011338 <SkewedLFO::TicksAtRate()>:
        int effective_rate = constrain(rate + rate_mod, 0, HEM_LFO_MAX_VALUE);
   11338:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
   1133a:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
   1133c:	4413      	add	r3, r2
        int inv_rate = HEM_LFO_MAX_VALUE - effective_rate;
   1133e:	2b78      	cmp	r3, #120	; 0x78
   11340:	bfa8      	it	ge
   11342:	2378      	movge	r3, #120	; 0x78
   11344:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   11348:	f1c3 0078 	rsb	r0, r3, #120	; 0x78
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1134c:	0380      	lsls	r0, r0, #14
   1134e:	2378      	movs	r3, #120	; 0x78
   11350:	fbb0 f0f3 	udiv	r0, r0, r3
        int scaled = simfloat2int(proportion * max_value);
   11354:	f649 1320 	movw	r3, #39200	; 0x9920
   11358:	4358      	muls	r0, r3
   1135a:	1380      	asrs	r0, r0, #14
    }
   1135c:	f500 7048 	add.w	r0, r0, #800	; 0x320
   11360:	4770      	bx	lr

00011362 <SkewedLFO::AmplitudeAtPosition(int, int)>:
    int AmplitudeAtPosition(int position, int max_amplitude) {
   11362:	b570      	push	{r4, r5, r6, lr}
   11364:	4606      	mov	r6, r0
   11366:	460c      	mov	r4, r1
   11368:	4615      	mov	r5, r2
        int ticks_at_rate = TicksAtRate();
   1136a:	f7ff ffe5 	bl	11338 <SkewedLFO::TicksAtRate()>
        int effective_skew = constrain(skew + skew_mod, 0, HEM_LFO_MAX_VALUE);
   1136e:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
   11372:	6f33      	ldr	r3, [r6, #112]	; 0x70
   11374:	4413      	add	r3, r2
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   11376:	2b78      	cmp	r3, #120	; 0x78
   11378:	bfa8      	it	ge
   1137a:	2378      	movge	r3, #120	; 0x78
   1137c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   11380:	2278      	movs	r2, #120	; 0x78
   11382:	039b      	lsls	r3, r3, #14
   11384:	fbb3 f3f2 	udiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   11388:	4343      	muls	r3, r0
        if (position < fall_point) {
   1138a:	ebb4 3fa3 	cmp.w	r4, r3, asr #14
   1138e:	ea4f 32a3 	mov.w	r2, r3, asr #14
            amplitude = Proportion(ticks_at_rate - position, ticks_at_rate - fall_point, max_amplitude);
   11392:	bfa9      	itett	ge
   11394:	1b04      	subge	r4, r0, r4
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   11396:	03a0      	lsllt	r0, r4, #14
   11398:	1a80      	subge	r0, r0, r2
   1139a:	03a4      	lslge	r4, r4, #14
   1139c:	bfb4      	ite	lt
   1139e:	fb90 f0f2 	sdivlt	r0, r0, r2
   113a2:	fb94 f0f0 	sdivge	r0, r4, r0
        int scaled = simfloat2int(proportion * max_value);
   113a6:	4368      	muls	r0, r5
   113a8:	1380      	asrs	r0, r0, #14
    }
   113aa:	bd70      	pop	{r4, r5, r6, pc}

000113ac <SkewedLFO::View()>:
        gfxHeader(applet_name());
   113ac:	6803      	ldr	r3, [r0, #0]
    void View() {
   113ae:	b573      	push	{r0, r1, r4, r5, r6, lr}
        gfxHeader(applet_name());
   113b0:	681b      	ldr	r3, [r3, #0]
    void View() {
   113b2:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   113b4:	4798      	blx	r3
   113b6:	4601      	mov	r1, r0
   113b8:	4620      	mov	r0, r4
   113ba:	f7f7 f920 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSkewedWaveform();
   113be:	4620      	mov	r0, r4
   113c0:	f7ff ff8c 	bl	112dc <SkewedLFO::DrawSkewedWaveform()>
        gfxFrame(1, 15, 62, 6);
   113c4:	2306      	movs	r3, #6
   113c6:	69a0      	ldr	r0, [r4, #24]
   113c8:	9300      	str	r3, [sp, #0]
   113ca:	220f      	movs	r2, #15
   113cc:	233e      	movs	r3, #62	; 0x3e
   113ce:	2101      	movs	r1, #1
   113d0:	f7f3 fb1c 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   113d4:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
        gfxLine(x, 15, x, 20);
   113d6:	69a0      	ldr	r0, [r4, #24]
   113d8:	2378      	movs	r3, #120	; 0x78
   113da:	03ad      	lsls	r5, r5, #14
   113dc:	fb95 f5f3 	sdiv	r5, r5, r3
        int scaled = simfloat2int(proportion * max_value);
   113e0:	233e      	movs	r3, #62	; 0x3e
   113e2:	435d      	muls	r5, r3
   113e4:	13ad      	asrs	r5, r5, #14
   113e6:	2314      	movs	r3, #20
   113e8:	9300      	str	r3, [sp, #0]
   113ea:	220f      	movs	r2, #15
   113ec:	462b      	mov	r3, r5
   113ee:	4629      	mov	r1, r5
   113f0:	f7f3 fafe 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        if (cursor == 0) gfxRect(1, 16, x, 4);
   113f4:	6f63      	ldr	r3, [r4, #116]	; 0x74
   113f6:	b93b      	cbnz	r3, 11408 <SkewedLFO::View()+0x5c>
   113f8:	2304      	movs	r3, #4
   113fa:	9300      	str	r3, [sp, #0]
   113fc:	69a0      	ldr	r0, [r4, #24]
   113fe:	462b      	mov	r3, r5
   11400:	2210      	movs	r2, #16
   11402:	2101      	movs	r1, #1
   11404:	f7f3 fafc 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        int height = AmplitudeAtPosition(cycle_tick, 30);
   11408:	6fa5      	ldr	r5, [r4, #120]	; 0x78
   1140a:	221e      	movs	r2, #30
   1140c:	4629      	mov	r1, r5
   1140e:	4620      	mov	r0, r4
   11410:	f7ff ffa7 	bl	11362 <SkewedLFO::AmplitudeAtPosition(int, int)>
   11414:	4606      	mov	r6, r0
        int x = Proportion(cycle_tick, TicksAtRate(), 62);
   11416:	4620      	mov	r0, r4
   11418:	f7ff ff8e 	bl	11338 <SkewedLFO::TicksAtRate()>
   1141c:	223e      	movs	r2, #62	; 0x3e
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1141e:	03ad      	lsls	r5, r5, #14
   11420:	fb95 f3f0 	sdiv	r3, r5, r0
        int scaled = simfloat2int(proportion * max_value);
   11424:	4353      	muls	r3, r2
   11426:	139b      	asrs	r3, r3, #14
        gfxLine(x, 63, x, 63 - height);
   11428:	f1c6 063f 	rsb	r6, r6, #63	; 0x3f
   1142c:	69a0      	ldr	r0, [r4, #24]
   1142e:	9600      	str	r6, [sp, #0]
   11430:	223f      	movs	r2, #63	; 0x3f
   11432:	4619      	mov	r1, r3
   11434:	f7f3 fadc 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
    }
   11438:	b002      	add	sp, #8
   1143a:	bd70      	pop	{r4, r5, r6, pc}

0001143c <SkewedLFO::Controller()>:
    void Controller() {
   1143c:	b570      	push	{r4, r5, r6, lr}
        mod = Proportion(DetentedIn(in), HEMISPHERE_MAX_CV, HEM_LFO_MAX_VALUE / 2);
   1143e:	2100      	movs	r1, #0
    void Controller() {
   11440:	4604      	mov	r4, r0
        mod = Proportion(DetentedIn(in), HEMISPHERE_MAX_CV, HEM_LFO_MAX_VALUE / 2);
   11442:	f7f7 fd3f 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
   11446:	253c      	movs	r5, #60	; 0x3c
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   11448:	0383      	lsls	r3, r0, #14
   1144a:	f44f 56f0 	mov.w	r6, #7680	; 0x1e00
   1144e:	fb93 f3f6 	sdiv	r3, r3, r6
        int scaled = simfloat2int(proportion * max_value);
   11452:	436b      	muls	r3, r5
   11454:	139b      	asrs	r3, r3, #14
        rate_mod = get_modification_with_input(0);
   11456:	67e3      	str	r3, [r4, #124]	; 0x7c
        mod = Proportion(DetentedIn(in), HEMISPHERE_MAX_CV, HEM_LFO_MAX_VALUE / 2);
   11458:	2101      	movs	r1, #1
   1145a:	4620      	mov	r0, r4
   1145c:	f7f7 fd32 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   11460:	0383      	lsls	r3, r0, #14
   11462:	fb93 f3f6 	sdiv	r3, r3, r6
        int scaled = simfloat2int(proportion * max_value);
   11466:	436b      	muls	r3, r5
   11468:	139b      	asrs	r3, r3, #14
        skew_mod = get_modification_with_input(1);
   1146a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
        cycle_tick++;
   1146e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
        if (Clock(0)) cycle_tick = 0;
   11470:	2200      	movs	r2, #0
        cycle_tick++;
   11472:	3301      	adds	r3, #1
   11474:	67a3      	str	r3, [r4, #120]	; 0x78
        if (Clock(0)) cycle_tick = 0;
   11476:	4611      	mov	r1, r2
   11478:	4620      	mov	r0, r4
   1147a:	f7f8 f883 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   1147e:	b108      	cbz	r0, 11484 <SkewedLFO::Controller()+0x48>
   11480:	2300      	movs	r3, #0
   11482:	67a3      	str	r3, [r4, #120]	; 0x78
        if (cycle_tick >= TicksAtRate()) {
   11484:	4620      	mov	r0, r4
   11486:	f7ff ff57 	bl	11338 <SkewedLFO::TicksAtRate()>
   1148a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   1148c:	4283      	cmp	r3, r0
   1148e:	db06      	blt.n	1149e <SkewedLFO::Controller()+0x62>
            cycle_tick = 0;
   11490:	2300      	movs	r3, #0
   11492:	67a3      	str	r3, [r4, #120]	; 0x78
            ClockOut(1);
   11494:	2264      	movs	r2, #100	; 0x64
   11496:	2101      	movs	r1, #1
   11498:	4620      	mov	r0, r4
   1149a:	f7f8 fa44 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
        int cv = AmplitudeAtPosition(cycle_tick, HEMISPHERE_MAX_CV) - (HEMISPHERE_MAX_CV / 2); // subtract for bipolar
   1149e:	6fa1      	ldr	r1, [r4, #120]	; 0x78
   114a0:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
   114a4:	4620      	mov	r0, r4
   114a6:	f7ff ff5c 	bl	11362 <SkewedLFO::AmplitudeAtPosition(int, int)>
        Out(0, cv);
   114aa:	2300      	movs	r3, #0
   114ac:	f5a0 6270 	sub.w	r2, r0, #3840	; 0xf00
   114b0:	4619      	mov	r1, r3
   114b2:	4620      	mov	r0, r4
   114b4:	f7f7 fd0f 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   114b8:	bd70      	pop	{r4, r5, r6, pc}

000114ba <Squanch::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   114ba:	b5f0      	push	{r4, r5, r6, r7, lr}
        scale = Unpack(data, PackLocation {0,8});
   114bc:	2300      	movs	r3, #0
   114be:	2708      	movs	r7, #8
    void OnDataReceive(uint32_t data) {
   114c0:	460d      	mov	r5, r1
   114c2:	b087      	sub	sp, #28
   114c4:	4604      	mov	r4, r0
        scale = Unpack(data, PackLocation {0,8});
   114c6:	4619      	mov	r1, r3
   114c8:	463a      	mov	r2, r7
   114ca:	4628      	mov	r0, r5
   114cc:	e9cd 3700 	strd	r3, r7, [sp]
   114d0:	f7f2 fcae 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        shift[0] = Unpack(data, PackLocation {8,8}) - 48;
   114d4:	463a      	mov	r2, r7
        scale = Unpack(data, PackLocation {0,8});
   114d6:	4606      	mov	r6, r0
   114d8:	f8c4 01b4 	str.w	r0, [r4, #436]	; 0x1b4
        shift[0] = Unpack(data, PackLocation {8,8}) - 48;
   114dc:	4639      	mov	r1, r7
   114de:	4628      	mov	r0, r5
   114e0:	e9cd 7702 	strd	r7, r7, [sp, #8]
   114e4:	f7f2 fca4 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        shift[1] = Unpack(data, PackLocation {16,8}) - 48;
   114e8:	2310      	movs	r3, #16
   114ea:	e9cd 3704 	strd	r3, r7, [sp, #16]
        shift[0] = Unpack(data, PackLocation {8,8}) - 48;
   114ee:	3830      	subs	r0, #48	; 0x30
        shift[1] = Unpack(data, PackLocation {16,8}) - 48;
   114f0:	ab06      	add	r3, sp, #24
   114f2:	e913 0006 	ldmdb	r3, {r1, r2}
        shift[0] = Unpack(data, PackLocation {8,8}) - 48;
   114f6:	f8a4 01b8 	strh.w	r0, [r4, #440]	; 0x1b8
        shift[1] = Unpack(data, PackLocation {16,8}) - 48;
   114fa:	4628      	mov	r0, r5
   114fc:	f7f2 fc98 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   11500:	3830      	subs	r0, #48	; 0x30
   11502:	f8a4 01ba 	strh.w	r0, [r4, #442]	; 0x1ba
        quantizer.Configure(OC::Scales::GetScale(scale), 0xffff);
   11506:	4630      	mov	r0, r6
   11508:	f7ef fd34 	bl	f74 <OC::Scales::GetScale(int)>
   1150c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   11510:	4601      	mov	r1, r0
   11512:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   11516:	f7f4 fd71 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    }
   1151a:	b007      	add	sp, #28
   1151c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1151e:	Address 0x000000000001151e is out of bounds.


00011520 <Squanch_OnDataReceive(bool, unsigned long)>:
void Squanch_OnDataReceive(bool hemisphere, uint32_t data) {Squanch_instance[hemisphere].OnDataReceive(data);}
   11520:	b508      	push	{r3, lr}
   11522:	4b04      	ldr	r3, [pc, #16]	; (11534 <Squanch_OnDataReceive(bool, unsigned long)+0x14>)
   11524:	f44f 72de 	mov.w	r2, #444	; 0x1bc
   11528:	fb02 3000 	mla	r0, r2, r0, r3
   1152c:	f7ff ffc5 	bl	114ba <Squanch::OnDataReceive(unsigned long)>
   11530:	bd08      	pop	{r3, pc}
   11532:	bf00      	nop
   11534:	20001b54 	.word	0x20001b54

00011538 <Squanch::DrawInterface()>:
    void DrawInterface() {
   11538:	b5f0      	push	{r4, r5, r6, r7, lr}
   1153a:	4604      	mov	r4, r0
   1153c:	b087      	sub	sp, #28
        const uint8_t notes[2][8] = {{0xc0, 0xe0, 0xe0, 0xe0, 0x7f, 0x02, 0x14, 0x08},
   1153e:	494a      	ldr	r1, [pc, #296]	; (11668 <Squanch::DrawInterface()+0x130>)
   11540:	2210      	movs	r2, #16
   11542:	a802      	add	r0, sp, #8
   11544:	f008 fd54 	bl	19ff0 <memcpy>
        if (!continuous) gfxIcon(56, 25, CLOCK_ICON);
   11548:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   1154c:	b92b      	cbnz	r3, 1155a <Squanch::DrawInterface()+0x22>
   1154e:	4b47      	ldr	r3, [pc, #284]	; (1166c <Squanch::DrawInterface()+0x134>)
   11550:	69a0      	ldr	r0, [r4, #24]
   11552:	2219      	movs	r2, #25
   11554:	2138      	movs	r1, #56	; 0x38
   11556:	f7f3 fa23 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxIcon(1, 14, notes[0]);
   1155a:	69a0      	ldr	r0, [r4, #24]
        gfxPrint(11, 15, shift[0] > -1 ? "+" : "");
   1155c:	4e44      	ldr	r6, [pc, #272]	; (11670 <Squanch::DrawInterface()+0x138>)
   1155e:	4d45      	ldr	r5, [pc, #276]	; (11674 <Squanch::DrawInterface()+0x13c>)
        gfxIcon(1, 14, notes[0]);
   11560:	ab02      	add	r3, sp, #8
   11562:	220e      	movs	r2, #14
   11564:	2101      	movs	r1, #1
   11566:	f7f3 fa1b 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(11, 15, shift[0] > -1 ? "+" : "");
   1156a:	f9b4 31b8 	ldrsh.w	r3, [r4, #440]	; 0x1b8
   1156e:	220f      	movs	r2, #15
   11570:	ea36 0323 	bics.w	r3, r6, r3, asr #32
   11574:	bf28      	it	cs
   11576:	462b      	movcs	r3, r5
   11578:	210b      	movs	r1, #11
   1157a:	4620      	mov	r0, r4
   1157c:	f7f6 ffb4 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        graphics.print(num);
   11580:	f9b4 11b8 	ldrsh.w	r1, [r4, #440]	; 0x1b8
   11584:	483c      	ldr	r0, [pc, #240]	; (11678 <Squanch::DrawInterface()+0x140>)
   11586:	f008 fb1a 	bl	19bbe <weegfx::Graphics::print(int)>
        gfxIcon(32, 14, notes[1]);
   1158a:	ab04      	add	r3, sp, #16
   1158c:	220e      	movs	r2, #14
   1158e:	69a0      	ldr	r0, [r4, #24]
   11590:	2120      	movs	r1, #32
   11592:	f7f3 fa05 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(43 + pad(10, shift[1]), 15, shift[1] > -1 ? "+" : "");
   11596:	f9b4 71ba 	ldrsh.w	r7, [r4, #442]	; 0x1ba
   1159a:	200a      	movs	r0, #10
   1159c:	4639      	mov	r1, r7
   1159e:	f7f3 f870 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   115a2:	ea36 0327 	bics.w	r3, r6, r7, asr #32
   115a6:	bf28      	it	cs
   115a8:	462b      	movcs	r3, r5
   115aa:	220f      	movs	r2, #15
   115ac:	f100 012b 	add.w	r1, r0, #43	; 0x2b
   115b0:	4620      	mov	r0, r4
   115b2:	f7f6 ff99 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
   115b6:	f9b4 11ba 	ldrsh.w	r1, [r4, #442]	; 0x1ba
   115ba:	482f      	ldr	r0, [pc, #188]	; (11678 <Squanch::DrawInterface()+0x140>)
   115bc:	f008 faff 	bl	19bbe <weegfx::Graphics::print(int)>
        gfxBitmap(1, 24, 8, SCALE_ICON);
   115c0:	4b2e      	ldr	r3, [pc, #184]	; (1167c <Squanch::DrawInterface()+0x144>)
   115c2:	69a0      	ldr	r0, [r4, #24]
   115c4:	9300      	str	r3, [sp, #0]
   115c6:	2218      	movs	r2, #24
   115c8:	2308      	movs	r3, #8
   115ca:	2101      	movs	r1, #1
   115cc:	f7f3 f9e2 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(12, 25, OC::scale_names_short[scale]);
   115d0:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
   115d4:	4b2a      	ldr	r3, [pc, #168]	; (11680 <Squanch::DrawInterface()+0x148>)
   115d6:	210c      	movs	r1, #12
   115d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   115dc:	4620      	mov	r0, r4
   115de:	2219      	movs	r2, #25
   115e0:	f7f6 ff82 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor == 0) gfxCursor(10, 23, 18);
   115e4:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   115e6:	b92b      	cbnz	r3, 115f4 <Squanch::DrawInterface()+0xbc>
   115e8:	2312      	movs	r3, #18
   115ea:	2217      	movs	r2, #23
   115ec:	210a      	movs	r1, #10
   115ee:	4620      	mov	r0, r4
   115f0:	f7f6 ff6e 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 1) gfxCursor(42, 23, 18);
   115f4:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   115f6:	2b01      	cmp	r3, #1
   115f8:	d105      	bne.n	11606 <Squanch::DrawInterface()+0xce>
   115fa:	2312      	movs	r3, #18
   115fc:	2217      	movs	r2, #23
   115fe:	212a      	movs	r1, #42	; 0x2a
   11600:	4620      	mov	r0, r4
   11602:	f7f6 ff65 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 2) gfxCursor(13, 33, 30); // Scale Cursor
   11606:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   11608:	2b02      	cmp	r3, #2
   1160a:	d105      	bne.n	11618 <Squanch::DrawInterface()+0xe0>
   1160c:	231e      	movs	r3, #30
   1160e:	2221      	movs	r2, #33	; 0x21
   11610:	210d      	movs	r1, #13
   11612:	4620      	mov	r0, r4
   11614:	f7f6 ff5c 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            int semitone = (last_note[ch] / 128) % 12;
   11618:	6f61      	ldr	r1, [r4, #116]	; 0x74
            gfxIcon(10 + note_x, 41 + (10 * ch), notes[ch]);
   1161a:	69a0      	ldr	r0, [r4, #24]
            int semitone = (last_note[ch] / 128) % 12;
   1161c:	2900      	cmp	r1, #0
   1161e:	bfb8      	it	lt
   11620:	317f      	addlt	r1, #127	; 0x7f
   11622:	250c      	movs	r5, #12
   11624:	11c9      	asrs	r1, r1, #7
   11626:	fb91 f3f5 	sdiv	r3, r1, r5
   1162a:	fb05 1113 	mls	r1, r5, r3, r1
            int note_x = semitone * 4; // 4 pixels per semitone
   1162e:	0089      	lsls	r1, r1, #2
            gfxIcon(10 + note_x, 41 + (10 * ch), notes[ch]);
   11630:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   11634:	ab02      	add	r3, sp, #8
   11636:	2229      	movs	r2, #41	; 0x29
   11638:	310a      	adds	r1, #10
   1163a:	f7f3 f9b1 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
            int semitone = (last_note[ch] / 128) % 12;
   1163e:	6fa1      	ldr	r1, [r4, #120]	; 0x78
            gfxIcon(10 + note_x, 41 + (10 * ch), notes[ch]);
   11640:	69a0      	ldr	r0, [r4, #24]
            int semitone = (last_note[ch] / 128) % 12;
   11642:	2900      	cmp	r1, #0
   11644:	bfb8      	it	lt
   11646:	317f      	addlt	r1, #127	; 0x7f
   11648:	11c9      	asrs	r1, r1, #7
   1164a:	fb91 f3f5 	sdiv	r3, r1, r5
   1164e:	fb05 1113 	mls	r1, r5, r3, r1
            int note_x = semitone * 4; // 4 pixels per semitone
   11652:	0089      	lsls	r1, r1, #2
            gfxIcon(10 + note_x, 41 + (10 * ch), notes[ch]);
   11654:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   11658:	ab04      	add	r3, sp, #16
   1165a:	2233      	movs	r2, #51	; 0x33
   1165c:	310a      	adds	r1, #10
   1165e:	f7f3 f99f 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
    }
   11662:	b007      	add	sp, #28
   11664:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11666:	bf00      	nop
   11668:	00022eee 	.word	0x00022eee
   1166c:	00023c28 	.word	0x00023c28
   11670:	0001e41c 	.word	0x0001e41c
   11674:	000211c8 	.word	0x000211c8
   11678:	200065e0 	.word	0x200065e0
   1167c:	00023c90 	.word	0x00023c90
   11680:	0001e600 	.word	0x0001e600

00011684 <Squanch::View()>:
        gfxHeader(applet_name());
   11684:	6803      	ldr	r3, [r0, #0]
    void View() {
   11686:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   11688:	681b      	ldr	r3, [r3, #0]
    void View() {
   1168a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   1168c:	4798      	blx	r3
   1168e:	4601      	mov	r1, r0
   11690:	4620      	mov	r0, r4
   11692:	f7f6 ffb4 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   11696:	4620      	mov	r0, r4
   11698:	f7ff ff4e 	bl	11538 <Squanch::DrawInterface()>
    }
   1169c:	bd10      	pop	{r4, pc}

0001169e <TLNeuron::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   1169e:	b570      	push	{r4, r5, r6, lr}
        dendrite_weight[0] = Unpack(data, PackLocation {0,5}) - 9;
   116a0:	2300      	movs	r3, #0
   116a2:	2605      	movs	r6, #5
    void OnDataReceive(uint32_t data) {
   116a4:	460d      	mov	r5, r1
   116a6:	b088      	sub	sp, #32
   116a8:	4604      	mov	r4, r0
        dendrite_weight[0] = Unpack(data, PackLocation {0,5}) - 9;
   116aa:	4619      	mov	r1, r3
   116ac:	4632      	mov	r2, r6
   116ae:	4628      	mov	r0, r5
   116b0:	e9cd 3600 	strd	r3, r6, [sp]
   116b4:	f7f2 fbbc 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   116b8:	3809      	subs	r0, #9
   116ba:	6720      	str	r0, [r4, #112]	; 0x70
        dendrite_weight[1] = Unpack(data, PackLocation {5,5}) - 9;
   116bc:	4632      	mov	r2, r6
   116be:	4631      	mov	r1, r6
   116c0:	4628      	mov	r0, r5
   116c2:	e9cd 6602 	strd	r6, r6, [sp, #8]
   116c6:	f7f2 fbb3 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        dendrite_weight[2] = Unpack(data, PackLocation {10,5}) - 9;
   116ca:	230a      	movs	r3, #10
        dendrite_weight[1] = Unpack(data, PackLocation {5,5}) - 9;
   116cc:	3809      	subs	r0, #9
   116ce:	6760      	str	r0, [r4, #116]	; 0x74
        dendrite_weight[2] = Unpack(data, PackLocation {10,5}) - 9;
   116d0:	4632      	mov	r2, r6
   116d2:	4619      	mov	r1, r3
   116d4:	4628      	mov	r0, r5
   116d6:	e9cd 3604 	strd	r3, r6, [sp, #16]
   116da:	f7f2 fba9 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        threshold = Unpack(data, PackLocation {15,6}) - 27;
   116de:	220f      	movs	r2, #15
   116e0:	2306      	movs	r3, #6
   116e2:	e9cd 2306 	strd	r2, r3, [sp, #24]
        dendrite_weight[2] = Unpack(data, PackLocation {10,5}) - 9;
   116e6:	3809      	subs	r0, #9
        threshold = Unpack(data, PackLocation {15,6}) - 27;
   116e8:	ab08      	add	r3, sp, #32
        dendrite_weight[2] = Unpack(data, PackLocation {10,5}) - 9;
   116ea:	67a0      	str	r0, [r4, #120]	; 0x78
        threshold = Unpack(data, PackLocation {15,6}) - 27;
   116ec:	e913 0006 	ldmdb	r3, {r1, r2}
   116f0:	4628      	mov	r0, r5
   116f2:	f7f2 fb9d 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   116f6:	381b      	subs	r0, #27
   116f8:	67e0      	str	r0, [r4, #124]	; 0x7c
    }
   116fa:	b008      	add	sp, #32
   116fc:	bd70      	pop	{r4, r5, r6, pc}
   116fe:	Address 0x00000000000116fe is out of bounds.


00011700 <TLNeuron_OnDataReceive(bool, unsigned long)>:

void TLNeuron_OnDataReceive(bool hemisphere, uint32_t data) {
   11700:	b508      	push	{r3, lr}
    TLNeuron_instance[hemisphere].OnDataReceive(data);
   11702:	4b03      	ldr	r3, [pc, #12]	; (11710 <TLNeuron_OnDataReceive(bool, unsigned long)+0x10>)
   11704:	228c      	movs	r2, #140	; 0x8c
   11706:	fb02 3000 	mla	r0, r2, r0, r3
   1170a:	f7ff ffc8 	bl	1169e <TLNeuron::OnDataReceive(unsigned long)>
}
   1170e:	bd08      	pop	{r3, pc}
   11710:	20001fbc 	.word	0x20001fbc

00011714 <TLNeuron::DrawDendrites()>:
    void DrawDendrites() {
   11714:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11718:	4604      	mov	r4, r0
   1171a:	f100 086c 	add.w	r8, r0, #108	; 0x6c
   1171e:	2615      	movs	r6, #21
        for (int d = 0; d < 3; d++)
   11720:	2500      	movs	r5, #0
            byte indent = d == 1 ? 4 : 0;
   11722:	1e6b      	subs	r3, r5, #1
   11724:	425f      	negs	r7, r3
   11726:	415f      	adcs	r7, r3
            gfxCircle(9 + indent, 21 + (16 * d), 8); // Dendrite
   11728:	00bf      	lsls	r7, r7, #2
   1172a:	f107 0909 	add.w	r9, r7, #9
   1172e:	4649      	mov	r1, r9
            int weight = dendrite_weight[d];
   11730:	f858 af04 	ldr.w	sl, [r8, #4]!
            gfxCircle(9 + indent, 21 + (16 * d), 8); // Dendrite
   11734:	69a0      	ldr	r0, [r4, #24]
   11736:	2308      	movs	r3, #8
   11738:	4632      	mov	r2, r6
   1173a:	f7f3 f939 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
            gfxPrint((weight < 0 ? 1 : 6) + indent , 18 + (16 * d), weight);
   1173e:	f1ba 0f00 	cmp.w	sl, #0
   11742:	bfb4      	ite	lt
   11744:	2101      	movlt	r1, #1
   11746:	2106      	movge	r1, #6
   11748:	4653      	mov	r3, sl
   1174a:	69a0      	ldr	r0, [r4, #24]
   1174c:	1ef2      	subs	r2, r6, #3
   1174e:	4439      	add	r1, r7
   11750:	f7f3 f98e 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
            if (selected == d && CursorBlink()) gfxCircle(9 + indent, 21 + (16 * d), 7);
   11754:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   11756:	42ab      	cmp	r3, r5
   11758:	d108      	bne.n	1176c <TLNeuron::DrawDendrites()+0x58>
   1175a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1175c:	2b00      	cmp	r3, #0
   1175e:	dd05      	ble.n	1176c <TLNeuron::DrawDendrites()+0x58>
   11760:	69a0      	ldr	r0, [r4, #24]
   11762:	2307      	movs	r3, #7
   11764:	4632      	mov	r2, r6
   11766:	4649      	mov	r1, r9
   11768:	f7f3 f922 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        for (int d = 0; d < 3; d++)
   1176c:	3501      	adds	r5, #1
   1176e:	2d03      	cmp	r5, #3
   11770:	f106 0610 	add.w	r6, r6, #16
   11774:	d1d5      	bne.n	11722 <TLNeuron::DrawDendrites()+0xe>
    }
   11776:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001177a <TLNeuron::View()>:
        gfxHeader(applet_name());
   1177a:	6803      	ldr	r3, [r0, #0]
    void View() {
   1177c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        gfxHeader(applet_name());
   1177e:	681b      	ldr	r3, [r3, #0]
    void View() {
   11780:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   11782:	4798      	blx	r3
   11784:	4601      	mov	r1, r0
   11786:	4620      	mov	r0, r4
   11788:	f7f6 ff39 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawDendrites();
   1178c:	4620      	mov	r0, r4
   1178e:	f7ff ffc1 	bl	11714 <TLNeuron::DrawDendrites()>
        gfxCircle(48, 37, 12);
   11792:	2130      	movs	r1, #48	; 0x30
   11794:	69a0      	ldr	r0, [r4, #24]
   11796:	230c      	movs	r3, #12
   11798:	2225      	movs	r2, #37	; 0x25
   1179a:	f7f3 f909 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
        if (threshold < 10 && threshold > -10) x += 5; // Shove over a bit if a one-digit number
   1179e:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
        gfxPrint(x, 34, threshold);
   117a0:	69a0      	ldr	r0, [r4, #24]
        if (threshold < 10 && threshold > -10) x += 5; // Shove over a bit if a one-digit number
   117a2:	f103 0209 	add.w	r2, r3, #9
   117a6:	2a12      	cmp	r2, #18
   117a8:	bf8c      	ite	hi
   117aa:	2129      	movhi	r1, #41	; 0x29
   117ac:	212e      	movls	r1, #46	; 0x2e
        if (threshold < 0) x -= 5; // Pull back if a sign is necessary
   117ae:	2b00      	cmp	r3, #0
   117b0:	bfb8      	it	lt
   117b2:	3905      	sublt	r1, #5
        gfxPrint(x, 34, threshold);
   117b4:	2222      	movs	r2, #34	; 0x22
   117b6:	f7f3 f95b 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (selected == 3 && CursorBlink()) gfxCircle(48, 37, 11);
   117ba:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   117bc:	2b03      	cmp	r3, #3
   117be:	d108      	bne.n	117d2 <TLNeuron::View()+0x58>
   117c0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   117c2:	2b00      	cmp	r3, #0
   117c4:	dd05      	ble.n	117d2 <TLNeuron::View()+0x58>
   117c6:	69a0      	ldr	r0, [r4, #24]
   117c8:	230b      	movs	r3, #11
   117ca:	2225      	movs	r2, #37	; 0x25
   117cc:	2130      	movs	r1, #48	; 0x30
   117ce:	f7f3 f8ef 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
   117d2:	f104 067f 	add.w	r6, r4, #127	; 0x7f
        if (threshold < 10 && threshold > -10) x += 5; // Shove over a bit if a one-digit number
   117d6:	2500      	movs	r5, #0
            gfxDottedLine(17 + indent, 21 + (16 * d), 36, 37, dendrite_activated[d] ? 1 : 3); // Synapse
   117d8:	2725      	movs	r7, #37	; 0x25
            byte indent = d == 1 ? 4 : 0;
   117da:	1e6b      	subs	r3, r5, #1
   117dc:	4259      	negs	r1, r3
   117de:	4159      	adcs	r1, r3
            gfxDottedLine(17 + indent, 21 + (16 * d), 36, 37, dendrite_activated[d] ? 1 : 3); // Synapse
   117e0:	f816 3f01 	ldrb.w	r3, [r6, #1]!
   117e4:	69a0      	ldr	r0, [r4, #24]
   117e6:	9700      	str	r7, [sp, #0]
   117e8:	2b00      	cmp	r3, #0
   117ea:	bf14      	ite	ne
   117ec:	2301      	movne	r3, #1
   117ee:	2303      	moveq	r3, #3
   117f0:	012a      	lsls	r2, r5, #4
            byte indent = d == 1 ? 4 : 0;
   117f2:	0089      	lsls	r1, r1, #2
            gfxDottedLine(17 + indent, 21 + (16 * d), 36, 37, dendrite_activated[d] ? 1 : 3); // Synapse
   117f4:	9301      	str	r3, [sp, #4]
   117f6:	3215      	adds	r2, #21
   117f8:	2324      	movs	r3, #36	; 0x24
   117fa:	3111      	adds	r1, #17
        for (int d = 0; d < 3; d++)
   117fc:	3501      	adds	r5, #1
            gfxDottedLine(17 + indent, 21 + (16 * d), 36, 37, dendrite_activated[d] ? 1 : 3); // Synapse
   117fe:	f7f3 f8dd 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        for (int d = 0; d < 3; d++)
   11802:	2d03      	cmp	r5, #3
   11804:	d1e9      	bne.n	117da <TLNeuron::View()+0x60>
        if (axon_activated) {
   11806:	f894 3083 	ldrb.w	r3, [r4, #131]	; 0x83
   1180a:	b17b      	cbz	r3, 1182c <TLNeuron::View()+0xb2>
            gfxCircle(48, 37, 12);
   1180c:	69a0      	ldr	r0, [r4, #24]
   1180e:	230c      	movs	r3, #12
   11810:	2225      	movs	r2, #37	; 0x25
   11812:	2130      	movs	r1, #48	; 0x30
   11814:	f7f3 f8cc 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
            gfxCircle(48, 37, axon_radius);
   11818:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   1181c:	69a0      	ldr	r0, [r4, #24]
   1181e:	2225      	movs	r2, #37	; 0x25
   11820:	2130      	movs	r1, #48	; 0x30
    }
   11822:	b003      	add	sp, #12
   11824:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            gfxCircle(48, 37, axon_radius);
   11828:	f7f3 b8c2 	b.w	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
    }
   1182c:	b003      	add	sp, #12
   1182e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00011830 <TM::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   11830:	b570      	push	{r4, r5, r6, lr}
        reg = Unpack(data, PackLocation {0,16});
   11832:	2300      	movs	r3, #0
    void OnDataReceive(uint32_t data) {
   11834:	460d      	mov	r5, r1
        reg = Unpack(data, PackLocation {0,16});
   11836:	2610      	movs	r6, #16
    void OnDataReceive(uint32_t data) {
   11838:	b088      	sub	sp, #32
   1183a:	4604      	mov	r4, r0
        reg = Unpack(data, PackLocation {0,16});
   1183c:	4632      	mov	r2, r6
   1183e:	4619      	mov	r1, r3
   11840:	4628      	mov	r0, r5
   11842:	e9cd 3600 	strd	r3, r6, [sp]
   11846:	f7f2 faf3 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        p = Unpack(data, PackLocation {16,7});
   1184a:	2307      	movs	r3, #7
        reg = Unpack(data, PackLocation {0,16});
   1184c:	f8a4 01ac 	strh.w	r0, [r4, #428]	; 0x1ac
        p = Unpack(data, PackLocation {16,7});
   11850:	461a      	mov	r2, r3
   11852:	4631      	mov	r1, r6
   11854:	4628      	mov	r0, r5
   11856:	9303      	str	r3, [sp, #12]
   11858:	9602      	str	r6, [sp, #8]
   1185a:	f7f2 fae9 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        length = Unpack(data, PackLocation {23,4}) + 1;
   1185e:	2304      	movs	r3, #4
   11860:	2217      	movs	r2, #23
   11862:	e9cd 2304 	strd	r2, r3, [sp, #16]
        p = Unpack(data, PackLocation {16,7});
   11866:	f8c4 01b0 	str.w	r0, [r4, #432]	; 0x1b0
        length = Unpack(data, PackLocation {23,4}) + 1;
   1186a:	461a      	mov	r2, r3
   1186c:	2117      	movs	r1, #23
   1186e:	4628      	mov	r0, r5
   11870:	f7f2 fade 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        scale = Unpack(data, PackLocation {27,6});
   11874:	211b      	movs	r1, #27
   11876:	2306      	movs	r3, #6
   11878:	e9cd 1306 	strd	r1, r3, [sp, #24]
        length = Unpack(data, PackLocation {23,4}) + 1;
   1187c:	3001      	adds	r0, #1
        scale = Unpack(data, PackLocation {27,6});
   1187e:	ab08      	add	r3, sp, #32
   11880:	e913 0006 	ldmdb	r3, {r1, r2}
        length = Unpack(data, PackLocation {23,4}) + 1;
   11884:	66e0      	str	r0, [r4, #108]	; 0x6c
        scale = Unpack(data, PackLocation {27,6});
   11886:	4628      	mov	r0, r5
   11888:	f7f2 fad2 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   1188c:	b240      	sxtb	r0, r0
   1188e:	f884 01b4 	strb.w	r0, [r4, #436]	; 0x1b4
        quantizer.Configure(OC::Scales::GetScale(scale), 0xffff);
   11892:	f7ef fb6f 	bl	f74 <OC::Scales::GetScale(int)>
   11896:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1189a:	4601      	mov	r1, r0
   1189c:	f104 0074 	add.w	r0, r4, #116	; 0x74
   118a0:	f7f4 fbac 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
    }
   118a4:	b008      	add	sp, #32
   118a6:	bd70      	pop	{r4, r5, r6, pc}

000118a8 <TM_OnDataReceive(bool, unsigned long)>:

void TM_OnDataReceive(bool hemisphere, uint32_t data) {
   118a8:	b508      	push	{r3, lr}
    TM_instance[hemisphere].OnDataReceive(data);
   118aa:	4b04      	ldr	r3, [pc, #16]	; (118bc <TM_OnDataReceive(bool, unsigned long)+0x14>)
   118ac:	f44f 72dc 	mov.w	r2, #440	; 0x1b8
   118b0:	fb02 3000 	mla	r0, r2, r0, r3
   118b4:	f7ff ffbc 	bl	11830 <TM::OnDataReceive(unsigned long)>
}
   118b8:	bd08      	pop	{r3, pc}
   118ba:	bf00      	nop
   118bc:	200020d4 	.word	0x200020d4

000118c0 <TM::DrawIndicator()>:
    void DrawIndicator() {
   118c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        gfxLine(0, 45, 63, 45);
   118c2:	222d      	movs	r2, #45	; 0x2d
   118c4:	9200      	str	r2, [sp, #0]
    void DrawIndicator() {
   118c6:	4604      	mov	r4, r0
        gfxLine(0, 45, 63, 45);
   118c8:	233f      	movs	r3, #63	; 0x3f
   118ca:	6980      	ldr	r0, [r0, #24]
   118cc:	2100      	movs	r1, #0
   118ce:	f7f3 f88f 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        gfxLine(0, 62, 63, 62);
   118d2:	223e      	movs	r2, #62	; 0x3e
   118d4:	69a0      	ldr	r0, [r4, #24]
   118d6:	9200      	str	r2, [sp, #0]
   118d8:	233f      	movs	r3, #63	; 0x3f
   118da:	2100      	movs	r1, #0
   118dc:	f7f3 f888 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        for (int b = 0; b < 16; b++)
   118e0:	2500      	movs	r5, #0
            if (v) gfxRect(60 - (4 * b), 47, 3, 14);
   118e2:	f06f 0603 	mvn.w	r6, #3
   118e6:	270e      	movs	r7, #14
            int v = (reg >> b) & 0x01;
   118e8:	f8b4 31ac 	ldrh.w	r3, [r4, #428]	; 0x1ac
   118ec:	412b      	asrs	r3, r5
            if (v) gfxRect(60 - (4 * b), 47, 3, 14);
   118ee:	07db      	lsls	r3, r3, #31
   118f0:	d508      	bpl.n	11904 <TM::DrawIndicator()+0x44>
   118f2:	fb06 f105 	mul.w	r1, r6, r5
   118f6:	69a0      	ldr	r0, [r4, #24]
   118f8:	9700      	str	r7, [sp, #0]
   118fa:	2303      	movs	r3, #3
   118fc:	222f      	movs	r2, #47	; 0x2f
   118fe:	313c      	adds	r1, #60	; 0x3c
   11900:	f7f3 f87e 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
        for (int b = 0; b < 16; b++)
   11904:	3501      	adds	r5, #1
   11906:	2d10      	cmp	r5, #16
   11908:	d1ee      	bne.n	118e8 <TM::DrawIndicator()+0x28>
    }
   1190a:	b003      	add	sp, #12
   1190c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1190e:	Address 0x000000000001190e is out of bounds.


00011910 <Trending::DrawSelector()>:
    void DrawSelector() {
   11910:	b537      	push	{r0, r1, r2, r4, r5, lr}
        gfxPrint(1, 15, hemisphere ? "C:" : "A:");
   11912:	4b29      	ldr	r3, [pc, #164]	; (119b8 <Trending::DrawSelector()+0xa8>)
   11914:	7901      	ldrb	r1, [r0, #4]
   11916:	4a29      	ldr	r2, [pc, #164]	; (119bc <Trending::DrawSelector()+0xac>)
        gfxPrint(Trending_assignments[assign[0]]);
   11918:	4d29      	ldr	r5, [pc, #164]	; (119c0 <Trending::DrawSelector()+0xb0>)
    void DrawSelector() {
   1191a:	4604      	mov	r4, r0
        gfxPrint(1, 15, hemisphere ? "C:" : "A:");
   1191c:	2900      	cmp	r1, #0
   1191e:	bf08      	it	eq
   11920:	4613      	moveq	r3, r2
   11922:	220f      	movs	r2, #15
   11924:	2101      	movs	r1, #1
   11926:	f7f6 fddf 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(Trending_assignments[assign[0]]);
   1192a:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
        graphics.print(str);
   1192e:	4825      	ldr	r0, [pc, #148]	; (119c4 <Trending::DrawSelector()+0xb4>)
   11930:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
   11934:	f008 f8cf 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxPrint(1, 25, hemisphere ? "D:" : "B:");
   11938:	7921      	ldrb	r1, [r4, #4]
   1193a:	4a23      	ldr	r2, [pc, #140]	; (119c8 <Trending::DrawSelector()+0xb8>)
   1193c:	4b23      	ldr	r3, [pc, #140]	; (119cc <Trending::DrawSelector()+0xbc>)
   1193e:	4620      	mov	r0, r4
   11940:	2900      	cmp	r1, #0
   11942:	bf08      	it	eq
   11944:	4613      	moveq	r3, r2
   11946:	2219      	movs	r2, #25
   11948:	2101      	movs	r1, #1
   1194a:	f7f6 fdcd 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(Trending_assignments[assign[1]]);
   1194e:	f894 3099 	ldrb.w	r3, [r4, #153]	; 0x99
   11952:	481c      	ldr	r0, [pc, #112]	; (119c4 <Trending::DrawSelector()+0xb4>)
   11954:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
        gfxFrame(1, 35, 62, 6);
   11958:	2506      	movs	r5, #6
   1195a:	f008 f8bc 	bl	19ad6 <weegfx::Graphics::print(char const*)>
   1195e:	233e      	movs	r3, #62	; 0x3e
   11960:	2223      	movs	r2, #35	; 0x23
   11962:	69a0      	ldr	r0, [r4, #24]
   11964:	9500      	str	r5, [sp, #0]
   11966:	2101      	movs	r1, #1
   11968:	f7f3 f850 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1196c:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
   11970:	227c      	movs	r2, #124	; 0x7c
   11972:	039b      	lsls	r3, r3, #14
   11974:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   11978:	223e      	movs	r2, #62	; 0x3e
   1197a:	4353      	muls	r3, r2
        if (cursor == 2) gfxRect(1, 35, px, 6);
   1197c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
   1197e:	2a02      	cmp	r2, #2
   11980:	ea4f 33a3 	mov.w	r3, r3, asr #14
   11984:	d107      	bne.n	11996 <Trending::DrawSelector()+0x86>
   11986:	69a0      	ldr	r0, [r4, #24]
   11988:	9500      	str	r5, [sp, #0]
   1198a:	2223      	movs	r2, #35	; 0x23
   1198c:	2101      	movs	r1, #1
   1198e:	f7f3 f837 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
    }
   11992:	b003      	add	sp, #12
   11994:	bd30      	pop	{r4, r5, pc}
            gfxLine(px, 35, px, 40);
   11996:	2228      	movs	r2, #40	; 0x28
   11998:	69a0      	ldr	r0, [r4, #24]
   1199a:	9200      	str	r2, [sp, #0]
   1199c:	4619      	mov	r1, r3
   1199e:	2223      	movs	r2, #35	; 0x23
   119a0:	f7f3 f826 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
            gfxCursor(12, 23 + (cursor * 10), 50);
   119a4:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
   119a6:	230a      	movs	r3, #10
   119a8:	435a      	muls	r2, r3
   119aa:	3217      	adds	r2, #23
   119ac:	2332      	movs	r3, #50	; 0x32
   119ae:	210c      	movs	r1, #12
   119b0:	4620      	mov	r0, r4
   119b2:	f7f6 fd8d 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   119b6:	e7ec      	b.n	11992 <Trending::DrawSelector()+0x82>
   119b8:	000212e6 	.word	0x000212e6
   119bc:	000212e9 	.word	0x000212e9
   119c0:	00024164 	.word	0x00024164
   119c4:	200065e0 	.word	0x200065e0
   119c8:	000212ef 	.word	0x000212ef
   119cc:	000212ec 	.word	0x000212ec

000119d0 <Trending::DrawIndicator()>:
            if (last_trend[ch] == Trend::rising) gfxDottedLine(5, 57 + (ch * 5), 57, 47 + (ch * 5), ch + 2);
   119d0:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    void DrawIndicator() {
   119d4:	b513      	push	{r0, r1, r4, lr}
   119d6:	4604      	mov	r4, r0
            if (last_trend[ch] == Trend::rising) gfxDottedLine(5, 57 + (ch * 5), 57, 47 + (ch * 5), ch + 2);
   119d8:	b94b      	cbnz	r3, 119ee <Trending::DrawIndicator()+0x1e>
   119da:	202f      	movs	r0, #47	; 0x2f
   119dc:	2302      	movs	r3, #2
   119de:	e9cd 0300 	strd	r0, r3, [sp]
   119e2:	2339      	movs	r3, #57	; 0x39
   119e4:	69a0      	ldr	r0, [r4, #24]
   119e6:	461a      	mov	r2, r3
   119e8:	2105      	movs	r1, #5
   119ea:	f7f2 ffe7 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
            if (last_trend[ch] == Trend::falling) gfxDottedLine(5, 47 + (ch * 5), 57, 57 + (ch * 5), ch + 2);
   119ee:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   119f2:	2b01      	cmp	r3, #1
   119f4:	d108      	bne.n	11a08 <Trending::DrawIndicator()+0x38>
   119f6:	2302      	movs	r3, #2
   119f8:	9301      	str	r3, [sp, #4]
   119fa:	2339      	movs	r3, #57	; 0x39
   119fc:	69a0      	ldr	r0, [r4, #24]
   119fe:	9300      	str	r3, [sp, #0]
   11a00:	222f      	movs	r2, #47	; 0x2f
   11a02:	2105      	movs	r1, #5
   11a04:	f7f2 ffda 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
            if (last_trend[ch] == Trend::steady) gfxDottedLine(5, 52 + (ch * 5), 57, 52 + (ch * 5), ch + 2);
   11a08:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   11a0c:	2b03      	cmp	r3, #3
   11a0e:	d108      	bne.n	11a22 <Trending::DrawIndicator()+0x52>
   11a10:	2302      	movs	r3, #2
   11a12:	2234      	movs	r2, #52	; 0x34
   11a14:	9301      	str	r3, [sp, #4]
   11a16:	69a0      	ldr	r0, [r4, #24]
   11a18:	9200      	str	r2, [sp, #0]
   11a1a:	2339      	movs	r3, #57	; 0x39
   11a1c:	2105      	movs	r1, #5
   11a1e:	f7f2 ffcd 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
            if (last_trend[ch] == Trend::rising) gfxDottedLine(5, 57 + (ch * 5), 57, 47 + (ch * 5), ch + 2);
   11a22:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   11a26:	b953      	cbnz	r3, 11a3e <Trending::DrawIndicator()+0x6e>
   11a28:	2334      	movs	r3, #52	; 0x34
   11a2a:	f04f 0c03 	mov.w	ip, #3
   11a2e:	e9cd 3c00 	strd	r3, ip, [sp]
   11a32:	69a0      	ldr	r0, [r4, #24]
   11a34:	2339      	movs	r3, #57	; 0x39
   11a36:	223e      	movs	r2, #62	; 0x3e
   11a38:	2105      	movs	r1, #5
   11a3a:	f7f2 ffbf 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
            if (last_trend[ch] == Trend::falling) gfxDottedLine(5, 47 + (ch * 5), 57, 57 + (ch * 5), ch + 2);
   11a3e:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   11a42:	2b01      	cmp	r3, #1
   11a44:	d109      	bne.n	11a5a <Trending::DrawIndicator()+0x8a>
   11a46:	213e      	movs	r1, #62	; 0x3e
   11a48:	2303      	movs	r3, #3
   11a4a:	e9cd 1300 	strd	r1, r3, [sp]
   11a4e:	69a0      	ldr	r0, [r4, #24]
   11a50:	2339      	movs	r3, #57	; 0x39
   11a52:	2234      	movs	r2, #52	; 0x34
   11a54:	2105      	movs	r1, #5
   11a56:	f7f2 ffb1 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
            if (last_trend[ch] == Trend::steady) gfxDottedLine(5, 52 + (ch * 5), 57, 52 + (ch * 5), ch + 2);
   11a5a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   11a5e:	2b03      	cmp	r3, #3
   11a60:	d107      	bne.n	11a72 <Trending::DrawIndicator()+0xa2>
   11a62:	9301      	str	r3, [sp, #4]
   11a64:	2339      	movs	r3, #57	; 0x39
   11a66:	69a0      	ldr	r0, [r4, #24]
   11a68:	9300      	str	r3, [sp, #0]
   11a6a:	461a      	mov	r2, r3
   11a6c:	2105      	movs	r1, #5
   11a6e:	f7f2 ffa5 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
    }
   11a72:	b002      	add	sp, #8
   11a74:	bd10      	pop	{r4, pc}

00011a76 <Trending::View()>:
        gfxHeader(applet_name());
   11a76:	6803      	ldr	r3, [r0, #0]
    void View() {
   11a78:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   11a7a:	681b      	ldr	r3, [r3, #0]
    void View() {
   11a7c:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   11a7e:	4798      	blx	r3
   11a80:	4601      	mov	r1, r0
   11a82:	4620      	mov	r0, r4
   11a84:	f7f6 fdbb 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSelector();
   11a88:	4620      	mov	r0, r4
   11a8a:	f7ff ff41 	bl	11910 <Trending::DrawSelector()>
        DrawIndicator();
   11a8e:	4620      	mov	r0, r4
   11a90:	f7ff ff9e 	bl	119d0 <Trending::DrawIndicator()>
    }
   11a94:	bd10      	pop	{r4, pc}

00011a96 <TrigSeq::DrawDisplay()>:
    void DrawDisplay() {
   11a96:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11a9a:	b089      	sub	sp, #36	; 0x24
   11a9c:	f100 0374 	add.w	r3, r0, #116	; 0x74
   11aa0:	9303      	str	r3, [sp, #12]
   11aa2:	2300      	movs	r3, #0
   11aa4:	4604      	mov	r4, r0
   11aa6:	f100 086c 	add.w	r8, r0, #108	; 0x6c
   11aaa:	2505      	movs	r5, #5
   11aac:	9302      	str	r3, [sp, #8]
            int this_cursor = cursor - (3 * ch);
   11aae:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   11ab2:	9a02      	ldr	r2, [sp, #8]
            for (int s = 0; s < 8; s++)
   11ab4:	2600      	movs	r6, #0
            int this_cursor = cursor - (3 * ch);
   11ab6:	eb02 0b03 	add.w	fp, r2, r3
            int x = 10 + (31 * ch);
   11aba:	f105 0905 	add.w	r9, r5, #5
            bool stop = 0; // Stop displaying when end_step is reached
   11abe:	9604      	str	r6, [sp, #16]
                if (!stop) {
   11ac0:	9b04      	ldr	r3, [sp, #16]
   11ac2:	b333      	cbz	r3, 11b12 <TrigSeq::DrawDisplay()+0x7c>
                        stop = 1;
   11ac4:	2301      	movs	r3, #1
   11ac6:	9304      	str	r3, [sp, #16]
            for (int s = 0; s < 8; s++)
   11ac8:	3601      	adds	r6, #1
   11aca:	2e08      	cmp	r6, #8
   11acc:	d1f8      	bne.n	11ac0 <TrigSeq::DrawDisplay()+0x2a>
            if ((this_cursor == 0 || this_cursor == 1) && CursorBlink()) {
   11ace:	f1bb 0f01 	cmp.w	fp, #1
   11ad2:	d80e      	bhi.n	11af2 <TrigSeq::DrawDisplay()+0x5c>
   11ad4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   11ad6:	2b00      	cmp	r3, #0
   11ad8:	dd0b      	ble.n	11af2 <TrigSeq::DrawDisplay()+0x5c>
                int y = 15 + (this_cursor * 24);
   11ada:	2318      	movs	r3, #24
   11adc:	fb03 f20b 	mul.w	r2, r3, fp
                gfxLine(x - 5, y, x - 5, y + 24);
   11ae0:	f102 0327 	add.w	r3, r2, #39	; 0x27
   11ae4:	9300      	str	r3, [sp, #0]
   11ae6:	69a0      	ldr	r0, [r4, #24]
   11ae8:	462b      	mov	r3, r5
   11aea:	320f      	adds	r2, #15
   11aec:	4629      	mov	r1, r5
   11aee:	f7f2 ff7f 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        ForEachChannel(ch)
   11af2:	9b02      	ldr	r3, [sp, #8]
   11af4:	3b03      	subs	r3, #3
   11af6:	9302      	str	r3, [sp, #8]
   11af8:	9b03      	ldr	r3, [sp, #12]
   11afa:	3301      	adds	r3, #1
   11afc:	9303      	str	r3, [sp, #12]
   11afe:	9b02      	ldr	r3, [sp, #8]
   11b00:	3306      	adds	r3, #6
   11b02:	f105 051f 	add.w	r5, r5, #31
   11b06:	f108 0804 	add.w	r8, r8, #4
   11b0a:	d1d0      	bne.n	11aae <TrigSeq::DrawDisplay()+0x18>
    }
   11b0c:	b009      	add	sp, #36	; 0x24
   11b0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    int y = 18 + (6 * s);
   11b12:	2306      	movs	r3, #6
   11b14:	4373      	muls	r3, r6
   11b16:	f103 0712 	add.w	r7, r3, #18
                    gfxCircle(x, y, 3);
   11b1a:	9305      	str	r3, [sp, #20]
   11b1c:	69a0      	ldr	r0, [r4, #24]
   11b1e:	2303      	movs	r3, #3
   11b20:	463a      	mov	r2, r7
   11b22:	4649      	mov	r1, r9
   11b24:	f7f2 ff44 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
                    int value = (pattern[ch] >> s) & 0x01;
   11b28:	9b03      	ldr	r3, [sp, #12]
   11b2a:	781b      	ldrb	r3, [r3, #0]
   11b2c:	4133      	asrs	r3, r6
                    if (value) {
   11b2e:	f013 0a01 	ands.w	sl, r3, #1
   11b32:	d018      	beq.n	11b66 <TrigSeq::DrawDisplay()+0xd0>
                            gfxCircle(x + 1, y, r);
   11b34:	1dab      	adds	r3, r5, #6
   11b36:	9306      	str	r3, [sp, #24]
                            gfxCircle(x + 2, y, r);
   11b38:	1deb      	adds	r3, r5, #7
   11b3a:	9307      	str	r3, [sp, #28]
                            gfxCircle(x, y, r);
   11b3c:	69a0      	ldr	r0, [r4, #24]
   11b3e:	4653      	mov	r3, sl
   11b40:	463a      	mov	r2, r7
   11b42:	4649      	mov	r1, r9
   11b44:	f7f2 ff34 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
                            gfxCircle(x + 1, y, r);
   11b48:	9906      	ldr	r1, [sp, #24]
   11b4a:	69a0      	ldr	r0, [r4, #24]
   11b4c:	4653      	mov	r3, sl
   11b4e:	463a      	mov	r2, r7
   11b50:	f7f2 ff2e 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
                            gfxCircle(x + 2, y, r);
   11b54:	9907      	ldr	r1, [sp, #28]
   11b56:	69a0      	ldr	r0, [r4, #24]
   11b58:	4653      	mov	r3, sl
   11b5a:	463a      	mov	r2, r7
   11b5c:	f7f2 ff28 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
                        for (int r = 1; r < 3; r++) {
   11b60:	f1ba 0f02 	cmp.w	sl, #2
   11b64:	d120      	bne.n	11ba8 <TrigSeq::DrawDisplay()+0x112>
                    if (s == step[ch]) {
   11b66:	f8d8 3000 	ldr.w	r3, [r8]
   11b6a:	42b3      	cmp	r3, r6
   11b6c:	d108      	bne.n	11b80 <TrigSeq::DrawDisplay()+0xea>
                        gfxLine(x + 4, y, x + 10, y);
   11b6e:	69a0      	ldr	r0, [r4, #24]
   11b70:	9700      	str	r7, [sp, #0]
   11b72:	f105 030f 	add.w	r3, r5, #15
   11b76:	463a      	mov	r2, r7
   11b78:	f105 0109 	add.w	r1, r5, #9
   11b7c:	f7f2 ff38 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                    if (s == end_step[ch]) {
   11b80:	f8d8 300c 	ldr.w	r3, [r8, #12]
   11b84:	42b3      	cmp	r3, r6
   11b86:	d19f      	bne.n	11ac8 <TrigSeq::DrawDisplay()+0x32>
                        if (this_cursor == 2 && CursorBlink()) {
   11b88:	f1bb 0f02 	cmp.w	fp, #2
   11b8c:	d19a      	bne.n	11ac4 <TrigSeq::DrawDisplay()+0x2e>
   11b8e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   11b90:	2b00      	cmp	r3, #0
   11b92:	dd97      	ble.n	11ac4 <TrigSeq::DrawDisplay()+0x2e>
                            gfxLine(x - 8, y + 3, x + 5, y + 3);
   11b94:	9a05      	ldr	r2, [sp, #20]
   11b96:	69a0      	ldr	r0, [r4, #24]
   11b98:	3215      	adds	r2, #21
   11b9a:	9200      	str	r2, [sp, #0]
   11b9c:	f105 030a 	add.w	r3, r5, #10
   11ba0:	1ee9      	subs	r1, r5, #3
   11ba2:	f7f2 ff25 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
   11ba6:	e78d      	b.n	11ac4 <TrigSeq::DrawDisplay()+0x2e>
   11ba8:	f04f 0a02 	mov.w	sl, #2
   11bac:	e7c6      	b.n	11b3c <TrigSeq::DrawDisplay()+0xa6>

00011bae <TrigSeq::View()>:
        gfxHeader(applet_name());
   11bae:	6803      	ldr	r3, [r0, #0]
    void View() {
   11bb0:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   11bb2:	681b      	ldr	r3, [r3, #0]
    void View() {
   11bb4:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   11bb6:	4798      	blx	r3
   11bb8:	4601      	mov	r1, r0
   11bba:	4620      	mov	r0, r4
   11bbc:	f7f6 fd1f 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawDisplay();
   11bc0:	4620      	mov	r0, r4
   11bc2:	f7ff ff68 	bl	11a96 <TrigSeq::DrawDisplay()>
    }
   11bc6:	bd10      	pop	{r4, pc}

00011bc8 <TrigSeq16::DrawDisplay()>:
    void DrawDisplay() {
   11bc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        ForEachChannel(ch)
   11bcc:	2600      	movs	r6, #0
    void DrawDisplay() {
   11bce:	b087      	sub	sp, #28
   11bd0:	4604      	mov	r4, r0
   11bd2:	2505      	movs	r5, #5
        bool stop = 0; // Stop displaying when end_step is reached
   11bd4:	46b0      	mov	r8, r6
            int x = 10 + (31 * ch);
   11bd6:	00f3      	lsls	r3, r6, #3
   11bd8:	f105 0905 	add.w	r9, r5, #5
            for (int s = 0; s < 8; s++)
   11bdc:	9303      	str	r3, [sp, #12]
   11bde:	2700      	movs	r7, #0
                if (!stop) {
   11be0:	f1b8 0f00 	cmp.w	r8, #0
   11be4:	d024      	beq.n	11c30 <TrigSeq16::DrawDisplay()+0x68>
                        stop = 1;
   11be6:	f04f 0801 	mov.w	r8, #1
            for (int s = 0; s < 8; s++)
   11bea:	3701      	adds	r7, #1
   11bec:	2f08      	cmp	r7, #8
   11bee:	d1f7      	bne.n	11be0 <TrigSeq16::DrawDisplay()+0x18>
            if (cursor < 4) {
   11bf0:	6fa2      	ldr	r2, [r4, #120]	; 0x78
   11bf2:	2a03      	cmp	r2, #3
   11bf4:	dc15      	bgt.n	11c22 <TrigSeq16::DrawDisplay()+0x5a>
                if (ch == (cursor > 1 ? 1 : 0) && CursorBlink()) {
   11bf6:	2a01      	cmp	r2, #1
   11bf8:	bfd4      	ite	le
   11bfa:	2300      	movle	r3, #0
   11bfc:	2301      	movgt	r3, #1
   11bfe:	42b3      	cmp	r3, r6
   11c00:	d10f      	bne.n	11c22 <TrigSeq16::DrawDisplay()+0x5a>
   11c02:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   11c04:	2b00      	cmp	r3, #0
   11c06:	dd0c      	ble.n	11c22 <TrigSeq16::DrawDisplay()+0x5a>
                    int y = 15 + (this_cursor * 24);
   11c08:	2318      	movs	r3, #24
                    int this_cursor = cursor - (ch * 2);
   11c0a:	eba2 0246 	sub.w	r2, r2, r6, lsl #1
                    int y = 15 + (this_cursor * 24);
   11c0e:	435a      	muls	r2, r3
                    gfxLine(x - 5, y, x - 5, y + 24);
   11c10:	f102 0327 	add.w	r3, r2, #39	; 0x27
   11c14:	9300      	str	r3, [sp, #0]
   11c16:	69a0      	ldr	r0, [r4, #24]
   11c18:	462b      	mov	r3, r5
   11c1a:	320f      	adds	r2, #15
   11c1c:	4629      	mov	r1, r5
   11c1e:	f7f2 fee7 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        ForEachChannel(ch)
   11c22:	351f      	adds	r5, #31
   11c24:	b116      	cbz	r6, 11c2c <TrigSeq16::DrawDisplay()+0x64>
    }
   11c26:	b007      	add	sp, #28
   11c28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11c2c:	2601      	movs	r6, #1
   11c2e:	e7d2      	b.n	11bd6 <TrigSeq16::DrawDisplay()+0xe>
                    int y = 18 + (6 * s);
   11c30:	2306      	movs	r3, #6
   11c32:	437b      	muls	r3, r7
   11c34:	f103 0b12 	add.w	fp, r3, #18
                    gfxCircle(x, y, 3);
   11c38:	9302      	str	r3, [sp, #8]
   11c3a:	69a0      	ldr	r0, [r4, #24]
   11c3c:	2303      	movs	r3, #3
   11c3e:	465a      	mov	r2, fp
   11c40:	4649      	mov	r1, r9
   11c42:	f7f2 feb5 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
                    int value = (pattern[ch] >> s) & 0x01;
   11c46:	f104 0370 	add.w	r3, r4, #112	; 0x70
   11c4a:	5d9b      	ldrb	r3, [r3, r6]
   11c4c:	413b      	asrs	r3, r7
                    if (value) {
   11c4e:	f013 0a01 	ands.w	sl, r3, #1
   11c52:	d018      	beq.n	11c86 <TrigSeq16::DrawDisplay()+0xbe>
                            gfxCircle(x + 1, y, r);
   11c54:	1dab      	adds	r3, r5, #6
   11c56:	9304      	str	r3, [sp, #16]
                            gfxCircle(x + 2, y, r);
   11c58:	1deb      	adds	r3, r5, #7
   11c5a:	9305      	str	r3, [sp, #20]
                            gfxCircle(x, y, r);
   11c5c:	69a0      	ldr	r0, [r4, #24]
   11c5e:	4653      	mov	r3, sl
   11c60:	465a      	mov	r2, fp
   11c62:	4649      	mov	r1, r9
   11c64:	f7f2 fea4 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
                            gfxCircle(x + 1, y, r);
   11c68:	9904      	ldr	r1, [sp, #16]
   11c6a:	69a0      	ldr	r0, [r4, #24]
   11c6c:	4653      	mov	r3, sl
   11c6e:	465a      	mov	r2, fp
   11c70:	f7f2 fe9e 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
                            gfxCircle(x + 2, y, r);
   11c74:	9905      	ldr	r1, [sp, #20]
   11c76:	69a0      	ldr	r0, [r4, #24]
   11c78:	4653      	mov	r3, sl
   11c7a:	465a      	mov	r2, fp
   11c7c:	f7f2 fe98 	bl	49b0 <HemisphereApplet::gfxCircle(int, int, int) [clone .isra.0]>
                        for (int r = 1; r < 3; r++) {
   11c80:	f1ba 0f02 	cmp.w	sl, #2
   11c84:	d11f      	bne.n	11cc6 <TrigSeq16::DrawDisplay()+0xfe>
                    if (s + (ch * 8) == step) {
   11c86:	9b03      	ldr	r3, [sp, #12]
   11c88:	eb07 0a03 	add.w	sl, r7, r3
   11c8c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   11c8e:	4553      	cmp	r3, sl
   11c90:	d109      	bne.n	11ca6 <TrigSeq16::DrawDisplay()+0xde>
                        gfxLine(x + 4, y, x + 10, y);
   11c92:	69a0      	ldr	r0, [r4, #24]
   11c94:	f8cd b000 	str.w	fp, [sp]
   11c98:	f105 030f 	add.w	r3, r5, #15
   11c9c:	465a      	mov	r2, fp
   11c9e:	f105 0109 	add.w	r1, r5, #9
   11ca2:	f7f2 fea5 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
                    if (s + (ch * 8) == end_step) {
   11ca6:	6f63      	ldr	r3, [r4, #116]	; 0x74
   11ca8:	4553      	cmp	r3, sl
   11caa:	d19e      	bne.n	11bea <TrigSeq16::DrawDisplay()+0x22>
                        if (cursor == 4) {
   11cac:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   11cae:	2b04      	cmp	r3, #4
   11cb0:	d199      	bne.n	11be6 <TrigSeq16::DrawDisplay()+0x1e>
                            gfxLine(x - 8, y + 3, x + 5, y + 3);
   11cb2:	9a02      	ldr	r2, [sp, #8]
   11cb4:	69a0      	ldr	r0, [r4, #24]
   11cb6:	3215      	adds	r2, #21
   11cb8:	9200      	str	r2, [sp, #0]
   11cba:	f105 030a 	add.w	r3, r5, #10
   11cbe:	1ee9      	subs	r1, r5, #3
   11cc0:	f7f2 fe96 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
   11cc4:	e78f      	b.n	11be6 <TrigSeq16::DrawDisplay()+0x1e>
   11cc6:	f04f 0a02 	mov.w	sl, #2
   11cca:	e7c7      	b.n	11c5c <TrigSeq16::DrawDisplay()+0x94>

00011ccc <TrigSeq16::View()>:
        gfxHeader(applet_name());
   11ccc:	6803      	ldr	r3, [r0, #0]
    void View() {
   11cce:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   11cd0:	681b      	ldr	r3, [r3, #0]
    void View() {
   11cd2:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   11cd4:	4798      	blx	r3
   11cd6:	4601      	mov	r1, r0
   11cd8:	4620      	mov	r0, r4
   11cda:	f7f6 fc90 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawDisplay();
   11cde:	4620      	mov	r0, r4
   11ce0:	f7ff ff72 	bl	11bc8 <TrigSeq16::DrawDisplay()>
    }
   11ce4:	bd10      	pop	{r4, pc}
   11ce6:	Address 0x0000000000011ce6 is out of bounds.


00011ce8 <Tuner::DrawTuner()>:
    void DrawTuner() {
   11ce8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    float get_frequency() {return frequency_;}
   11cec:	6fc7      	ldr	r7, [r0, #124]	; 0x7c
    void DrawTuner() {
   11cee:	4606      	mov	r6, r0
        return(static_cast<float>(A4_Hz * HEM_TUNER_AaboveMidCtoC0));
   11cf0:	f8d0 0084 	ldr.w	r0, [r0, #132]	; 0x84
   11cf4:	f00a fe3a 	bl	1c96c <__aeabi_i2d>
   11cf8:	a37d      	add	r3, pc, #500	; (adr r3, 11ef0 <Tuner::DrawTuner()+0x208>)
   11cfa:	e9d3 2300 	ldrd	r2, r3, [r3]
   11cfe:	f00a fe9f 	bl	1ca40 <__aeabi_dmul>
   11d02:	f00b f8cf 	bl	1cea4 <__aeabi_d2f>
   11d06:	4601      	mov	r1, r0
        int32_t deviation = round(12000.0 * log2f(frequency_ / c0_freq_)) + 500;
   11d08:	4638      	mov	r0, r7
   11d0a:	f00b fadd 	bl	1d2c8 <__aeabi_fdiv>
   11d0e:	f009 fca1 	bl	1b654 <log2f>
   11d12:	4979      	ldr	r1, [pc, #484]	; (11ef8 <Tuner::DrawTuner()+0x210>)
   11d14:	f00b fa24 	bl	1d160 <__aeabi_fmul>
   11d18:	2100      	movs	r1, #0
   11d1a:	4604      	mov	r4, r0
   11d1c:	f00b fbd2 	bl	1d4c4 <__aeabi_fcmpge>
   11d20:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   11d24:	2800      	cmp	r0, #0
   11d26:	f000 80a4 	beq.w	11e72 <Tuner::DrawTuner()+0x18a>
   11d2a:	4620      	mov	r0, r4
   11d2c:	f00b f910 	bl	1cf50 <__addsf3>
   11d30:	f00b fbf2 	bl	1d518 <__aeabi_f2iz>
        int8_t note = (deviation - (octave * 12000)) / 1000;
   11d34:	4d71      	ldr	r5, [pc, #452]	; (11efc <Tuner::DrawTuner()+0x214>)
        int32_t deviation = round(12000.0 * log2f(frequency_ / c0_freq_)) + 500;
   11d36:	f500 74fa 	add.w	r4, r0, #500	; 0x1f4
        int8_t octave = deviation / 12000;
   11d3a:	f642 68e0 	movw	r8, #12000	; 0x2ee0
   11d3e:	fb94 f8f8 	sdiv	r8, r4, r8
        int8_t note = (deviation - (octave * 12000)) / 1000;
   11d42:	fa4f f888 	sxtb.w	r8, r8
   11d46:	fb05 f508 	mul.w	r5, r5, r8
   11d4a:	eb05 0904 	add.w	r9, r5, r4
   11d4e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   11d52:	fb99 f9f3 	sdiv	r9, r9, r3
   11d56:	fa4f f989 	sxtb.w	r9, r9
        note = constrain(note, 0, 12);
   11d5a:	f1b9 0f00 	cmp.w	r9, #0
   11d5e:	f2c0 808c 	blt.w	11e7a <Tuner::DrawTuner()+0x192>
   11d62:	f1b9 0f0c 	cmp.w	r9, #12
   11d66:	bfa8      	it	ge
   11d68:	f04f 090c 	movge.w	r9, #12
        if (frequency_ > 0.0) {
   11d6c:	2100      	movs	r1, #0
   11d6e:	4638      	mov	r0, r7
   11d70:	f00b fbb2 	bl	1d4d8 <__aeabi_fcmpgt>
   11d74:	2800      	cmp	r0, #0
   11d76:	d064      	beq.n	11e42 <Tuner::DrawTuner()+0x15a>
        int32_t residual = ((deviation - ((octave - 1) * 12000)) % 1000) - 500;
   11d78:	f505 533b 	add.w	r3, r5, #11968	; 0x2ec0
   11d7c:	3320      	adds	r3, #32
   11d7e:	4423      	add	r3, r4
   11d80:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   11d84:	fb93 f1f2 	sdiv	r1, r3, r2
   11d88:	fb02 3411 	mls	r4, r2, r1, r3
            gfxPrint(20, 30, OC::Strings::note_names[note]);
   11d8c:	4b5c      	ldr	r3, [pc, #368]	; (11f00 <Tuner::DrawTuner()+0x218>)
   11d8e:	221e      	movs	r2, #30
   11d90:	f853 3029 	ldr.w	r3, [r3, r9, lsl #2]
   11d94:	2114      	movs	r1, #20
   11d96:	4630      	mov	r0, r6
   11d98:	f7f6 fba6 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        graphics.print(str);
   11d9c:	4959      	ldr	r1, [pc, #356]	; (11f04 <Tuner::DrawTuner()+0x21c>)
   11d9e:	485a      	ldr	r0, [pc, #360]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11da0:	f007 fe99 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
   11da4:	4858      	ldr	r0, [pc, #352]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11da6:	4641      	mov	r1, r8
   11da8:	f007 ff09 	bl	19bbe <weegfx::Graphics::print(int)>
            if (residual < 10 && residual > -10) gfxInvert(1, 28, 62, 11);
   11dac:	f46f 73f5 	mvn.w	r3, #490	; 0x1ea
        int32_t residual = ((deviation - ((octave - 1) * 12000)) % 1000) - 500;
   11db0:	f5a4 75fa 	sub.w	r5, r4, #500	; 0x1f4
            if (residual < 10 && residual > -10) gfxInvert(1, 28, 62, 11);
   11db4:	441c      	add	r4, r3
   11db6:	2c12      	cmp	r4, #18
   11db8:	d862      	bhi.n	11e80 <Tuner::DrawTuner()+0x198>
   11dba:	230b      	movs	r3, #11
   11dbc:	9300      	str	r3, [sp, #0]
   11dbe:	221c      	movs	r2, #28
   11dc0:	233e      	movs	r3, #62	; 0x3e
   11dc2:	2101      	movs	r1, #1
   11dc4:	4630      	mov	r0, r6
   11dc6:	f7f6 fbdd 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
            if (residual > 10) {
   11dca:	2d0a      	cmp	r5, #10
   11dcc:	dd74      	ble.n	11eb8 <Tuner::DrawTuner()+0x1d0>
                    gfxPrint(48 + (i * 2), 38, "<");
   11dce:	f8df 813c 	ldr.w	r8, [pc, #316]	; 11f0c <Tuner::DrawTuner()+0x224>
                uint8_t n = residual / 100;
   11dd2:	2464      	movs	r4, #100	; 0x64
   11dd4:	fb95 f4f4 	sdiv	r4, r5, r4
   11dd8:	2500      	movs	r5, #0
   11dda:	b2e4      	uxtb	r4, r4
                    gfxPrint(48 + (i * 2), 38, "<");
   11ddc:	f105 0118 	add.w	r1, r5, #24
   11de0:	b2c9      	uxtb	r1, r1
   11de2:	2226      	movs	r2, #38	; 0x26
   11de4:	4643      	mov	r3, r8
   11de6:	0049      	lsls	r1, r1, #1
   11de8:	4630      	mov	r0, r6
                for (uint8_t i = 0; i < (n + 1); i++)
   11dea:	3501      	adds	r5, #1
                    gfxPrint(48 + (i * 2), 38, "<");
   11dec:	f7f6 fb7c 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
                for (uint8_t i = 0; i < (n + 1); i++)
   11df0:	b2ea      	uxtb	r2, r5
   11df2:	4294      	cmp	r4, r2
   11df4:	d2f2      	bcs.n	11ddc <Tuner::DrawTuner()+0xf4>
            const int f = int(floor(frequency_ * 100));
   11df6:	4946      	ldr	r1, [pc, #280]	; (11f10 <Tuner::DrawTuner()+0x228>)
   11df8:	4638      	mov	r0, r7
   11dfa:	f00b f9b1 	bl	1d160 <__aeabi_fmul>
  { return __builtin_floorf(__x); }
   11dfe:	f009 fee3 	bl	1bbc8 <floorf>
   11e02:	f00b fb89 	bl	1d518 <__aeabi_f2iz>
            const int value = f / 100;
   11e06:	2364      	movs	r3, #100	; 0x64
   11e08:	fb90 f5f3 	sdiv	r5, r0, r3
            const int cents = f % 100;
   11e0c:	fb03 0415 	mls	r4, r3, r5, r0
            gfxPrint(6 + pad(10000, value), 54, value);
   11e10:	4629      	mov	r1, r5
   11e12:	f242 7010 	movw	r0, #10000	; 0x2710
   11e16:	f7f2 fc34 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   11e1a:	462b      	mov	r3, r5
   11e1c:	1d81      	adds	r1, r0, #6
   11e1e:	2236      	movs	r2, #54	; 0x36
   11e20:	69b0      	ldr	r0, [r6, #24]
   11e22:	f7f2 fe25 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        graphics.print(str);
   11e26:	493b      	ldr	r1, [pc, #236]	; (11f14 <Tuner::DrawTuner()+0x22c>)
   11e28:	4837      	ldr	r0, [pc, #220]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11e2a:	f007 fe54 	bl	19ad6 <weegfx::Graphics::print(char const*)>
            if (cents < 10) gfxPrint("0");
   11e2e:	2c09      	cmp	r4, #9
   11e30:	dc03      	bgt.n	11e3a <Tuner::DrawTuner()+0x152>
   11e32:	4939      	ldr	r1, [pc, #228]	; (11f18 <Tuner::DrawTuner()+0x230>)
   11e34:	4834      	ldr	r0, [pc, #208]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11e36:	f007 fe4e 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
   11e3a:	4833      	ldr	r0, [pc, #204]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11e3c:	4621      	mov	r1, r4
   11e3e:	f007 febe 	bl	19bbe <weegfx::Graphics::print(int)>
        gfxPrint(1, 15, "A4= ");
   11e42:	4b36      	ldr	r3, [pc, #216]	; (11f1c <Tuner::DrawTuner()+0x234>)
   11e44:	220f      	movs	r2, #15
   11e46:	4630      	mov	r0, r6
   11e48:	2101      	movs	r1, #1
   11e4a:	f7f6 fb4d 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
   11e4e:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
   11e52:	482d      	ldr	r0, [pc, #180]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11e54:	f007 feb3 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
   11e58:	4931      	ldr	r1, [pc, #196]	; (11f20 <Tuner::DrawTuner()+0x238>)
   11e5a:	482b      	ldr	r0, [pc, #172]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11e5c:	f007 fe3b 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxCursor(25, 23, 36);
   11e60:	2324      	movs	r3, #36	; 0x24
   11e62:	2217      	movs	r2, #23
   11e64:	2119      	movs	r1, #25
   11e66:	4630      	mov	r0, r6
   11e68:	f7f6 fb32 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   11e6c:	b003      	add	sp, #12
   11e6e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        int32_t deviation = round(12000.0 * log2f(frequency_ / c0_freq_)) + 500;
   11e72:	4620      	mov	r0, r4
   11e74:	f00b f86a 	bl	1cf4c <__aeabi_fsub>
   11e78:	e75a      	b.n	11d30 <Tuner::DrawTuner()+0x48>
        note = constrain(note, 0, 12);
   11e7a:	f04f 0900 	mov.w	r9, #0
   11e7e:	e775      	b.n	11d6c <Tuner::DrawTuner()+0x84>
                if (residual >= 0) {
   11e80:	2d00      	cmp	r5, #0
                    gfxPrint(residual / 10);
   11e82:	f04f 040a 	mov.w	r4, #10
   11e86:	fb95 f4f4 	sdiv	r4, r5, r4
                if (residual >= 0) {
   11e8a:	db0e      	blt.n	11eaa <Tuner::DrawTuner()+0x1c2>
                    gfxPrint(22, 38, "+");
   11e8c:	2116      	movs	r1, #22
   11e8e:	4630      	mov	r0, r6
   11e90:	4b24      	ldr	r3, [pc, #144]	; (11f24 <Tuner::DrawTuner()+0x23c>)
   11e92:	2226      	movs	r2, #38	; 0x26
   11e94:	f7f6 fb28 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        graphics.print(num);
   11e98:	481b      	ldr	r0, [pc, #108]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11e9a:	4621      	mov	r1, r4
   11e9c:	f007 fe8f 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
   11ea0:	4921      	ldr	r1, [pc, #132]	; (11f28 <Tuner::DrawTuner()+0x240>)
   11ea2:	4819      	ldr	r0, [pc, #100]	; (11f08 <Tuner::DrawTuner()+0x220>)
   11ea4:	f007 fe17 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    }
   11ea8:	e78f      	b.n	11dca <Tuner::DrawTuner()+0xe2>
                    gfxPrint(22, 38, residual / 10);
   11eaa:	69b0      	ldr	r0, [r6, #24]
   11eac:	4623      	mov	r3, r4
   11eae:	2226      	movs	r2, #38	; 0x26
   11eb0:	2116      	movs	r1, #22
   11eb2:	f7f2 fddd 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
   11eb6:	e7f3      	b.n	11ea0 <Tuner::DrawTuner()+0x1b8>
            } else if (residual < -10) {
   11eb8:	f115 0f0a 	cmn.w	r5, #10
   11ebc:	da9b      	bge.n	11df6 <Tuner::DrawTuner()+0x10e>
                    gfxPrint(10 - (i * 2), 38, ">");
   11ebe:	f8df 806c 	ldr.w	r8, [pc, #108]	; 11f2c <Tuner::DrawTuner()+0x244>
                uint8_t n = -(residual / 100);
   11ec2:	f06f 0363 	mvn.w	r3, #99	; 0x63
   11ec6:	2400      	movs	r4, #0
   11ec8:	fb95 f5f3 	sdiv	r5, r5, r3
                    gfxPrint(10 - (i * 2), 38, ">");
   11ecc:	f06f 0901 	mvn.w	r9, #1
                uint8_t n = -(residual / 100);
   11ed0:	b2ed      	uxtb	r5, r5
                    gfxPrint(10 - (i * 2), 38, ">");
   11ed2:	fb09 f104 	mul.w	r1, r9, r4
   11ed6:	2226      	movs	r2, #38	; 0x26
   11ed8:	4643      	mov	r3, r8
   11eda:	310a      	adds	r1, #10
   11edc:	4630      	mov	r0, r6
                for (uint8_t i = 0; i < (n + 1); i++)
   11ede:	3401      	adds	r4, #1
                    gfxPrint(10 - (i * 2), 38, ">");
   11ee0:	f7f6 fb02 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
                for (uint8_t i = 0; i < (n + 1); i++)
   11ee4:	b2e2      	uxtb	r2, r4
   11ee6:	4295      	cmp	r5, r2
   11ee8:	d2f3      	bcs.n	11ed2 <Tuner::DrawTuner()+0x1ea>
   11eea:	e784      	b.n	11df6 <Tuner::DrawTuner()+0x10e>
   11eec:	f3af 8000 	nop.w
   11ef0:	00000000 	.word	0x00000000
   11ef4:	3fa306fe 	.word	0x3fa306fe
   11ef8:	463b8000 	.word	0x463b8000
   11efc:	ffffd120 	.word	0xffffd120
   11f00:	0001f344 	.word	0x0001f344
   11f04:	000211c7 	.word	0x000211c7
   11f08:	200065e0 	.word	0x200065e0
   11f0c:	000212f2 	.word	0x000212f2
   11f10:	42c80000 	.word	0x42c80000
   11f14:	00020f2c 	.word	0x00020f2c
   11f18:	00020525 	.word	0x00020525
   11f1c:	000212f4 	.word	0x000212f4
   11f20:	000212f9 	.word	0x000212f9
   11f24:	0001e41c 	.word	0x0001e41c
   11f28:	0001f217 	.word	0x0001f217
   11f2c:	00020fec 	.word	0x00020fec

00011f30 <Tuner::View()>:
        gfxHeader(applet_name());
   11f30:	6803      	ldr	r3, [r0, #0]
    void View() {
   11f32:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   11f34:	681b      	ldr	r3, [r3, #0]
    void View() {
   11f36:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   11f38:	4798      	blx	r3
   11f3a:	4601      	mov	r1, r0
   11f3c:	4620      	mov	r0, r4
   11f3e:	f7f6 fb5e 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        if (hemisphere == 0) DrawTuner();
   11f42:	7923      	ldrb	r3, [r4, #4]
   11f44:	b91b      	cbnz	r3, 11f4e <Tuner::View()+0x1e>
   11f46:	4620      	mov	r0, r4
   11f48:	f7ff fece 	bl	11ce8 <Tuner::DrawTuner()>
    }
   11f4c:	bd10      	pop	{r4, pc}
        gfxPrint(1, 15, "Tuner goes");
   11f4e:	4620      	mov	r0, r4
   11f50:	4b0b      	ldr	r3, [pc, #44]	; (11f80 <Tuner::View()+0x50>)
   11f52:	220f      	movs	r2, #15
   11f54:	2101      	movs	r1, #1
   11f56:	f7f6 fac7 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(1, 25, "in left");
   11f5a:	4620      	mov	r0, r4
   11f5c:	4b09      	ldr	r3, [pc, #36]	; (11f84 <Tuner::View()+0x54>)
   11f5e:	2219      	movs	r2, #25
   11f60:	2101      	movs	r1, #1
   11f62:	f7f6 fac1 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(1, 35, "hemisphere");
   11f66:	4620      	mov	r0, r4
   11f68:	4b07      	ldr	r3, [pc, #28]	; (11f88 <Tuner::View()+0x58>)
   11f6a:	2223      	movs	r2, #35	; 0x23
   11f6c:	2101      	movs	r1, #1
   11f6e:	f7f6 fabb 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(1, 45, "<--");
   11f72:	4b06      	ldr	r3, [pc, #24]	; (11f8c <Tuner::View()+0x5c>)
   11f74:	222d      	movs	r2, #45	; 0x2d
   11f76:	2101      	movs	r1, #1
   11f78:	4620      	mov	r0, r4
   11f7a:	f7f6 fab5 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
    }
   11f7e:	e7e5      	b.n	11f4c <Tuner::View()+0x1c>
   11f80:	000212fd 	.word	0x000212fd
   11f84:	00021308 	.word	0x00021308
   11f88:	00020eb8 	.word	0x00020eb8
   11f8c:	00021310 	.word	0x00021310

00011f90 <VectorEG::DrawWaveform(unsigned char)>:
    byte TotalTime() {return total_time;}
   11f90:	2348      	movs	r3, #72	; 0x48
    void DrawWaveform(byte ch) {
   11f92:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11f96:	fb03 0701 	mla	r7, r3, r1, r0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   11f9a:	f107 0470 	add.w	r4, r7, #112	; 0x70
   11f9e:	f897 1088 	ldrb.w	r1, [r7, #136]	; 0x88
   11fa2:	f8d7 908c 	ldr.w	r9, [r7, #140]	; 0x8c
   11fa6:	3901      	subs	r1, #1
    void DrawWaveform(byte ch) {
   11fa8:	b087      	sub	sp, #28
   11faa:	4605      	mov	r5, r0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   11fac:	b2c9      	uxtb	r1, r1
   11fae:	4620      	mov	r0, r4
   11fb0:	f7fb fa24 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
        byte prev_y = 63 - Proportion(seg.level, 255, 38);
   11fb4:	b2c2      	uxtb	r2, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   11fb6:	23ff      	movs	r3, #255	; 0xff
   11fb8:	0392      	lsls	r2, r2, #14
   11fba:	fbb2 f2f3 	udiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
   11fbe:	2326      	movs	r3, #38	; 0x26
   11fc0:	435a      	muls	r2, r3
   11fc2:	1392      	asrs	r2, r2, #14
   11fc4:	f1c2 023f 	rsb	r2, r2, #63	; 0x3f
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   11fc8:	2600      	movs	r6, #0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   11fca:	f8ad 0014 	strh.w	r0, [sp, #20]
        byte prev_y = 63 - Proportion(seg.level, 255, 38);
   11fce:	b2d2      	uxtb	r2, r2
        byte prev_x = 0; // Starting coordinates
   11fd0:	46b0      	mov	r8, r6
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   11fd2:	fa5f f989 	uxtb.w	r9, r9
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   11fd6:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
   11fda:	b2f1      	uxtb	r1, r6
   11fdc:	428b      	cmp	r3, r1
   11fde:	d80b      	bhi.n	11ff8 <VectorEG::DrawWaveform(unsigned char)+0x68>
        gfxDottedLine(0, 44, 63, 44, 8);
   11fe0:	222c      	movs	r2, #44	; 0x2c
   11fe2:	2308      	movs	r3, #8
   11fe4:	9301      	str	r3, [sp, #4]
   11fe6:	69a8      	ldr	r0, [r5, #24]
   11fe8:	9200      	str	r2, [sp, #0]
   11fea:	233f      	movs	r3, #63	; 0x3f
   11fec:	2100      	movs	r1, #0
   11fee:	f7f2 fce5 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
    }
   11ff2:	b007      	add	sp, #28
   11ff4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            seg = osc[ch].GetSegment(i);
   11ff8:	4620      	mov	r0, r4
   11ffa:	9203      	str	r2, [sp, #12]
   11ffc:	f7fb f9fe 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
            byte y = 63 - Proportion(seg.level, 255, 38);
   12000:	b2c1      	uxtb	r1, r0
        int scaled = simfloat2int(proportion * max_value);
   12002:	223e      	movs	r2, #62	; 0x3e
            seg = osc[ch].GetSegment(i);
   12004:	f8ad 0014 	strh.w	r0, [sp, #20]
            byte seg_x = Proportion(seg.time, total_time, 62);
   12008:	f3c0 2307 	ubfx	r3, r0, #8, #8
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1200c:	0389      	lsls	r1, r1, #14
   1200e:	20ff      	movs	r0, #255	; 0xff
   12010:	fbb1 f1f0 	udiv	r1, r1, r0
        int scaled = simfloat2int(proportion * max_value);
   12014:	2026      	movs	r0, #38	; 0x26
   12016:	4341      	muls	r1, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12018:	039b      	lsls	r3, r3, #14
   1201a:	fbb3 f3f9 	udiv	r3, r3, r9
        int scaled = simfloat2int(proportion * max_value);
   1201e:	4353      	muls	r3, r2
            byte x = prev_x + seg_x;
   12020:	eb08 33a3 	add.w	r3, r8, r3, asr #14
   12024:	1389      	asrs	r1, r1, #14
            x = constrain(x, 0, 62);
   12026:	b2db      	uxtb	r3, r3
            byte y = 63 - Proportion(seg.level, 255, 38);
   12028:	f1c1 013f 	rsb	r1, r1, #63	; 0x3f
            y = constrain(y, 25, 62);
   1202c:	b2c9      	uxtb	r1, r1
            x = constrain(x, 0, 62);
   1202e:	4293      	cmp	r3, r2
   12030:	bfa8      	it	ge
   12032:	4613      	movge	r3, r2
            y = constrain(y, 25, 62);
   12034:	4291      	cmp	r1, r2
   12036:	bfa8      	it	ge
   12038:	4611      	movge	r1, r2
            x = constrain(x, 0, 62);
   1203a:	fa5f fa83 	uxtb.w	sl, r3
            gfxLine(prev_x, prev_y, x, y);
   1203e:	9a03      	ldr	r2, [sp, #12]
   12040:	9100      	str	r1, [sp, #0]
            y = constrain(y, 25, 62);
   12042:	fa5f fb81 	uxtb.w	fp, r1
            gfxLine(prev_x, prev_y, x, y);
   12046:	69a8      	ldr	r0, [r5, #24]
   12048:	4641      	mov	r1, r8
   1204a:	f7f2 fcd1 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   1204e:	3601      	adds	r6, #1
            prev_y = y;
   12050:	465a      	mov	r2, fp
            prev_x = x;
   12052:	46d0      	mov	r8, sl
   12054:	e7bf      	b.n	11fd6 <VectorEG::DrawWaveform(unsigned char)+0x46>
   12056:	Address 0x0000000000012056 is out of bounds.


00012058 <VectorEG::DrawInterface()>:
    void DrawInterface() {
   12058:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1205c:	4604      	mov	r4, r0
        byte c = cursor;
   1205e:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
        graphics.setPrintPos(x + gfx_offset, y);
   12060:	69a3      	ldr	r3, [r4, #24]
   12062:	4832      	ldr	r0, [pc, #200]	; (1212c <VectorEG::DrawInterface()+0xd4>)
   12064:	3301      	adds	r3, #1
   12066:	6043      	str	r3, [r0, #4]
  text_y_ = y;
   12068:	230f      	movs	r3, #15
        byte ch = cursor < 2 ? 0 : 1;
   1206a:	2e01      	cmp	r6, #1
        byte c = cursor;
   1206c:	b2f5      	uxtb	r5, r6
   1206e:	6083      	str	r3, [r0, #8]
        if (hemisphere == 0) gfxPrint(ch ? "B" : "A");
   12070:	7923      	ldrb	r3, [r4, #4]
        if (ch) c -= 2;
   12072:	bfc5      	ittet	gt
   12074:	3d02      	subgt	r5, #2
        byte ch = cursor < 2 ? 0 : 1;
   12076:	2701      	movgt	r7, #1
   12078:	2700      	movle	r7, #0
        if (ch) c -= 2;
   1207a:	b2ed      	uxtbgt	r5, r5
        if (hemisphere == 0) gfxPrint(ch ? "B" : "A");
   1207c:	2b00      	cmp	r3, #0
   1207e:	d144      	bne.n	1210a <VectorEG::DrawInterface()+0xb2>
        graphics.print(str);
   12080:	492b      	ldr	r1, [pc, #172]	; (12130 <VectorEG::DrawInterface()+0xd8>)
   12082:	4b2c      	ldr	r3, [pc, #176]	; (12134 <VectorEG::DrawInterface()+0xdc>)
   12084:	2e01      	cmp	r6, #1
   12086:	bfc8      	it	gt
   12088:	4619      	movgt	r1, r3
   1208a:	f007 fd24 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxInvert(1, 14, 7, 9);
   1208e:	2309      	movs	r3, #9
   12090:	9300      	str	r3, [sp, #0]
   12092:	220e      	movs	r2, #14
   12094:	2307      	movs	r3, #7
   12096:	2101      	movs	r1, #1
   12098:	4620      	mov	r0, r4
   1209a:	f7f6 fa73 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
        gfxPrint(10, 15, ones(freq[ch]));
   1209e:	2e01      	cmp	r6, #1
   120a0:	bfcc      	ite	gt
   120a2:	2604      	movgt	r6, #4
   120a4:	2600      	movle	r6, #0
   120a6:	4426      	add	r6, r4
    int ones(int n) {return (n / 100);}
   120a8:	f04f 0864 	mov.w	r8, #100	; 0x64
   120ac:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
        gfxPrint(10, 15, ones(freq[ch]));
   120b0:	69a0      	ldr	r0, [r4, #24]
   120b2:	fb93 f3f8 	sdiv	r3, r3, r8
   120b6:	220f      	movs	r2, #15
   120b8:	210a      	movs	r1, #10
   120ba:	f7f2 fcd9 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
   120be:	491e      	ldr	r1, [pc, #120]	; (12138 <VectorEG::DrawInterface()+0xe0>)
   120c0:	481a      	ldr	r0, [pc, #104]	; (1212c <VectorEG::DrawInterface()+0xd4>)
   120c2:	f007 fd08 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    int hundredths(int n) {return (n % 100);}
   120c6:	f8d6 610c 	ldr.w	r6, [r6, #268]	; 0x10c
   120ca:	fb96 f3f8 	sdiv	r3, r6, r8
   120ce:	fb08 6613 	mls	r6, r8, r3, r6
        if (h < 10) gfxPrint("0");
   120d2:	2e09      	cmp	r6, #9
   120d4:	dc03      	bgt.n	120de <VectorEG::DrawInterface()+0x86>
   120d6:	4919      	ldr	r1, [pc, #100]	; (1213c <VectorEG::DrawInterface()+0xe4>)
   120d8:	4814      	ldr	r0, [pc, #80]	; (1212c <VectorEG::DrawInterface()+0xd4>)
   120da:	f007 fcfc 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
   120de:	4813      	ldr	r0, [pc, #76]	; (1212c <VectorEG::DrawInterface()+0xd4>)
   120e0:	4631      	mov	r1, r6
   120e2:	f007 fd6c 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
   120e6:	4916      	ldr	r1, [pc, #88]	; (12140 <VectorEG::DrawInterface()+0xe8>)
   120e8:	4810      	ldr	r0, [pc, #64]	; (1212c <VectorEG::DrawInterface()+0xd4>)
   120ea:	f007 fcf4 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        DrawWaveform(ch);
   120ee:	4639      	mov	r1, r7
   120f0:	4620      	mov	r0, r4
   120f2:	f7ff ff4d 	bl	11f90 <VectorEG::DrawWaveform(unsigned char)>
        if (c == 0) gfxCursor(8, 23, 55);
   120f6:	b95d      	cbnz	r5, 12110 <VectorEG::DrawInterface()+0xb8>
   120f8:	2337      	movs	r3, #55	; 0x37
   120fa:	2217      	movs	r2, #23
   120fc:	2108      	movs	r1, #8
   120fe:	4620      	mov	r0, r4
   12100:	f7f6 f9e6 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   12104:	b002      	add	sp, #8
   12106:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1210a:	490e      	ldr	r1, [pc, #56]	; (12144 <VectorEG::DrawInterface()+0xec>)
   1210c:	4b0e      	ldr	r3, [pc, #56]	; (12148 <VectorEG::DrawInterface()+0xf0>)
   1210e:	e7b9      	b.n	12084 <VectorEG::DrawInterface()+0x2c>
        if (c == 1 && CursorBlink()) gfxFrame(0, 24, 63, 40);
   12110:	2d01      	cmp	r5, #1
   12112:	d1f7      	bne.n	12104 <VectorEG::DrawInterface()+0xac>
   12114:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   12116:	2b00      	cmp	r3, #0
   12118:	ddf4      	ble.n	12104 <VectorEG::DrawInterface()+0xac>
   1211a:	2328      	movs	r3, #40	; 0x28
   1211c:	9300      	str	r3, [sp, #0]
   1211e:	69a0      	ldr	r0, [r4, #24]
   12120:	233f      	movs	r3, #63	; 0x3f
   12122:	2218      	movs	r2, #24
   12124:	2100      	movs	r1, #0
   12126:	f7f2 fc71 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    }
   1212a:	e7eb      	b.n	12104 <VectorEG::DrawInterface()+0xac>
   1212c:	200065e0 	.word	0x200065e0
   12130:	00021283 	.word	0x00021283
   12134:	00021b62 	.word	0x00021b62
   12138:	00020f2c 	.word	0x00020f2c
   1213c:	00020525 	.word	0x00020525
   12140:	000212f9 	.word	0x000212f9
   12144:	0002127f 	.word	0x0002127f
   12148:	00021b74 	.word	0x00021b74

0001214c <VectorEG::View()>:
        gfxHeader(applet_name());
   1214c:	6803      	ldr	r3, [r0, #0]
    void View() {
   1214e:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   12150:	681b      	ldr	r3, [r3, #0]
    void View() {
   12152:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   12154:	4798      	blx	r3
   12156:	4601      	mov	r1, r0
   12158:	4620      	mov	r0, r4
   1215a:	f7f6 fa50 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   1215e:	4620      	mov	r0, r4
   12160:	f7ff ff7a 	bl	12058 <VectorEG::DrawInterface()>
    }
   12164:	bd10      	pop	{r4, pc}

00012166 <VectorEG::SwitchWaveform(unsigned char, int)>:
    void SwitchWaveform(byte ch, int waveform) {
   12166:	b5f0      	push	{r4, r5, r6, r7, lr}
   12168:	b093      	sub	sp, #76	; 0x4c
   1216a:	4604      	mov	r4, r0
   1216c:	460d      	mov	r5, r1
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   1216e:	4668      	mov	r0, sp
   12170:	b2d1      	uxtb	r1, r2
   12172:	2748      	movs	r7, #72	; 0x48
    void SwitchWaveform(byte ch, int waveform) {
   12174:	4616      	mov	r6, r2
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   12176:	f7fb fcbf 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
   1217a:	fb07 4305 	mla	r3, r7, r5, r4
   1217e:	3370      	adds	r3, #112	; 0x70
   12180:	4669      	mov	r1, sp
   12182:	4618      	mov	r0, r3
   12184:	2246      	movs	r2, #70	; 0x46
   12186:	f007 ff33 	bl	19ff0 <memcpy>
        waveform_number[ch] = waveform;
   1218a:	eb04 0285 	add.w	r2, r4, r5, lsl #2
        osc[ch].SetFrequency(freq[ch]);
   1218e:	f8d2 110c 	ldr.w	r1, [r2, #268]	; 0x10c
        waveform_number[ch] = waveform;
   12192:	f8c2 6104 	str.w	r6, [r2, #260]	; 0x104
        osc[ch].SetFrequency(freq[ch]);
   12196:	f7fb fa37 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
    void SetScale(uint16_t scale_) {scale = scale_;}
   1219a:	fb07 4105 	mla	r1, r7, r5, r4
   1219e:	f44f 6370 	mov.w	r3, #3840	; 0xf00
   121a2:	f8a1 30a4 	strh.w	r3, [r1, #164]	; 0xa4
    void Offset(int32_t offset_) {offset = offset_;}
   121a6:	f8c1 30b0 	str.w	r3, [r1, #176]	; 0xb0
    void Sustain(bool sustain_ = 1) {sustain = sustain_;}
   121aa:	2301      	movs	r3, #1
   121ac:	f881 30b4 	strb.w	r3, [r1, #180]	; 0xb4
    void Cycle(bool cycle_ = 1) {cycle = cycle_;}
   121b0:	2300      	movs	r3, #0
   121b2:	f881 30ac 	strb.w	r3, [r1, #172]	; 0xac
    }
   121b6:	b013      	add	sp, #76	; 0x4c
   121b8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000121ba <VectorEG::Start()>:
    void Start() {
   121ba:	b570      	push	{r4, r5, r6, lr}
   121bc:	4604      	mov	r4, r0
            freq[ch] = 50;
   121be:	2632      	movs	r6, #50	; 0x32
            gated[ch] = 0;
   121c0:	2500      	movs	r5, #0
            freq[ch] = 50;
   121c2:	f8c0 610c 	str.w	r6, [r0, #268]	; 0x10c
            SwitchWaveform(ch, HS::EG1 + ch);
   121c6:	2230      	movs	r2, #48	; 0x30
   121c8:	2100      	movs	r1, #0
   121ca:	f7ff ffcc 	bl	12166 <VectorEG::SwitchWaveform(unsigned char, int)>
            Out(ch, 0);
   121ce:	462b      	mov	r3, r5
   121d0:	462a      	mov	r2, r5
   121d2:	4629      	mov	r1, r5
   121d4:	4620      	mov	r0, r4
            gated[ch] = 0;
   121d6:	f884 5100 	strb.w	r5, [r4, #256]	; 0x100
            Out(ch, 0);
   121da:	f7f6 fe7c 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            SwitchWaveform(ch, HS::EG1 + ch);
   121de:	4620      	mov	r0, r4
            freq[ch] = 50;
   121e0:	f8c4 6110 	str.w	r6, [r4, #272]	; 0x110
            SwitchWaveform(ch, HS::EG1 + ch);
   121e4:	2231      	movs	r2, #49	; 0x31
   121e6:	2101      	movs	r1, #1
   121e8:	f7ff ffbd 	bl	12166 <VectorEG::SwitchWaveform(unsigned char, int)>
            gated[ch] = 0;
   121ec:	f884 5101 	strb.w	r5, [r4, #257]	; 0x101
            Out(ch, 0);
   121f0:	462b      	mov	r3, r5
   121f2:	462a      	mov	r2, r5
   121f4:	2101      	movs	r1, #1
   121f6:	4620      	mov	r0, r4
   121f8:	f7f6 fe6d 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   121fc:	bd70      	pop	{r4, r5, r6, pc}
   121fe:	Address 0x00000000000121fe is out of bounds.


00012200 <VectorEG_OnEncoderMove(bool, int)>:
void VectorEG_OnEncoderMove(bool hemisphere, int direction) {VectorEG_instance[hemisphere].OnEncoderMove(direction);}
   12200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        byte c = cursor;
   12202:	4f23      	ldr	r7, [pc, #140]	; (12290 <VectorEG_OnEncoderMove(bool, int)+0x90>)
   12204:	f44f 768a 	mov.w	r6, #276	; 0x114
   12208:	4346      	muls	r6, r0
   1220a:	19bb      	adds	r3, r7, r6
   1220c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
        byte ch = cursor < 2 ? 0 : 1;
   1220e:	2a01      	cmp	r2, #1
        byte c = cursor;
   12210:	b2d3      	uxtb	r3, r2
        if (ch) c -= 2;
   12212:	bfc3      	ittte	gt
   12214:	3b02      	subgt	r3, #2
   12216:	b2db      	uxtbgt	r3, r3
        byte ch = cursor < 2 ? 0 : 1;
   12218:	2401      	movgt	r4, #1
   1221a:	2400      	movle	r4, #0
        if (c == 1) { // Waveform
   1221c:	2b01      	cmp	r3, #1
   1221e:	d10f      	bne.n	12240 <VectorEG_OnEncoderMove(bool, int)+0x40>
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   12220:	2545      	movs	r5, #69	; 0x45
   12222:	fb05 4500 	mla	r5, r5, r0, r4
   12226:	3540      	adds	r5, #64	; 0x40
   12228:	eb07 0585 	add.w	r5, r7, r5, lsl #2
   1222c:	7928      	ldrb	r0, [r5, #4]
   1222e:	f7fb fc29 	bl	da84 <WaveformManager::GetNextWaveform(unsigned char, int)>
            SwitchWaveform(ch, waveform_number[ch]);
   12232:	4621      	mov	r1, r4
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   12234:	4602      	mov	r2, r0
   12236:	6068      	str	r0, [r5, #4]
            SwitchWaveform(ch, waveform_number[ch]);
   12238:	19b8      	adds	r0, r7, r6
   1223a:	f7ff ff94 	bl	12166 <VectorEG::SwitchWaveform(unsigned char, int)>
void VectorEG_OnEncoderMove(bool hemisphere, int direction) {VectorEG_instance[hemisphere].OnEncoderMove(direction);}
   1223e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (c == 0) { // Frequency
   12240:	2b00      	cmp	r3, #0
   12242:	d1fc      	bne.n	1223e <VectorEG_OnEncoderMove(bool, int)+0x3e>
            if (freq[ch] > 50) direction *= 10;
   12244:	2345      	movs	r3, #69	; 0x45
   12246:	fb03 4300 	mla	r3, r3, r0, r4
   1224a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
            osc[ch].SetFrequency(freq[ch]);
   1224e:	3670      	adds	r6, #112	; 0x70
            if (freq[ch] > 50) direction *= 10;
   12250:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   12254:	2b32      	cmp	r3, #50	; 0x32
   12256:	bfc4      	itt	gt
   12258:	250a      	movgt	r5, #10
   1225a:	4369      	mulgt	r1, r5
            freq[ch] = constrain(freq[ch] + direction, 10, 500);
   1225c:	4419      	add	r1, r3
   1225e:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
   12262:	bfa8      	it	ge
   12264:	f44f 71fa 	movge.w	r1, #500	; 0x1f4
   12268:	290a      	cmp	r1, #10
   1226a:	f04f 0345 	mov.w	r3, #69	; 0x45
   1226e:	fb03 4400 	mla	r4, r3, r0, r4
   12272:	bfb8      	it	lt
   12274:	210a      	movlt	r1, #10
            osc[ch].SetFrequency(freq[ch]);
   12276:	2a01      	cmp	r2, #1
            freq[ch] = constrain(freq[ch] + direction, 10, 500);
   12278:	eb07 0484 	add.w	r4, r7, r4, lsl #2
            osc[ch].SetFrequency(freq[ch]);
   1227c:	bfcc      	ite	gt
   1227e:	2048      	movgt	r0, #72	; 0x48
   12280:	2000      	movle	r0, #0
   12282:	4430      	add	r0, r6
            freq[ch] = constrain(freq[ch] + direction, 10, 500);
   12284:	f8c4 110c 	str.w	r1, [r4, #268]	; 0x10c
            osc[ch].SetFrequency(freq[ch]);
   12288:	4438      	add	r0, r7
   1228a:	f7fb f9bd 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
void VectorEG_OnEncoderMove(bool hemisphere, int direction) {VectorEG_instance[hemisphere].OnEncoderMove(direction);}
   1228e:	e7d6      	b.n	1223e <VectorEG_OnEncoderMove(bool, int)+0x3e>
   12290:	20002ab0 	.word	0x20002ab0

00012294 <VectorEG::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   12294:	b5f0      	push	{r4, r5, r6, r7, lr}
        freq[0] = Unpack(data, PackLocation {12,10});
   12296:	230c      	movs	r3, #12
    void OnDataReceive(uint32_t data) {
   12298:	460d      	mov	r5, r1
        freq[0] = Unpack(data, PackLocation {12,10});
   1229a:	260a      	movs	r6, #10
    void OnDataReceive(uint32_t data) {
   1229c:	b089      	sub	sp, #36	; 0x24
   1229e:	4604      	mov	r4, r0
        freq[0] = Unpack(data, PackLocation {12,10});
   122a0:	4632      	mov	r2, r6
   122a2:	4619      	mov	r1, r3
   122a4:	4628      	mov	r0, r5
   122a6:	e9cd 3600 	strd	r3, r6, [sp]
   122aa:	f7f1 fdc1 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        freq[1] = Unpack(data, PackLocation {22,10});
   122ae:	2316      	movs	r3, #22
   122b0:	4619      	mov	r1, r3
        freq[0] = Unpack(data, PackLocation {12,10});
   122b2:	f8c4 010c 	str.w	r0, [r4, #268]	; 0x10c
        freq[1] = Unpack(data, PackLocation {22,10});
   122b6:	4632      	mov	r2, r6
   122b8:	4628      	mov	r0, r5
   122ba:	e9cd 3602 	strd	r3, r6, [sp, #8]
   122be:	f7f1 fdb7 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        SwitchWaveform(0, Unpack(data, PackLocation {0,6}));
   122c2:	2700      	movs	r7, #0
   122c4:	2606      	movs	r6, #6
        freq[1] = Unpack(data, PackLocation {22,10});
   122c6:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
        SwitchWaveform(0, Unpack(data, PackLocation {0,6}));
   122ca:	4632      	mov	r2, r6
   122cc:	4639      	mov	r1, r7
   122ce:	4628      	mov	r0, r5
   122d0:	e9cd 7604 	strd	r7, r6, [sp, #16]
   122d4:	f7f1 fdac 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   122d8:	4639      	mov	r1, r7
   122da:	4602      	mov	r2, r0
   122dc:	4620      	mov	r0, r4
   122de:	f7ff ff42 	bl	12166 <VectorEG::SwitchWaveform(unsigned char, int)>
        SwitchWaveform(1, Unpack(data, PackLocation {6,6}));
   122e2:	e9cd 6606 	strd	r6, r6, [sp, #24]
   122e6:	ab08      	add	r3, sp, #32
   122e8:	e913 0006 	ldmdb	r3, {r1, r2}
   122ec:	4628      	mov	r0, r5
   122ee:	f7f1 fd9f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   122f2:	2101      	movs	r1, #1
   122f4:	4602      	mov	r2, r0
   122f6:	4620      	mov	r0, r4
   122f8:	f7ff ff35 	bl	12166 <VectorEG::SwitchWaveform(unsigned char, int)>
    }
   122fc:	b009      	add	sp, #36	; 0x24
   122fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

00012300 <VectorEG_OnDataReceive(bool, unsigned long)>:
void VectorEG_OnDataReceive(bool hemisphere, uint32_t data) {VectorEG_instance[hemisphere].OnDataReceive(data);}
   12300:	b508      	push	{r3, lr}
   12302:	4b04      	ldr	r3, [pc, #16]	; (12314 <VectorEG_OnDataReceive(bool, unsigned long)+0x14>)
   12304:	f44f 728a 	mov.w	r2, #276	; 0x114
   12308:	fb02 3000 	mla	r0, r2, r0, r3
   1230c:	f7ff ffc2 	bl	12294 <VectorEG::OnDataReceive(unsigned long)>
   12310:	bd08      	pop	{r3, pc}
   12312:	bf00      	nop
   12314:	20002ab0 	.word	0x20002ab0

00012318 <VectorLFO::DrawWaveform(unsigned char)>:
    byte TotalTime() {return total_time;}
   12318:	2348      	movs	r3, #72	; 0x48
    void DrawWaveform(byte ch) {
   1231a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1231e:	fb03 0701 	mla	r7, r3, r1, r0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   12322:	f107 0470 	add.w	r4, r7, #112	; 0x70
   12326:	f897 1088 	ldrb.w	r1, [r7, #136]	; 0x88
   1232a:	f8d7 908c 	ldr.w	r9, [r7, #140]	; 0x8c
   1232e:	3901      	subs	r1, #1
    void DrawWaveform(byte ch) {
   12330:	b087      	sub	sp, #28
   12332:	4605      	mov	r5, r0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   12334:	b2c9      	uxtb	r1, r1
   12336:	4620      	mov	r0, r4
   12338:	f7fb f860 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
        byte prev_y = 63 - Proportion(seg.level, 255, 38);
   1233c:	b2c2      	uxtb	r2, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1233e:	23ff      	movs	r3, #255	; 0xff
   12340:	0392      	lsls	r2, r2, #14
   12342:	fbb2 f2f3 	udiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
   12346:	2326      	movs	r3, #38	; 0x26
   12348:	435a      	muls	r2, r3
   1234a:	1392      	asrs	r2, r2, #14
   1234c:	f1c2 023f 	rsb	r2, r2, #63	; 0x3f
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   12350:	2600      	movs	r6, #0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   12352:	f8ad 0014 	strh.w	r0, [sp, #20]
        byte prev_y = 63 - Proportion(seg.level, 255, 38);
   12356:	b2d2      	uxtb	r2, r2
        byte prev_x = 0; // Starting coordinates
   12358:	46b0      	mov	r8, r6
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1235a:	fa5f f989 	uxtb.w	r9, r9
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   1235e:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
   12362:	b2f1      	uxtb	r1, r6
   12364:	428b      	cmp	r3, r1
   12366:	d80b      	bhi.n	12380 <VectorLFO::DrawWaveform(unsigned char)+0x68>
        gfxDottedLine(0, 44, 63, 44, 8);
   12368:	222c      	movs	r2, #44	; 0x2c
   1236a:	2308      	movs	r3, #8
   1236c:	9301      	str	r3, [sp, #4]
   1236e:	69a8      	ldr	r0, [r5, #24]
   12370:	9200      	str	r2, [sp, #0]
   12372:	233f      	movs	r3, #63	; 0x3f
   12374:	2100      	movs	r1, #0
   12376:	f7f2 fb21 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
    }
   1237a:	b007      	add	sp, #28
   1237c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            seg = osc[ch].GetSegment(i);
   12380:	4620      	mov	r0, r4
   12382:	9203      	str	r2, [sp, #12]
   12384:	f7fb f83a 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
            byte y = 63 - Proportion(seg.level, 255, 38);
   12388:	b2c1      	uxtb	r1, r0
        int scaled = simfloat2int(proportion * max_value);
   1238a:	223e      	movs	r2, #62	; 0x3e
            seg = osc[ch].GetSegment(i);
   1238c:	f8ad 0014 	strh.w	r0, [sp, #20]
            byte seg_x = Proportion(seg.time, total_time, 62);
   12390:	f3c0 2307 	ubfx	r3, r0, #8, #8
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12394:	0389      	lsls	r1, r1, #14
   12396:	20ff      	movs	r0, #255	; 0xff
   12398:	fbb1 f1f0 	udiv	r1, r1, r0
        int scaled = simfloat2int(proportion * max_value);
   1239c:	2026      	movs	r0, #38	; 0x26
   1239e:	4341      	muls	r1, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   123a0:	039b      	lsls	r3, r3, #14
   123a2:	fbb3 f3f9 	udiv	r3, r3, r9
        int scaled = simfloat2int(proportion * max_value);
   123a6:	4353      	muls	r3, r2
            byte x = prev_x + seg_x;
   123a8:	eb08 33a3 	add.w	r3, r8, r3, asr #14
   123ac:	1389      	asrs	r1, r1, #14
            x = constrain(x, 0, 62);
   123ae:	b2db      	uxtb	r3, r3
            byte y = 63 - Proportion(seg.level, 255, 38);
   123b0:	f1c1 013f 	rsb	r1, r1, #63	; 0x3f
            y = constrain(y, 25, 62);
   123b4:	b2c9      	uxtb	r1, r1
            x = constrain(x, 0, 62);
   123b6:	4293      	cmp	r3, r2
   123b8:	bfa8      	it	ge
   123ba:	4613      	movge	r3, r2
            y = constrain(y, 25, 62);
   123bc:	4291      	cmp	r1, r2
   123be:	bfa8      	it	ge
   123c0:	4611      	movge	r1, r2
            x = constrain(x, 0, 62);
   123c2:	fa5f fa83 	uxtb.w	sl, r3
            gfxLine(prev_x, prev_y, x, y);
   123c6:	9a03      	ldr	r2, [sp, #12]
   123c8:	9100      	str	r1, [sp, #0]
            y = constrain(y, 25, 62);
   123ca:	fa5f fb81 	uxtb.w	fp, r1
            gfxLine(prev_x, prev_y, x, y);
   123ce:	69a8      	ldr	r0, [r5, #24]
   123d0:	4641      	mov	r1, r8
   123d2:	f7f2 fb0d 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   123d6:	3601      	adds	r6, #1
            prev_y = y;
   123d8:	465a      	mov	r2, fp
            prev_x = x;
   123da:	46d0      	mov	r8, sl
   123dc:	e7bf      	b.n	1235e <VectorLFO::DrawWaveform(unsigned char)+0x46>
   123de:	Address 0x00000000000123de is out of bounds.


000123e0 <VectorLFO::DrawInterface()>:
    void DrawInterface() {
   123e0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   123e4:	4604      	mov	r4, r0
        byte c = cursor;
   123e6:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
        graphics.setPrintPos(x + gfx_offset, y);
   123e8:	69a3      	ldr	r3, [r4, #24]
  text_x_ = x;
   123ea:	4832      	ldr	r0, [pc, #200]	; (124b4 <VectorLFO::DrawInterface()+0xd4>)
   123ec:	3301      	adds	r3, #1
   123ee:	6043      	str	r3, [r0, #4]
  text_y_ = y;
   123f0:	230f      	movs	r3, #15
        byte ch = cursor < 2 ? 0 : 1;
   123f2:	2e01      	cmp	r6, #1
        byte c = cursor;
   123f4:	b2f5      	uxtb	r5, r6
   123f6:	6083      	str	r3, [r0, #8]
        if (hemisphere == 0) gfxPrint(ch ? "B" : "A");
   123f8:	7923      	ldrb	r3, [r4, #4]
        if (ch) c -= 2;
   123fa:	bfc5      	ittet	gt
   123fc:	3d02      	subgt	r5, #2
        byte ch = cursor < 2 ? 0 : 1;
   123fe:	2701      	movgt	r7, #1
   12400:	2700      	movle	r7, #0
        if (ch) c -= 2;
   12402:	b2ed      	uxtbgt	r5, r5
        if (hemisphere == 0) gfxPrint(ch ? "B" : "A");
   12404:	2b00      	cmp	r3, #0
   12406:	d144      	bne.n	12492 <VectorLFO::DrawInterface()+0xb2>
        graphics.print(str);
   12408:	492b      	ldr	r1, [pc, #172]	; (124b8 <VectorLFO::DrawInterface()+0xd8>)
   1240a:	4b2c      	ldr	r3, [pc, #176]	; (124bc <VectorLFO::DrawInterface()+0xdc>)
   1240c:	2e01      	cmp	r6, #1
   1240e:	bfc8      	it	gt
   12410:	4619      	movgt	r1, r3
   12412:	f007 fb60 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxInvert(1, 14, 7, 9);
   12416:	2309      	movs	r3, #9
   12418:	9300      	str	r3, [sp, #0]
   1241a:	220e      	movs	r2, #14
   1241c:	2307      	movs	r3, #7
   1241e:	2101      	movs	r1, #1
   12420:	4620      	mov	r0, r4
   12422:	f7f6 f8af 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
        gfxPrint(10, 15, ones(freq[ch]));
   12426:	2e01      	cmp	r6, #1
   12428:	bfcc      	ite	gt
   1242a:	2604      	movgt	r6, #4
   1242c:	2600      	movle	r6, #0
   1242e:	4426      	add	r6, r4
    int ones(int n) {return (n / 100);}
   12430:	f04f 0864 	mov.w	r8, #100	; 0x64
   12434:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
        gfxPrint(10, 15, ones(freq[ch]));
   12438:	69a0      	ldr	r0, [r4, #24]
   1243a:	fb93 f3f8 	sdiv	r3, r3, r8
   1243e:	220f      	movs	r2, #15
   12440:	210a      	movs	r1, #10
   12442:	f7f2 fb15 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
   12446:	491e      	ldr	r1, [pc, #120]	; (124c0 <VectorLFO::DrawInterface()+0xe0>)
   12448:	481a      	ldr	r0, [pc, #104]	; (124b4 <VectorLFO::DrawInterface()+0xd4>)
   1244a:	f007 fb44 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    int hundredths(int n) {return (n % 100);}
   1244e:	f8d6 6108 	ldr.w	r6, [r6, #264]	; 0x108
   12452:	fb96 f3f8 	sdiv	r3, r6, r8
   12456:	fb08 6613 	mls	r6, r8, r3, r6
        if (h < 10) gfxPrint("0");
   1245a:	2e09      	cmp	r6, #9
   1245c:	dc03      	bgt.n	12466 <VectorLFO::DrawInterface()+0x86>
   1245e:	4919      	ldr	r1, [pc, #100]	; (124c4 <VectorLFO::DrawInterface()+0xe4>)
   12460:	4814      	ldr	r0, [pc, #80]	; (124b4 <VectorLFO::DrawInterface()+0xd4>)
   12462:	f007 fb38 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
   12466:	4813      	ldr	r0, [pc, #76]	; (124b4 <VectorLFO::DrawInterface()+0xd4>)
   12468:	4631      	mov	r1, r6
   1246a:	f007 fba8 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
   1246e:	4916      	ldr	r1, [pc, #88]	; (124c8 <VectorLFO::DrawInterface()+0xe8>)
   12470:	4810      	ldr	r0, [pc, #64]	; (124b4 <VectorLFO::DrawInterface()+0xd4>)
   12472:	f007 fb30 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        DrawWaveform(ch);
   12476:	4639      	mov	r1, r7
   12478:	4620      	mov	r0, r4
   1247a:	f7ff ff4d 	bl	12318 <VectorLFO::DrawWaveform(unsigned char)>
        if (c == 0) gfxCursor(8, 23, 55);
   1247e:	b95d      	cbnz	r5, 12498 <VectorLFO::DrawInterface()+0xb8>
   12480:	2337      	movs	r3, #55	; 0x37
   12482:	2217      	movs	r2, #23
   12484:	2108      	movs	r1, #8
   12486:	4620      	mov	r0, r4
   12488:	f7f6 f822 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   1248c:	b002      	add	sp, #8
   1248e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12492:	490e      	ldr	r1, [pc, #56]	; (124cc <VectorLFO::DrawInterface()+0xec>)
   12494:	4b0e      	ldr	r3, [pc, #56]	; (124d0 <VectorLFO::DrawInterface()+0xf0>)
   12496:	e7b9      	b.n	1240c <VectorLFO::DrawInterface()+0x2c>
        if (c == 1 && CursorBlink()) gfxFrame(0, 24, 63, 40);
   12498:	2d01      	cmp	r5, #1
   1249a:	d1f7      	bne.n	1248c <VectorLFO::DrawInterface()+0xac>
   1249c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1249e:	2b00      	cmp	r3, #0
   124a0:	ddf4      	ble.n	1248c <VectorLFO::DrawInterface()+0xac>
   124a2:	2328      	movs	r3, #40	; 0x28
   124a4:	9300      	str	r3, [sp, #0]
   124a6:	69a0      	ldr	r0, [r4, #24]
   124a8:	233f      	movs	r3, #63	; 0x3f
   124aa:	2218      	movs	r2, #24
   124ac:	2100      	movs	r1, #0
   124ae:	f7f2 faad 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    }
   124b2:	e7eb      	b.n	1248c <VectorLFO::DrawInterface()+0xac>
   124b4:	200065e0 	.word	0x200065e0
   124b8:	00021283 	.word	0x00021283
   124bc:	00021b62 	.word	0x00021b62
   124c0:	00020f2c 	.word	0x00020f2c
   124c4:	00020525 	.word	0x00020525
   124c8:	000212f9 	.word	0x000212f9
   124cc:	0002127f 	.word	0x0002127f
   124d0:	00021b74 	.word	0x00021b74

000124d4 <VectorLFO::View()>:
        gfxHeader(applet_name());
   124d4:	6803      	ldr	r3, [r0, #0]
    void View() {
   124d6:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   124d8:	681b      	ldr	r3, [r3, #0]
    void View() {
   124da:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   124dc:	4798      	blx	r3
   124de:	4601      	mov	r1, r0
   124e0:	4620      	mov	r0, r4
   124e2:	f7f6 f88c 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   124e6:	4620      	mov	r0, r4
   124e8:	f7ff ff7a 	bl	123e0 <VectorLFO::DrawInterface()>
    }
   124ec:	bd10      	pop	{r4, pc}

000124ee <VectorLFO::SwitchWaveform(unsigned char, int)>:
    void SwitchWaveform(byte ch, int waveform) {
   124ee:	b5f0      	push	{r4, r5, r6, r7, lr}
   124f0:	b093      	sub	sp, #76	; 0x4c
   124f2:	460d      	mov	r5, r1
   124f4:	4604      	mov	r4, r0
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   124f6:	b2d1      	uxtb	r1, r2
   124f8:	4668      	mov	r0, sp
   124fa:	2748      	movs	r7, #72	; 0x48
    void SwitchWaveform(byte ch, int waveform) {
   124fc:	4616      	mov	r6, r2
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   124fe:	f7fb fafb 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
   12502:	fb07 4305 	mla	r3, r7, r5, r4
   12506:	3370      	adds	r3, #112	; 0x70
   12508:	4669      	mov	r1, sp
   1250a:	4618      	mov	r0, r3
   1250c:	2246      	movs	r2, #70	; 0x46
   1250e:	f007 fd6f 	bl	19ff0 <memcpy>
        waveform_number[ch] = waveform;
   12512:	eb04 0285 	add.w	r2, r4, r5, lsl #2
    void SetScale(uint16_t scale_) {scale = scale_;}
   12516:	fb07 4405 	mla	r4, r7, r5, r4
        osc[ch].SetFrequency(freq[ch]);
   1251a:	f8d2 1108 	ldr.w	r1, [r2, #264]	; 0x108
        waveform_number[ch] = waveform;
   1251e:	f8c2 6100 	str.w	r6, [r2, #256]	; 0x100
        osc[ch].SetFrequency(freq[ch]);
   12522:	f7fb f871 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
   12526:	f44f 5390 	mov.w	r3, #4608	; 0x1200
   1252a:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
    }
   1252e:	b013      	add	sp, #76	; 0x4c
   12530:	bdf0      	pop	{r4, r5, r6, r7, pc}

00012532 <VectorLFO::Start()>:
    void Start() {
   12532:	b570      	push	{r4, r5, r6, lr}
            waveform_number[ch] = 0;
   12534:	2500      	movs	r5, #0
            freq[ch] = 200;
   12536:	26c8      	movs	r6, #200	; 0xc8
    void Start() {
   12538:	4604      	mov	r4, r0
            freq[ch] = 200;
   1253a:	f8c0 6108 	str.w	r6, [r0, #264]	; 0x108
            waveform_number[ch] = 0;
   1253e:	f8c0 5100 	str.w	r5, [r0, #256]	; 0x100
            SwitchWaveform(ch, 0);
   12542:	462a      	mov	r2, r5
   12544:	4629      	mov	r1, r5
   12546:	f7ff ffd2 	bl	124ee <VectorLFO::SwitchWaveform(unsigned char, int)>
            Out(ch, 0);
   1254a:	462b      	mov	r3, r5
   1254c:	462a      	mov	r2, r5
   1254e:	4629      	mov	r1, r5
   12550:	4620      	mov	r0, r4
   12552:	f7f6 fcc0 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            SwitchWaveform(ch, 0);
   12556:	462a      	mov	r2, r5
   12558:	4620      	mov	r0, r4
            freq[ch] = 200;
   1255a:	f8c4 610c 	str.w	r6, [r4, #268]	; 0x10c
            waveform_number[ch] = 0;
   1255e:	f8c4 5104 	str.w	r5, [r4, #260]	; 0x104
            SwitchWaveform(ch, 0);
   12562:	2101      	movs	r1, #1
   12564:	f7ff ffc3 	bl	124ee <VectorLFO::SwitchWaveform(unsigned char, int)>
            Out(ch, 0);
   12568:	462b      	mov	r3, r5
   1256a:	462a      	mov	r2, r5
   1256c:	2101      	movs	r1, #1
   1256e:	4620      	mov	r0, r4
   12570:	f7f6 fcb1 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   12574:	bd70      	pop	{r4, r5, r6, pc}
   12576:	Address 0x0000000000012576 is out of bounds.


00012578 <VectorLFO::OnEncoderMove(int)>:
        byte c = cursor;
   12578:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
        byte ch = cursor < 2 ? 0 : 1;
   1257a:	2a01      	cmp	r2, #1
        byte c = cursor;
   1257c:	b2d3      	uxtb	r3, r2
        if (ch) c -= 2;
   1257e:	bfc4      	itt	gt
   12580:	3b02      	subgt	r3, #2
   12582:	b2db      	uxtbgt	r3, r3
    void OnEncoderMove(int direction) {
   12584:	b570      	push	{r4, r5, r6, lr}
        byte ch = cursor < 2 ? 0 : 1;
   12586:	bfcc      	ite	gt
   12588:	2601      	movgt	r6, #1
   1258a:	2600      	movle	r6, #0
        if (c == 1) { // Waveform
   1258c:	2b01      	cmp	r3, #1
    void OnEncoderMove(int direction) {
   1258e:	4604      	mov	r4, r0
        if (c == 1) { // Waveform
   12590:	d118      	bne.n	125c4 <VectorLFO::OnEncoderMove(int)+0x4c>
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   12592:	2a01      	cmp	r2, #1
   12594:	bfcc      	ite	gt
   12596:	2504      	movgt	r5, #4
   12598:	2500      	movle	r5, #0
   1259a:	4405      	add	r5, r0
   1259c:	f895 0100 	ldrb.w	r0, [r5, #256]	; 0x100
   125a0:	f7fb fa70 	bl	da84 <WaveformManager::GetNextWaveform(unsigned char, int)>
            SwitchWaveform(ch, waveform_number[ch]);
   125a4:	4631      	mov	r1, r6
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   125a6:	4602      	mov	r2, r0
   125a8:	f8c5 0100 	str.w	r0, [r5, #256]	; 0x100
            SwitchWaveform(ch, waveform_number[ch]);
   125ac:	4620      	mov	r0, r4
   125ae:	f7ff ff9e 	bl	124ee <VectorLFO::SwitchWaveform(unsigned char, int)>
            ForEachChannel(ch) osc[ch].Reset();
   125b2:	f104 0070 	add.w	r0, r4, #112	; 0x70
   125b6:	f7fb f830 	bl	d61a <VectorOscillator::Reset()>
   125ba:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
   125be:	f7fb f82c 	bl	d61a <VectorOscillator::Reset()>
    }
   125c2:	bd70      	pop	{r4, r5, r6, pc}
        if (c == 0) { // Frequency
   125c4:	2b00      	cmp	r3, #0
   125c6:	d1fc      	bne.n	125c2 <VectorLFO::OnEncoderMove(int)+0x4a>
            if (freq[ch] > 100000) direction *= 10000;
   125c8:	2a01      	cmp	r2, #1
   125ca:	bfcc      	ite	gt
   125cc:	2004      	movgt	r0, #4
   125ce:	2000      	movle	r0, #0
   125d0:	4420      	add	r0, r4
   125d2:	4d15      	ldr	r5, [pc, #84]	; (12628 <VectorLFO::OnEncoderMove(int)+0xb0>)
   125d4:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
   125d8:	42ab      	cmp	r3, r5
   125da:	f242 7510 	movw	r5, #10000	; 0x2710
   125de:	dd13      	ble.n	12608 <VectorLFO::OnEncoderMove(int)+0x90>
            else if (freq[ch] > 300) direction *= 10;
   125e0:	4369      	muls	r1, r5
            freq[ch] = constrain(freq[ch] + direction, 10, 99900);
   125e2:	4419      	add	r1, r3
   125e4:	4b11      	ldr	r3, [pc, #68]	; (1262c <VectorLFO::OnEncoderMove(int)+0xb4>)
   125e6:	4299      	cmp	r1, r3
   125e8:	bfa8      	it	ge
   125ea:	4619      	movge	r1, r3
   125ec:	290a      	cmp	r1, #10
   125ee:	bfb8      	it	lt
   125f0:	210a      	movlt	r1, #10
            osc[ch].SetFrequency(freq[ch]);
   125f2:	2a01      	cmp	r2, #1
            freq[ch] = constrain(freq[ch] + direction, 10, 99900);
   125f4:	f8c0 1108 	str.w	r1, [r0, #264]	; 0x108
            osc[ch].SetFrequency(freq[ch]);
   125f8:	bfcc      	ite	gt
   125fa:	2048      	movgt	r0, #72	; 0x48
   125fc:	2000      	movle	r0, #0
   125fe:	3070      	adds	r0, #112	; 0x70
   12600:	4420      	add	r0, r4
   12602:	f7fb f801 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
    }
   12606:	e7dc      	b.n	125c2 <VectorLFO::OnEncoderMove(int)+0x4a>
            else if (freq[ch] > 10000) direction *= 1000;
   12608:	42ab      	cmp	r3, r5
   1260a:	dd02      	ble.n	12612 <VectorLFO::OnEncoderMove(int)+0x9a>
   1260c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   12610:	e7e6      	b.n	125e0 <VectorLFO::OnEncoderMove(int)+0x68>
            else if (freq[ch] > 1000) direction *= 100;
   12612:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   12616:	dd01      	ble.n	1261c <VectorLFO::OnEncoderMove(int)+0xa4>
   12618:	2564      	movs	r5, #100	; 0x64
   1261a:	e7e1      	b.n	125e0 <VectorLFO::OnEncoderMove(int)+0x68>
            else if (freq[ch] > 300) direction *= 10;
   1261c:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   12620:	dddf      	ble.n	125e2 <VectorLFO::OnEncoderMove(int)+0x6a>
   12622:	250a      	movs	r5, #10
   12624:	e7dc      	b.n	125e0 <VectorLFO::OnEncoderMove(int)+0x68>
   12626:	bf00      	nop
   12628:	000186a0 	.word	0x000186a0
   1262c:	0001863c 	.word	0x0001863c

00012630 <VectorLFO_OnEncoderMove(bool, int)>:
void VectorLFO_OnEncoderMove(bool hemisphere, int direction) {VectorLFO_instance[hemisphere].OnEncoderMove(direction);}
   12630:	b508      	push	{r3, lr}
   12632:	4b04      	ldr	r3, [pc, #16]	; (12644 <VectorLFO_OnEncoderMove(bool, int)+0x14>)
   12634:	f44f 7288 	mov.w	r2, #272	; 0x110
   12638:	fb02 3000 	mla	r0, r2, r0, r3
   1263c:	f7ff ff9c 	bl	12578 <VectorLFO::OnEncoderMove(int)>
   12640:	bd08      	pop	{r3, pc}
   12642:	bf00      	nop
   12644:	20002cd8 	.word	0x20002cd8

00012648 <VectorLFO::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   12648:	b5f0      	push	{r4, r5, r6, r7, lr}
        freq[0] = Unpack(data, PackLocation {12,10});
   1264a:	230c      	movs	r3, #12
    void OnDataReceive(uint32_t data) {
   1264c:	460d      	mov	r5, r1
        freq[0] = Unpack(data, PackLocation {12,10});
   1264e:	260a      	movs	r6, #10
    void OnDataReceive(uint32_t data) {
   12650:	b089      	sub	sp, #36	; 0x24
   12652:	4604      	mov	r4, r0
        freq[0] = Unpack(data, PackLocation {12,10});
   12654:	4632      	mov	r2, r6
   12656:	4619      	mov	r1, r3
   12658:	4628      	mov	r0, r5
   1265a:	e9cd 3600 	strd	r3, r6, [sp]
   1265e:	f7f1 fbe7 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        freq[1] = Unpack(data, PackLocation {22,10});
   12662:	2316      	movs	r3, #22
   12664:	4619      	mov	r1, r3
        freq[0] = Unpack(data, PackLocation {12,10});
   12666:	f8c4 0108 	str.w	r0, [r4, #264]	; 0x108
        freq[1] = Unpack(data, PackLocation {22,10});
   1266a:	4632      	mov	r2, r6
   1266c:	4628      	mov	r0, r5
   1266e:	e9cd 3602 	strd	r3, r6, [sp, #8]
   12672:	f7f1 fbdd 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        SwitchWaveform(0, Unpack(data, PackLocation {0,6}));
   12676:	2700      	movs	r7, #0
   12678:	2606      	movs	r6, #6
        freq[1] = Unpack(data, PackLocation {22,10});
   1267a:	f8c4 010c 	str.w	r0, [r4, #268]	; 0x10c
        SwitchWaveform(0, Unpack(data, PackLocation {0,6}));
   1267e:	4632      	mov	r2, r6
   12680:	4639      	mov	r1, r7
   12682:	4628      	mov	r0, r5
   12684:	e9cd 7604 	strd	r7, r6, [sp, #16]
   12688:	f7f1 fbd2 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   1268c:	4639      	mov	r1, r7
   1268e:	4602      	mov	r2, r0
   12690:	4620      	mov	r0, r4
   12692:	f7ff ff2c 	bl	124ee <VectorLFO::SwitchWaveform(unsigned char, int)>
        SwitchWaveform(1, Unpack(data, PackLocation {6,6}));
   12696:	e9cd 6606 	strd	r6, r6, [sp, #24]
   1269a:	ab08      	add	r3, sp, #32
   1269c:	e913 0006 	ldmdb	r3, {r1, r2}
   126a0:	4628      	mov	r0, r5
   126a2:	f7f1 fbc5 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   126a6:	2101      	movs	r1, #1
   126a8:	4602      	mov	r2, r0
   126aa:	4620      	mov	r0, r4
   126ac:	f7ff ff1f 	bl	124ee <VectorLFO::SwitchWaveform(unsigned char, int)>
    }
   126b0:	b009      	add	sp, #36	; 0x24
   126b2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000126b4 <VectorLFO_OnDataReceive(bool, unsigned long)>:
void VectorLFO_OnDataReceive(bool hemisphere, uint32_t data) {VectorLFO_instance[hemisphere].OnDataReceive(data);}
   126b4:	b508      	push	{r3, lr}
   126b6:	4b04      	ldr	r3, [pc, #16]	; (126c8 <VectorLFO_OnDataReceive(bool, unsigned long)+0x14>)
   126b8:	f44f 7288 	mov.w	r2, #272	; 0x110
   126bc:	fb02 3000 	mla	r0, r2, r0, r3
   126c0:	f7ff ffc2 	bl	12648 <VectorLFO::OnDataReceive(unsigned long)>
   126c4:	bd08      	pop	{r3, pc}
   126c6:	bf00      	nop
   126c8:	20002cd8 	.word	0x20002cd8

000126cc <VectorMod::DrawWaveform(unsigned char)>:
    byte TotalTime() {return total_time;}
   126cc:	2348      	movs	r3, #72	; 0x48
    void DrawWaveform(byte ch) {
   126ce:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   126d2:	fb03 0701 	mla	r7, r3, r1, r0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   126d6:	f107 0470 	add.w	r4, r7, #112	; 0x70
   126da:	f897 1088 	ldrb.w	r1, [r7, #136]	; 0x88
   126de:	f8d7 908c 	ldr.w	r9, [r7, #140]	; 0x8c
   126e2:	3901      	subs	r1, #1
    void DrawWaveform(byte ch) {
   126e4:	b087      	sub	sp, #28
   126e6:	4605      	mov	r5, r0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   126e8:	b2c9      	uxtb	r1, r1
   126ea:	4620      	mov	r0, r4
   126ec:	f7fa fe86 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
        byte prev_y = 63 - Proportion(seg.level, 255, 38);
   126f0:	b2c2      	uxtb	r2, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   126f2:	23ff      	movs	r3, #255	; 0xff
   126f4:	0392      	lsls	r2, r2, #14
   126f6:	fbb2 f2f3 	udiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
   126fa:	2326      	movs	r3, #38	; 0x26
   126fc:	435a      	muls	r2, r3
   126fe:	1392      	asrs	r2, r2, #14
   12700:	f1c2 023f 	rsb	r2, r2, #63	; 0x3f
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   12704:	2600      	movs	r6, #0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   12706:	f8ad 0014 	strh.w	r0, [sp, #20]
        byte prev_y = 63 - Proportion(seg.level, 255, 38);
   1270a:	b2d2      	uxtb	r2, r2
        byte prev_x = 0; // Starting coordinates
   1270c:	46b0      	mov	r8, r6
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1270e:	fa5f f989 	uxtb.w	r9, r9
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   12712:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
   12716:	b2f1      	uxtb	r1, r6
   12718:	428b      	cmp	r3, r1
   1271a:	d80b      	bhi.n	12734 <VectorMod::DrawWaveform(unsigned char)+0x68>
        gfxDottedLine(0, 44, 63, 44, 8);
   1271c:	222c      	movs	r2, #44	; 0x2c
   1271e:	2308      	movs	r3, #8
   12720:	9301      	str	r3, [sp, #4]
   12722:	69a8      	ldr	r0, [r5, #24]
   12724:	9200      	str	r2, [sp, #0]
   12726:	233f      	movs	r3, #63	; 0x3f
   12728:	2100      	movs	r1, #0
   1272a:	f7f2 f947 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
    }
   1272e:	b007      	add	sp, #28
   12730:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            seg = osc[ch].GetSegment(i);
   12734:	4620      	mov	r0, r4
   12736:	9203      	str	r2, [sp, #12]
   12738:	f7fa fe60 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
            byte y = 63 - Proportion(seg.level, 255, 38);
   1273c:	b2c1      	uxtb	r1, r0
        int scaled = simfloat2int(proportion * max_value);
   1273e:	223e      	movs	r2, #62	; 0x3e
            seg = osc[ch].GetSegment(i);
   12740:	f8ad 0014 	strh.w	r0, [sp, #20]
            byte seg_x = Proportion(seg.time, total_time, 62);
   12744:	f3c0 2307 	ubfx	r3, r0, #8, #8
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12748:	0389      	lsls	r1, r1, #14
   1274a:	20ff      	movs	r0, #255	; 0xff
   1274c:	fbb1 f1f0 	udiv	r1, r1, r0
        int scaled = simfloat2int(proportion * max_value);
   12750:	2026      	movs	r0, #38	; 0x26
   12752:	4341      	muls	r1, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12754:	039b      	lsls	r3, r3, #14
   12756:	fbb3 f3f9 	udiv	r3, r3, r9
        int scaled = simfloat2int(proportion * max_value);
   1275a:	4353      	muls	r3, r2
            byte x = prev_x + seg_x;
   1275c:	eb08 33a3 	add.w	r3, r8, r3, asr #14
   12760:	1389      	asrs	r1, r1, #14
            x = constrain(x, 0, 62);
   12762:	b2db      	uxtb	r3, r3
            byte y = 63 - Proportion(seg.level, 255, 38);
   12764:	f1c1 013f 	rsb	r1, r1, #63	; 0x3f
            y = constrain(y, 25, 62);
   12768:	b2c9      	uxtb	r1, r1
            x = constrain(x, 0, 62);
   1276a:	4293      	cmp	r3, r2
   1276c:	bfa8      	it	ge
   1276e:	4613      	movge	r3, r2
            y = constrain(y, 25, 62);
   12770:	4291      	cmp	r1, r2
   12772:	bfa8      	it	ge
   12774:	4611      	movge	r1, r2
            x = constrain(x, 0, 62);
   12776:	fa5f fa83 	uxtb.w	sl, r3
            gfxLine(prev_x, prev_y, x, y);
   1277a:	9a03      	ldr	r2, [sp, #12]
   1277c:	9100      	str	r1, [sp, #0]
            y = constrain(y, 25, 62);
   1277e:	fa5f fb81 	uxtb.w	fp, r1
            gfxLine(prev_x, prev_y, x, y);
   12782:	69a8      	ldr	r0, [r5, #24]
   12784:	4641      	mov	r1, r8
   12786:	f7f2 f933 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   1278a:	3601      	adds	r6, #1
            prev_y = y;
   1278c:	465a      	mov	r2, fp
            prev_x = x;
   1278e:	46d0      	mov	r8, sl
   12790:	e7bf      	b.n	12712 <VectorMod::DrawWaveform(unsigned char)+0x46>
   12792:	Address 0x0000000000012792 is out of bounds.


00012794 <VectorMod::DrawInterface()>:
    void DrawInterface() {
   12794:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   12798:	4604      	mov	r4, r0
        byte c = cursor;
   1279a:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
        graphics.setPrintPos(x + gfx_offset, y);
   1279c:	69a3      	ldr	r3, [r4, #24]
  text_x_ = x;
   1279e:	4832      	ldr	r0, [pc, #200]	; (12868 <VectorMod::DrawInterface()+0xd4>)
   127a0:	3301      	adds	r3, #1
   127a2:	6043      	str	r3, [r0, #4]
  text_y_ = y;
   127a4:	230f      	movs	r3, #15
        byte ch = cursor < 2 ? 0 : 1;
   127a6:	2e01      	cmp	r6, #1
        byte c = cursor;
   127a8:	b2f5      	uxtb	r5, r6
   127aa:	6083      	str	r3, [r0, #8]
        if (hemisphere == 0) gfxPrint(ch ? "B" : "A");
   127ac:	7923      	ldrb	r3, [r4, #4]
        if (ch) c -= 2;
   127ae:	bfc5      	ittet	gt
   127b0:	3d02      	subgt	r5, #2
        byte ch = cursor < 2 ? 0 : 1;
   127b2:	2701      	movgt	r7, #1
   127b4:	2700      	movle	r7, #0
        if (ch) c -= 2;
   127b6:	b2ed      	uxtbgt	r5, r5
        if (hemisphere == 0) gfxPrint(ch ? "B" : "A");
   127b8:	2b00      	cmp	r3, #0
   127ba:	d144      	bne.n	12846 <VectorMod::DrawInterface()+0xb2>
        graphics.print(str);
   127bc:	492b      	ldr	r1, [pc, #172]	; (1286c <VectorMod::DrawInterface()+0xd8>)
   127be:	4b2c      	ldr	r3, [pc, #176]	; (12870 <VectorMod::DrawInterface()+0xdc>)
   127c0:	2e01      	cmp	r6, #1
   127c2:	bfc8      	it	gt
   127c4:	4619      	movgt	r1, r3
   127c6:	f007 f986 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxInvert(1, 14, 7, 9);
   127ca:	2309      	movs	r3, #9
   127cc:	9300      	str	r3, [sp, #0]
   127ce:	220e      	movs	r2, #14
   127d0:	2307      	movs	r3, #7
   127d2:	2101      	movs	r1, #1
   127d4:	4620      	mov	r0, r4
   127d6:	f7f5 fed5 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
        gfxPrint(10, 15, ones(freq[ch]));
   127da:	2e01      	cmp	r6, #1
   127dc:	bfcc      	ite	gt
   127de:	2604      	movgt	r6, #4
   127e0:	2600      	movle	r6, #0
   127e2:	4426      	add	r6, r4
    int ones(int n) {return (n / 100);}
   127e4:	f04f 0864 	mov.w	r8, #100	; 0x64
   127e8:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
        gfxPrint(10, 15, ones(freq[ch]));
   127ec:	69a0      	ldr	r0, [r4, #24]
   127ee:	fb93 f3f8 	sdiv	r3, r3, r8
   127f2:	220f      	movs	r2, #15
   127f4:	210a      	movs	r1, #10
   127f6:	f7f2 f93b 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
   127fa:	491e      	ldr	r1, [pc, #120]	; (12874 <VectorMod::DrawInterface()+0xe0>)
   127fc:	481a      	ldr	r0, [pc, #104]	; (12868 <VectorMod::DrawInterface()+0xd4>)
   127fe:	f007 f96a 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    int hundredths(int n) {return (n % 100);}
   12802:	f8d6 6108 	ldr.w	r6, [r6, #264]	; 0x108
   12806:	fb96 f3f8 	sdiv	r3, r6, r8
   1280a:	fb08 6613 	mls	r6, r8, r3, r6
        if (h < 10) gfxPrint("0");
   1280e:	2e09      	cmp	r6, #9
   12810:	dc03      	bgt.n	1281a <VectorMod::DrawInterface()+0x86>
   12812:	4919      	ldr	r1, [pc, #100]	; (12878 <VectorMod::DrawInterface()+0xe4>)
   12814:	4814      	ldr	r0, [pc, #80]	; (12868 <VectorMod::DrawInterface()+0xd4>)
   12816:	f007 f95e 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        graphics.print(num);
   1281a:	4813      	ldr	r0, [pc, #76]	; (12868 <VectorMod::DrawInterface()+0xd4>)
   1281c:	4631      	mov	r1, r6
   1281e:	f007 f9ce 	bl	19bbe <weegfx::Graphics::print(int)>
        graphics.print(str);
   12822:	4916      	ldr	r1, [pc, #88]	; (1287c <VectorMod::DrawInterface()+0xe8>)
   12824:	4810      	ldr	r0, [pc, #64]	; (12868 <VectorMod::DrawInterface()+0xd4>)
   12826:	f007 f956 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        DrawWaveform(ch);
   1282a:	4639      	mov	r1, r7
   1282c:	4620      	mov	r0, r4
   1282e:	f7ff ff4d 	bl	126cc <VectorMod::DrawWaveform(unsigned char)>
        if (c == 0) gfxCursor(8, 23, 55);
   12832:	b95d      	cbnz	r5, 1284c <VectorMod::DrawInterface()+0xb8>
   12834:	2337      	movs	r3, #55	; 0x37
   12836:	2217      	movs	r2, #23
   12838:	2108      	movs	r1, #8
   1283a:	4620      	mov	r0, r4
   1283c:	f7f5 fe48 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   12840:	b002      	add	sp, #8
   12842:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12846:	490e      	ldr	r1, [pc, #56]	; (12880 <VectorMod::DrawInterface()+0xec>)
   12848:	4b0e      	ldr	r3, [pc, #56]	; (12884 <VectorMod::DrawInterface()+0xf0>)
   1284a:	e7b9      	b.n	127c0 <VectorMod::DrawInterface()+0x2c>
        if (c == 1 && CursorBlink()) gfxFrame(0, 24, 63, 40);
   1284c:	2d01      	cmp	r5, #1
   1284e:	d1f7      	bne.n	12840 <VectorMod::DrawInterface()+0xac>
   12850:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   12852:	2b00      	cmp	r3, #0
   12854:	ddf4      	ble.n	12840 <VectorMod::DrawInterface()+0xac>
   12856:	2328      	movs	r3, #40	; 0x28
   12858:	9300      	str	r3, [sp, #0]
   1285a:	69a0      	ldr	r0, [r4, #24]
   1285c:	233f      	movs	r3, #63	; 0x3f
   1285e:	2218      	movs	r2, #24
   12860:	2100      	movs	r1, #0
   12862:	f7f2 f8d3 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
    }
   12866:	e7eb      	b.n	12840 <VectorMod::DrawInterface()+0xac>
   12868:	200065e0 	.word	0x200065e0
   1286c:	00021283 	.word	0x00021283
   12870:	00021b62 	.word	0x00021b62
   12874:	00020f2c 	.word	0x00020f2c
   12878:	00020525 	.word	0x00020525
   1287c:	000212f9 	.word	0x000212f9
   12880:	0002127f 	.word	0x0002127f
   12884:	00021b74 	.word	0x00021b74

00012888 <VectorMod::View()>:
        gfxHeader(applet_name());
   12888:	6803      	ldr	r3, [r0, #0]
    void View() {
   1288a:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   1288c:	681b      	ldr	r3, [r3, #0]
    void View() {
   1288e:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   12890:	4798      	blx	r3
   12892:	4601      	mov	r1, r0
   12894:	4620      	mov	r0, r4
   12896:	f7f5 feb2 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   1289a:	4620      	mov	r0, r4
   1289c:	f7ff ff7a 	bl	12794 <VectorMod::DrawInterface()>
    }
   128a0:	bd10      	pop	{r4, pc}

000128a2 <VectorMod::SwitchWaveform(unsigned char, int)>:
    void SwitchWaveform(byte ch, int waveform) {
   128a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   128a6:	460e      	mov	r6, r1
   128a8:	4604      	mov	r4, r0
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   128aa:	f04f 0848 	mov.w	r8, #72	; 0x48
    void SwitchWaveform(byte ch, int waveform) {
   128ae:	b092      	sub	sp, #72	; 0x48
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   128b0:	fb08 4506 	mla	r5, r8, r6, r4
   128b4:	3570      	adds	r5, #112	; 0x70
   128b6:	b2d1      	uxtb	r1, r2
   128b8:	4668      	mov	r0, sp
    void SwitchWaveform(byte ch, int waveform) {
   128ba:	4617      	mov	r7, r2
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   128bc:	f7fb f91c 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
   128c0:	2246      	movs	r2, #70	; 0x46
   128c2:	4669      	mov	r1, sp
   128c4:	4628      	mov	r0, r5
   128c6:	f007 fb93 	bl	19ff0 <memcpy>
        waveform_number[ch] = waveform;
   128ca:	eb04 0386 	add.w	r3, r4, r6, lsl #2
        osc[ch].SetFrequency(freq[ch]);
   128ce:	4628      	mov	r0, r5
   128d0:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
        waveform_number[ch] = waveform;
   128d4:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
    void SetScale(uint16_t scale_) {scale = scale_;}
   128d8:	fb08 4406 	mla	r4, r8, r6, r4
        osc[ch].SetFrequency(freq[ch]);
   128dc:	f7fa fe94 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
   128e0:	f44f 5390 	mov.w	r3, #4608	; 0x1200
   128e4:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
    void Cycle(bool cycle_ = 1) {cycle = cycle_;}
   128e8:	2300      	movs	r3, #0
   128ea:	f884 30ac 	strb.w	r3, [r4, #172]	; 0xac
        osc[ch].Reset();
   128ee:	4628      	mov	r0, r5
   128f0:	f7fa fe93 	bl	d61a <VectorOscillator::Reset()>
    }
   128f4:	b012      	add	sp, #72	; 0x48
   128f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000128fa <VectorMod::Start()>:
    void Start() {
   128fa:	b538      	push	{r3, r4, r5, lr}
            SwitchWaveform(ch, 0);
   128fc:	2200      	movs	r2, #0
            freq[ch] = 50;
   128fe:	2532      	movs	r5, #50	; 0x32
   12900:	f8c0 5108 	str.w	r5, [r0, #264]	; 0x108
            SwitchWaveform(ch, 0);
   12904:	4611      	mov	r1, r2
    void Start() {
   12906:	4604      	mov	r4, r0
            SwitchWaveform(ch, 0);
   12908:	f7ff ffcb 	bl	128a2 <VectorMod::SwitchWaveform(unsigned char, int)>
            Out(ch, 0);
   1290c:	2300      	movs	r3, #0
   1290e:	461a      	mov	r2, r3
   12910:	4619      	mov	r1, r3
   12912:	4620      	mov	r0, r4
   12914:	f7f6 fadf 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            SwitchWaveform(ch, 0);
   12918:	4620      	mov	r0, r4
            freq[ch] = 50;
   1291a:	f8c4 510c 	str.w	r5, [r4, #268]	; 0x10c
            SwitchWaveform(ch, 0);
   1291e:	2200      	movs	r2, #0
   12920:	2101      	movs	r1, #1
   12922:	f7ff ffbe 	bl	128a2 <VectorMod::SwitchWaveform(unsigned char, int)>
            Out(ch, 0);
   12926:	2300      	movs	r3, #0
   12928:	461a      	mov	r2, r3
   1292a:	2101      	movs	r1, #1
   1292c:	4620      	mov	r0, r4
   1292e:	f7f6 fad2 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   12932:	bd38      	pop	{r3, r4, r5, pc}

00012934 <VectorMod_OnEncoderMove(bool, int)>:
void VectorMod_OnEncoderMove(bool hemisphere, int direction) {VectorMod_instance[hemisphere].OnEncoderMove(direction);}
   12934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        byte c = cursor;
   12936:	4d22      	ldr	r5, [pc, #136]	; (129c0 <VectorMod_OnEncoderMove(bool, int)+0x8c>)
   12938:	f44f 7688 	mov.w	r6, #272	; 0x110
   1293c:	4346      	muls	r6, r0
   1293e:	19ab      	adds	r3, r5, r6
   12940:	6eda      	ldr	r2, [r3, #108]	; 0x6c
        byte ch = cursor < 2 ? 0 : 1;
   12942:	2a01      	cmp	r2, #1
        byte c = cursor;
   12944:	b2d3      	uxtb	r3, r2
        if (ch) c -= 2;
   12946:	bfc3      	ittte	gt
   12948:	3b02      	subgt	r3, #2
   1294a:	b2db      	uxtbgt	r3, r3
        byte ch = cursor < 2 ? 0 : 1;
   1294c:	2401      	movgt	r4, #1
   1294e:	2400      	movle	r4, #0
        if (c == 1) { // Waveform
   12950:	2b01      	cmp	r3, #1
   12952:	d10f      	bne.n	12974 <VectorMod_OnEncoderMove(bool, int)+0x40>
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   12954:	2744      	movs	r7, #68	; 0x44
   12956:	fb07 4700 	mla	r7, r7, r0, r4
   1295a:	3740      	adds	r7, #64	; 0x40
   1295c:	f815 0027 	ldrb.w	r0, [r5, r7, lsl #2]
   12960:	f7fb f890 	bl	da84 <WaveformManager::GetNextWaveform(unsigned char, int)>
            SwitchWaveform(ch, waveform_number[ch]);
   12964:	4621      	mov	r1, r4
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   12966:	f845 0027 	str.w	r0, [r5, r7, lsl #2]
   1296a:	4602      	mov	r2, r0
            SwitchWaveform(ch, waveform_number[ch]);
   1296c:	19a8      	adds	r0, r5, r6
   1296e:	f7ff ff98 	bl	128a2 <VectorMod::SwitchWaveform(unsigned char, int)>
void VectorMod_OnEncoderMove(bool hemisphere, int direction) {VectorMod_instance[hemisphere].OnEncoderMove(direction);}
   12972:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (c == 0) { // Frequency
   12974:	2b00      	cmp	r3, #0
   12976:	d1fc      	bne.n	12972 <VectorMod_OnEncoderMove(bool, int)+0x3e>
            if (freq[ch] > 50) direction *= 10;
   12978:	2344      	movs	r3, #68	; 0x44
   1297a:	fb03 4300 	mla	r3, r3, r0, r4
   1297e:	3342      	adds	r3, #66	; 0x42
            osc[ch].SetFrequency(freq[ch]);
   12980:	3670      	adds	r6, #112	; 0x70
            if (freq[ch] > 50) direction *= 10;
   12982:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   12986:	2b32      	cmp	r3, #50	; 0x32
   12988:	bfc4      	itt	gt
   1298a:	270a      	movgt	r7, #10
   1298c:	4379      	mulgt	r1, r7
            freq[ch] = constrain(freq[ch] + direction, 10, 500);
   1298e:	4419      	add	r1, r3
   12990:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
   12994:	bfa8      	it	ge
   12996:	f44f 71fa 	movge.w	r1, #500	; 0x1f4
   1299a:	290a      	cmp	r1, #10
   1299c:	bfb8      	it	lt
   1299e:	210a      	movlt	r1, #10
   129a0:	2344      	movs	r3, #68	; 0x44
            osc[ch].SetFrequency(freq[ch]);
   129a2:	2a01      	cmp	r2, #1
            freq[ch] = constrain(freq[ch] + direction, 10, 500);
   129a4:	fb03 4400 	mla	r4, r3, r0, r4
            osc[ch].SetFrequency(freq[ch]);
   129a8:	bfcc      	ite	gt
   129aa:	2048      	movgt	r0, #72	; 0x48
   129ac:	2000      	movle	r0, #0
            freq[ch] = constrain(freq[ch] + direction, 10, 500);
   129ae:	3442      	adds	r4, #66	; 0x42
            osc[ch].SetFrequency(freq[ch]);
   129b0:	4430      	add	r0, r6
   129b2:	4428      	add	r0, r5
            freq[ch] = constrain(freq[ch] + direction, 10, 500);
   129b4:	f845 1024 	str.w	r1, [r5, r4, lsl #2]
            osc[ch].SetFrequency(freq[ch]);
   129b8:	f7fa fe26 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
void VectorMod_OnEncoderMove(bool hemisphere, int direction) {VectorMod_instance[hemisphere].OnEncoderMove(direction);}
   129bc:	e7d9      	b.n	12972 <VectorMod_OnEncoderMove(bool, int)+0x3e>
   129be:	bf00      	nop
   129c0:	20002ef8 	.word	0x20002ef8

000129c4 <VectorMod::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   129c4:	b5f0      	push	{r4, r5, r6, r7, lr}
        freq[0] = Unpack(data, PackLocation {12,10});
   129c6:	230c      	movs	r3, #12
    void OnDataReceive(uint32_t data) {
   129c8:	460d      	mov	r5, r1
        freq[0] = Unpack(data, PackLocation {12,10});
   129ca:	260a      	movs	r6, #10
    void OnDataReceive(uint32_t data) {
   129cc:	b089      	sub	sp, #36	; 0x24
   129ce:	4604      	mov	r4, r0
        freq[0] = Unpack(data, PackLocation {12,10});
   129d0:	4632      	mov	r2, r6
   129d2:	4619      	mov	r1, r3
   129d4:	4628      	mov	r0, r5
   129d6:	e9cd 3600 	strd	r3, r6, [sp]
   129da:	f7f1 fa29 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        freq[1] = Unpack(data, PackLocation {22,10});
   129de:	2316      	movs	r3, #22
   129e0:	4619      	mov	r1, r3
        freq[0] = Unpack(data, PackLocation {12,10});
   129e2:	f8c4 0108 	str.w	r0, [r4, #264]	; 0x108
        freq[1] = Unpack(data, PackLocation {22,10});
   129e6:	4632      	mov	r2, r6
   129e8:	4628      	mov	r0, r5
   129ea:	e9cd 3602 	strd	r3, r6, [sp, #8]
   129ee:	f7f1 fa1f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        SwitchWaveform(0, Unpack(data, PackLocation {0,6}));
   129f2:	2700      	movs	r7, #0
   129f4:	2606      	movs	r6, #6
        freq[1] = Unpack(data, PackLocation {22,10});
   129f6:	f8c4 010c 	str.w	r0, [r4, #268]	; 0x10c
        SwitchWaveform(0, Unpack(data, PackLocation {0,6}));
   129fa:	4632      	mov	r2, r6
   129fc:	4639      	mov	r1, r7
   129fe:	4628      	mov	r0, r5
   12a00:	e9cd 7604 	strd	r7, r6, [sp, #16]
   12a04:	f7f1 fa14 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   12a08:	4639      	mov	r1, r7
   12a0a:	4602      	mov	r2, r0
   12a0c:	4620      	mov	r0, r4
   12a0e:	f7ff ff48 	bl	128a2 <VectorMod::SwitchWaveform(unsigned char, int)>
        SwitchWaveform(1, Unpack(data, PackLocation {6,6}));
   12a12:	e9cd 6606 	strd	r6, r6, [sp, #24]
   12a16:	ab08      	add	r3, sp, #32
   12a18:	e913 0006 	ldmdb	r3, {r1, r2}
   12a1c:	4628      	mov	r0, r5
   12a1e:	f7f1 fa07 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   12a22:	2101      	movs	r1, #1
   12a24:	4602      	mov	r2, r0
   12a26:	4620      	mov	r0, r4
   12a28:	f7ff ff3b 	bl	128a2 <VectorMod::SwitchWaveform(unsigned char, int)>
    }
   12a2c:	b009      	add	sp, #36	; 0x24
   12a2e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00012a30 <VectorMod_OnDataReceive(bool, unsigned long)>:
void VectorMod_OnDataReceive(bool hemisphere, uint32_t data) {VectorMod_instance[hemisphere].OnDataReceive(data);}
   12a30:	b508      	push	{r3, lr}
   12a32:	4b04      	ldr	r3, [pc, #16]	; (12a44 <VectorMod_OnDataReceive(bool, unsigned long)+0x14>)
   12a34:	f44f 7288 	mov.w	r2, #272	; 0x110
   12a38:	fb02 3000 	mla	r0, r2, r0, r3
   12a3c:	f7ff ffc2 	bl	129c4 <VectorMod::OnDataReceive(unsigned long)>
   12a40:	bd08      	pop	{r3, pc}
   12a42:	bf00      	nop
   12a44:	20002ef8 	.word	0x20002ef8

00012a48 <VectorMorph::DrawWaveform(unsigned char)>:
    void DrawWaveform(byte ch) {
   12a48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    byte TotalTime() {return total_time;}
   12a4c:	2648      	movs	r6, #72	; 0x48
   12a4e:	fb06 0801 	mla	r8, r6, r1, r0
   12a52:	460d      	mov	r5, r1
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   12a54:	f898 1088 	ldrb.w	r1, [r8, #136]	; 0x88
   12a58:	f8d8 a08c 	ldr.w	sl, [r8, #140]	; 0x8c
   12a5c:	4646      	mov	r6, r8
   12a5e:	3670      	adds	r6, #112	; 0x70
   12a60:	3901      	subs	r1, #1
    void DrawWaveform(byte ch) {
   12a62:	b087      	sub	sp, #28
   12a64:	4604      	mov	r4, r0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   12a66:	b2c9      	uxtb	r1, r1
   12a68:	4630      	mov	r0, r6
   12a6a:	f7fa fcc7 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
        byte prev_y = 63 - Proportion(seg.level, 255, 38);
   12a6e:	b2c2      	uxtb	r2, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12a70:	23ff      	movs	r3, #255	; 0xff
   12a72:	0392      	lsls	r2, r2, #14
   12a74:	fbb2 f2f3 	udiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
   12a78:	2326      	movs	r3, #38	; 0x26
   12a7a:	435a      	muls	r2, r3
   12a7c:	1392      	asrs	r2, r2, #14
   12a7e:	f1c2 023f 	rsb	r2, r2, #63	; 0x3f
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   12a82:	2700      	movs	r7, #0
        VOSegment seg = osc[ch].GetSegment(osc[ch].SegmentCount() - 1);
   12a84:	f8ad 0014 	strh.w	r0, [sp, #20]
        byte prev_y = 63 - Proportion(seg.level, 255, 38);
   12a88:	b2d2      	uxtb	r2, r2
        byte prev_x = 0; // Starting coordinates
   12a8a:	46b9      	mov	r9, r7
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12a8c:	fa5f fa8a 	uxtb.w	sl, sl
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   12a90:	f898 3088 	ldrb.w	r3, [r8, #136]	; 0x88
   12a94:	b2f9      	uxtb	r1, r7
   12a96:	428b      	cmp	r3, r1
   12a98:	d826      	bhi.n	12ae8 <VectorMorph::DrawWaveform(unsigned char)+0xa0>
        gfxDottedLine(0, 44, 63, 44, 8);
   12a9a:	222c      	movs	r2, #44	; 0x2c
   12a9c:	2308      	movs	r3, #8
        byte transport_x = Proportion(abs(last_phase[ch]) % 3600, 3600, 63);
   12a9e:	3540      	adds	r5, #64	; 0x40
        gfxDottedLine(0, 44, 63, 44, 8);
   12aa0:	69a0      	ldr	r0, [r4, #24]
   12aa2:	9301      	str	r3, [sp, #4]
   12aa4:	9200      	str	r2, [sp, #0]
   12aa6:	233f      	movs	r3, #63	; 0x3f
   12aa8:	2100      	movs	r1, #0
   12aaa:	f7f1 ff87 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
        byte transport_x = Proportion(abs(last_phase[ch]) % 3600, 3600, 63);
   12aae:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   12ab2:	2b00      	cmp	r3, #0
   12ab4:	bfb8      	it	lt
   12ab6:	425b      	neglt	r3, r3
   12ab8:	f44f 6261 	mov.w	r2, #3600	; 0xe10
   12abc:	fbb3 f1f2 	udiv	r1, r3, r2
   12ac0:	fb02 3311 	mls	r3, r2, r1, r3
   12ac4:	039b      	lsls	r3, r3, #14
   12ac6:	fbb3 f3f2 	udiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   12aca:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
   12ace:	139b      	asrs	r3, r3, #14
        gfxDottedLine(transport_x, 24, transport_x, 63, 3);
   12ad0:	203f      	movs	r0, #63	; 0x3f
   12ad2:	2203      	movs	r2, #3
   12ad4:	e9cd 0200 	strd	r0, r2, [sp]
   12ad8:	4619      	mov	r1, r3
   12ada:	69a0      	ldr	r0, [r4, #24]
   12adc:	2218      	movs	r2, #24
   12ade:	f7f1 ff6d 	bl	49bc <HemisphereApplet::gfxDottedLine(int, int, int, int, unsigned char) [clone .isra.0]>
    }
   12ae2:	b007      	add	sp, #28
   12ae4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            seg = osc[ch].GetSegment(i);
   12ae8:	4630      	mov	r0, r6
   12aea:	9203      	str	r2, [sp, #12]
   12aec:	f7fa fc86 	bl	d3fc <VectorOscillator::GetSegment(unsigned char)>
            byte y = 63 - Proportion(seg.level, 255, 38);
   12af0:	b2c1      	uxtb	r1, r0
   12af2:	223e      	movs	r2, #62	; 0x3e
            seg = osc[ch].GetSegment(i);
   12af4:	f8ad 0014 	strh.w	r0, [sp, #20]
            byte seg_x = Proportion(seg.time, total_time, 62);
   12af8:	f3c0 2307 	ubfx	r3, r0, #8, #8
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12afc:	0389      	lsls	r1, r1, #14
   12afe:	20ff      	movs	r0, #255	; 0xff
   12b00:	fbb1 f1f0 	udiv	r1, r1, r0
        int scaled = simfloat2int(proportion * max_value);
   12b04:	2026      	movs	r0, #38	; 0x26
   12b06:	4341      	muls	r1, r0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12b08:	039b      	lsls	r3, r3, #14
   12b0a:	fbb3 f3fa 	udiv	r3, r3, sl
        int scaled = simfloat2int(proportion * max_value);
   12b0e:	4353      	muls	r3, r2
            byte x = prev_x + seg_x;
   12b10:	eb09 33a3 	add.w	r3, r9, r3, asr #14
   12b14:	1389      	asrs	r1, r1, #14
            x = constrain(x, 0, 62);
   12b16:	b2db      	uxtb	r3, r3
            byte y = 63 - Proportion(seg.level, 255, 38);
   12b18:	f1c1 013f 	rsb	r1, r1, #63	; 0x3f
            y = constrain(y, 25, 62);
   12b1c:	b2c9      	uxtb	r1, r1
            x = constrain(x, 0, 62);
   12b1e:	4293      	cmp	r3, r2
   12b20:	bfa8      	it	ge
   12b22:	4613      	movge	r3, r2
            y = constrain(y, 25, 62);
   12b24:	293e      	cmp	r1, #62	; 0x3e
   12b26:	bfa8      	it	ge
   12b28:	213e      	movge	r1, #62	; 0x3e
            x = constrain(x, 0, 62);
   12b2a:	b2da      	uxtb	r2, r3
   12b2c:	9202      	str	r2, [sp, #8]
            y = constrain(y, 25, 62);
   12b2e:	fa5f fb81 	uxtb.w	fp, r1
            gfxLine(prev_x, prev_y, x, y);
   12b32:	9a03      	ldr	r2, [sp, #12]
   12b34:	9100      	str	r1, [sp, #0]
   12b36:	69a0      	ldr	r0, [r4, #24]
   12b38:	4649      	mov	r1, r9
   12b3a:	f7f1 ff59 	bl	49f0 <HemisphereApplet::gfxLine(int, int, int, int) [clone .isra.0]>
        for (byte i = 0; i < osc[ch].SegmentCount(); i++)
   12b3e:	3701      	adds	r7, #1
            prev_x = x;
   12b40:	f8dd 9008 	ldr.w	r9, [sp, #8]
            prev_y = y;
   12b44:	465a      	mov	r2, fp
   12b46:	e7a3      	b.n	12a90 <VectorMorph::DrawWaveform(unsigned char)+0x48>

00012b48 <VectorMorph::DrawInterface()>:
    void DrawInterface() {
   12b48:	b573      	push	{r0, r1, r4, r5, r6, lr}
   12b4a:	4604      	mov	r4, r0
        byte c = cursor;
   12b4c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
        graphics.setPrintPos(x + gfx_offset, y);
   12b4e:	69a2      	ldr	r2, [r4, #24]
  text_x_ = x;
   12b50:	4829      	ldr	r0, [pc, #164]	; (12bf8 <VectorMorph::DrawInterface()+0xb0>)
   12b52:	3201      	adds	r2, #1
   12b54:	6042      	str	r2, [r0, #4]
  text_y_ = y;
   12b56:	220f      	movs	r2, #15
        byte ch = cursor < 2 ? 0 : 1;
   12b58:	2b01      	cmp	r3, #1
        byte c = cursor;
   12b5a:	b2dd      	uxtb	r5, r3
   12b5c:	6082      	str	r2, [r0, #8]
        if (hemisphere == 0) gfxPrint(ch ? "B" : "A");
   12b5e:	7922      	ldrb	r2, [r4, #4]
        if (ch) c -= 2;
   12b60:	bfc5      	ittet	gt
   12b62:	3d02      	subgt	r5, #2
        byte ch = cursor < 2 ? 0 : 1;
   12b64:	2601      	movgt	r6, #1
   12b66:	2600      	movle	r6, #0
        if (ch) c -= 2;
   12b68:	b2ed      	uxtbgt	r5, r5
        if (hemisphere == 0) gfxPrint(ch ? "B" : "A");
   12b6a:	bb92      	cbnz	r2, 12bd2 <VectorMorph::DrawInterface()+0x8a>
        graphics.print(str);
   12b6c:	4923      	ldr	r1, [pc, #140]	; (12bfc <VectorMorph::DrawInterface()+0xb4>)
   12b6e:	4a24      	ldr	r2, [pc, #144]	; (12c00 <VectorMorph::DrawInterface()+0xb8>)
   12b70:	2b01      	cmp	r3, #1
   12b72:	bfc8      	it	gt
   12b74:	4611      	movgt	r1, r2
   12b76:	f006 ffae 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        gfxInvert(1, 14, 7, 9);
   12b7a:	2309      	movs	r3, #9
   12b7c:	9300      	str	r3, [sp, #0]
   12b7e:	220e      	movs	r2, #14
   12b80:	2307      	movs	r3, #7
   12b82:	2101      	movs	r1, #1
   12b84:	4620      	mov	r0, r4
   12b86:	f7f5 fcfd 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
        gfxPrint(10, 15, phase[ch]);
   12b8a:	f106 0344 	add.w	r3, r6, #68	; 0x44
   12b8e:	69a0      	ldr	r0, [r4, #24]
   12b90:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   12b94:	220f      	movs	r2, #15
   12b96:	210a      	movs	r1, #10
   12b98:	f7f1 ff6a 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
   12b9c:	4919      	ldr	r1, [pc, #100]	; (12c04 <VectorMorph::DrawInterface()+0xbc>)
   12b9e:	4816      	ldr	r0, [pc, #88]	; (12bf8 <VectorMorph::DrawInterface()+0xb0>)
   12ba0:	f006 ff99 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        DrawWaveform(ch);
   12ba4:	4631      	mov	r1, r6
   12ba6:	4620      	mov	r0, r4
   12ba8:	f7ff ff4e 	bl	12a48 <VectorMorph::DrawWaveform(unsigned char)>
        if (c == 0) gfxCursor(8, 23, 55);
   12bac:	b9a5      	cbnz	r5, 12bd8 <VectorMorph::DrawInterface()+0x90>
   12bae:	2337      	movs	r3, #55	; 0x37
   12bb0:	2217      	movs	r2, #23
   12bb2:	2108      	movs	r1, #8
   12bb4:	4620      	mov	r0, r4
   12bb6:	f7f5 fc8b 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (linked) gfxIcon(54, 15, LINK_ICON);
   12bba:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
   12bbe:	b1cb      	cbz	r3, 12bf4 <VectorMorph::DrawInterface()+0xac>
   12bc0:	4b11      	ldr	r3, [pc, #68]	; (12c08 <VectorMorph::DrawInterface()+0xc0>)
   12bc2:	69a0      	ldr	r0, [r4, #24]
   12bc4:	220f      	movs	r2, #15
   12bc6:	2136      	movs	r1, #54	; 0x36
    }
   12bc8:	b002      	add	sp, #8
   12bca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        if (linked) gfxIcon(54, 15, LINK_ICON);
   12bce:	f7f1 bee7 	b.w	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
   12bd2:	490e      	ldr	r1, [pc, #56]	; (12c0c <VectorMorph::DrawInterface()+0xc4>)
   12bd4:	4a0e      	ldr	r2, [pc, #56]	; (12c10 <VectorMorph::DrawInterface()+0xc8>)
   12bd6:	e7cb      	b.n	12b70 <VectorMorph::DrawInterface()+0x28>
        if (c == 1 && CursorBlink()) gfxFrame(0, 24, 63, 40);
   12bd8:	2d01      	cmp	r5, #1
   12bda:	d1ee      	bne.n	12bba <VectorMorph::DrawInterface()+0x72>
   12bdc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   12bde:	2b00      	cmp	r3, #0
   12be0:	ddeb      	ble.n	12bba <VectorMorph::DrawInterface()+0x72>
   12be2:	2328      	movs	r3, #40	; 0x28
   12be4:	9300      	str	r3, [sp, #0]
   12be6:	69a0      	ldr	r0, [r4, #24]
   12be8:	233f      	movs	r3, #63	; 0x3f
   12bea:	2218      	movs	r2, #24
   12bec:	2100      	movs	r1, #0
   12bee:	f7f1 ff0d 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
   12bf2:	e7e2      	b.n	12bba <VectorMorph::DrawInterface()+0x72>
    }
   12bf4:	b002      	add	sp, #8
   12bf6:	bd70      	pop	{r4, r5, r6, pc}
   12bf8:	200065e0 	.word	0x200065e0
   12bfc:	00021283 	.word	0x00021283
   12c00:	00021b62 	.word	0x00021b62
   12c04:	00021314 	.word	0x00021314
   12c08:	00024208 	.word	0x00024208
   12c0c:	0002127f 	.word	0x0002127f
   12c10:	00021b74 	.word	0x00021b74

00012c14 <VectorMorph::View()>:
        gfxHeader(applet_name());
   12c14:	6803      	ldr	r3, [r0, #0]
    void View() {
   12c16:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   12c18:	681b      	ldr	r3, [r3, #0]
    void View() {
   12c1a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   12c1c:	4798      	blx	r3
   12c1e:	4601      	mov	r1, r0
   12c20:	4620      	mov	r0, r4
   12c22:	f7f5 fcec 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   12c26:	4620      	mov	r0, r4
   12c28:	f7ff ff8e 	bl	12b48 <VectorMorph::DrawInterface()>
    }
   12c2c:	bd10      	pop	{r4, pc}

00012c2e <VectorMorph::SwitchWaveform(unsigned char, int)>:
    void SwitchWaveform(byte ch, int waveform) {
   12c2e:	b5f0      	push	{r4, r5, r6, r7, lr}
   12c30:	b093      	sub	sp, #76	; 0x4c
   12c32:	460d      	mov	r5, r1
   12c34:	4604      	mov	r4, r0
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   12c36:	b2d1      	uxtb	r1, r2
   12c38:	4668      	mov	r0, sp
   12c3a:	2748      	movs	r7, #72	; 0x48
    void SwitchWaveform(byte ch, int waveform) {
   12c3c:	4616      	mov	r6, r2
        osc[ch] = WaveformManager::VectorOscillatorFromWaveform(waveform);
   12c3e:	f7fa ff5b 	bl	daf8 <WaveformManager::VectorOscillatorFromWaveform(unsigned char)>
   12c42:	fb07 4005 	mla	r0, r7, r5, r4
   12c46:	2246      	movs	r2, #70	; 0x46
   12c48:	4669      	mov	r1, sp
   12c4a:	3070      	adds	r0, #112	; 0x70
   12c4c:	f007 f9d0 	bl	19ff0 <memcpy>
        waveform_number[ch] = waveform;
   12c50:	f105 0342 	add.w	r3, r5, #66	; 0x42
   12c54:	f844 6023 	str.w	r6, [r4, r3, lsl #2]
    void SetScale(uint16_t scale_) {scale = scale_;}
   12c58:	fb07 4405 	mla	r4, r7, r5, r4
   12c5c:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   12c60:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
    }
   12c64:	b013      	add	sp, #76	; 0x4c
   12c66:	bdf0      	pop	{r4, r5, r6, r7, pc}

00012c68 <VectorMorph::Start()>:
        		phase[ch] = (ch * 180) + (hemisphere * 90);
   12c68:	7903      	ldrb	r3, [r0, #4]
    void Start() {
   12c6a:	b570      	push	{r4, r5, r6, lr}
        		phase[ch] = (ch * 180) + (hemisphere * 90);
   12c6c:	265a      	movs	r6, #90	; 0x5a
        		last_phase[ch] = 0;
   12c6e:	2500      	movs	r5, #0
        		phase[ch] = (ch * 180) + (hemisphere * 90);
   12c70:	4373      	muls	r3, r6
    void Start() {
   12c72:	4604      	mov	r4, r0
        		phase[ch] = (ch * 180) + (hemisphere * 90);
   12c74:	f8c0 3110 	str.w	r3, [r0, #272]	; 0x110
        		last_phase[ch] = 0;
   12c78:	f8c0 5100 	str.w	r5, [r0, #256]	; 0x100
            SwitchWaveform(ch, HS::Morph1);
   12c7c:	4629      	mov	r1, r5
   12c7e:	2239      	movs	r2, #57	; 0x39
   12c80:	f7ff ffd5 	bl	12c2e <VectorMorph::SwitchWaveform(unsigned char, int)>
            Out(ch, 0);
   12c84:	462b      	mov	r3, r5
   12c86:	462a      	mov	r2, r5
   12c88:	4629      	mov	r1, r5
   12c8a:	4620      	mov	r0, r4
   12c8c:	f7f6 f923 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        		phase[ch] = (ch * 180) + (hemisphere * 90);
   12c90:	7923      	ldrb	r3, [r4, #4]
        		last_phase[ch] = 0;
   12c92:	f8c4 5104 	str.w	r5, [r4, #260]	; 0x104
        		phase[ch] = (ch * 180) + (hemisphere * 90);
   12c96:	4373      	muls	r3, r6
   12c98:	33b4      	adds	r3, #180	; 0xb4
   12c9a:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
            SwitchWaveform(ch, HS::Morph1);
   12c9e:	4620      	mov	r0, r4
   12ca0:	2239      	movs	r2, #57	; 0x39
   12ca2:	2101      	movs	r1, #1
   12ca4:	f7ff ffc3 	bl	12c2e <VectorMorph::SwitchWaveform(unsigned char, int)>
            Out(ch, 0);
   12ca8:	462b      	mov	r3, r5
   12caa:	462a      	mov	r2, r5
   12cac:	2101      	movs	r1, #1
   12cae:	4620      	mov	r0, r4
   12cb0:	f7f6 f911 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   12cb4:	bd70      	pop	{r4, r5, r6, pc}
   12cb6:	Address 0x0000000000012cb6 is out of bounds.


00012cb8 <VectorMorph_OnEncoderMove(bool, int)>:
void VectorMorph_OnEncoderMove(bool hemisphere, int direction) {VectorMorph_instance[hemisphere].OnEncoderMove(direction);}
   12cb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        byte c = cursor;
   12cbc:	4d1d      	ldr	r5, [pc, #116]	; (12d34 <VectorMorph_OnEncoderMove(bool, int)+0x7c>)
   12cbe:	f44f 738e 	mov.w	r3, #284	; 0x11c
   12cc2:	fb03 5300 	mla	r3, r3, r0, r5
void VectorMorph_OnEncoderMove(bool hemisphere, int direction) {VectorMorph_instance[hemisphere].OnEncoderMove(direction);}
   12cc6:	4680      	mov	r8, r0
        byte c = cursor;
   12cc8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
        byte ch = cursor < 2 ? 0 : 1;
   12cca:	2b01      	cmp	r3, #1
        byte c = cursor;
   12ccc:	b2df      	uxtb	r7, r3
        if (ch) c -= 2;
   12cce:	bfc3      	ittte	gt
   12cd0:	3f02      	subgt	r7, #2
   12cd2:	b2ff      	uxtbgt	r7, r7
        byte ch = cursor < 2 ? 0 : 1;
   12cd4:	2401      	movgt	r4, #1
   12cd6:	2400      	movle	r4, #0
        if (c == 1) { // Waveform
   12cd8:	2f01      	cmp	r7, #1
   12cda:	d116      	bne.n	12d0a <VectorMorph_OnEncoderMove(bool, int)+0x52>
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   12cdc:	2647      	movs	r6, #71	; 0x47
   12cde:	fb06 4600 	mla	r6, r6, r0, r4
   12ce2:	3642      	adds	r6, #66	; 0x42
   12ce4:	f815 0026 	ldrb.w	r0, [r5, r6, lsl #2]
   12ce8:	f7fa fecc 	bl	da84 <WaveformManager::GetNextWaveform(unsigned char, int)>
void VectorMorph_OnEncoderMove(bool hemisphere, int direction) {VectorMorph_instance[hemisphere].OnEncoderMove(direction);}
   12cec:	f44f 738e 	mov.w	r3, #284	; 0x11c
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   12cf0:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
void VectorMorph_OnEncoderMove(bool hemisphere, int direction) {VectorMorph_instance[hemisphere].OnEncoderMove(direction);}
   12cf4:	fb03 5508 	mla	r5, r3, r8, r5
            waveform_number[ch] = WaveformManager::GetNextWaveform(waveform_number[ch], direction);
   12cf8:	4602      	mov	r2, r0
            SwitchWaveform(ch, waveform_number[ch]);
   12cfa:	4621      	mov	r1, r4
   12cfc:	4628      	mov	r0, r5
   12cfe:	f7ff ff96 	bl	12c2e <VectorMorph::SwitchWaveform(unsigned char, int)>
            linked = 1; // Restore link when waveform is changed
   12d02:	f885 7118 	strb.w	r7, [r5, #280]	; 0x118
void VectorMorph_OnEncoderMove(bool hemisphere, int direction) {VectorMorph_instance[hemisphere].OnEncoderMove(direction);}
   12d06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (c == 0) { // Phase
   12d0a:	2f00      	cmp	r7, #0
   12d0c:	d1fb      	bne.n	12d06 <VectorMorph_OnEncoderMove(bool, int)+0x4e>
        		phase[ch] = constrain(phase[ch] + (direction * 5), 0, 355);
   12d0e:	2347      	movs	r3, #71	; 0x47
   12d10:	fb03 4400 	mla	r4, r3, r0, r4
   12d14:	3444      	adds	r4, #68	; 0x44
   12d16:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   12d1a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   12d1e:	f240 1263 	movw	r2, #355	; 0x163
   12d22:	440b      	add	r3, r1
   12d24:	4293      	cmp	r3, r2
   12d26:	bfa8      	it	ge
   12d28:	4613      	movge	r3, r2
   12d2a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   12d2e:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
void VectorMorph_OnEncoderMove(bool hemisphere, int direction) {VectorMorph_instance[hemisphere].OnEncoderMove(direction);}
   12d32:	e7e8      	b.n	12d06 <VectorMorph_OnEncoderMove(bool, int)+0x4e>
   12d34:	20003118 	.word	0x20003118

00012d38 <VectorMorph::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   12d38:	b5f0      	push	{r4, r5, r6, r7, lr}
        phase[0] = Unpack(data, PackLocation {12,9});
   12d3a:	230c      	movs	r3, #12
    void OnDataReceive(uint32_t data) {
   12d3c:	460d      	mov	r5, r1
        phase[0] = Unpack(data, PackLocation {12,9});
   12d3e:	2609      	movs	r6, #9
    void OnDataReceive(uint32_t data) {
   12d40:	b08b      	sub	sp, #44	; 0x2c
   12d42:	4604      	mov	r4, r0
        phase[0] = Unpack(data, PackLocation {12,9});
   12d44:	4632      	mov	r2, r6
   12d46:	4619      	mov	r1, r3
   12d48:	4628      	mov	r0, r5
   12d4a:	e9cd 3600 	strd	r3, r6, [sp]
   12d4e:	f7f1 f86f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        phase[1] = Unpack(data, PackLocation {21,9});
   12d52:	2315      	movs	r3, #21
   12d54:	4619      	mov	r1, r3
        phase[0] = Unpack(data, PackLocation {12,9});
   12d56:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
        phase[1] = Unpack(data, PackLocation {21,9});
   12d5a:	4632      	mov	r2, r6
   12d5c:	4628      	mov	r0, r5
   12d5e:	e9cd 3602 	strd	r3, r6, [sp, #8]
   12d62:	f7f1 f865 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        SwitchWaveform(0, Unpack(data, PackLocation {0,6}));
   12d66:	2606      	movs	r6, #6
   12d68:	2700      	movs	r7, #0
        phase[1] = Unpack(data, PackLocation {21,9});
   12d6a:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
        SwitchWaveform(0, Unpack(data, PackLocation {0,6}));
   12d6e:	4632      	mov	r2, r6
   12d70:	4639      	mov	r1, r7
   12d72:	4628      	mov	r0, r5
   12d74:	e9cd 7604 	strd	r7, r6, [sp, #16]
   12d78:	f7f1 f85a 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   12d7c:	4639      	mov	r1, r7
   12d7e:	4602      	mov	r2, r0
   12d80:	4620      	mov	r0, r4
   12d82:	f7ff ff54 	bl	12c2e <VectorMorph::SwitchWaveform(unsigned char, int)>
        SwitchWaveform(1, Unpack(data, PackLocation {6,6}));
   12d86:	4632      	mov	r2, r6
   12d88:	4631      	mov	r1, r6
   12d8a:	4628      	mov	r0, r5
   12d8c:	e9cd 6606 	strd	r6, r6, [sp, #24]
   12d90:	f7f1 f84e 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   12d94:	2101      	movs	r1, #1
   12d96:	4602      	mov	r2, r0
   12d98:	4620      	mov	r0, r4
   12d9a:	f7ff ff48 	bl	12c2e <VectorMorph::SwitchWaveform(unsigned char, int)>
        linked = Unpack(data, PackLocation {30,1});
   12d9e:	221e      	movs	r2, #30
   12da0:	2301      	movs	r3, #1
   12da2:	e9cd 2308 	strd	r2, r3, [sp, #32]
   12da6:	ab0a      	add	r3, sp, #40	; 0x28
   12da8:	e913 0006 	ldmdb	r3, {r1, r2}
   12dac:	4628      	mov	r0, r5
   12dae:	f7f1 f83f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   12db2:	1bc0      	subs	r0, r0, r7
   12db4:	bf18      	it	ne
   12db6:	2001      	movne	r0, #1
   12db8:	f884 0118 	strb.w	r0, [r4, #280]	; 0x118
    }
   12dbc:	b00b      	add	sp, #44	; 0x2c
   12dbe:	bdf0      	pop	{r4, r5, r6, r7, pc}

00012dc0 <VectorMorph_OnDataReceive(bool, unsigned long)>:
void VectorMorph_OnDataReceive(bool hemisphere, uint32_t data) {VectorMorph_instance[hemisphere].OnDataReceive(data);}
   12dc0:	b508      	push	{r3, lr}
   12dc2:	4b04      	ldr	r3, [pc, #16]	; (12dd4 <VectorMorph_OnDataReceive(bool, unsigned long)+0x14>)
   12dc4:	f44f 728e 	mov.w	r2, #284	; 0x11c
   12dc8:	fb02 3000 	mla	r0, r2, r0, r3
   12dcc:	f7ff ffb4 	bl	12d38 <VectorMorph::OnDataReceive(unsigned long)>
   12dd0:	bd08      	pop	{r3, pc}
   12dd2:	bf00      	nop
   12dd4:	20003118 	.word	0x20003118

00012dd8 <Voltage::OnDataReceive(unsigned long)>:
    void OnDataReceive(uint32_t data) {
   12dd8:	b570      	push	{r4, r5, r6, lr}
        voltage[0] = Unpack(data, PackLocation {0,9}) - 256;
   12dda:	2300      	movs	r3, #0
    void OnDataReceive(uint32_t data) {
   12ddc:	460d      	mov	r5, r1
        voltage[0] = Unpack(data, PackLocation {0,9}) - 256;
   12dde:	2609      	movs	r6, #9
    void OnDataReceive(uint32_t data) {
   12de0:	b088      	sub	sp, #32
   12de2:	4604      	mov	r4, r0
        voltage[0] = Unpack(data, PackLocation {0,9}) - 256;
   12de4:	4632      	mov	r2, r6
   12de6:	4619      	mov	r1, r3
   12de8:	4628      	mov	r0, r5
   12dea:	e9cd 3600 	strd	r3, r6, [sp]
   12dee:	f7f1 f81f 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        voltage[1] = Unpack(data, PackLocation {10,9}) - 256;
   12df2:	230a      	movs	r3, #10
        voltage[0] = Unpack(data, PackLocation {0,9}) - 256;
   12df4:	f5a0 7080 	sub.w	r0, r0, #256	; 0x100
   12df8:	6760      	str	r0, [r4, #116]	; 0x74
        voltage[1] = Unpack(data, PackLocation {10,9}) - 256;
   12dfa:	4632      	mov	r2, r6
   12dfc:	4619      	mov	r1, r3
   12dfe:	4628      	mov	r0, r5
   12e00:	e9cd 3602 	strd	r3, r6, [sp, #8]
   12e04:	f7f1 f814 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        gate[0] = Unpack(data, PackLocation {19,1});
   12e08:	2601      	movs	r6, #1
   12e0a:	2313      	movs	r3, #19
        voltage[1] = Unpack(data, PackLocation {10,9}) - 256;
   12e0c:	f5a0 7080 	sub.w	r0, r0, #256	; 0x100
   12e10:	67a0      	str	r0, [r4, #120]	; 0x78
        gate[0] = Unpack(data, PackLocation {19,1});
   12e12:	4632      	mov	r2, r6
   12e14:	4619      	mov	r1, r3
   12e16:	4628      	mov	r0, r5
   12e18:	e9cd 3604 	strd	r3, r6, [sp, #16]
   12e1c:	f7f1 f808 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
        gate[1] = Unpack(data, PackLocation {20,1});
   12e20:	2314      	movs	r3, #20
   12e22:	e9cd 3606 	strd	r3, r6, [sp, #24]
        gate[0] = Unpack(data, PackLocation {19,1});
   12e26:	3800      	subs	r0, #0
   12e28:	bf18      	it	ne
   12e2a:	2001      	movne	r0, #1
        gate[1] = Unpack(data, PackLocation {20,1});
   12e2c:	ab08      	add	r3, sp, #32
        gate[0] = Unpack(data, PackLocation {19,1});
   12e2e:	f884 007c 	strb.w	r0, [r4, #124]	; 0x7c
        gate[1] = Unpack(data, PackLocation {20,1});
   12e32:	e913 0006 	ldmdb	r3, {r1, r2}
   12e36:	4628      	mov	r0, r5
   12e38:	f7f0 fffa 	bl	3e30 <HemisphereApplet::Unpack(unsigned long, PackLocation) [clone .constprop.0]>
   12e3c:	3800      	subs	r0, #0
   12e3e:	bf18      	it	ne
   12e40:	2001      	movne	r0, #1
   12e42:	f884 007d 	strb.w	r0, [r4, #125]	; 0x7d
    }
   12e46:	b008      	add	sp, #32
   12e48:	bd70      	pop	{r4, r5, r6, pc}
   12e4a:	Address 0x0000000000012e4a is out of bounds.


00012e4c <Voltage_OnDataReceive(bool, unsigned long)>:
void Voltage_OnDataReceive(bool hemisphere, uint32_t data) {Voltage_instance[hemisphere].OnDataReceive(data);}
   12e4c:	b508      	push	{r3, lr}
   12e4e:	4b03      	ldr	r3, [pc, #12]	; (12e5c <Voltage_OnDataReceive(bool, unsigned long)+0x10>)
   12e50:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
   12e54:	f7ff ffc0 	bl	12dd8 <Voltage::OnDataReceive(unsigned long)>
   12e58:	bd08      	pop	{r3, pc}
   12e5a:	bf00      	nop
   12e5c:	20003350 	.word	0x20003350

00012e60 <Voltage::DrawInterface()>:
    void DrawInterface() {
   12e60:	b513      	push	{r0, r1, r4, lr}
            gfxPrint(0, 15 + (ch * 20), (hemisphere ? (ch ? "D " : "C ") : (ch ? "B " : "A ")));
   12e62:	4a31      	ldr	r2, [pc, #196]	; (12f28 <Voltage::DrawInterface()+0xc8>)
   12e64:	7901      	ldrb	r1, [r0, #4]
   12e66:	4b31      	ldr	r3, [pc, #196]	; (12f2c <Voltage::DrawInterface()+0xcc>)
    void DrawInterface() {
   12e68:	4604      	mov	r4, r0
            gfxPrint(0, 15 + (ch * 20), (hemisphere ? (ch ? "D " : "C ") : (ch ? "B " : "A ")));
   12e6a:	2900      	cmp	r1, #0
   12e6c:	bf18      	it	ne
   12e6e:	4613      	movne	r3, r2
   12e70:	220f      	movs	r2, #15
   12e72:	2100      	movs	r1, #0
   12e74:	f7f5 fb38 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            int cv = voltage[ch] * VOLTAGE_INCREMENTS;
   12e78:	6f61      	ldr	r1, [r4, #116]	; 0x74
            gfxPrintVoltage(cv);
   12e7a:	4620      	mov	r0, r4
   12e7c:	01c9      	lsls	r1, r1, #7
   12e7e:	f7f5 fb41 	bl	8504 <HemisphereApplet::gfxPrintVoltage(int)>
            gfxPrint(0, 25 + (ch * 20), gate[ch] ? "  G-On" : "  G-Off");
   12e82:	f894 107c 	ldrb.w	r1, [r4, #124]	; 0x7c
   12e86:	4a2a      	ldr	r2, [pc, #168]	; (12f30 <Voltage::DrawInterface()+0xd0>)
   12e88:	4b2a      	ldr	r3, [pc, #168]	; (12f34 <Voltage::DrawInterface()+0xd4>)
   12e8a:	4620      	mov	r0, r4
   12e8c:	2900      	cmp	r1, #0
   12e8e:	bf08      	it	eq
   12e90:	4613      	moveq	r3, r2
   12e92:	2219      	movs	r2, #25
   12e94:	2100      	movs	r1, #0
   12e96:	f7f5 fb27 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            if (view[ch]) gfxInvert(0, 14 + (ch * 20), 7, 9);
   12e9a:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   12e9e:	b13b      	cbz	r3, 12eb0 <Voltage::DrawInterface()+0x50>
   12ea0:	2309      	movs	r3, #9
   12ea2:	9300      	str	r3, [sp, #0]
   12ea4:	220e      	movs	r2, #14
   12ea6:	2307      	movs	r3, #7
   12ea8:	2100      	movs	r1, #0
   12eaa:	4620      	mov	r0, r4
   12eac:	f7f5 fb6a 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
            gfxPrint(0, 15 + (ch * 20), (hemisphere ? (ch ? "D " : "C ") : (ch ? "B " : "A ")));
   12eb0:	7921      	ldrb	r1, [r4, #4]
   12eb2:	4a21      	ldr	r2, [pc, #132]	; (12f38 <Voltage::DrawInterface()+0xd8>)
   12eb4:	4b21      	ldr	r3, [pc, #132]	; (12f3c <Voltage::DrawInterface()+0xdc>)
   12eb6:	4620      	mov	r0, r4
   12eb8:	2900      	cmp	r1, #0
   12eba:	bf18      	it	ne
   12ebc:	4613      	movne	r3, r2
   12ebe:	2223      	movs	r2, #35	; 0x23
   12ec0:	2100      	movs	r1, #0
   12ec2:	f7f5 fb11 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            int cv = voltage[ch] * VOLTAGE_INCREMENTS;
   12ec6:	6fa1      	ldr	r1, [r4, #120]	; 0x78
            gfxPrintVoltage(cv);
   12ec8:	4620      	mov	r0, r4
   12eca:	01c9      	lsls	r1, r1, #7
   12ecc:	f7f5 fb1a 	bl	8504 <HemisphereApplet::gfxPrintVoltage(int)>
            gfxPrint(0, 25 + (ch * 20), gate[ch] ? "  G-On" : "  G-Off");
   12ed0:	f894 107d 	ldrb.w	r1, [r4, #125]	; 0x7d
   12ed4:	4a16      	ldr	r2, [pc, #88]	; (12f30 <Voltage::DrawInterface()+0xd0>)
   12ed6:	4b17      	ldr	r3, [pc, #92]	; (12f34 <Voltage::DrawInterface()+0xd4>)
   12ed8:	4620      	mov	r0, r4
   12eda:	2900      	cmp	r1, #0
   12edc:	bf08      	it	eq
   12ede:	4613      	moveq	r3, r2
   12ee0:	222d      	movs	r2, #45	; 0x2d
   12ee2:	2100      	movs	r1, #0
   12ee4:	f7f5 fb00 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            if (view[ch]) gfxInvert(0, 14 + (ch * 20), 7, 9);
   12ee8:	f894 3071 	ldrb.w	r3, [r4, #113]	; 0x71
   12eec:	b13b      	cbz	r3, 12efe <Voltage::DrawInterface()+0x9e>
   12eee:	2309      	movs	r3, #9
   12ef0:	9300      	str	r3, [sp, #0]
   12ef2:	2222      	movs	r2, #34	; 0x22
   12ef4:	2307      	movs	r3, #7
   12ef6:	2100      	movs	r1, #0
   12ef8:	4620      	mov	r0, r4
   12efa:	f7f5 fb43 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
        int ch = cursor / 2;
   12efe:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   12f00:	eb03 72d3 	add.w	r2, r3, r3, lsr #31
        if (cursor == 0 or cursor == 2) gfxCursor(13, 23 + (ch * 20), 36);
   12f04:	2114      	movs	r1, #20
        int ch = cursor / 2;
   12f06:	1052      	asrs	r2, r2, #1
        if (cursor == 0 or cursor == 2) gfxCursor(13, 23 + (ch * 20), 36);
   12f08:	434a      	muls	r2, r1
   12f0a:	f033 0302 	bics.w	r3, r3, #2
   12f0e:	bf08      	it	eq
   12f10:	3217      	addeq	r2, #23
   12f12:	f04f 0324 	mov.w	r3, #36	; 0x24
        else gfxCursor(13, 33 + (ch * 20), 36);
   12f16:	bf18      	it	ne
   12f18:	3221      	addne	r2, #33	; 0x21
   12f1a:	210d      	movs	r1, #13
   12f1c:	4620      	mov	r0, r4
   12f1e:	f7f5 fad7 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   12f22:	b002      	add	sp, #8
   12f24:	bd10      	pop	{r4, pc}
   12f26:	bf00      	nop
   12f28:	0001f297 	.word	0x0001f297
   12f2c:	0001f2a3 	.word	0x0001f2a3
   12f30:	0002131d 	.word	0x0002131d
   12f34:	00021316 	.word	0x00021316
   12f38:	0001f29a 	.word	0x0001f29a
   12f3c:	0001f2a6 	.word	0x0001f2a6

00012f40 <Voltage::View()>:
        gfxHeader(applet_name());
   12f40:	6803      	ldr	r3, [r0, #0]
    void View() {
   12f42:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   12f44:	681b      	ldr	r3, [r3, #0]
    void View() {
   12f46:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   12f48:	4798      	blx	r3
   12f4a:	4601      	mov	r1, r0
   12f4c:	4620      	mov	r0, r4
   12f4e:	f7f5 fb56 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawInterface();
   12f52:	4620      	mov	r0, r4
   12f54:	f7ff ff84 	bl	12e60 <Voltage::DrawInterface()>
    }
   12f58:	bd10      	pop	{r4, pc}

00012f5a <hMIDIIn::UpdateLog(int, int, int)>:
    void UpdateLog(int message, int data1, int data2) {
   12f5a:	b570      	push	{r4, r5, r6, lr}
   12f5c:	4604      	mov	r4, r0
        log[log_index++] = {message, data1, data2};
   12f5e:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
   12f62:	260c      	movs	r6, #12
   12f64:	1c45      	adds	r5, r0, #1
   12f66:	fb06 4000 	mla	r0, r6, r0, r4
        if (log_index == 7) {
   12f6a:	2d07      	cmp	r5, #7
        log[log_index++] = {message, data1, data2};
   12f6c:	f8c4 50fc 	str.w	r5, [r4, #252]	; 0xfc
   12f70:	f8c0 10a8 	str.w	r1, [r0, #168]	; 0xa8
   12f74:	f8c0 20ac 	str.w	r2, [r0, #172]	; 0xac
   12f78:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
        if (log_index == 7) {
   12f7c:	d110      	bne.n	12fa0 <hMIDIIn::UpdateLog(int, int, int)+0x46>
   12f7e:	f104 05a8 	add.w	r5, r4, #168	; 0xa8
   12f82:	f104 06f0 	add.w	r6, r4, #240	; 0xf0
                memcpy(&log[i], &log[i+1], sizeof(log[i+1]));
   12f86:	4628      	mov	r0, r5
   12f88:	350c      	adds	r5, #12
   12f8a:	220c      	movs	r2, #12
   12f8c:	4629      	mov	r1, r5
   12f8e:	f007 f82f 	bl	19ff0 <memcpy>
            for (int i = 0; i < 6; i++)
   12f92:	42b5      	cmp	r5, r6
   12f94:	d1f7      	bne.n	12f86 <hMIDIIn::UpdateLog(int, int, int)+0x2c>
            log_index--;
   12f96:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
   12f9a:	3b01      	subs	r3, #1
   12f9c:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    }
   12fa0:	bd70      	pop	{r4, r5, r6, pc}
   12fa2:	Address 0x0000000000012fa2 is out of bounds.


00012fa4 <hMIDIIn::Controller()>:
    void Controller() {
   12fa4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12fa8:	4604      	mov	r4, r0
		return usb_midi_read(channel);
   12faa:	2000      	movs	r0, #0
   12fac:	f007 ffb2 	bl	1af14 <usb_midi_read>
        if (usbMIDI.read()) {
   12fb0:	2800      	cmp	r0, #0
   12fb2:	f000 808a 	beq.w	130ca <hMIDIIn::Controller()+0x126>
                return usb_midi_msg_type;
   12fb6:	4b8e      	ldr	r3, [pc, #568]	; (131f0 <hMIDIIn::Controller()+0x24c>)
            int message = usbMIDI.getType();
   12fb8:	781f      	ldrb	r7, [r3, #0]
                return usb_midi_msg_data1;
   12fba:	4b8e      	ldr	r3, [pc, #568]	; (131f4 <hMIDIIn::Controller()+0x250>)
   12fbc:	781d      	ldrb	r5, [r3, #0]
                return usb_midi_msg_data2;
   12fbe:	4b8e      	ldr	r3, [pc, #568]	; (131f8 <hMIDIIn::Controller()+0x254>)
            if (message == HEM_MIDI_SYSEX) ReceiveManagerSysEx();
   12fc0:	2f07      	cmp	r7, #7
   12fc2:	f893 8000 	ldrb.w	r8, [r3]
   12fc6:	d131      	bne.n	1302c <hMIDIIn::Controller()+0x88>
   12fc8:	f7f7 fb6c 	bl	a6a4 <ReceiveManagerSysEx()>
                return usb_midi_msg_channel;
   12fcc:	4b8b      	ldr	r3, [pc, #556]	; (131fc <hMIDIIn::Controller()+0x258>)
            if (usbMIDI.getChannel() == (channel + 1)) {
   12fce:	781a      	ldrb	r2, [r3, #0]
   12fd0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   12fd2:	3301      	adds	r3, #1
   12fd4:	429a      	cmp	r2, r3
   12fd6:	d178      	bne.n	130ca <hMIDIIn::Controller()+0x126>
                last_tick = OC::CORE::ticks;
   12fd8:	4b89      	ldr	r3, [pc, #548]	; (13200 <hMIDIIn::Controller()+0x25c>)
                if (message == HEM_MIDI_NOTE_ON) { // Note on
   12fda:	2f01      	cmp	r7, #1
                last_tick = OC::CORE::ticks;
   12fdc:	681b      	ldr	r3, [r3, #0]
   12fde:	67e3      	str	r3, [r4, #124]	; 0x7c
                if (message == HEM_MIDI_NOTE_ON) { // Note on
   12fe0:	d16c      	bne.n	130bc <hMIDIIn::Controller()+0x118>
                    if (first_note == -1) first_note = data1;
   12fe2:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   12fe6:	ea4f 3688 	mov.w	r6, r8, lsl #14
   12fea:	3301      	adds	r3, #1
   12fec:	f04f 037f 	mov.w	r3, #127	; 0x7f
   12ff0:	fbb6 f6f3 	udiv	r6, r6, r3
        int scaled = simfloat2int(proportion * max_value);
   12ff4:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   12ff8:	fb03 f606 	mul.w	r6, r3, r6
   12ffc:	bf08      	it	eq
   12ffe:	f8c4 5080 	streq.w	r5, [r4, #128]	; 0x80
   13002:	13b6      	asrs	r6, r6, #14
   13004:	f104 0b6c 	add.w	fp, r4, #108	; 0x6c
   13008:	f04f 0900 	mov.w	r9, #0
                        if (function[ch] == HEM_MIDI_NOTE_OUT)
   1300c:	f85b af04 	ldr.w	sl, [fp, #4]!
   13010:	f1ba 0f00 	cmp.w	sl, #0
   13014:	d131      	bne.n	1307a <hMIDIIn::Controller()+0xd6>
                            Out(ch, MIDIQuantizer::CV(data1));
   13016:	4651      	mov	r1, sl
   13018:	4628      	mov	r0, r5
   1301a:	f7f2 fcc4 	bl	59a6 <MIDIQuantizer::CV(unsigned char, int)>
   1301e:	4653      	mov	r3, sl
   13020:	4602      	mov	r2, r0
                            Out(ch, Proportion(data2, 127, HEMISPHERE_MAX_CV));
   13022:	4649      	mov	r1, r9
   13024:	4620      	mov	r0, r4
   13026:	f7f5 ff56 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
   1302a:	e037      	b.n	1309c <hMIDIIn::Controller()+0xf8>
            if (message == HEM_MIDI_REALTIME && data1 == 0) {
   1302c:	2f08      	cmp	r7, #8
   1302e:	d1cd      	bne.n	12fcc <hMIDIIn::Controller()+0x28>
   13030:	2d00      	cmp	r5, #0
   13032:	d1cb      	bne.n	12fcc <hMIDIIn::Controller()+0x28>
                if (++clock_count == 1) {
   13034:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
   13038:	3301      	adds	r3, #1
   1303a:	b2db      	uxtb	r3, r3
   1303c:	2b01      	cmp	r3, #1
   1303e:	f884 30a4 	strb.w	r3, [r4, #164]	; 0xa4
   13042:	d10f      	bne.n	13064 <hMIDIIn::Controller()+0xc0>
                        if (function[ch] == HEM_MIDI_REALTIME_OUT) {
   13044:	6f23      	ldr	r3, [r4, #112]	; 0x70
   13046:	2b07      	cmp	r3, #7
   13048:	d104      	bne.n	13054 <hMIDIIn::Controller()+0xb0>
                            ClockOut(ch);
   1304a:	2264      	movs	r2, #100	; 0x64
   1304c:	4629      	mov	r1, r5
   1304e:	4620      	mov	r0, r4
   13050:	f7f6 fc69 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
                        if (function[ch] == HEM_MIDI_REALTIME_OUT) {
   13054:	6f63      	ldr	r3, [r4, #116]	; 0x74
   13056:	2b07      	cmp	r3, #7
   13058:	d104      	bne.n	13064 <hMIDIIn::Controller()+0xc0>
                            ClockOut(ch);
   1305a:	2264      	movs	r2, #100	; 0x64
   1305c:	2101      	movs	r1, #1
   1305e:	4620      	mov	r0, r4
   13060:	f7f6 fc61 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
                if (clock_count == HEM_MIDI_CLOCK_DIVISOR) clock_count = 0;
   13064:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
   13068:	2b0c      	cmp	r3, #12
   1306a:	bf04      	itt	eq
   1306c:	2300      	moveq	r3, #0
   1306e:	f884 30a4 	strbeq.w	r3, [r4, #164]	; 0xa4
   13072:	e7ab      	b.n	12fcc <hMIDIIn::Controller()+0x28>
   13074:	f04f 0901 	mov.w	r9, #1
   13078:	e7c8      	b.n	1300c <hMIDIIn::Controller()+0x68>
                        if (function[ch] == HEM_MIDI_TRIG_OUT)
   1307a:	f1ba 0f01 	cmp.w	sl, #1
   1307e:	d008      	beq.n	13092 <hMIDIIn::Controller()+0xee>
                        if (function[ch] == HEM_MIDI_GATE_OUT)
   13080:	f1ba 0f02 	cmp.w	sl, #2
   13084:	d114      	bne.n	130b0 <hMIDIIn::Controller()+0x10c>
                            GateOut(ch, 1);
   13086:	2201      	movs	r2, #1
   13088:	4649      	mov	r1, r9
   1308a:	4620      	mov	r0, r4
   1308c:	f7f6 ff21 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
                        if (function[ch] == HEM_MIDI_VEL_OUT)
   13090:	e004      	b.n	1309c <hMIDIIn::Controller()+0xf8>
                            ClockOut(ch);
   13092:	2264      	movs	r2, #100	; 0x64
   13094:	4649      	mov	r1, r9
   13096:	4620      	mov	r0, r4
   13098:	f7f6 fc45 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
                    ForEachChannel(ch)
   1309c:	f1b9 0f00 	cmp.w	r9, #0
   130a0:	d0e8      	beq.n	13074 <hMIDIIn::Controller()+0xd0>
                if (log_this) UpdateLog(message, data1, data2);
   130a2:	4643      	mov	r3, r8
   130a4:	462a      	mov	r2, r5
   130a6:	4639      	mov	r1, r7
   130a8:	4620      	mov	r0, r4
   130aa:	f7ff ff56 	bl	12f5a <hMIDIIn::UpdateLog(int, int, int)>
    }
   130ae:	e00c      	b.n	130ca <hMIDIIn::Controller()+0x126>
                        if (function[ch] == HEM_MIDI_VEL_OUT)
   130b0:	f1ba 0f03 	cmp.w	sl, #3
   130b4:	d1f2      	bne.n	1309c <hMIDIIn::Controller()+0xf8>
                            Out(ch, Proportion(data2, 127, HEMISPHERE_MAX_CV));
   130b6:	2300      	movs	r3, #0
   130b8:	4632      	mov	r2, r6
   130ba:	e7b2      	b.n	13022 <hMIDIIn::Controller()+0x7e>
                if (message == HEM_MIDI_NOTE_OFF) { // Note off
   130bc:	b13f      	cbz	r7, 130ce <hMIDIIn::Controller()+0x12a>
                if (message == HEM_MIDI_CC) { // Modulation wheel
   130be:	2f03      	cmp	r7, #3
   130c0:	d023      	beq.n	1310a <hMIDIIn::Controller()+0x166>
                if (message == HEM_MIDI_AFTERTOUCH) { // Aftertouch
   130c2:	2f05      	cmp	r7, #5
   130c4:	d047      	beq.n	13156 <hMIDIIn::Controller()+0x1b2>
                if (message == HEM_MIDI_PITCHBEND) { // Pitch Bend
   130c6:	2f06      	cmp	r7, #6
   130c8:	d073      	beq.n	131b2 <hMIDIIn::Controller()+0x20e>
    }
   130ca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    if (data1 == first_note) first_note = -1;
   130ce:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   130d2:	42ab      	cmp	r3, r5
   130d4:	bf04      	itt	eq
   130d6:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   130da:	f8c4 3080 	streq.w	r3, [r4, #128]	; 0x80
                        if (function[ch] == HEM_MIDI_GATE_OUT) {
   130de:	6f23      	ldr	r3, [r4, #112]	; 0x70
   130e0:	2b02      	cmp	r3, #2
   130e2:	d10f      	bne.n	13104 <hMIDIIn::Controller()+0x160>
                            GateOut(ch, 0);
   130e4:	2200      	movs	r2, #0
   130e6:	4611      	mov	r1, r2
   130e8:	4620      	mov	r0, r4
   130ea:	f7f6 fef2 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
                            log_this = 1;
   130ee:	f04f 0901 	mov.w	r9, #1
                        if (function[ch] == HEM_MIDI_GATE_OUT) {
   130f2:	6f63      	ldr	r3, [r4, #116]	; 0x74
   130f4:	2b02      	cmp	r3, #2
   130f6:	d155      	bne.n	131a4 <hMIDIIn::Controller()+0x200>
                            GateOut(ch, 0);
   130f8:	2200      	movs	r2, #0
   130fa:	2101      	movs	r1, #1
   130fc:	4620      	mov	r0, r4
   130fe:	f7f6 fee8 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
                if (log_this) UpdateLog(message, data1, data2);
   13102:	e7ce      	b.n	130a2 <hMIDIIn::Controller()+0xfe>
                bool log_this = false;
   13104:	f04f 0900 	mov.w	r9, #0
   13108:	e7f3      	b.n	130f2 <hMIDIIn::Controller()+0x14e>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1310a:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1310e:	ea4f 5688 	mov.w	r6, r8, lsl #22
   13112:	fbb6 f6f3 	udiv	r6, r6, r3
        int scaled = simfloat2int(proportion * max_value);
   13116:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   1311a:	435e      	muls	r6, r3
                        if (function[ch] == HEM_MIDI_CC_OUT && data1 == 1) {
   1311c:	6f23      	ldr	r3, [r4, #112]	; 0x70
   1311e:	2b04      	cmp	r3, #4
   13120:	ea4f 36a6 	mov.w	r6, r6, asr #14
   13124:	d114      	bne.n	13150 <hMIDIIn::Controller()+0x1ac>
   13126:	2d01      	cmp	r5, #1
   13128:	d112      	bne.n	13150 <hMIDIIn::Controller()+0x1ac>
                            Out(ch, Proportion(data, 0x7fff, HEMISPHERE_MAX_CV));
   1312a:	2300      	movs	r3, #0
   1312c:	4632      	mov	r2, r6
   1312e:	4619      	mov	r1, r3
   13130:	4620      	mov	r0, r4
   13132:	f7f5 fed0 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                            log_this = 1;
   13136:	46a9      	mov	r9, r5
                        if (function[ch] == HEM_MIDI_CC_OUT && data1 == 1) {
   13138:	6f63      	ldr	r3, [r4, #116]	; 0x74
   1313a:	2b04      	cmp	r3, #4
   1313c:	d132      	bne.n	131a4 <hMIDIIn::Controller()+0x200>
   1313e:	2d01      	cmp	r5, #1
                        if (function[ch] == HEM_MIDI_PB_OUT) {
   13140:	d130      	bne.n	131a4 <hMIDIIn::Controller()+0x200>
                            Out(ch, Proportion(data, 0x7fff, HEMISPHERE_3V_CV));
   13142:	2300      	movs	r3, #0
   13144:	4632      	mov	r2, r6
   13146:	2101      	movs	r1, #1
   13148:	4620      	mov	r0, r4
   1314a:	f7f5 fec4 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                if (log_this) UpdateLog(message, data1, data2);
   1314e:	e7a8      	b.n	130a2 <hMIDIIn::Controller()+0xfe>
                bool log_this = false;
   13150:	f04f 0900 	mov.w	r9, #0
   13154:	e7f0      	b.n	13138 <hMIDIIn::Controller()+0x194>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   13156:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1315a:	ea4f 5688 	mov.w	r6, r8, lsl #22
   1315e:	fbb6 f6f3 	udiv	r6, r6, r3
        int scaled = simfloat2int(proportion * max_value);
   13162:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   13166:	435e      	muls	r6, r3
                        if (function[ch] == HEM_MIDI_AT_OUT) {
   13168:	6f23      	ldr	r3, [r4, #112]	; 0x70
   1316a:	2b05      	cmp	r3, #5
   1316c:	ea4f 36a6 	mov.w	r6, r6, asr #14
   13170:	d11c      	bne.n	131ac <hMIDIIn::Controller()+0x208>
                            Out(ch, Proportion(data, 0x7fff, HEMISPHERE_MAX_CV));
   13172:	2300      	movs	r3, #0
   13174:	4632      	mov	r2, r6
   13176:	4619      	mov	r1, r3
   13178:	4620      	mov	r0, r4
   1317a:	f7f5 feac 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                            log_this = 1;
   1317e:	f04f 0901 	mov.w	r9, #1
                        if (function[ch] == HEM_MIDI_AT_OUT) {
   13182:	6f63      	ldr	r3, [r4, #116]	; 0x74
   13184:	2b05      	cmp	r3, #5
   13186:	d107      	bne.n	13198 <hMIDIIn::Controller()+0x1f4>
                            Out(ch, Proportion(data, 0x7fff, HEMISPHERE_MAX_CV));
   13188:	2300      	movs	r3, #0
   1318a:	4632      	mov	r2, r6
   1318c:	2101      	movs	r1, #1
   1318e:	4620      	mov	r0, r4
   13190:	f7f5 fea1 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                            log_this = 1;
   13194:	f04f 0901 	mov.w	r9, #1
                    UpdateLog(message, data1, data2);
   13198:	4643      	mov	r3, r8
   1319a:	462a      	mov	r2, r5
   1319c:	2105      	movs	r1, #5
   1319e:	4620      	mov	r0, r4
   131a0:	f7ff fedb 	bl	12f5a <hMIDIIn::UpdateLog(int, int, int)>
                if (log_this) UpdateLog(message, data1, data2);
   131a4:	f1b9 0f00 	cmp.w	r9, #0
   131a8:	d08f      	beq.n	130ca <hMIDIIn::Controller()+0x126>
   131aa:	e77a      	b.n	130a2 <hMIDIIn::Controller()+0xfe>
                bool log_this = false;
   131ac:	f04f 0900 	mov.w	r9, #0
   131b0:	e7e7      	b.n	13182 <hMIDIIn::Controller()+0x1de>
                            int data = (data2 << 7) + data1 - 8192;
   131b2:	f5a5 5600 	sub.w	r6, r5, #8192	; 0x2000
   131b6:	eb06 16c8 	add.w	r6, r6, r8, lsl #7
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   131ba:	f647 73ff 	movw	r3, #32767	; 0x7fff
   131be:	03b6      	lsls	r6, r6, #14
   131c0:	fb96 f6f3 	sdiv	r6, r6, r3
        int scaled = simfloat2int(proportion * max_value);
   131c4:	f44f 5390 	mov.w	r3, #4608	; 0x1200
   131c8:	435e      	muls	r6, r3
                        if (function[ch] == HEM_MIDI_PB_OUT) {
   131ca:	6f23      	ldr	r3, [r4, #112]	; 0x70
   131cc:	2b06      	cmp	r3, #6
   131ce:	ea4f 36a6 	mov.w	r6, r6, asr #14
   131d2:	d10a      	bne.n	131ea <hMIDIIn::Controller()+0x246>
                            Out(ch, Proportion(data, 0x7fff, HEMISPHERE_3V_CV));
   131d4:	2300      	movs	r3, #0
   131d6:	4632      	mov	r2, r6
   131d8:	4619      	mov	r1, r3
   131da:	4620      	mov	r0, r4
   131dc:	f7f5 fe7b 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                            log_this = 1;
   131e0:	f04f 0901 	mov.w	r9, #1
                        if (function[ch] == HEM_MIDI_PB_OUT) {
   131e4:	6f63      	ldr	r3, [r4, #116]	; 0x74
   131e6:	2b06      	cmp	r3, #6
   131e8:	e7aa      	b.n	13140 <hMIDIIn::Controller()+0x19c>
                bool log_this = false;
   131ea:	f04f 0900 	mov.w	r9, #0
   131ee:	e7f9      	b.n	131e4 <hMIDIIn::Controller()+0x240>
   131f0:	20006884 	.word	0x20006884
   131f4:	2000675e 	.word	0x2000675e
   131f8:	2000675f 	.word	0x2000675f
   131fc:	2000675d 	.word	0x2000675d
   13200:	200046cc 	.word	0x200046cc

00013204 <hMIDIIn::log_entry(int, int)>:
    void log_entry(int y, int index) {
   13204:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        if (log[index].message == HEM_MIDI_NOTE_ON) {
   13206:	270c      	movs	r7, #12
   13208:	fb07 0702 	mla	r7, r7, r2, r0
    void log_entry(int y, int index) {
   1320c:	460d      	mov	r5, r1
        if (log[index].message == HEM_MIDI_NOTE_ON) {
   1320e:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
   13212:	2901      	cmp	r1, #1
    void log_entry(int y, int index) {
   13214:	4604      	mov	r4, r0
   13216:	4616      	mov	r6, r2
        if (log[index].message == HEM_MIDI_NOTE_ON) {
   13218:	d117      	bne.n	1324a <hMIDIIn::log_entry(int, int)+0x46>
            gfxBitmap(1, y, 8, NOTE_ICON);
   1321a:	4b3e      	ldr	r3, [pc, #248]	; (13314 <hMIDIIn::log_entry(int, int)+0x110>)
   1321c:	9300      	str	r3, [sp, #0]
   1321e:	6980      	ldr	r0, [r0, #24]
   13220:	2308      	movs	r3, #8
   13222:	462a      	mov	r2, r5
   13224:	f7f1 fbb6 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10, y, midi_note_numbers[log[index].data1]);
   13228:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   1322c:	4b3a      	ldr	r3, [pc, #232]	; (13318 <hMIDIIn::log_entry(int, int)+0x114>)
   1322e:	210a      	movs	r1, #10
   13230:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13234:	4620      	mov	r0, r4
   13236:	462a      	mov	r2, r5
   13238:	f7f5 f956 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(40, y, log[index].data2);
   1323c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   13240:	69a0      	ldr	r0, [r4, #24]
   13242:	462a      	mov	r2, r5
   13244:	2128      	movs	r1, #40	; 0x28
   13246:	f7f1 fc13 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (log[index].message == HEM_MIDI_NOTE_OFF) {
   1324a:	270c      	movs	r7, #12
   1324c:	fb07 4706 	mla	r7, r7, r6, r4
   13250:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   13254:	b97b      	cbnz	r3, 13276 <hMIDIIn::log_entry(int, int)+0x72>
            gfxPrint(1, y, "-");
   13256:	4b31      	ldr	r3, [pc, #196]	; (1331c <hMIDIIn::log_entry(int, int)+0x118>)
   13258:	462a      	mov	r2, r5
   1325a:	2101      	movs	r1, #1
   1325c:	4620      	mov	r0, r4
   1325e:	f7f5 f943 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(10, y, midi_note_numbers[log[index].data1]);
   13262:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   13266:	4b2c      	ldr	r3, [pc, #176]	; (13318 <hMIDIIn::log_entry(int, int)+0x114>)
   13268:	210a      	movs	r1, #10
   1326a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1326e:	4620      	mov	r0, r4
   13270:	462a      	mov	r2, r5
   13272:	f7f5 f939 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (log[index].message == HEM_MIDI_CC) {
   13276:	270c      	movs	r7, #12
   13278:	fb07 4706 	mla	r7, r7, r6, r4
   1327c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   13280:	2b03      	cmp	r3, #3
   13282:	d10e      	bne.n	132a2 <hMIDIIn::log_entry(int, int)+0x9e>
            gfxBitmap(1, y, 8, MOD_ICON);
   13284:	4b26      	ldr	r3, [pc, #152]	; (13320 <hMIDIIn::log_entry(int, int)+0x11c>)
   13286:	69a0      	ldr	r0, [r4, #24]
   13288:	9300      	str	r3, [sp, #0]
   1328a:	462a      	mov	r2, r5
   1328c:	2308      	movs	r3, #8
   1328e:	2101      	movs	r1, #1
   13290:	f7f1 fb80 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10, y, log[index].data2);
   13294:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   13298:	69a0      	ldr	r0, [r4, #24]
   1329a:	462a      	mov	r2, r5
   1329c:	210a      	movs	r1, #10
   1329e:	f7f1 fbe7 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (log[index].message == HEM_MIDI_AFTERTOUCH) {
   132a2:	270c      	movs	r7, #12
   132a4:	fb07 4706 	mla	r7, r7, r6, r4
   132a8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   132ac:	2b05      	cmp	r3, #5
   132ae:	d10e      	bne.n	132ce <hMIDIIn::log_entry(int, int)+0xca>
            gfxBitmap(1, y, 8, AFTERTOUCH_ICON);
   132b0:	4b1c      	ldr	r3, [pc, #112]	; (13324 <hMIDIIn::log_entry(int, int)+0x120>)
   132b2:	69a0      	ldr	r0, [r4, #24]
   132b4:	9300      	str	r3, [sp, #0]
   132b6:	462a      	mov	r2, r5
   132b8:	2308      	movs	r3, #8
   132ba:	2101      	movs	r1, #1
   132bc:	f7f1 fb6a 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10, y, log[index].data2);
   132c0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   132c4:	69a0      	ldr	r0, [r4, #24]
   132c6:	462a      	mov	r2, r5
   132c8:	210a      	movs	r1, #10
   132ca:	f7f1 fbd1 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (log[index].message == HEM_MIDI_PITCHBEND) {
   132ce:	230c      	movs	r3, #12
   132d0:	fb03 4606 	mla	r6, r3, r6, r4
   132d4:	f8d6 30a8 	ldr.w	r3, [r6, #168]	; 0xa8
   132d8:	2b06      	cmp	r3, #6
   132da:	d118      	bne.n	1330e <hMIDIIn::log_entry(int, int)+0x10a>
            int data = (log[index].data2 << 7) + log[index].data1 - 8192;
   132dc:	f8d6 30b0 	ldr.w	r3, [r6, #176]	; 0xb0
   132e0:	f8d6 60ac 	ldr.w	r6, [r6, #172]	; 0xac
            gfxBitmap(1, y, 8, BEND_ICON);
   132e4:	69a0      	ldr	r0, [r4, #24]
            int data = (log[index].data2 << 7) + log[index].data1 - 8192;
   132e6:	eb06 16c3 	add.w	r6, r6, r3, lsl #7
            gfxBitmap(1, y, 8, BEND_ICON);
   132ea:	4b0f      	ldr	r3, [pc, #60]	; (13328 <hMIDIIn::log_entry(int, int)+0x124>)
   132ec:	9300      	str	r3, [sp, #0]
   132ee:	462a      	mov	r2, r5
   132f0:	2308      	movs	r3, #8
   132f2:	2101      	movs	r1, #1
   132f4:	f7f1 fb4e 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            int data = (log[index].data2 << 7) + log[index].data1 - 8192;
   132f8:	f5a6 5600 	sub.w	r6, r6, #8192	; 0x2000
            gfxPrint(10, y, data);
   132fc:	69a0      	ldr	r0, [r4, #24]
   132fe:	4633      	mov	r3, r6
   13300:	462a      	mov	r2, r5
   13302:	210a      	movs	r1, #10
    }
   13304:	b003      	add	sp, #12
   13306:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            gfxPrint(10, y, data);
   1330a:	f7f1 bbb1 	b.w	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
    }
   1330e:	b003      	add	sp, #12
   13310:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13312:	bf00      	nop
   13314:	00024228 	.word	0x00024228
   13318:	00023f34 	.word	0x00023f34
   1331c:	0001f2ef 	.word	0x0001f2ef
   13320:	000241f8 	.word	0x000241f8
   13324:	00023ed8 	.word	0x00023ed8
   13328:	00024200 	.word	0x00024200

0001332c <hMIDIIn::DrawSelector()>:
    void DrawSelector() {
   1332c:	b513      	push	{r0, r1, r4, lr}
   1332e:	4604      	mov	r4, r0
        gfxPrint(1, 15, "Ch:");
   13330:	4b28      	ldr	r3, [pc, #160]	; (133d4 <hMIDIIn::DrawSelector()+0xa8>)
   13332:	220f      	movs	r2, #15
   13334:	2101      	movs	r1, #1
   13336:	f7f5 f8d7 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(24, 15, channel + 1);
   1333a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   1333c:	69a0      	ldr	r0, [r4, #24]
   1333e:	3301      	adds	r3, #1
   13340:	220f      	movs	r2, #15
   13342:	2118      	movs	r1, #24
   13344:	f7f1 fb94 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (hemisphere == 0) gfxPrint(1, 25, "A :");
   13348:	7923      	ldrb	r3, [r4, #4]
   1334a:	2b00      	cmp	r3, #0
   1334c:	d13d      	bne.n	133ca <hMIDIIn::DrawSelector()+0x9e>
   1334e:	4b22      	ldr	r3, [pc, #136]	; (133d8 <hMIDIIn::DrawSelector()+0xac>)
        else gfxPrint(1, 25, "C :");
   13350:	2219      	movs	r2, #25
   13352:	2101      	movs	r1, #1
   13354:	4620      	mov	r0, r4
   13356:	f7f5 f8c7 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(24, 25, fn_name[function[0]]);
   1335a:	6f23      	ldr	r3, [r4, #112]	; 0x70
   1335c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   13360:	2219      	movs	r2, #25
   13362:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   13366:	2118      	movs	r1, #24
   13368:	4620      	mov	r0, r4
   1336a:	f7f5 f8bd 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (hemisphere == 0) gfxPrint(1, 35, "B :");
   1336e:	7923      	ldrb	r3, [r4, #4]
   13370:	bb6b      	cbnz	r3, 133ce <hMIDIIn::DrawSelector()+0xa2>
   13372:	4b1a      	ldr	r3, [pc, #104]	; (133dc <hMIDIIn::DrawSelector()+0xb0>)
        else gfxPrint(1, 35, "D :");
   13374:	2223      	movs	r2, #35	; 0x23
   13376:	2101      	movs	r1, #1
   13378:	4620      	mov	r0, r4
   1337a:	f7f5 f8b5 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(24, 35, fn_name[function[1]]);
   1337e:	6f63      	ldr	r3, [r4, #116]	; 0x74
   13380:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   13384:	2223      	movs	r2, #35	; 0x23
   13386:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   1338a:	2118      	movs	r1, #24
   1338c:	4620      	mov	r0, r4
   1338e:	f7f5 f8ab 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxCursor(24, 23 + (cursor * 10), 39);
   13392:	6fa2      	ldr	r2, [r4, #120]	; 0x78
   13394:	230a      	movs	r3, #10
   13396:	435a      	muls	r2, r3
   13398:	3217      	adds	r2, #23
   1339a:	2327      	movs	r3, #39	; 0x27
   1339c:	2118      	movs	r1, #24
   1339e:	4620      	mov	r0, r4
   133a0:	f7f5 f896 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (log_index > 0) {
   133a4:	f8d4 20fc 	ldr.w	r2, [r4, #252]	; 0xfc
   133a8:	2a00      	cmp	r2, #0
   133aa:	dd04      	ble.n	133b6 <hMIDIIn::DrawSelector()+0x8a>
            log_entry(56, log_index - 1);
   133ac:	3a01      	subs	r2, #1
   133ae:	2138      	movs	r1, #56	; 0x38
   133b0:	4620      	mov	r0, r4
   133b2:	f7ff ff27 	bl	13204 <hMIDIIn::log_entry(int, int)>
        gfxInvert(0, 55, 63, 9);
   133b6:	2309      	movs	r3, #9
   133b8:	9300      	str	r3, [sp, #0]
   133ba:	2237      	movs	r2, #55	; 0x37
   133bc:	233f      	movs	r3, #63	; 0x3f
   133be:	2100      	movs	r1, #0
   133c0:	4620      	mov	r0, r4
   133c2:	f7f5 f8df 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
    }
   133c6:	b002      	add	sp, #8
   133c8:	bd10      	pop	{r4, pc}
        else gfxPrint(1, 25, "C :");
   133ca:	4b05      	ldr	r3, [pc, #20]	; (133e0 <hMIDIIn::DrawSelector()+0xb4>)
   133cc:	e7c0      	b.n	13350 <hMIDIIn::DrawSelector()+0x24>
        else gfxPrint(1, 35, "D :");
   133ce:	4b05      	ldr	r3, [pc, #20]	; (133e4 <hMIDIIn::DrawSelector()+0xb8>)
   133d0:	e7d0      	b.n	13374 <hMIDIIn::DrawSelector()+0x48>
   133d2:	bf00      	nop
   133d4:	00021325 	.word	0x00021325
   133d8:	00021329 	.word	0x00021329
   133dc:	00021331 	.word	0x00021331
   133e0:	0002132d 	.word	0x0002132d
   133e4:	00021335 	.word	0x00021335

000133e8 <hMIDIIn::View()>:
        gfxHeader(applet_name());
   133e8:	6803      	ldr	r3, [r0, #0]
    void View() {
   133ea:	b537      	push	{r0, r1, r2, r4, r5, lr}
        gfxHeader(applet_name());
   133ec:	681b      	ldr	r3, [r3, #0]
    void View() {
   133ee:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   133f0:	4798      	blx	r3
   133f2:	4601      	mov	r1, r0
   133f4:	4620      	mov	r0, r4
   133f6:	f7f5 f902 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        if (OC::CORE::ticks - last_tick < 4000) {
   133fa:	4b14      	ldr	r3, [pc, #80]	; (1344c <hMIDIIn::View()+0x64>)
   133fc:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
   133fe:	681b      	ldr	r3, [r3, #0]
   13400:	1a9b      	subs	r3, r3, r2
   13402:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
   13406:	d207      	bcs.n	13418 <hMIDIIn::View()+0x30>
            gfxBitmap(46, 1, 8, MIDI_ICON);
   13408:	4b11      	ldr	r3, [pc, #68]	; (13450 <hMIDIIn::View()+0x68>)
   1340a:	9300      	str	r3, [sp, #0]
   1340c:	69a0      	ldr	r0, [r4, #24]
   1340e:	2308      	movs	r3, #8
   13410:	2201      	movs	r2, #1
   13412:	212e      	movs	r1, #46	; 0x2e
   13414:	f7f1 fabe 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        if (cursor == 3) DrawLog();
   13418:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   1341a:	2b03      	cmp	r3, #3
   1341c:	d112      	bne.n	13444 <hMIDIIn::View()+0x5c>
        if (log_index) {
   1341e:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
   13422:	b96b      	cbnz	r3, 13440 <hMIDIIn::View()+0x58>
    }
   13424:	b003      	add	sp, #12
   13426:	bd30      	pop	{r4, r5, pc}
                log_entry(15 + (i * 8), i);
   13428:	00e9      	lsls	r1, r5, #3
   1342a:	462a      	mov	r2, r5
   1342c:	310f      	adds	r1, #15
   1342e:	4620      	mov	r0, r4
   13430:	f7ff fee8 	bl	13204 <hMIDIIn::log_entry(int, int)>
            for (int i = 0; i < log_index; i++)
   13434:	3501      	adds	r5, #1
   13436:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
   1343a:	429d      	cmp	r5, r3
   1343c:	dbf4      	blt.n	13428 <hMIDIIn::View()+0x40>
   1343e:	e7f1      	b.n	13424 <hMIDIIn::View()+0x3c>
   13440:	2500      	movs	r5, #0
   13442:	e7f8      	b.n	13436 <hMIDIIn::View()+0x4e>
        else DrawSelector();
   13444:	4620      	mov	r0, r4
   13446:	f7ff ff71 	bl	1332c <hMIDIIn::DrawSelector()>
    }
   1344a:	e7eb      	b.n	13424 <hMIDIIn::View()+0x3c>
   1344c:	200046cc 	.word	0x200046cc
   13450:	00024220 	.word	0x00024220

00013454 <hMIDIOut::UpdateLog(int, int, int)>:
    void UpdateLog(int message, int data1, int data2) {
   13454:	b570      	push	{r4, r5, r6, lr}
   13456:	4604      	mov	r4, r0
        log[log_index++] = {message, data1, data2};
   13458:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
   1345c:	260c      	movs	r6, #12
   1345e:	1c45      	adds	r5, r0, #1
   13460:	fb06 4000 	mla	r0, r6, r0, r4
        if (log_index == 7) {
   13464:	2d07      	cmp	r5, #7
        log[log_index++] = {message, data1, data2};
   13466:	f8c4 50fc 	str.w	r5, [r4, #252]	; 0xfc
   1346a:	f8c0 10a8 	str.w	r1, [r0, #168]	; 0xa8
   1346e:	f8c0 20ac 	str.w	r2, [r0, #172]	; 0xac
   13472:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
        if (log_index == 7) {
   13476:	d110      	bne.n	1349a <hMIDIOut::UpdateLog(int, int, int)+0x46>
   13478:	f104 05a8 	add.w	r5, r4, #168	; 0xa8
   1347c:	f104 06f0 	add.w	r6, r4, #240	; 0xf0
                memcpy(&log[i], &log[i+1], sizeof(log[i+1]));
   13480:	4628      	mov	r0, r5
   13482:	350c      	adds	r5, #12
   13484:	220c      	movs	r2, #12
   13486:	4629      	mov	r1, r5
   13488:	f006 fdb2 	bl	19ff0 <memcpy>
            for (int i = 0; i < 6; i++)
   1348c:	42b5      	cmp	r5, r6
   1348e:	d1f7      	bne.n	13480 <hMIDIOut::UpdateLog(int, int, int)+0x2c>
            log_index--;
   13490:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
   13494:	3b01      	subs	r3, #1
   13496:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    }
   1349a:	bd70      	pop	{r4, r5, r6, pc}

0001349c <hMIDIOut::DrawSelector()>:
    void DrawSelector() {
   1349c:	b513      	push	{r0, r1, r4, lr}
   1349e:	4604      	mov	r4, r0
        gfxPrint(1, 15, "Ch:");
   134a0:	4b3b      	ldr	r3, [pc, #236]	; (13590 <hMIDIOut::DrawSelector()+0xf4>)
   134a2:	220f      	movs	r2, #15
   134a4:	2101      	movs	r1, #1
   134a6:	f7f5 f81f 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(24, 15, channel + 1);
   134aa:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   134ac:	69a0      	ldr	r0, [r4, #24]
   134ae:	3301      	adds	r3, #1
   134b0:	220f      	movs	r2, #15
   134b2:	2118      	movs	r1, #24
   134b4:	f7f1 fadc 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxPrint(1, 25, "Tr:");
   134b8:	4b36      	ldr	r3, [pc, #216]	; (13594 <hMIDIOut::DrawSelector()+0xf8>)
   134ba:	2219      	movs	r2, #25
   134bc:	2101      	movs	r1, #1
   134be:	4620      	mov	r0, r4
   134c0:	f7f5 f812 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (transpose > -1) gfxPrint(24, 25, "+");
   134c4:	6f63      	ldr	r3, [r4, #116]	; 0x74
   134c6:	2b00      	cmp	r3, #0
   134c8:	db05      	blt.n	134d6 <hMIDIOut::DrawSelector()+0x3a>
   134ca:	4b33      	ldr	r3, [pc, #204]	; (13598 <hMIDIOut::DrawSelector()+0xfc>)
   134cc:	2219      	movs	r2, #25
   134ce:	2118      	movs	r1, #24
   134d0:	4620      	mov	r0, r4
   134d2:	f7f5 f809 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(30, 25, transpose);
   134d6:	6f63      	ldr	r3, [r4, #116]	; 0x74
   134d8:	69a0      	ldr	r0, [r4, #24]
   134da:	2219      	movs	r2, #25
   134dc:	211e      	movs	r1, #30
   134de:	f7f1 fac7 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxPrint(1, 35, "i2:");
   134e2:	4b2e      	ldr	r3, [pc, #184]	; (1359c <hMIDIOut::DrawSelector()+0x100>)
   134e4:	2223      	movs	r2, #35	; 0x23
   134e6:	2101      	movs	r1, #1
   134e8:	4620      	mov	r0, r4
   134ea:	f7f4 fffd 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(24, 35, fn_name[function]);
   134ee:	6f23      	ldr	r3, [r4, #112]	; 0x70
   134f0:	3326      	adds	r3, #38	; 0x26
   134f2:	2223      	movs	r2, #35	; 0x23
   134f4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   134f8:	2118      	movs	r1, #24
   134fa:	4620      	mov	r0, r4
   134fc:	f7f4 fff4 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        gfxPrint(1, 45, "Legato ");
   13500:	4b27      	ldr	r3, [pc, #156]	; (135a0 <hMIDIOut::DrawSelector()+0x104>)
   13502:	222d      	movs	r2, #45	; 0x2d
   13504:	2101      	movs	r1, #1
   13506:	4620      	mov	r0, r4
   13508:	f7f4 ffee 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor != 3 || CursorBlink()) gfxIcon(54, 45, legato ? CHECK_ON_ICON : CHECK_OFF_ICON);
   1350c:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
   1350e:	2b03      	cmp	r3, #3
   13510:	d102      	bne.n	13518 <hMIDIOut::DrawSelector()+0x7c>
   13512:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   13514:	2b00      	cmp	r3, #0
   13516:	dd0a      	ble.n	1352e <hMIDIOut::DrawSelector()+0x92>
   13518:	6fa1      	ldr	r1, [r4, #120]	; 0x78
   1351a:	4a22      	ldr	r2, [pc, #136]	; (135a4 <hMIDIOut::DrawSelector()+0x108>)
   1351c:	4b22      	ldr	r3, [pc, #136]	; (135a8 <hMIDIOut::DrawSelector()+0x10c>)
   1351e:	69a0      	ldr	r0, [r4, #24]
   13520:	2900      	cmp	r1, #0
   13522:	bf08      	it	eq
   13524:	4613      	moveq	r3, r2
   13526:	222d      	movs	r2, #45	; 0x2d
   13528:	2136      	movs	r1, #54	; 0x36
   1352a:	f7f1 fa39 	bl	49a0 <HemisphereApplet::gfxIcon(int, int, unsigned char const*) [clone .isra.0]>
        if (cursor < 3) gfxCursor(24, 23 + (cursor * 10), 39);
   1352e:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
   13530:	2a02      	cmp	r2, #2
   13532:	dc07      	bgt.n	13544 <hMIDIOut::DrawSelector()+0xa8>
   13534:	230a      	movs	r3, #10
   13536:	435a      	muls	r2, r3
   13538:	3217      	adds	r2, #23
   1353a:	2327      	movs	r3, #39	; 0x27
   1353c:	2118      	movs	r1, #24
   1353e:	4620      	mov	r0, r4
   13540:	f7f4 ffc6 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (last_velocity) {
   13544:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   13548:	b1c3      	cbz	r3, 1357c <hMIDIOut::DrawSelector()+0xe0>
            gfxBitmap(1, 56, 8, NOTE_ICON);
   1354a:	4b18      	ldr	r3, [pc, #96]	; (135ac <hMIDIOut::DrawSelector()+0x110>)
   1354c:	69a0      	ldr	r0, [r4, #24]
   1354e:	9300      	str	r3, [sp, #0]
   13550:	2238      	movs	r2, #56	; 0x38
   13552:	2308      	movs	r3, #8
   13554:	2101      	movs	r1, #1
   13556:	f7f1 fa1d 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10, 56, midi_note_numbers[last_note]);
   1355a:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   1355e:	4b14      	ldr	r3, [pc, #80]	; (135b0 <hMIDIOut::DrawSelector()+0x114>)
   13560:	210a      	movs	r1, #10
   13562:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13566:	4620      	mov	r0, r4
   13568:	2238      	movs	r2, #56	; 0x38
   1356a:	f7f4 ffbd 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(40, 56, last_velocity);
   1356e:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   13572:	69a0      	ldr	r0, [r4, #24]
   13574:	2238      	movs	r2, #56	; 0x38
   13576:	2128      	movs	r1, #40	; 0x28
   13578:	f7f1 fa7a 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxInvert(0, 55, 63, 9);
   1357c:	2309      	movs	r3, #9
   1357e:	9300      	str	r3, [sp, #0]
   13580:	2237      	movs	r2, #55	; 0x37
   13582:	233f      	movs	r3, #63	; 0x3f
   13584:	2100      	movs	r1, #0
   13586:	4620      	mov	r0, r4
   13588:	f7f4 fffc 	bl	8584 <HemisphereApplet::gfxInvert(int, int, int, int)>
    }
   1358c:	b002      	add	sp, #8
   1358e:	bd10      	pop	{r4, pc}
   13590:	00021325 	.word	0x00021325
   13594:	00021339 	.word	0x00021339
   13598:	0001e41c 	.word	0x0001e41c
   1359c:	0002133d 	.word	0x0002133d
   135a0:	00021341 	.word	0x00021341
   135a4:	00023ec0 	.word	0x00023ec0
   135a8:	00023d38 	.word	0x00023d38
   135ac:	00024228 	.word	0x00024228
   135b0:	00023f34 	.word	0x00023f34

000135b4 <hMIDIOut::log_entry(int, int)>:
    void log_entry(int y, int index) {
   135b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        if (log[index].message == HEM_MIDI_NOTE_ON) {
   135b6:	270c      	movs	r7, #12
   135b8:	fb07 0702 	mla	r7, r7, r2, r0
    void log_entry(int y, int index) {
   135bc:	460d      	mov	r5, r1
        if (log[index].message == HEM_MIDI_NOTE_ON) {
   135be:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
   135c2:	2901      	cmp	r1, #1
    void log_entry(int y, int index) {
   135c4:	4604      	mov	r4, r0
   135c6:	4616      	mov	r6, r2
        if (log[index].message == HEM_MIDI_NOTE_ON) {
   135c8:	d117      	bne.n	135fa <hMIDIOut::log_entry(int, int)+0x46>
            gfxBitmap(1, y, 8, NOTE_ICON);
   135ca:	4b3b      	ldr	r3, [pc, #236]	; (136b8 <hMIDIOut::log_entry(int, int)+0x104>)
   135cc:	9300      	str	r3, [sp, #0]
   135ce:	6980      	ldr	r0, [r0, #24]
   135d0:	2308      	movs	r3, #8
   135d2:	462a      	mov	r2, r5
   135d4:	f7f1 f9de 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10, y, midi_note_numbers[log[index].data1]);
   135d8:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   135dc:	4b37      	ldr	r3, [pc, #220]	; (136bc <hMIDIOut::log_entry(int, int)+0x108>)
   135de:	210a      	movs	r1, #10
   135e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   135e4:	4620      	mov	r0, r4
   135e6:	462a      	mov	r2, r5
   135e8:	f7f4 ff7e 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(40, y, log[index].data2);
   135ec:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   135f0:	69a0      	ldr	r0, [r4, #24]
   135f2:	462a      	mov	r2, r5
   135f4:	2128      	movs	r1, #40	; 0x28
   135f6:	f7f1 fa3b 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (log[index].message == HEM_MIDI_NOTE_OFF) {
   135fa:	270c      	movs	r7, #12
   135fc:	fb07 4706 	mla	r7, r7, r6, r4
   13600:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   13604:	b97b      	cbnz	r3, 13626 <hMIDIOut::log_entry(int, int)+0x72>
            gfxPrint(1, y, "-");
   13606:	4b2e      	ldr	r3, [pc, #184]	; (136c0 <hMIDIOut::log_entry(int, int)+0x10c>)
   13608:	462a      	mov	r2, r5
   1360a:	2101      	movs	r1, #1
   1360c:	4620      	mov	r0, r4
   1360e:	f7f4 ff6b 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
            gfxPrint(10, y, midi_note_numbers[log[index].data1]);
   13612:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   13616:	4b29      	ldr	r3, [pc, #164]	; (136bc <hMIDIOut::log_entry(int, int)+0x108>)
   13618:	210a      	movs	r1, #10
   1361a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1361e:	4620      	mov	r0, r4
   13620:	462a      	mov	r2, r5
   13622:	f7f4 ff61 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (log[index].message == HEM_MIDI_CC) {
   13626:	270c      	movs	r7, #12
   13628:	fb07 4706 	mla	r7, r7, r6, r4
   1362c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   13630:	2b03      	cmp	r3, #3
   13632:	d10e      	bne.n	13652 <hMIDIOut::log_entry(int, int)+0x9e>
            gfxBitmap(1, y, 8, MOD_ICON);
   13634:	4b23      	ldr	r3, [pc, #140]	; (136c4 <hMIDIOut::log_entry(int, int)+0x110>)
   13636:	69a0      	ldr	r0, [r4, #24]
   13638:	9300      	str	r3, [sp, #0]
   1363a:	462a      	mov	r2, r5
   1363c:	2308      	movs	r3, #8
   1363e:	2101      	movs	r1, #1
   13640:	f7f1 f9a8 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10, y, log[index].data1);
   13644:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   13648:	69a0      	ldr	r0, [r4, #24]
   1364a:	462a      	mov	r2, r5
   1364c:	210a      	movs	r1, #10
   1364e:	f7f1 fa0f 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (log[index].message == HEM_MIDI_AFTERTOUCH) {
   13652:	270c      	movs	r7, #12
   13654:	fb07 4706 	mla	r7, r7, r6, r4
   13658:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   1365c:	2b05      	cmp	r3, #5
   1365e:	d10e      	bne.n	1367e <hMIDIOut::log_entry(int, int)+0xca>
            gfxBitmap(1, y, 8, AFTERTOUCH_ICON);
   13660:	4b19      	ldr	r3, [pc, #100]	; (136c8 <hMIDIOut::log_entry(int, int)+0x114>)
   13662:	69a0      	ldr	r0, [r4, #24]
   13664:	9300      	str	r3, [sp, #0]
   13666:	462a      	mov	r2, r5
   13668:	2308      	movs	r3, #8
   1366a:	2101      	movs	r1, #1
   1366c:	f7f1 f992 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10, y, log[index].data1);
   13670:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   13674:	69a0      	ldr	r0, [r4, #24]
   13676:	462a      	mov	r2, r5
   13678:	210a      	movs	r1, #10
   1367a:	f7f1 f9f9 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        if (log[index].message == HEM_MIDI_PITCHBEND) {
   1367e:	230c      	movs	r3, #12
   13680:	fb03 4606 	mla	r6, r3, r6, r4
   13684:	f8d6 30a8 	ldr.w	r3, [r6, #168]	; 0xa8
   13688:	2b06      	cmp	r3, #6
   1368a:	d112      	bne.n	136b2 <hMIDIOut::log_entry(int, int)+0xfe>
            gfxBitmap(1, y, 8, BEND_ICON);
   1368c:	4b0f      	ldr	r3, [pc, #60]	; (136cc <hMIDIOut::log_entry(int, int)+0x118>)
            int data = log[index].data1;
   1368e:	f8d6 60ac 	ldr.w	r6, [r6, #172]	; 0xac
            gfxBitmap(1, y, 8, BEND_ICON);
   13692:	69a0      	ldr	r0, [r4, #24]
   13694:	9300      	str	r3, [sp, #0]
   13696:	462a      	mov	r2, r5
   13698:	2308      	movs	r3, #8
   1369a:	2101      	movs	r1, #1
   1369c:	f7f1 f97a 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
            gfxPrint(10, y, data);
   136a0:	69a0      	ldr	r0, [r4, #24]
   136a2:	4633      	mov	r3, r6
   136a4:	462a      	mov	r2, r5
   136a6:	210a      	movs	r1, #10
    }
   136a8:	b003      	add	sp, #12
   136aa:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            gfxPrint(10, y, data);
   136ae:	f7f1 b9df 	b.w	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
    }
   136b2:	b003      	add	sp, #12
   136b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   136b6:	bf00      	nop
   136b8:	00024228 	.word	0x00024228
   136bc:	00023f34 	.word	0x00023f34
   136c0:	0001f2ef 	.word	0x0001f2ef
   136c4:	000241f8 	.word	0x000241f8
   136c8:	00023ed8 	.word	0x00023ed8
   136cc:	00024200 	.word	0x00024200

000136d0 <hMIDIOut::View()>:
        gfxHeader(applet_name());
   136d0:	6803      	ldr	r3, [r0, #0]
    void View() {
   136d2:	b537      	push	{r0, r1, r2, r4, r5, lr}
        gfxHeader(applet_name());
   136d4:	681b      	ldr	r3, [r3, #0]
    void View() {
   136d6:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   136d8:	4798      	blx	r3
   136da:	4601      	mov	r1, r0
   136dc:	4620      	mov	r0, r4
   136de:	f7f4 ff8e 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        if (OC::CORE::ticks - last_tick < 4000) {
   136e2:	4b15      	ldr	r3, [pc, #84]	; (13738 <hMIDIOut::View()+0x68>)
   136e4:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
   136e8:	681b      	ldr	r3, [r3, #0]
   136ea:	1a9b      	subs	r3, r3, r2
   136ec:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
   136f0:	d207      	bcs.n	13702 <hMIDIOut::View()+0x32>
            gfxBitmap(46, 1, 8, MIDI_ICON);
   136f2:	4b12      	ldr	r3, [pc, #72]	; (1373c <hMIDIOut::View()+0x6c>)
   136f4:	9300      	str	r3, [sp, #0]
   136f6:	69a0      	ldr	r0, [r4, #24]
   136f8:	2308      	movs	r3, #8
   136fa:	2201      	movs	r2, #1
   136fc:	212e      	movs	r1, #46	; 0x2e
   136fe:	f7f1 f949 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        if (cursor == 4) DrawLog();
   13702:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
   13704:	2b04      	cmp	r3, #4
   13706:	d112      	bne.n	1372e <hMIDIOut::View()+0x5e>
        if (log_index) {
   13708:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
   1370c:	b96b      	cbnz	r3, 1372a <hMIDIOut::View()+0x5a>
    }
   1370e:	b003      	add	sp, #12
   13710:	bd30      	pop	{r4, r5, pc}
                log_entry(15 + (i * 8), i);
   13712:	00e9      	lsls	r1, r5, #3
   13714:	462a      	mov	r2, r5
   13716:	310f      	adds	r1, #15
   13718:	4620      	mov	r0, r4
   1371a:	f7ff ff4b 	bl	135b4 <hMIDIOut::log_entry(int, int)>
            for (int i = 0; i < log_index; i++)
   1371e:	3501      	adds	r5, #1
   13720:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
   13724:	429d      	cmp	r5, r3
   13726:	dbf4      	blt.n	13712 <hMIDIOut::View()+0x42>
   13728:	e7f1      	b.n	1370e <hMIDIOut::View()+0x3e>
   1372a:	2500      	movs	r5, #0
   1372c:	e7f8      	b.n	13720 <hMIDIOut::View()+0x50>
        else DrawSelector();
   1372e:	4620      	mov	r0, r4
   13730:	f7ff feb4 	bl	1349c <hMIDIOut::DrawSelector()>
    }
   13734:	e7eb      	b.n	1370e <hMIDIOut::View()+0x3e>
   13736:	bf00      	nop
   13738:	200046cc 	.word	0x200046cc
   1373c:	00024220 	.word	0x00024220

00013740 <OC::save_global_settings()>:
AppDataStorage app_data_storage;

static constexpr int DEFAULT_APP_INDEX = 0;
static const uint16_t DEFAULT_APP_ID = available_apps[DEFAULT_APP_INDEX].id;

void save_global_settings() {
   13740:	b538      	push	{r3, r4, r5, lr}
  SERIAL_PRINTLN("Save global settings");

  memcpy(global_settings.user_scales, OC::user_scales, sizeof(OC::user_scales));
   13742:	4c26      	ldr	r4, [pc, #152]	; (137dc <OC::save_global_settings()+0x9c>)
   13744:	4926      	ldr	r1, [pc, #152]	; (137e0 <OC::save_global_settings()+0xa0>)
   13746:	22a0      	movs	r2, #160	; 0xa0
   13748:	f104 000c 	add.w	r0, r4, #12
   1374c:	f006 fc50 	bl	19ff0 <memcpy>
  memcpy(global_settings.user_patterns, OC::user_patterns, sizeof(OC::user_patterns));
   13750:	4924      	ldr	r1, [pc, #144]	; (137e4 <OC::save_global_settings()+0xa4>)
   13752:	f44f 7280 	mov.w	r2, #256	; 0x100
   13756:	f104 00ac 	add.w	r0, r4, #172	; 0xac
   1375a:	f006 fc49 	bl	19ff0 <memcpy>
  memcpy(global_settings.user_turing_machines, HS::user_turing_machines, sizeof(HS::user_turing_machines));
   1375e:	4922      	ldr	r1, [pc, #136]	; (137e8 <OC::save_global_settings()+0xa8>)
   13760:	22a0      	movs	r2, #160	; 0xa0
   13762:	f504 70d6 	add.w	r0, r4, #428	; 0x1ac
   13766:	f006 fc43 	bl	19ff0 <memcpy>
  memcpy(global_settings.user_waveforms, HS::user_waveforms, sizeof(HS::user_waveforms));
   1376a:	4920      	ldr	r1, [pc, #128]	; (137ec <OC::save_global_settings()+0xac>)
   1376c:	2280      	movs	r2, #128	; 0x80
   1376e:	f504 7013 	add.w	r0, r4, #588	; 0x24c
   13772:	f006 fc3d 	bl	19ff0 <memcpy>
  memcpy(global_settings.auto_calibration_data, OC::auto_calibration_data, sizeof(OC::auto_calibration_data));
   13776:	491e      	ldr	r1, [pc, #120]	; (137f0 <OC::save_global_settings()+0xb0>)
   13778:	2260      	movs	r2, #96	; 0x60
   1377a:	f504 7033 	add.w	r0, r4, #716	; 0x2cc
   1377e:	f006 fc37 	bl	19ff0 <memcpy>
  // scaling settings:
  global_settings.DAC_scaling = OC::DAC::store_scaling();
   13782:	f7ec ff39 	bl	5f8 <OC::DAC::store_scaling()>
   */
  bool Save(const DATA_TYPE &data) {

    bool dirty = false;
    const uint8_t *src = (const uint8_t*)&data;
    uint8_t *dst = (uint8_t*)&page_.data;
   13786:	4b1b      	ldr	r3, [pc, #108]	; (137f4 <OC::save_global_settings()+0xb4>)
   13788:	6060      	str	r0, [r4, #4]
    size_t length = sizeof(DATA_TYPE);
   1378a:	f44f 724b 	mov.w	r2, #812	; 0x32c
    bool dirty = false;
   1378e:	2100      	movs	r1, #0
    while (length--) {
   13790:	3a01      	subs	r2, #1
   13792:	d215      	bcs.n	137c0 <OC::save_global_settings()+0x80>
      }
      ++dst;
      ++src;
    }

    if (dirty) {
   13794:	b199      	cbz	r1, 137be <OC::save_global_settings()+0x7e>
      ++page_.header.generation;
   13796:	4a18      	ldr	r2, [pc, #96]	; (137f8 <OC::save_global_settings()+0xb8>)
   13798:	6893      	ldr	r3, [r2, #8]
   1379a:	3301      	adds	r3, #1
   1379c:	6093      	str	r3, [r2, #8]
  static uint16_t checksum(const page_data &page) {
    uint16_t c = 0;
    // header not included in crc
    const uint8_t *p = (const uint8_t *)&page.data;
    size_t length = sizeof(page_data) - sizeof(page_header);
    while (length--) {
   1379e:	f240 312d 	movw	r1, #813	; 0x32d
    const uint8_t *p = (const uint8_t *)&page.data;
   137a2:	f102 0010 	add.w	r0, r2, #16
    uint16_t c = 0;
   137a6:	2300      	movs	r3, #0
    while (length--) {
   137a8:	3901      	subs	r1, #1
   137aa:	d112      	bne.n	137d2 <OC::save_global_settings()+0x92>
      c += *p++;
    }

    return c ^ 0xffff;
   137ac:	43db      	mvns	r3, r3
      page_index_ = (page_index_ + 1) % PAGES;
   137ae:	6011      	str	r1, [r2, #0]
      page_.header.checksum = checksum(page_);
   137b0:	81d3      	strh	r3, [r2, #14]
        STORAGE::update(BASE_ADDR + page_index_ * PAGESIZE, &page_, sizeof(page_));
   137b2:	4912      	ldr	r1, [pc, #72]	; (137fc <OC::save_global_settings()+0xbc>)
   137b4:	f44f 724e 	mov.w	r2, #824	; 0x338
   137b8:	2080      	movs	r0, #128	; 0x80
   137ba:	f7f1 fc07 	bl	4fcc <EEPROMStorage::update(unsigned int, void const*, unsigned int)>
  
  global_settings_storage.Save(global_settings);
  SERIAL_PRINTLN("Saved global settings: page_index %d", global_settings_storage.page_index());
}
   137be:	bd38      	pop	{r3, r4, r5, pc}
      if (*dst != *src) {
   137c0:	781d      	ldrb	r5, [r3, #0]
   137c2:	f814 0b01 	ldrb.w	r0, [r4], #1
   137c6:	4285      	cmp	r5, r0
        *dst = *src;
   137c8:	bf1c      	itt	ne
   137ca:	7018      	strbne	r0, [r3, #0]
        dirty = true;
   137cc:	2101      	movne	r1, #1
      ++dst;
   137ce:	3301      	adds	r3, #1
   137d0:	e7de      	b.n	13790 <OC::save_global_settings()+0x50>
      c += *p++;
   137d2:	f810 4b01 	ldrb.w	r4, [r0], #1
   137d6:	4423      	add	r3, r4
   137d8:	b29b      	uxth	r3, r3
   137da:	e7e5      	b.n	137a8 <OC::save_global_settings()+0x68>
   137dc:	20003b70 	.word	0x20003b70
   137e0:	1fffa728 	.word	0x1fffa728
   137e4:	1fffa628 	.word	0x1fffa628
   137e8:	200036e8 	.word	0x200036e8
   137ec:	20003668 	.word	0x20003668
   137f0:	1fffa528 	.word	0x1fffa528
   137f4:	2000439c 	.word	0x2000439c
   137f8:	2000438c 	.word	0x2000438c
   137fc:	20004390 	.word	0x20004390

00013800 <OC::save_app_data()>:

void save_app_data() {
   13800:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  SERIAL_PRINTLN("Save app data... (%u bytes available)", OC::AppData::kAppDataSize);

  app_settings.used = 0;
   13804:	4c35      	ldr	r4, [pc, #212]	; (138dc <OC::save_app_data()+0xdc>)
  char *data_end = data + OC::AppData::kAppDataSize;

  size_t start_app = random(NUM_AVAILABLE_APPS);
  for (size_t i = 0; i < NUM_AVAILABLE_APPS; ++i) {
    const auto &app = available_apps[(start_app + i) % NUM_AVAILABLE_APPS];
    size_t storage_size = app.storageSize() + sizeof(AppChunkHeader);
   13806:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 138e0 <OC::save_app_data()+0xe0>
  app_settings.used = 0;
   1380a:	2600      	movs	r6, #0
  size_t start_app = random(NUM_AVAILABLE_APPS);
   1380c:	200a      	movs	r0, #10
  app_settings.used = 0;
   1380e:	f8c4 63e4 	str.w	r6, [r4, #996]	; 0x3e4
  size_t start_app = random(NUM_AVAILABLE_APPS);
   13812:	f006 fb61 	bl	19ed8 <random(unsigned long)>
   13816:	46a2      	mov	sl, r4
   13818:	4607      	mov	r7, r0
    if (storage_size & 1) ++storage_size; // Align chunks on 2-byte boundaries
    if (storage_size > sizeof(AppChunkHeader) && app.Save) {
      if (data + storage_size > data_end) {
   1381a:	f504 7879 	add.w	r8, r4, #996	; 0x3e4
    const auto &app = available_apps[(start_app + i) % NUM_AVAILABLE_APPS];
   1381e:	230a      	movs	r3, #10
   13820:	19bd      	adds	r5, r7, r6
   13822:	fbb5 f2f3 	udiv	r2, r5, r3
   13826:	fb03 5512 	mls	r5, r3, r2, r5
    size_t storage_size = app.storageSize() + sizeof(AppChunkHeader);
   1382a:	2334      	movs	r3, #52	; 0x34
   1382c:	fb03 9305 	mla	r3, r3, r5, r9
   13830:	68db      	ldr	r3, [r3, #12]
   13832:	4798      	blx	r3
    if (storage_size & 1) ++storage_size; // Align chunks on 2-byte boundaries
   13834:	07c2      	lsls	r2, r0, #31
    size_t storage_size = app.storageSize() + sizeof(AppChunkHeader);
   13836:	f100 0304 	add.w	r3, r0, #4
    if (storage_size & 1) ++storage_size; // Align chunks on 2-byte boundaries
   1383a:	bf48      	it	mi
   1383c:	1d43      	addmi	r3, r0, #5
    if (storage_size > sizeof(AppChunkHeader) && app.Save) {
   1383e:	2b04      	cmp	r3, #4
   13840:	d91d      	bls.n	1387e <OC::save_app_data()+0x7e>
   13842:	2234      	movs	r2, #52	; 0x34
   13844:	4355      	muls	r5, r2
   13846:	eb09 0105 	add.w	r1, r9, r5
   1384a:	690a      	ldr	r2, [r1, #16]
   1384c:	b1ba      	cbz	r2, 1387e <OC::save_app_data()+0x7e>
      if (data + storage_size > data_end) {
   1384e:	18e0      	adds	r0, r4, r3
   13850:	4540      	cmp	r0, r8
   13852:	d814      	bhi.n	1387e <OC::save_app_data()+0x7e>
        SERIAL_PRINTLN("%s: ERROR: %u BYTES NEEDED, %u BYTES AVAILABLE OF %u BYTES TOTAL", app.name, storage_size, data_end - data, AppData::kAppDataSize);
        continue;
      }

      AppChunkHeader *chunk = reinterpret_cast<AppChunkHeader *>(data);
      chunk->id = app.id;
   13854:	f819 0005 	ldrb.w	r0, [r9, r5]
      chunk->length = storage_size;
   13858:	70a3      	strb	r3, [r4, #2]
      chunk->id = app.id;
   1385a:	7849      	ldrb	r1, [r1, #1]
   1385c:	7020      	strb	r0, [r4, #0]
      chunk->length = storage_size;
   1385e:	f3c3 2307 	ubfx	r3, r3, #8, #8
   13862:	70e3      	strb	r3, [r4, #3]
      chunk->id = app.id;
   13864:	7061      	strb	r1, [r4, #1]
      #ifdef PRINT_DEBUG
        SERIAL_PRINTLN("* %s (%02x) : Saved %u bytes... (%u)", app.name, app.id, app.Save(chunk + 1), storage_size);
      #else
        app.Save(chunk + 1);
   13866:	1d20      	adds	r0, r4, #4
   13868:	4790      	blx	r2
      #endif
      app_settings.used += chunk->length;
   1386a:	78e2      	ldrb	r2, [r4, #3]
   1386c:	78a3      	ldrb	r3, [r4, #2]
   1386e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   13872:	f8da 23e4 	ldr.w	r2, [sl, #996]	; 0x3e4
   13876:	441a      	add	r2, r3
   13878:	f8ca 23e4 	str.w	r2, [sl, #996]	; 0x3e4
      data += chunk->length;
   1387c:	441c      	add	r4, r3
  for (size_t i = 0; i < NUM_AVAILABLE_APPS; ++i) {
   1387e:	3601      	adds	r6, #1
   13880:	2e0a      	cmp	r6, #10
   13882:	d1cc      	bne.n	1381e <OC::save_app_data()+0x1e>
   13884:	4815      	ldr	r0, [pc, #84]	; (138dc <OC::save_app_data()+0xdc>)
    uint8_t *dst = (uint8_t*)&page_.data;
   13886:	4a17      	ldr	r2, [pc, #92]	; (138e4 <OC::save_app_data()+0xe4>)
   13888:	f240 33e9 	movw	r3, #1001	; 0x3e9
    bool dirty = false;
   1388c:	2100      	movs	r1, #0
    while (length--) {
   1388e:	3b01      	subs	r3, #1
   13890:	d116      	bne.n	138c0 <OC::save_app_data()+0xc0>
    if (dirty) {
   13892:	b199      	cbz	r1, 138bc <OC::save_app_data()+0xbc>
      ++page_.header.generation;
   13894:	4a14      	ldr	r2, [pc, #80]	; (138e8 <OC::save_app_data()+0xe8>)
   13896:	6891      	ldr	r1, [r2, #8]
   13898:	3101      	adds	r1, #1
   1389a:	6091      	str	r1, [r2, #8]
    const uint8_t *p = (const uint8_t *)&page.data;
   1389c:	f102 0010 	add.w	r0, r2, #16
    while (length--) {
   138a0:	f240 31e9 	movw	r1, #1001	; 0x3e9
   138a4:	3901      	subs	r1, #1
   138a6:	d114      	bne.n	138d2 <OC::save_app_data()+0xd2>
    return c ^ 0xffff;
   138a8:	43db      	mvns	r3, r3
      page_index_ = (page_index_ + 1) % PAGES;
   138aa:	6011      	str	r1, [r2, #0]
      page_.header.checksum = checksum(page_);
   138ac:	81d3      	strh	r3, [r2, #14]
        STORAGE::update(BASE_ADDR + page_index_ * PAGESIZE, &page_, sizeof(page_));
   138ae:	490f      	ldr	r1, [pc, #60]	; (138ec <OC::save_app_data()+0xec>)
   138b0:	f44f 727d 	mov.w	r2, #1012	; 0x3f4
   138b4:	f44f 7070 	mov.w	r0, #960	; 0x3c0
   138b8:	f7f1 fb88 	bl	4fcc <EEPROMStorage::update(unsigned int, void const*, unsigned int)>
    }
  }
  SERIAL_PRINTLN("App settings used: %u/%u", app_settings.used, EEPROM_APPDATA_BINARY_SIZE);
  app_data_storage.Save(app_settings);
  SERIAL_PRINTLN("Saved app settings in page_index %d", app_data_storage.page_index());
}
   138bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if (*dst != *src) {
   138c0:	7815      	ldrb	r5, [r2, #0]
   138c2:	f810 4b01 	ldrb.w	r4, [r0], #1
   138c6:	42a5      	cmp	r5, r4
        *dst = *src;
   138c8:	bf1c      	itt	ne
   138ca:	7014      	strbne	r4, [r2, #0]
        dirty = true;
   138cc:	2101      	movne	r1, #1
      ++dst;
   138ce:	3201      	adds	r2, #1
   138d0:	e7dd      	b.n	1388e <OC::save_app_data()+0x8e>
      c += *p++;
   138d2:	f810 4b01 	ldrb.w	r4, [r0], #1
   138d6:	4423      	add	r3, r4
   138d8:	b29b      	uxth	r3, r3
   138da:	e7e3      	b.n	138a4 <OC::save_app_data()+0xa4>
   138dc:	20003788 	.word	0x20003788
   138e0:	1fff9e54 	.word	0x1fff9e54
   138e4:	20003eac 	.word	0x20003eac
   138e8:	20003e9c 	.word	0x20003e9c
   138ec:	20003ea0 	.word	0x20003ea0

000138f0 <OC::apps::set_current_app(int)>:
}

namespace apps {

void set_current_app(int index) {
  current_app = &available_apps[index];
   138f0:	4b04      	ldr	r3, [pc, #16]	; (13904 <OC::apps::set_current_app(int)+0x14>)
   138f2:	2234      	movs	r2, #52	; 0x34
   138f4:	4350      	muls	r0, r2
   138f6:	4a04      	ldr	r2, [pc, #16]	; (13908 <OC::apps::set_current_app(int)+0x18>)
   138f8:	1819      	adds	r1, r3, r0
   138fa:	6011      	str	r1, [r2, #0]
  global_settings.current_app_id = current_app->id;
   138fc:	5a1a      	ldrh	r2, [r3, r0]
   138fe:	4b03      	ldr	r3, [pc, #12]	; (1390c <OC::apps::set_current_app(int)+0x1c>)
   13900:	811a      	strh	r2, [r3, #8]
}
   13902:	4770      	bx	lr
   13904:	1fff9e54 	.word	0x1fff9e54
   13908:	1fff9d90 	.word	0x1fff9d90
   1390c:	20003b70 	.word	0x20003b70

00013910 <OC::apps::find(unsigned short)>:

App *current_app = &available_apps[DEFAULT_APP_INDEX];

App *find(uint16_t id) {
   13910:	4602      	mov	r2, r0
   13912:	4805      	ldr	r0, [pc, #20]	; (13928 <OC::apps::find(unsigned short)+0x18>)
   13914:	230a      	movs	r3, #10
  for (auto &app : available_apps)
    if (app.id == id) return &app;
   13916:	8801      	ldrh	r1, [r0, #0]
   13918:	4291      	cmp	r1, r2
   1391a:	d004      	beq.n	13926 <OC::apps::find(unsigned short)+0x16>
  for (auto &app : available_apps)
   1391c:	3b01      	subs	r3, #1
   1391e:	f100 0034 	add.w	r0, r0, #52	; 0x34
   13922:	d1f8      	bne.n	13916 <OC::apps::find(unsigned short)+0x6>
  return nullptr;
   13924:	4618      	mov	r0, r3
}
   13926:	4770      	bx	lr
   13928:	1fff9e54 	.word	0x1fff9e54

0001392c <OC::restore_app_data()>:
void restore_app_data() {
   1392c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  const char *data_end = data + app_settings.used;
   13930:	4c1a      	ldr	r4, [pc, #104]	; (1399c <OC::restore_app_data()+0x70>)
   13932:	f8d4 73e4 	ldr.w	r7, [r4, #996]	; 0x3e4
   13936:	4427      	add	r7, r4
  while (data < data_end) {
   13938:	42bc      	cmp	r4, r7
   1393a:	d301      	bcc.n	13940 <OC::restore_app_data()+0x14>
}
   1393c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (data + chunk->length > data_end) {
   13940:	f894 8002 	ldrb.w	r8, [r4, #2]
   13944:	78e3      	ldrb	r3, [r4, #3]
   13946:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
   1394a:	eb04 0508 	add.w	r5, r4, r8
   1394e:	42bd      	cmp	r5, r7
   13950:	d8f4      	bhi.n	1393c <OC::restore_app_data()+0x10>
    App *app = apps::find(chunk->id);
   13952:	7823      	ldrb	r3, [r4, #0]
   13954:	7860      	ldrb	r0, [r4, #1]
   13956:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   1395a:	f7ff ffd9 	bl	13910 <OC::apps::find(unsigned short)>
    if (!app) {
   1395e:	4606      	mov	r6, r0
   13960:	b920      	cbnz	r0, 1396c <OC::restore_app_data()+0x40>
      if (!chunk->length)
   13962:	f1b8 0f00 	cmp.w	r8, #0
   13966:	d0e9      	beq.n	1393c <OC::restore_app_data()+0x10>
void restore_app_data() {
   13968:	462c      	mov	r4, r5
   1396a:	e7e5      	b.n	13938 <OC::restore_app_data()+0xc>
    size_t expected_length = app->storageSize() + sizeof(AppChunkHeader);
   1396c:	68c3      	ldr	r3, [r0, #12]
   1396e:	4798      	blx	r3
    if (chunk->length != expected_length) {
   13970:	78a5      	ldrb	r5, [r4, #2]
    if (expected_length & 0x1) ++expected_length;
   13972:	07c2      	lsls	r2, r0, #31
    if (chunk->length != expected_length) {
   13974:	78e2      	ldrb	r2, [r4, #3]
    size_t expected_length = app->storageSize() + sizeof(AppChunkHeader);
   13976:	f100 0304 	add.w	r3, r0, #4
    if (chunk->length != expected_length) {
   1397a:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
    if (expected_length & 0x1) ++expected_length;
   1397e:	bf48      	it	mi
   13980:	1d43      	addmi	r3, r0, #5
    if (chunk->length != expected_length) {
   13982:	429d      	cmp	r5, r3
   13984:	d001      	beq.n	1398a <OC::restore_app_data()+0x5e>
    data += chunk->length;
   13986:	4425      	add	r5, r4
   13988:	e7ee      	b.n	13968 <OC::restore_app_data()+0x3c>
    if (app->Restore) {
   1398a:	6973      	ldr	r3, [r6, #20]
   1398c:	b10b      	cbz	r3, 13992 <OC::restore_app_data()+0x66>
        app->Restore(chunk + 1);
   1398e:	1d20      	adds	r0, r4, #4
   13990:	4798      	blx	r3
    restored_bytes += chunk->length;
   13992:	78a5      	ldrb	r5, [r4, #2]
   13994:	78e3      	ldrb	r3, [r4, #3]
   13996:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
   1399a:	e7f4      	b.n	13986 <OC::restore_app_data()+0x5a>
   1399c:	20003788 	.word	0x20003788

000139a0 <OC::apps::index_of(unsigned short)>:

int index_of(uint16_t id) {
   139a0:	b510      	push	{r4, lr}
  int i = 0;
  for (const auto &app : available_apps) {
    if (app.id == id) return i;
   139a2:	4a06      	ldr	r2, [pc, #24]	; (139bc <OC::apps::index_of(unsigned short)+0x1c>)
int index_of(uint16_t id) {
   139a4:	4603      	mov	r3, r0
    if (app.id == id) return i;
   139a6:	2134      	movs	r1, #52	; 0x34
  int i = 0;
   139a8:	2000      	movs	r0, #0
    if (app.id == id) return i;
   139aa:	fb01 f400 	mul.w	r4, r1, r0
   139ae:	5aa4      	ldrh	r4, [r4, r2]
   139b0:	429c      	cmp	r4, r3
   139b2:	d002      	beq.n	139ba <OC::apps::index_of(unsigned short)+0x1a>
    ++i;
   139b4:	3001      	adds	r0, #1
  for (const auto &app : available_apps) {
   139b6:	280a      	cmp	r0, #10
   139b8:	d1f7      	bne.n	139aa <OC::apps::index_of(unsigned short)+0xa>
  }
  return i;
}
   139ba:	bd10      	pop	{r4, pc}
   139bc:	1fff9e54 	.word	0x1fff9e54

000139c0 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)>:
  delay(100);
}

}; // namespace apps

void draw_app_menu(const menu::ScreenCursor<5> &cursor) {
   139c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return write_ptr_ - read_ptr_;
   139c4:	4d32      	ldr	r5, [pc, #200]	; (13a90 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xd0>)
   139c6:	b089      	sub	sp, #36	; 0x24
   139c8:	4606      	mov	r6, r0
   139ca:	f8d5 2808 	ldr.w	r2, [r5, #2056]	; 0x808
   139ce:	f8d5 380c 	ldr.w	r3, [r5, #2060]	; 0x80c
  GRAPHICS_BEGIN_FRAME(true);
   139d2:	1a9b      	subs	r3, r3, r2
   139d4:	3302      	adds	r3, #2
   139d6:	d0f8      	beq.n	139ca <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xa>
    return frame_buffers_[write_ptr_ % frames];
   139d8:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
   139dc:	f003 0301 	and.w	r3, r3, #1
   139e0:	f503 7300 	add.w	r3, r3, #512	; 0x200
   139e4:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
   139e8:	2900      	cmp	r1, #0
   139ea:	d0ee      	beq.n	139ca <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xa>
   139ec:	4829      	ldr	r0, [pc, #164]	; (13a94 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xd4>)
   139ee:	4f2a      	ldr	r7, [pc, #168]	; (13a98 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xd8>)
   139f0:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 13a94 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xd4>
    graphics.movePrintPos(weegfx::Graphics::kFixedFontW, 0);
    graphics.print(available_apps[current].name);
//    if (global_settings.current_app_id == available_apps[current].id)
//       graphics.drawBitmap8(item.x + 2, item.y + 1, 4, bitmap_indicator_4x8);
    graphics.drawBitmap8(0, item.y + 1, 8,
        global_settings.current_app_id == available_apps[current].id ? CHECK_ON_ICON : CHECK_OFF_ICON);
   139f4:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 13a9c <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xdc>
    graphics.drawBitmap8(0, item.y + 1, 8,
   139f8:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 13aa0 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xe0>
  GRAPHICS_BEGIN_FRAME(true);
   139fc:	2201      	movs	r2, #1
   139fe:	f005 fc38 	bl	19272 <weegfx::Graphics::Begin(unsigned char*, bool)>
  item.x = menu::kIndentDx + 8;
   13a02:	230a      	movs	r3, #10
   13a04:	9304      	str	r3, [sp, #16]
  item.y = (64 - (5 * menu::kMenuLineH)) / 2;
   13a06:	2302      	movs	r3, #2
    return cursor_pos_ - screen_line_;
   13a08:	68f4      	ldr	r4, [r6, #12]
   13a0a:	9305      	str	r3, [sp, #20]
   13a0c:	6933      	ldr	r3, [r6, #16]
   13a0e:	1ae4      	subs	r4, r4, r3
   13a10:	2334      	movs	r3, #52	; 0x34
   13a12:	fb03 7704 	mla	r7, r3, r4, r7
    return cursor_pos_ - screen_line_ + screen_lines - 1;
   13a16:	68f2      	ldr	r2, [r6, #12]
   13a18:	6933      	ldr	r3, [r6, #16]
   13a1a:	1ad3      	subs	r3, r2, r3
   13a1c:	3304      	adds	r3, #4
       current <= cursor.last_visible();
   13a1e:	429c      	cmp	r4, r3
   13a20:	dd0a      	ble.n	13a38 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0x78>
    item.DrawCustom();
  }

  GRAPHICS_END_FRAME();
   13a22:	481c      	ldr	r0, [pc, #112]	; (13a94 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xd4>)
   13a24:	f005 fc33 	bl	1928e <weegfx::Graphics::End()>
    ++write_ptr_;
   13a28:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
   13a2c:	3301      	adds	r3, #1
   13a2e:	f8c5 3808 	str.w	r3, [r5, #2056]	; 0x808
}
   13a32:	b009      	add	sp, #36	; 0x24
   13a34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    item.selected = current == cursor.cursor_pos();
   13a38:	1aa3      	subs	r3, r4, r2
    graphics.setPrintPos(x + kIndentDx, y + kTextDy);
   13a3a:	f8dd b014 	ldr.w	fp, [sp, #20]
    graphics.print(available_apps[current].name);
   13a3e:	6879      	ldr	r1, [r7, #4]
   13a40:	4814      	ldr	r0, [pc, #80]	; (13a94 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xd4>)
    item.selected = current == cursor.cursor_pos();
   13a42:	425a      	negs	r2, r3
   13a44:	415a      	adcs	r2, r3
   13a46:	f10b 0302 	add.w	r3, fp, #2
   13a4a:	f8c8 3008 	str.w	r3, [r8, #8]
  text_x_ += dx;
   13a4e:	9b04      	ldr	r3, [sp, #16]
   13a50:	f88d 200c 	strb.w	r2, [sp, #12]
   13a54:	3308      	adds	r3, #8
   13a56:	f8c8 3004 	str.w	r3, [r8, #4]
    graphics.print(available_apps[current].name);
   13a5a:	f006 f83c 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    graphics.drawBitmap8(0, item.y + 1, 8,
   13a5e:	f837 2b34 	ldrh.w	r2, [r7], #52
   13a62:	f8b9 1008 	ldrh.w	r1, [r9, #8]
   13a66:	4b0f      	ldr	r3, [pc, #60]	; (13aa4 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0xe4>)
   13a68:	4291      	cmp	r1, r2
   13a6a:	bf08      	it	eq
   13a6c:	4653      	moveq	r3, sl
   13a6e:	9300      	str	r3, [sp, #0]
   13a70:	f10b 0201 	add.w	r2, fp, #1
   13a74:	2308      	movs	r3, #8
   13a76:	2100      	movs	r1, #0
   13a78:	4640      	mov	r0, r8
   13a7a:	f005 fde3 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
    item.DrawCustom();
   13a7e:	a803      	add	r0, sp, #12
   13a80:	f7f1 fad8 	bl	5034 <OC::menu::SettingsListItem::DrawCustom() const>
       ++current, item.y += menu::kMenuLineH) {
   13a84:	9b05      	ldr	r3, [sp, #20]
   13a86:	330c      	adds	r3, #12
   13a88:	3401      	adds	r4, #1
   13a8a:	9305      	str	r3, [sp, #20]
   13a8c:	e7c3      	b.n	13a16 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)+0x56>
   13a8e:	bf00      	nop
   13a90:	20005dc8 	.word	0x20005dc8
   13a94:	200065e0 	.word	0x200065e0
   13a98:	1fff9e54 	.word	0x1fff9e54
   13a9c:	20003b70 	.word	0x20003b70
   13aa0:	00023d38 	.word	0x00023d38
   13aa4:	00023ec0 	.word	0x00023ec0

00013aa8 <OC::draw_save_message(unsigned char)>:

void draw_save_message(uint8_t c) {
   13aa8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    return write_ptr_ - read_ptr_;
   13aaa:	4c1b      	ldr	r4, [pc, #108]	; (13b18 <OC::draw_save_message(unsigned char)+0x70>)
   13aac:	4606      	mov	r6, r0
   13aae:	f8d4 2808 	ldr.w	r2, [r4, #2056]	; 0x808
   13ab2:	f8d4 380c 	ldr.w	r3, [r4, #2060]	; 0x80c
  GRAPHICS_BEGIN_FRAME(true);
   13ab6:	1a9b      	subs	r3, r3, r2
   13ab8:	3302      	adds	r3, #2
   13aba:	d0f8      	beq.n	13aae <OC::draw_save_message(unsigned char)+0x6>
    return frame_buffers_[write_ptr_ % frames];
   13abc:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
   13ac0:	f003 0301 	and.w	r3, r3, #1
   13ac4:	f503 7300 	add.w	r3, r3, #512	; 0x200
   13ac8:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
   13acc:	2900      	cmp	r1, #0
   13ace:	d0ee      	beq.n	13aae <OC::draw_save_message(unsigned char)+0x6>
   13ad0:	4d12      	ldr	r5, [pc, #72]	; (13b1c <OC::draw_save_message(unsigned char)+0x74>)
   13ad2:	2201      	movs	r2, #1
   13ad4:	4628      	mov	r0, r5
   13ad6:	f005 fbcc 	bl	19272 <weegfx::Graphics::Begin(unsigned char*, bool)>
  text_x_ = x;
   13ada:	2325      	movs	r3, #37	; 0x25
   13adc:	606b      	str	r3, [r5, #4]
  uint8_t _size = c % 120;
  graphics.setPrintPos(37, 18);
  graphics.print("Saving...");
   13ade:	4628      	mov	r0, r5
  text_y_ = y;
   13ae0:	2312      	movs	r3, #18
   13ae2:	490f      	ldr	r1, [pc, #60]	; (13b20 <OC::draw_save_message(unsigned char)+0x78>)
   13ae4:	60ab      	str	r3, [r5, #8]
   13ae6:	f005 fff6 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  uint8_t _size = c % 120;
   13aea:	2378      	movs	r3, #120	; 0x78
   13aec:	fbb6 f2f3 	udiv	r2, r6, r3
   13af0:	fb03 6312 	mls	r3, r3, r2, r6
  graphics.drawRect(0, 28, _size, 8);
   13af4:	2208      	movs	r2, #8
   13af6:	9200      	str	r2, [sp, #0]
   13af8:	b2db      	uxtb	r3, r3
   13afa:	221c      	movs	r2, #28
   13afc:	2100      	movs	r1, #0
   13afe:	4628      	mov	r0, r5
   13b00:	f005 fbc8 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
  GRAPHICS_END_FRAME();
   13b04:	4628      	mov	r0, r5
   13b06:	f005 fbc2 	bl	1928e <weegfx::Graphics::End()>
    ++write_ptr_;
   13b0a:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
   13b0e:	3301      	adds	r3, #1
   13b10:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808
}
   13b14:	b002      	add	sp, #8
   13b16:	bd70      	pop	{r4, r5, r6, pc}
   13b18:	20005dc8 	.word	0x20005dc8
   13b1c:	200065e0 	.word	0x200065e0
   13b20:	00021349 	.word	0x00021349

00013b24 <OC::Ui::ConfirmReset()>:
  // Restore state
  apps::current_app->HandleAppEvent(APP_EVENT_RESUME);
  CORE::app_isr_enabled = true;
}

bool Ui::ConfirmReset() {
   13b24:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    button_ignore_mask_ = button_state_;
   13b28:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
    return write_ptr_ - read_ptr_;
   13b2c:	4f40      	ldr	r7, [pc, #256]	; (13c30 <OC::Ui::ConfirmReset()+0x10c>)
        confirm = false;
        done = true;
      }
    }

    GRAPHICS_BEGIN_FRAME(true);
   13b2e:	4d41      	ldr	r5, [pc, #260]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
    graphics.setPrintPos(1, 2);
    graphics.print("Setup: Reset");
   13b30:	f8df 9104 	ldr.w	r9, [pc, #260]	; 13c38 <OC::Ui::ConfirmReset()+0x114>
   13b34:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  bool confirm = false;
   13b38:	2600      	movs	r6, #0
bool Ui::ConfirmReset() {
   13b3a:	4604      	mov	r4, r0
  bool done = false;
   13b3c:	46b0      	mov	r8, r6
    return write_ptr_ - read_ptr_;
   13b3e:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
   13b42:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    while (event_queue_.available()) {
   13b46:	429a      	cmp	r2, r3
   13b48:	d153      	bne.n	13bf2 <OC::Ui::ConfirmReset()+0xce>
   13b4a:	f8d7 2808 	ldr.w	r2, [r7, #2056]	; 0x808
   13b4e:	f8d7 380c 	ldr.w	r3, [r7, #2060]	; 0x80c
    GRAPHICS_BEGIN_FRAME(true);
   13b52:	1a9b      	subs	r3, r3, r2
   13b54:	3302      	adds	r3, #2
   13b56:	d0f8      	beq.n	13b4a <OC::Ui::ConfirmReset()+0x26>
    return frame_buffers_[write_ptr_ % frames];
   13b58:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
   13b5c:	f003 0301 	and.w	r3, r3, #1
   13b60:	f503 7300 	add.w	r3, r3, #512	; 0x200
   13b64:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
   13b68:	2900      	cmp	r1, #0
   13b6a:	d0ee      	beq.n	13b4a <OC::Ui::ConfirmReset()+0x26>
   13b6c:	2201      	movs	r2, #1
   13b6e:	4831      	ldr	r0, [pc, #196]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
   13b70:	f005 fb7f 	bl	19272 <weegfx::Graphics::Begin(unsigned char*, bool)>
  text_x_ = x;
   13b74:	f04f 0a01 	mov.w	sl, #1
  text_y_ = y;
   13b78:	2302      	movs	r3, #2
    graphics.print("Setup: Reset");
   13b7a:	482e      	ldr	r0, [pc, #184]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
   13b7c:	60ab      	str	r3, [r5, #8]
   13b7e:	4649      	mov	r1, r9
  text_x_ = x;
   13b80:	f8c5 a004 	str.w	sl, [r5, #4]
   13b84:	f005 ffa7 	bl	19ad6 <weegfx::Graphics::print(char const*)>
    graphics.drawLine(0, 10, 127, 10);
   13b88:	220a      	movs	r2, #10
   13b8a:	482a      	ldr	r0, [pc, #168]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
   13b8c:	9200      	str	r2, [sp, #0]
   13b8e:	237f      	movs	r3, #127	; 0x7f
   13b90:	2100      	movs	r1, #0
   13b92:	f005 fe2d 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
    graphics.drawLine(0, 12, 127, 12);
   13b96:	220c      	movs	r2, #12
   13b98:	9200      	str	r2, [sp, #0]
   13b9a:	4826      	ldr	r0, [pc, #152]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
   13b9c:	237f      	movs	r3, #127	; 0x7f
   13b9e:	2100      	movs	r1, #0
   13ba0:	f005 fe26 	bl	197f0 <weegfx::Graphics::drawLine(int, int, int, int)>
  text_y_ = y;
   13ba4:	230f      	movs	r3, #15

    graphics.setPrintPos(1, 15);
    graphics.print("Reset application");
   13ba6:	4925      	ldr	r1, [pc, #148]	; (13c3c <OC::Ui::ConfirmReset()+0x118>)
   13ba8:	4822      	ldr	r0, [pc, #136]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
   13baa:	60ab      	str	r3, [r5, #8]
  text_x_ = x;
   13bac:	f8c5 a004 	str.w	sl, [r5, #4]
   13bb0:	f005 ff91 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_y_ = y;
   13bb4:	2319      	movs	r3, #25
    graphics.setPrintPos(1, 25);
    graphics.print("settings on EEPROM?");
   13bb6:	4922      	ldr	r1, [pc, #136]	; (13c40 <OC::Ui::ConfirmReset()+0x11c>)
   13bb8:	481e      	ldr	r0, [pc, #120]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
   13bba:	60ab      	str	r3, [r5, #8]
  text_x_ = x;
   13bbc:	f8c5 a004 	str.w	sl, [r5, #4]
   13bc0:	f005 ff89 	bl	19ad6 <weegfx::Graphics::print(char const*)>
   13bc4:	2300      	movs	r3, #0

    graphics.setPrintPos(0, 55);
    graphics.print("[CANCEL]         [OK]");
   13bc6:	491f      	ldr	r1, [pc, #124]	; (13c44 <OC::Ui::ConfirmReset()+0x120>)
   13bc8:	481a      	ldr	r0, [pc, #104]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
   13bca:	606b      	str	r3, [r5, #4]
  text_y_ = y;
   13bcc:	2337      	movs	r3, #55	; 0x37
   13bce:	60ab      	str	r3, [r5, #8]
   13bd0:	f005 ff81 	bl	19ad6 <weegfx::Graphics::print(char const*)>

    GRAPHICS_END_FRAME();
   13bd4:	4817      	ldr	r0, [pc, #92]	; (13c34 <OC::Ui::ConfirmReset()+0x110>)
   13bd6:	f005 fb5a 	bl	1928e <weegfx::Graphics::End()>
    ++write_ptr_;
   13bda:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
   13bde:	4453      	add	r3, sl
   13be0:	f8c7 3808 	str.w	r3, [r7, #2056]	; 0x808

  } while (!done);
   13be4:	f1b8 0f00 	cmp.w	r8, #0
   13be8:	d0a9      	beq.n	13b3e <OC::Ui::ConfirmReset()+0x1a>

  return confirm;
}
   13bea:	4630      	mov	r0, r6
   13bec:	b002      	add	sp, #8
   13bee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    size_t read_ptr = read_ptr_;
   13bf2:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    T value = buffer_[read_ptr & (size - 1)];
   13bf6:	f003 020f 	and.w	r2, r3, #15
   13bfa:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    read_ptr_ = read_ptr + 1;
   13bfe:	3301      	adds	r3, #1
    T value = buffer_[read_ptr & (size - 1)];
   13c00:	f8b2 a06e 	ldrh.w	sl, [r2, #110]	; 0x6e
    read_ptr_ = read_ptr + 1;
   13c04:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
      if (IgnoreEvent(event))
   13c08:	4651      	mov	r1, sl
   13c0a:	4620      	mov	r0, r4
   13c0c:	f7f0 ffda 	bl	4bc4 <OC::Ui::IgnoreEvent(UI::Event const&) [clone .isra.0]>
   13c10:	2800      	cmp	r0, #0
   13c12:	d194      	bne.n	13b3e <OC::Ui::ConfirmReset()+0x1a>
      if (CONTROL_BUTTON_R == event.control) {
   13c14:	f1ba 0f08 	cmp.w	sl, #8
   13c18:	d006      	beq.n	13c28 <OC::Ui::ConfirmReset()+0x104>
        confirm = false;
   13c1a:	f1ba 0f04 	cmp.w	sl, #4
   13c1e:	bf04      	itt	eq
   13c20:	2600      	moveq	r6, #0
   13c22:	f04f 0801 	moveq.w	r8, #1
   13c26:	e78a      	b.n	13b3e <OC::Ui::ConfirmReset()+0x1a>
        confirm = true;
   13c28:	2601      	movs	r6, #1
        done = true;
   13c2a:	46b0      	mov	r8, r6
   13c2c:	e787      	b.n	13b3e <OC::Ui::ConfirmReset()+0x1a>
   13c2e:	bf00      	nop
   13c30:	20005dc8 	.word	0x20005dc8
   13c34:	200065e0 	.word	0x200065e0
   13c38:	00021353 	.word	0x00021353
   13c3c:	00021360 	.word	0x00021360
   13c40:	00021372 	.word	0x00021372
   13c44:	00021386 	.word	0x00021386

00013c48 <calibration_reset()>:
  #else
  0 // reserved1
  #endif
};

void calibration_reset() {
   13c48:	b508      	push	{r3, lr}
  memcpy(&OC::calibration_data, &kCalibrationDefaults, sizeof(OC::calibration_data));
   13c4a:	4903      	ldr	r1, [pc, #12]	; (13c58 <calibration_reset()+0x10>)
   13c4c:	4803      	ldr	r0, [pc, #12]	; (13c5c <calibration_reset()+0x14>)
   13c4e:	2274      	movs	r2, #116	; 0x74
   13c50:	f006 f9ce 	bl	19ff0 <memcpy>
    OC::calibration_data.dac.calibrated_octaves[0][i] += DAC_OFFSET;
    OC::calibration_data.dac.calibrated_octaves[1][i] += DAC_OFFSET;
    OC::calibration_data.dac.calibrated_octaves[2][i] += DAC_OFFSET;
    OC::calibration_data.dac.calibrated_octaves[3][i] += DAC_OFFSET;
  }
}
   13c54:	bd08      	pop	{r3, pc}
   13c56:	bf00      	nop
   13c58:	0002417c 	.word	0x0002417c
   13c5c:	20004294 	.word	0x20004294

00013c60 <calibration_load()>:

void calibration_load() {
   13c60:	b570      	push	{r4, r5, r6, lr}
    page_index_ = -1;
   13c62:	4c2b      	ldr	r4, [pc, #172]	; (13d10 <calibration_load()+0xb0>)
   13c64:	b0a0      	sub	sp, #128	; 0x80
  SERIAL_PRINTLN("Cal.Storage: PAGESIZE=%u, PAGES=%u, LENGTH=%u",
                 OC::CalibrationStorage::PAGESIZE, OC::CalibrationStorage::PAGES, OC::CalibrationStorage::LENGTH);

  calibration_reset();
   13c66:	f7ff ffef 	bl	13c48 <calibration_reset()>
   13c6a:	4620      	mov	r0, r4
   13c6c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    memset(&page_, 0, sizeof(page_));
   13c70:	2280      	movs	r2, #128	; 0x80
   13c72:	2100      	movs	r1, #0
    page_index_ = -1;
   13c74:	f840 5b04 	str.w	r5, [r0], #4
    memset(&page_, 0, sizeof(page_));
   13c78:	f006 fa8e 	bl	1a198 <memset>
      STORAGE::read(BASE_ADDR + i * PAGESIZE, &next_page, sizeof(next_page));
   13c7c:	4669      	mov	r1, sp
   13c7e:	2280      	movs	r2, #128	; 0x80
   13c80:	2000      	movs	r0, #0
    page_.header.generation = -1;
   13c82:	60a5      	str	r5, [r4, #8]
      STORAGE::read(BASE_ADDR + i * PAGESIZE, &next_page, sizeof(next_page));
   13c84:	f7f1 f9b6 	bl	4ff4 <EEPROMStorage::read(unsigned int, void*, unsigned int)>
          (next_page.header.checksum != checksum(next_page)) ||
   13c88:	4922      	ldr	r1, [pc, #136]	; (13d14 <calibration_load()+0xb4>)
   13c8a:	9b00      	ldr	r3, [sp, #0]
   13c8c:	428b      	cmp	r3, r1
   13c8e:	d126      	bne.n	13cde <calibration_load()+0x7e>
      if ((DATA_TYPE::FOURCC != next_page.header.fourcc) ||
   13c90:	f8bd 2008 	ldrh.w	r2, [sp, #8]
   13c94:	2a74      	cmp	r2, #116	; 0x74
   13c96:	d122      	bne.n	13cde <calibration_load()+0x7e>
          (next_page.header.checksum != checksum(next_page)) ||
   13c98:	f8bd 500a 	ldrh.w	r5, [sp, #10]
    const uint8_t *p = (const uint8_t *)&page.data;
   13c9c:	a803      	add	r0, sp, #12
    uint16_t c = 0;
   13c9e:	2300      	movs	r3, #0
    while (length--) {
   13ca0:	3a01      	subs	r2, #1
   13ca2:	d217      	bcs.n	13cd4 <calibration_load()+0x74>
    return c ^ 0xffff;
   13ca4:	43db      	mvns	r3, r3
          (sizeof(DATA_TYPE) != next_page.header.size) ||
   13ca6:	b29b      	uxth	r3, r3
   13ca8:	429d      	cmp	r5, r3
   13caa:	d118      	bne.n	13cde <calibration_load()+0x7e>
          (next_page.header.generation < page_.header.generation && (int32_t)page_.header.generation != -1)) {
   13cac:	68a3      	ldr	r3, [r4, #8]
          (next_page.header.checksum != checksum(next_page)) ||
   13cae:	9a01      	ldr	r2, [sp, #4]
   13cb0:	429a      	cmp	r2, r3
   13cb2:	d201      	bcs.n	13cb8 <calibration_load()+0x58>
          (next_page.header.generation < page_.header.generation && (int32_t)page_.header.generation != -1)) {
   13cb4:	3301      	adds	r3, #1
   13cb6:	d112      	bne.n	13cde <calibration_load()+0x7e>
      page_index_ = i;
   13cb8:	2300      	movs	r3, #0
      memcpy(&page_, &next_page, sizeof(page_));
   13cba:	4817      	ldr	r0, [pc, #92]	; (13d18 <calibration_load()+0xb8>)
      page_index_ = i;
   13cbc:	6023      	str	r3, [r4, #0]
      memcpy(&page_, &next_page, sizeof(page_));
   13cbe:	2280      	movs	r2, #128	; 0x80
   13cc0:	4669      	mov	r1, sp
   13cc2:	f006 f995 	bl	19ff0 <memcpy>
      memcpy(&data, &page_.data, sizeof(DATA_TYPE));
   13cc6:	4915      	ldr	r1, [pc, #84]	; (13d1c <calibration_load()+0xbc>)
   13cc8:	4815      	ldr	r0, [pc, #84]	; (13d20 <calibration_load()+0xc0>)
   13cca:	2274      	movs	r2, #116	; 0x74
   13ccc:	f006 f990 	bl	19ff0 <memcpy>
      return true;
   13cd0:	2301      	movs	r3, #1
   13cd2:	e00b      	b.n	13cec <calibration_load()+0x8c>
      c += *p++;
   13cd4:	f810 6b01 	ldrb.w	r6, [r0], #1
   13cd8:	4433      	add	r3, r6
   13cda:	b29b      	uxth	r3, r3
   13cdc:	e7e0      	b.n	13ca0 <calibration_load()+0x40>
    if (-1 == page_index_) {
   13cde:	6823      	ldr	r3, [r4, #0]
   13ce0:	3301      	adds	r3, #1
   13ce2:	d1f0      	bne.n	13cc6 <calibration_load()+0x66>
      page_.header.size = sizeof(DATA_TYPE);
   13ce4:	2374      	movs	r3, #116	; 0x74
   13ce6:	81a3      	strh	r3, [r4, #12]
      page_.header.fourcc = DATA_TYPE::FOURCC;
   13ce8:	6061      	str	r1, [r4, #4]
      return false;
   13cea:	2300      	movs	r3, #0
  calibration_data_loaded = OC::calibration_storage.Load(OC::calibration_data);
   13cec:	4a0d      	ldr	r2, [pc, #52]	; (13d24 <calibration_load()+0xc4>)
   13cee:	7013      	strb	r3, [r2, #0]
  } else {
    SERIAL_PRINTLN("Calibration data loaded...");
  }

  // Fix-up left-overs from development
  if (!OC::calibration_data.adc.pitch_cv_scale) {
   13cf0:	4b0b      	ldr	r3, [pc, #44]	; (13d20 <calibration_load()+0xc0>)
   13cf2:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
   13cf6:	b91a      	cbnz	r2, 13d00 <calibration_load()+0xa0>
    SERIAL_PRINTLN("CV scale not set, using default");
    OC::calibration_data.adc.pitch_cv_scale = OC::ADC::kDefaultPitchCVScale;
   13cf8:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
   13cfc:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
  }

  if (!OC::calibration_data.screensaver_timeout)
   13d00:	f893 206c 	ldrb.w	r2, [r3, #108]	; 0x6c
   13d04:	b912      	cbnz	r2, 13d0c <calibration_load()+0xac>
    OC::calibration_data.screensaver_timeout = SCREENSAVER_TIMEOUT_S;
   13d06:	2219      	movs	r2, #25
   13d08:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c
}
   13d0c:	b020      	add	sp, #128	; 0x80
   13d0e:	bd70      	pop	{r4, r5, r6, pc}
   13d10:	20004308 	.word	0x20004308
   13d14:	43414c01 	.word	0x43414c01
   13d18:	2000430c 	.word	0x2000430c
   13d1c:	20004318 	.word	0x20004318
   13d20:	20004294 	.word	0x20004294
   13d24:	200046e8 	.word	0x200046e8

00013d28 <calibration_save()>:

void calibration_save() {
   13d28:	b538      	push	{r3, r4, r5, lr}
   13d2a:	4813      	ldr	r0, [pc, #76]	; (13d78 <calibration_save()+0x50>)
    uint8_t *dst = (uint8_t*)&page_.data;
   13d2c:	4b13      	ldr	r3, [pc, #76]	; (13d7c <calibration_save()+0x54>)
    size_t length = sizeof(DATA_TYPE);
   13d2e:	2274      	movs	r2, #116	; 0x74
    bool dirty = false;
   13d30:	2100      	movs	r1, #0
    while (length--) {
   13d32:	3a01      	subs	r2, #1
   13d34:	d212      	bcs.n	13d5c <calibration_save()+0x34>
    if (dirty) {
   13d36:	b181      	cbz	r1, 13d5a <calibration_save()+0x32>
      ++page_.header.generation;
   13d38:	4a11      	ldr	r2, [pc, #68]	; (13d80 <calibration_save()+0x58>)
   13d3a:	6893      	ldr	r3, [r2, #8]
   13d3c:	3301      	adds	r3, #1
   13d3e:	6093      	str	r3, [r2, #8]
    while (length--) {
   13d40:	2075      	movs	r0, #117	; 0x75
    const uint8_t *p = (const uint8_t *)&page.data;
   13d42:	f102 0110 	add.w	r1, r2, #16
    uint16_t c = 0;
   13d46:	2300      	movs	r3, #0
    while (length--) {
   13d48:	3801      	subs	r0, #1
   13d4a:	d110      	bne.n	13d6e <calibration_save()+0x46>
    return c ^ 0xffff;
   13d4c:	43db      	mvns	r3, r3
      page_.header.checksum = checksum(page_);
   13d4e:	81d3      	strh	r3, [r2, #14]
      page_index_ = (page_index_ + 1) % PAGES;
   13d50:	6010      	str	r0, [r2, #0]
        STORAGE::update(BASE_ADDR + page_index_ * PAGESIZE, &page_, sizeof(page_));
   13d52:	490c      	ldr	r1, [pc, #48]	; (13d84 <calibration_save()+0x5c>)
   13d54:	2280      	movs	r2, #128	; 0x80
   13d56:	f7f1 f939 	bl	4fcc <EEPROMStorage::update(unsigned int, void const*, unsigned int)>
  SERIAL_PRINTLN("Saving calibration data");
  OC::calibration_storage.Save(OC::calibration_data);
}
   13d5a:	bd38      	pop	{r3, r4, r5, pc}
      if (*dst != *src) {
   13d5c:	781d      	ldrb	r5, [r3, #0]
   13d5e:	f810 4b01 	ldrb.w	r4, [r0], #1
   13d62:	42a5      	cmp	r5, r4
        *dst = *src;
   13d64:	bf1c      	itt	ne
   13d66:	701c      	strbne	r4, [r3, #0]
        dirty = true;
   13d68:	2101      	movne	r1, #1
      ++dst;
   13d6a:	3301      	adds	r3, #1
   13d6c:	e7e1      	b.n	13d32 <calibration_save()+0xa>
      c += *p++;
   13d6e:	f811 4b01 	ldrb.w	r4, [r1], #1
   13d72:	4423      	add	r3, r4
   13d74:	b29b      	uxth	r3, r3
   13d76:	e7e7      	b.n	13d48 <calibration_save()+0x20>
   13d78:	20004294 	.word	0x20004294
   13d7c:	20004318 	.word	0x20004318
   13d80:	20004308 	.word	0x20004308
   13d84:	2000430c 	.word	0x2000430c

00013d88 <step_to_channel(int)>:
  const char * const *value_str; // if non-null, use these instead of encoder value
  int min, max;
};

DAC_CHANNEL step_to_channel(int step) {
  if (step >= DAC_D_VOLT_3m) return DAC_CHANNEL_D;
   13d88:	2822      	cmp	r0, #34	; 0x22
   13d8a:	dc06      	bgt.n	13d9a <step_to_channel(int)+0x12>
  if (step >= DAC_C_VOLT_3m) return DAC_CHANNEL_C;
   13d8c:	2817      	cmp	r0, #23
   13d8e:	dc06      	bgt.n	13d9e <step_to_channel(int)+0x16>
  if (step >= DAC_D_VOLT_3m) return DAC_CHANNEL_D;
   13d90:	280c      	cmp	r0, #12
   13d92:	bfd4      	ite	le
   13d94:	2000      	movle	r0, #0
   13d96:	2001      	movgt	r0, #1
   13d98:	4770      	bx	lr
   13d9a:	2003      	movs	r0, #3
   13d9c:	4770      	bx	lr
  if (step >= DAC_C_VOLT_3m) return DAC_CHANNEL_C;
   13d9e:	2002      	movs	r0, #2
  if (step >= DAC_B_VOLT_3m) return DAC_CHANNEL_B;
  /*if (step >= DAC_B_VOLT_3m)*/ 
  return DAC_CHANNEL_A;
}
   13da0:	4770      	bx	lr
   13da2:	Address 0x0000000000013da2 is out of bounds.


00013da4 <calibration_update(CalibrationState&)>:

/* DAC output etc */ 

void calibration_update(CalibrationState &state) {

  CONSTRAIN(state.encoder_value, state.current_step->min, state.current_step->max);
   13da4:	6843      	ldr	r3, [r0, #4]
   13da6:	6881      	ldr	r1, [r0, #8]
   13da8:	6a1a      	ldr	r2, [r3, #32]
   13daa:	4291      	cmp	r1, r2
void calibration_update(CalibrationState &state) {
   13dac:	b510      	push	{r4, lr}
   13dae:	4604      	mov	r4, r0
  CONSTRAIN(state.encoder_value, state.current_step->min, state.current_step->max);
   13db0:	da01      	bge.n	13db6 <calibration_update(CalibrationState&)+0x12>
   13db2:	60a2      	str	r2, [r4, #8]
   13db4:	e002      	b.n	13dbc <calibration_update(CalibrationState&)+0x18>
   13db6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   13db8:	4291      	cmp	r1, r2
   13dba:	dcfa      	bgt.n	13db2 <calibration_update(CalibrationState&)+0xe>
  const CalibrationStep *step = state.current_step;

  switch (step->calibration_type) {
   13dbc:	7d1a      	ldrb	r2, [r3, #20]
   13dbe:	2a08      	cmp	r2, #8
   13dc0:	d809      	bhi.n	13dd6 <calibration_update(CalibrationState&)+0x32>
   13dc2:	e8df f002 	tbb	[pc, r2]
   13dc6:	0905      	.short	0x0905
   13dc8:	3e362a1b 	.word	0x3e362a1b
   13dcc:	4240      	.short	0x4240
   13dce:	4a          	.byte	0x4a
   13dcf:	00          	.byte	0x00
    case CALIBRATE_NONE:
      DAC::set_all_octave(0);
   13dd0:	2000      	movs	r0, #0
      break;
    case CALIBRATE_ADC_1V:
      DAC::set_all_octave(1);
      break;
    case CALIBRATE_ADC_3V:
      DAC::set_all_octave(3);
   13dd2:	f7f1 f8b1 	bl	4f38 <OC::DAC::set_all_octave(int)>
    case CALIBRATE_SCREENSAVER:
      DAC::set_all_octave(0);
      OC::calibration_data.screensaver_timeout = state.encoder_value;
      break;
  }
}
   13dd6:	bd10      	pop	{r4, pc}
      OC::calibration_data.dac.calibrated_octaves[step_to_channel(step->step)][step->index + DAC::kOctaveZero] =
   13dd8:	7818      	ldrb	r0, [r3, #0]
   13dda:	f7ff ffd5 	bl	13d88 <step_to_channel(int)>
   13dde:	699a      	ldr	r2, [r3, #24]
   13de0:	210b      	movs	r1, #11
   13de2:	1d53      	adds	r3, r2, #5
   13de4:	fb01 3300 	mla	r3, r1, r0, r3
   13de8:	4920      	ldr	r1, [pc, #128]	; (13e6c <calibration_update(CalibrationState&)+0xc8>)
   13dea:	68a0      	ldr	r0, [r4, #8]
   13dec:	f821 0013 	strh.w	r0, [r1, r3, lsl #1]
      DAC::set_all_octave(step->index);
   13df0:	4610      	mov	r0, r2
      DAC::set_all_octave(0);
   13df2:	f7f1 f8a1 	bl	4f38 <OC::DAC::set_all_octave(int)>
      DAC::set_Vbias(DAC::VBiasUnipolar);
   13df6:	f640 703c 	movw	r0, #3900	; 0xf3c
   13dfa:	e00a      	b.n	13e12 <calibration_update(CalibrationState&)+0x6e>
      DAC::set_all_octave(5);
   13dfc:	2005      	movs	r0, #5
   13dfe:	f7f1 f89b 	bl	4f38 <OC::DAC::set_all_octave(int)>
      OC::calibration_data.v_bias = (OC::calibration_data.v_bias & 0xFFFF0000) | state.encoder_value;
   13e02:	4b1a      	ldr	r3, [pc, #104]	; (13e6c <calibration_update(CalibrationState&)+0xc8>)
   13e04:	68a2      	ldr	r2, [r4, #8]
   13e06:	6f18      	ldr	r0, [r3, #112]	; 0x70
   13e08:	0c00      	lsrs	r0, r0, #16
   13e0a:	0400      	lsls	r0, r0, #16
   13e0c:	4310      	orrs	r0, r2
   13e0e:	6718      	str	r0, [r3, #112]	; 0x70
      DAC::set_Vbias(0xFFFF & OC::calibration_data.v_bias);
   13e10:	b280      	uxth	r0, r0
}
   13e12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      DAC::set_Vbias(0xFFFF & OC::calibration_data.v_bias);
   13e16:	f7ec bc13 	b.w	640 <OC::DAC::set_Vbias(unsigned long)>
      DAC::set_all_octave(3);
   13e1a:	2003      	movs	r0, #3
   13e1c:	f7f1 f88c 	bl	4f38 <OC::DAC::set_all_octave(int)>
      OC::calibration_data.v_bias = (OC::calibration_data.v_bias & 0xFFFF) | (state.encoder_value << 16);
   13e20:	4b12      	ldr	r3, [pc, #72]	; (13e6c <calibration_update(CalibrationState&)+0xc8>)
   13e22:	68a2      	ldr	r2, [r4, #8]
   13e24:	f8b3 0070 	ldrh.w	r0, [r3, #112]	; 0x70
   13e28:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
   13e2c:	6718      	str	r0, [r3, #112]	; 0x70
      DAC::set_Vbias(OC::calibration_data.v_bias >> 16);
   13e2e:	0c00      	lsrs	r0, r0, #16
   13e30:	e7ef      	b.n	13e12 <calibration_update(CalibrationState&)+0x6e>
      OC::calibration_data.adc.offset[step->index] = state.encoder_value;
   13e32:	699b      	ldr	r3, [r3, #24]
   13e34:	4a0d      	ldr	r2, [pc, #52]	; (13e6c <calibration_update(CalibrationState&)+0xc8>)
   13e36:	68a1      	ldr	r1, [r4, #8]
   13e38:	332c      	adds	r3, #44	; 0x2c
      DAC::set_all_octave(0);
   13e3a:	2000      	movs	r0, #0
      OC::calibration_data.adc.offset[step->index] = state.encoder_value;
   13e3c:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
      DAC::set_all_octave(0);
   13e40:	e7d7      	b.n	13df2 <calibration_update(CalibrationState&)+0x4e>
      DAC::set_all_octave(1);
   13e42:	2001      	movs	r0, #1
   13e44:	e7c5      	b.n	13dd2 <calibration_update(CalibrationState&)+0x2e>
      DAC::set_all_octave(3);
   13e46:	2003      	movs	r0, #3
   13e48:	e7c3      	b.n	13dd2 <calibration_update(CalibrationState&)+0x2e>
      OC::calibration_data.display_offset = state.encoder_value;
   13e4a:	4b08      	ldr	r3, [pc, #32]	; (13e6c <calibration_update(CalibrationState&)+0xc8>)
   13e4c:	7a20      	ldrb	r0, [r4, #8]
   13e4e:	f883 0064 	strb.w	r0, [r3, #100]	; 0x64
}
   13e52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      display::AdjustOffset(OC::calibration_data.display_offset);
   13e56:	f005 ba05 	b.w	19264 <display::AdjustOffset(unsigned char)>
      DAC::set_all_octave(0);
   13e5a:	2000      	movs	r0, #0
   13e5c:	f7f1 f86c 	bl	4f38 <OC::DAC::set_all_octave(int)>
      OC::calibration_data.screensaver_timeout = state.encoder_value;
   13e60:	4b02      	ldr	r3, [pc, #8]	; (13e6c <calibration_update(CalibrationState&)+0xc8>)
   13e62:	68a2      	ldr	r2, [r4, #8]
   13e64:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c
}
   13e68:	e7b5      	b.n	13dd6 <calibration_update(CalibrationState&)+0x32>
   13e6a:	bf00      	nop
   13e6c:	20004294 	.word	0x20004294

00013e70 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)0>()>:
			return (CORE_PIN3_PINREG & CORE_PIN3_BITMASK) ? 1 : 0;
   13e70:	4b03      	ldr	r3, [pc, #12]	; (13e80 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)0>()+0x10>)
   13e72:	6918      	ldr	r0, [r3, #16]
    return !digitalReadFast(InputPinDesc<input>::PIN);
   13e74:	f480 5080 	eor.w	r0, r0, #4096	; 0x1000
  }
   13e78:	f3c0 3000 	ubfx	r0, r0, #12, #1
   13e7c:	4770      	bx	lr
   13e7e:	bf00      	nop
   13e80:	400ff000 	.word	0x400ff000

00013e84 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)2>()>:
			return (CORE_PIN1_PINREG & CORE_PIN1_BITMASK) ? 1 : 0;
   13e84:	4b03      	ldr	r3, [pc, #12]	; (13e94 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)2>()+0x10>)
   13e86:	6d18      	ldr	r0, [r3, #80]	; 0x50
    return !digitalReadFast(InputPinDesc<input>::PIN);
   13e88:	f480 3000 	eor.w	r0, r0, #131072	; 0x20000
  }
   13e8c:	f3c0 4040 	ubfx	r0, r0, #17, #1
   13e90:	4770      	bx	lr
   13e92:	bf00      	nop
   13e94:	400ff000 	.word	0x400ff000

00013e98 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()>:
			return (CORE_PIN0_PINREG & CORE_PIN0_BITMASK) ? 1 : 0;
   13e98:	4b03      	ldr	r3, [pc, #12]	; (13ea8 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()+0x10>)
   13e9a:	6d18      	ldr	r0, [r3, #80]	; 0x50
    return !digitalReadFast(InputPinDesc<input>::PIN);
   13e9c:	f480 3080 	eor.w	r0, r0, #65536	; 0x10000
  }
   13ea0:	f3c0 4000 	ubfx	r0, r0, #16, #1
   13ea4:	4770      	bx	lr
   13ea6:	bf00      	nop
   13ea8:	400ff000 	.word	0x400ff000

00013eac <HSApplication::Gate(int)>:
    bool Gate(int ch) {
   13eac:	b508      	push	{r3, lr}
        if (ch == 0) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_1>();
   13eae:	b911      	cbnz	r1, 13eb6 <HSApplication::Gate(int)+0xa>
   13eb0:	f7ff ffde 	bl	13e70 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)0>()>
    }
   13eb4:	bd08      	pop	{r3, pc}
        if (ch == 1) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_2>();
   13eb6:	2901      	cmp	r1, #1
   13eb8:	d004      	beq.n	13ec4 <HSApplication::Gate(int)+0x18>
        if (ch == 2) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_3>();
   13eba:	2902      	cmp	r1, #2
   13ebc:	d109      	bne.n	13ed2 <HSApplication::Gate(int)+0x26>
   13ebe:	f7ff ffe1 	bl	13e84 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)2>()>
        if (ch == 3) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_4>();
   13ec2:	e7f7      	b.n	13eb4 <HSApplication::Gate(int)+0x8>
			return (CORE_PIN2_PINREG & CORE_PIN2_BITMASK) ? 1 : 0;
   13ec4:	4b06      	ldr	r3, [pc, #24]	; (13ee0 <HSApplication::Gate(int)+0x34>)
   13ec6:	f8d3 00d0 	ldr.w	r0, [r3, #208]	; 0xd0
    return !digitalReadFast(InputPinDesc<input>::PIN);
   13eca:	43c0      	mvns	r0, r0
   13ecc:	f000 0001 	and.w	r0, r0, #1
   13ed0:	e7f0      	b.n	13eb4 <HSApplication::Gate(int)+0x8>
   13ed2:	2903      	cmp	r1, #3
   13ed4:	d001      	beq.n	13eda <HSApplication::Gate(int)+0x2e>
        bool high = 0;
   13ed6:	2000      	movs	r0, #0
   13ed8:	e7ec      	b.n	13eb4 <HSApplication::Gate(int)+0x8>
        if (ch == 3) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_4>();
   13eda:	f7ff ffdd 	bl	13e98 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()>
   13ede:	e7e9      	b.n	13eb4 <HSApplication::Gate(int)+0x8>
   13ee0:	400ff000 	.word	0x400ff000

00013ee4 <NeuralNetwork::Controller()>:
    void Controller() {
   13ee4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13ee8:	4604      	mov	r4, r0
        ListenForSysEx();
   13eea:	3080      	adds	r0, #128	; 0x80
   13eec:	f7f1 f996 	bl	521c <SystemExclusiveHandler::ListenForSysEx()>
        uint16_t tmp_source_state = source_state; // Set temporary state for this cycle
   13ef0:	f8b4 57a4 	ldrh.w	r5, [r4, #1956]	; 0x7a4
        for (byte i = 0; i < 8; i++)
   13ef4:	f204 779b 	addw	r7, r4, #1947	; 0x79b
        uint16_t tmp_source_state = source_state; // Set temporary state for this cycle
   13ef8:	2600      	movs	r6, #0
        else source_state &= ~(0x01 << b);
   13efa:	f04f 0801 	mov.w	r8, #1
            bool set = (i < 4) ? Gate(i) : (In(i - 4) > HSAPPLICATION_3V);
   13efe:	2e03      	cmp	r6, #3
   13f00:	d857      	bhi.n	13fb2 <NeuralNetwork::Controller()+0xce>
   13f02:	4631      	mov	r1, r6
   13f04:	4620      	mov	r0, r4
   13f06:	f7ff ffd1 	bl	13eac <HSApplication::Gate(int)>
        if (v) source_state |= (0x01 << b);
   13f0a:	2800      	cmp	r0, #0
   13f0c:	d058      	beq.n	13fc0 <NeuralNetwork::Controller()+0xdc>
   13f0e:	fa08 f306 	lsl.w	r3, r8, r6
   13f12:	432b      	orrs	r3, r5
   13f14:	b29d      	uxth	r5, r3
   13f16:	2301      	movs	r3, #1
        for (byte i = 0; i < 8; i++)
   13f18:	3601      	adds	r6, #1
   13f1a:	2e08      	cmp	r6, #8
            input_state[i] = set; // For display
   13f1c:	f807 3f01 	strb.w	r3, [r7, #1]!
        for (byte i = 0; i < 8; i++)
   13f20:	d1ed      	bne.n	13efe <NeuralNetwork::Controller()+0x1a>
   13f22:	f04f 0800 	mov.w	r8, #0
            bool set = neuron[ix].Calculate(tmp_source_state);
   13f26:	f04f 0924 	mov.w	r9, #36	; 0x24
   13f2a:	f44f 7a7f 	mov.w	sl, #1020	; 0x3fc
        if (v) source_state |= (0x01 << b);
   13f2e:	f04f 0b01 	mov.w	fp, #1
            byte ix = (setup * 6) + n;
   13f32:	f894 63f0 	ldrb.w	r6, [r4, #1008]	; 0x3f0
   13f36:	eb06 0746 	add.w	r7, r6, r6, lsl #1
   13f3a:	007f      	lsls	r7, r7, #1
   13f3c:	b2ff      	uxtb	r7, r7
   13f3e:	eb07 0008 	add.w	r0, r7, r8
            bool set = neuron[ix].Calculate(tmp_source_state);
   13f42:	b2c0      	uxtb	r0, r0
   13f44:	fb19 a000 	smlabb	r0, r9, r0, sl
   13f48:	4629      	mov	r1, r5
   13f4a:	4420      	add	r0, r4
   13f4c:	f7f7 f946 	bl	b1dc <LogicGate::Calculate(unsigned short)>
        if (v) source_state |= (0x01 << b);
   13f50:	f108 0308 	add.w	r3, r8, #8
   13f54:	fa0b f303 	lsl.w	r3, fp, r3
   13f58:	b3c0      	cbz	r0, 13fcc <NeuralNetwork::Controller()+0xe8>
   13f5a:	432b      	orrs	r3, r5
   13f5c:	b29d      	uxth	r5, r3
        for (byte n = 0; n < 6; n++)
   13f5e:	f108 0801 	add.w	r8, r8, #1
   13f62:	f1b8 0f06 	cmp.w	r8, #6
   13f66:	d1e4      	bne.n	13f32 <NeuralNetwork::Controller()+0x4e>
            byte ix = (setup * 4) + o;
   13f68:	00b6      	lsls	r6, r6, #2
   13f6a:	b2f6      	uxtb	r6, r6
   13f6c:	f04f 0a00 	mov.w	sl, #0
            bool set = neuron[n].state;
   13f70:	f04f 0924 	mov.w	r9, #36	; 0x24
            Out(o, set * HSAPPLICATION_5V);
   13f74:	f44f 58f0 	mov.w	r8, #7680	; 0x1e00
            byte ix = (setup * 4) + o;
   13f78:	eb06 030a 	add.w	r3, r6, sl
            byte n = output_neuron[ix] + (setup * 6);
   13f7c:	b2db      	uxtb	r3, r3
   13f7e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
            Out(o, set * HSAPPLICATION_5V);
   13f82:	4651      	mov	r1, sl
            byte n = output_neuron[ix] + (setup * 6);
   13f84:	f8d3 375c 	ldr.w	r3, [r3, #1884]	; 0x75c
   13f88:	443b      	add	r3, r7
            bool set = neuron[n].state;
   13f8a:	b2db      	uxtb	r3, r3
   13f8c:	fb09 4303 	mla	r3, r9, r3, r4
            Out(o, set * HSAPPLICATION_5V);
   13f90:	4620      	mov	r0, r4
   13f92:	f893 23fc 	ldrb.w	r2, [r3, #1020]	; 0x3fc
        for (byte o = 0; o < 4; o++)
   13f96:	f10a 0a01 	add.w	sl, sl, #1
            Out(o, set * HSAPPLICATION_5V);
   13f9a:	2300      	movs	r3, #0
   13f9c:	fb08 f202 	mul.w	r2, r8, r2
   13fa0:	f7f1 fe14 	bl	5bcc <HSApplication::Out(int, int, int)>
        for (byte o = 0; o < 4; o++)
   13fa4:	f1ba 0f04 	cmp.w	sl, #4
   13fa8:	d1e6      	bne.n	13f78 <NeuralNetwork::Controller()+0x94>
        source_state = tmp_source_state;
   13faa:	f8a4 57a4 	strh.w	r5, [r4, #1956]	; 0x7a4
    }
   13fae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return inputs[ch];
   13fb2:	f104 031c 	add.w	r3, r4, #28
        if (v) source_state |= (0x01 << b);
   13fb6:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   13fba:	f5b3 5f90 	cmp.w	r3, #4608	; 0x1200
   13fbe:	dca6      	bgt.n	13f0e <NeuralNetwork::Controller()+0x2a>
        else source_state &= ~(0x01 << b);
   13fc0:	fa08 f306 	lsl.w	r3, r8, r6
   13fc4:	ea25 0503 	bic.w	r5, r5, r3
   13fc8:	2300      	movs	r3, #0
   13fca:	e7a5      	b.n	13f18 <NeuralNetwork::Controller()+0x34>
   13fcc:	ea25 0503 	bic.w	r5, r5, r3
   13fd0:	e7c5      	b.n	13f5e <NeuralNetwork::Controller()+0x7a>

00013fd2 <CaptainMIDI::midi_out()>:
    void midi_out() {
   13fd2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13fd6:	4605      	mov	r5, r0
   13fd8:	b089      	sub	sp, #36	; 0x24
   13fda:	f100 041c 	add.w	r4, r0, #28
   13fde:	f100 0b54 	add.w	fp, r0, #84	; 0x54
        for (int ch = 0; ch < 4; ch++)
   13fe2:	2600      	movs	r6, #0
        int setup_offset = get_setup_number() * MIDI_PARAMETER_COUNT;
   13fe4:	f8d5 3308 	ldr.w	r3, [r5, #776]	; 0x308
        return values_[4 + ch + setup_offset];
   13fe8:	2228      	movs	r2, #40	; 0x28
   13fea:	fb02 6a03 	mla	sl, r2, r3, r6
   13fee:	f10a 0326 	add.w	r3, sl, #38	; 0x26
   13ff2:	f855 8023 	ldr.w	r8, [r5, r3, lsl #2]
        return values_[12 + ch + setup_offset];
   13ff6:	f10a 032e 	add.w	r3, sl, #46	; 0x2e
   13ffa:	f855 7023 	ldr.w	r7, [r5, r3, lsl #2]
            if (out_ch == 0) continue;
   13ffe:	2f00      	cmp	r7, #0
   14000:	f000 81b3 	beq.w	1436a <CaptainMIDI::midi_out()+0x398>
            if (out_fn == MIDI_OUT_NOTE || out_fn == MIDI_OUT_LEGATO) {
   14004:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   14008:	2b01      	cmp	r3, #1
   1400a:	f200 815a 	bhi.w	142c2 <CaptainMIDI::midi_out()+0x2f0>
                bool read_gate = Gate(ch);
   1400e:	4631      	mov	r1, r6
   14010:	f105 0008 	add.w	r0, r5, #8
   14014:	f7ff ff4a 	bl	13eac <HSApplication::Gate(int)>
                if (read_gate && !gated[ch]) StartADCLag(ch);
   14018:	4681      	mov	r9, r0
   1401a:	b120      	cbz	r0, 14026 <CaptainMIDI::midi_out()+0x54>
   1401c:	f89b 3629 	ldrb.w	r3, [fp, #1577]	; 0x629
   14020:	b90b      	cbnz	r3, 14026 <CaptainMIDI::midi_out()+0x54>
    void StartADCLag(int ch) {adc_lag_countdown[ch] = 96;}
   14022:	2360      	movs	r3, #96	; 0x60
   14024:	6023      	str	r3, [r4, #0]
    bool EndOfADCLag(int ch) {return (--adc_lag_countdown[ch] == 0);}
   14026:	6823      	ldr	r3, [r4, #0]
   14028:	3b01      	subs	r3, #1
   1402a:	2b00      	cmp	r3, #0
   1402c:	6023      	str	r3, [r4, #0]
   1402e:	bf0c      	ite	eq
   14030:	2301      	moveq	r3, #1
   14032:	2300      	movne	r3, #0
   14034:	9305      	str	r3, [sp, #20]
                if (note_on || legato_on[ch]) {
   14036:	f8d4 3688 	ldr.w	r3, [r4, #1672]	; 0x688
   1403a:	d002      	beq.n	14042 <CaptainMIDI::midi_out()+0x70>
   1403c:	2b00      	cmp	r3, #0
   1403e:	f000 8092 	beq.w	14166 <CaptainMIDI::midi_out()+0x194>
        return values_[20 + ch + setup_offset];
   14042:	f10a 0a36 	add.w	sl, sl, #54	; 0x36
                    uint8_t midi_note = MIDIQuantizer::NoteNumber(In(ch), get_out_transpose(ch));
   14046:	69a0      	ldr	r0, [r4, #24]
   14048:	f855 102a 	ldr.w	r1, [r5, sl, lsl #2]
   1404c:	9306      	str	r3, [sp, #24]
   1404e:	f7f1 fc8e 	bl	596e <MIDIQuantizer::NoteNumber(int, int)>
                    if (legato_on[ch] && midi_note != note_out[ch]) {
   14052:	9b06      	ldr	r3, [sp, #24]
                    uint8_t midi_note = MIDIQuantizer::NoteNumber(In(ch), get_out_transpose(ch));
   14054:	4682      	mov	sl, r0
                    if (legato_on[ch] && midi_note != note_out[ch]) {
   14056:	b33b      	cbz	r3, 140a8 <CaptainMIDI::midi_out()+0xd6>
   14058:	f8d4 3668 	ldr.w	r3, [r4, #1640]	; 0x668
   1405c:	4283      	cmp	r3, r0
   1405e:	f000 812e 	beq.w	142be <CaptainMIDI::midi_out()+0x2ec>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14062:	f894 0678 	ldrb.w	r0, [r4, #1656]	; 0x678
   14066:	3801      	subs	r0, #1
   14068:	0200      	lsls	r0, r0, #8
   1406a:	041b      	lsls	r3, r3, #16
   1406c:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
   14070:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   14074:	4318      	orrs	r0, r3
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14076:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
   1407a:	f040 0008 	orr.w	r0, r0, #8
   1407e:	f006 fe95 	bl	1adac <usb_midi_write_packed>
                        UpdateLog(0, ch, 1, last_channel[ch], note_out[ch], 0);
   14082:	2100      	movs	r1, #0
   14084:	9102      	str	r1, [sp, #8]
   14086:	f9b4 3668 	ldrsh.w	r3, [r4, #1640]	; 0x668
   1408a:	9301      	str	r3, [sp, #4]
   1408c:	f894 3678 	ldrb.w	r3, [r4, #1656]	; 0x678
   14090:	9300      	str	r3, [sp, #0]
   14092:	4632      	mov	r2, r6
   14094:	2301      	movs	r3, #1
   14096:	4628      	mov	r0, r5
   14098:	f7f6 feae 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
                        note_out[ch] = -1;
   1409c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   140a0:	f8c4 3668 	str.w	r3, [r4, #1640]	; 0x668
                        note_on = 1;
   140a4:	2301      	movs	r3, #1
   140a6:	9305      	str	r3, [sp, #20]
        int setup_offset = get_setup_number() * MIDI_PARAMETER_COUNT;
   140a8:	f8d5 2308 	ldr.w	r2, [r5, #776]	; 0x308
   140ac:	2128      	movs	r1, #40	; 0x28
   140ae:	434a      	muls	r2, r1
        int range_low = values_[28 + ch + setup_offset];
   140b0:	18b1      	adds	r1, r6, r2
   140b2:	f101 003e 	add.w	r0, r1, #62	; 0x3e
        return (note >= range_low && note <= range_high);
   140b6:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
   140ba:	4582      	cmp	sl, r0
   140bc:	db53      	blt.n	14166 <CaptainMIDI::midi_out()+0x194>
        int range_high = values_[36 + ch + setup_offset];
   140be:	3146      	adds	r1, #70	; 0x46
        return (note >= range_low && note <= range_high);
   140c0:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
   140c4:	458a      	cmp	sl, r1
   140c6:	dc4e      	bgt.n	14166 <CaptainMIDI::midi_out()+0x194>
                    if (note_on) {
   140c8:	9905      	ldr	r1, [sp, #20]
   140ca:	2900      	cmp	r1, #0
   140cc:	d04b      	beq.n	14166 <CaptainMIDI::midi_out()+0x194>
   140ce:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   140d2:	3225      	adds	r2, #37	; 0x25
   140d4:	eb05 0282 	add.w	r2, r5, r2, lsl #2
   140d8:	f105 0134 	add.w	r1, r5, #52	; 0x34
   140dc:	f105 0c44 	add.w	ip, r5, #68	; 0x44
                        int velocity = 0x64;
   140e0:	2364      	movs	r3, #100	; 0x64
                            if (get_out_assign(vch) == MIDI_OUT_VELOCITY && get_out_channel(vch) == out_ch) {
   140e2:	f852 0f04 	ldr.w	r0, [r2, #4]!
   140e6:	2803      	cmp	r0, #3
   140e8:	d10b      	bne.n	14102 <CaptainMIDI::midi_out()+0x130>
   140ea:	6a10      	ldr	r0, [r2, #32]
   140ec:	4287      	cmp	r7, r0
   140ee:	d108      	bne.n	14102 <CaptainMIDI::midi_out()+0x130>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   140f0:	680b      	ldr	r3, [r1, #0]
   140f2:	f44f 50f0 	mov.w	r0, #7680	; 0x1e00
   140f6:	039b      	lsls	r3, r3, #14
   140f8:	fb93 f3f0 	sdiv	r3, r3, r0
        int scaled = simfloat2int(proportion * max_value);
   140fc:	ebc3 13c3 	rsb	r3, r3, r3, lsl #7
   14100:	139b      	asrs	r3, r3, #14
                        for (int vch = 0; vch < 4; vch++)
   14102:	3104      	adds	r1, #4
   14104:	458c      	cmp	ip, r1
   14106:	d1ec      	bne.n	140e2 <CaptainMIDI::midi_out()+0x110>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14108:	b2fa      	uxtb	r2, r7
   1410a:	1e50      	subs	r0, r2, #1
   1410c:	0200      	lsls	r0, r0, #8
   1410e:	f383 0307 	usat	r3, #7, r3
   14112:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   14116:	ea4f 410a 	mov.w	r1, sl, lsl #16
			  | ((data2 & 0x7F) << 24));
   1411a:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1411e:	f401 01fe 	and.w	r1, r1, #8323072	; 0x7f0000
			  | ((data2 & 0x7F) << 24));
   14122:	4308      	orrs	r0, r1
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14124:	f440 4010 	orr.w	r0, r0, #36864	; 0x9000
   14128:	f040 0009 	orr.w	r0, r0, #9
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1412c:	9207      	str	r2, [sp, #28]
			  | ((data2 & 0x7F) << 24));
   1412e:	9306      	str	r3, [sp, #24]
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14130:	f006 fe3c 	bl	1adac <usb_midi_write_packed>
                        UpdateLog(0, ch, 0, out_ch, midi_note, velocity);
   14134:	9b06      	ldr	r3, [sp, #24]
   14136:	9a07      	ldr	r2, [sp, #28]
   14138:	9200      	str	r2, [sp, #0]
   1413a:	b21b      	sxth	r3, r3
   1413c:	9302      	str	r3, [sp, #8]
   1413e:	fa0f f38a 	sxth.w	r3, sl
   14142:	9301      	str	r3, [sp, #4]
   14144:	2300      	movs	r3, #0
   14146:	4619      	mov	r1, r3
   14148:	4632      	mov	r2, r6
   1414a:	4628      	mov	r0, r5
   1414c:	f7f6 fe54 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
                        if (legato) legato_on[ch] = 1;
   14150:	f1b8 0f02 	cmp.w	r8, #2
   14154:	bf04      	itt	eq
   14156:	2301      	moveq	r3, #1
   14158:	f8c4 3688 	streq.w	r3, [r4, #1672]	; 0x688
                        indicator = 1;
   1415c:	9b05      	ldr	r3, [sp, #20]
                        note_out[ch] = midi_note;
   1415e:	f8c4 a668 	str.w	sl, [r4, #1640]	; 0x668
                        last_channel[ch] = out_ch;
   14162:	f8c4 7678 	str.w	r7, [r4, #1656]	; 0x678
                if (!read_gate && gated[ch]) { // A note off message should be sent
   14166:	f1b9 0f00 	cmp.w	r9, #0
   1416a:	d129      	bne.n	141c0 <CaptainMIDI::midi_out()+0x1ee>
   1416c:	f89b a629 	ldrb.w	sl, [fp, #1577]	; 0x629
   14170:	f1ba 0f00 	cmp.w	sl, #0
   14174:	d024      	beq.n	141c0 <CaptainMIDI::midi_out()+0x1ee>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14176:	f894 0678 	ldrb.w	r0, [r4, #1656]	; 0x678
   1417a:	f8d4 3668 	ldr.w	r3, [r4, #1640]	; 0x668
   1417e:	3801      	subs	r0, #1
   14180:	0200      	lsls	r0, r0, #8
   14182:	041b      	lsls	r3, r3, #16
   14184:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
   14188:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   1418c:	4318      	orrs	r0, r3
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   1418e:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
   14192:	f040 0008 	orr.w	r0, r0, #8
   14196:	f006 fe09 	bl	1adac <usb_midi_write_packed>
                    UpdateLog(0, ch, 1, last_channel[ch], note_out[ch], 0);
   1419a:	f8cd 9008 	str.w	r9, [sp, #8]
   1419e:	f9b4 3668 	ldrsh.w	r3, [r4, #1640]	; 0x668
   141a2:	9301      	str	r3, [sp, #4]
   141a4:	f894 3678 	ldrb.w	r3, [r4, #1656]	; 0x678
   141a8:	9300      	str	r3, [sp, #0]
   141aa:	4632      	mov	r2, r6
   141ac:	2301      	movs	r3, #1
   141ae:	4649      	mov	r1, r9
   141b0:	4628      	mov	r0, r5
   141b2:	f7f6 fe21 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
                    note_out[ch] = -1;
   141b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   141ba:	f8c4 3668 	str.w	r3, [r4, #1640]	; 0x668
                    indicator = 1;
   141be:	4653      	mov	r3, sl
                gated[ch] = read_gate;
   141c0:	f88b 9629 	strb.w	r9, [fp, #1577]	; 0x629
                if (!gated[ch]) legato_on[ch] = 0;
   141c4:	f1b9 0f00 	cmp.w	r9, #0
   141c8:	d101      	bne.n	141ce <CaptainMIDI::midi_out()+0x1fc>
   141ca:	f8c4 9688 	str.w	r9, [r4, #1672]	; 0x688
        return changed_cv[ch];
   141ce:	f89b 9000 	ldrb.w	r9, [fp]
            if (Changed(ch)) {
   141d2:	f1b9 0f00 	cmp.w	r9, #0
   141d6:	f000 80c6 	beq.w	14366 <CaptainMIDI::midi_out()+0x394>
                if (out_fn == MIDI_OUT_MOD || out_fn >= MIDI_OUT_EXPRESSION) {
   141da:	f1b8 0f04 	cmp.w	r8, #4
   141de:	d072      	beq.n	142c6 <CaptainMIDI::midi_out()+0x2f4>
   141e0:	f1b8 0f06 	cmp.w	r8, #6
   141e4:	dd3e      	ble.n	14264 <CaptainMIDI::midi_out()+0x292>
                    if (out_fn == MIDI_OUT_EXPRESSION) cc = 11;
   141e6:	f1b8 0f07 	cmp.w	r8, #7
   141ea:	d06e      	beq.n	142ca <CaptainMIDI::midi_out()+0x2f8>
                    if (out_fn == MIDI_OUT_PAN) cc = 10;
   141ec:	f1b8 0f08 	cmp.w	r8, #8
   141f0:	d06d      	beq.n	142ce <CaptainMIDI::midi_out()+0x2fc>
                    if (out_fn == MIDI_OUT_HOLD) cc = 64;
   141f2:	f1b8 0f09 	cmp.w	r8, #9
   141f6:	d06c      	beq.n	142d2 <CaptainMIDI::midi_out()+0x300>
                    if (out_fn == MIDI_OUT_BREATH) cc = 2;
   141f8:	f1b8 0f0a 	cmp.w	r8, #10
   141fc:	d06b      	beq.n	142d6 <CaptainMIDI::midi_out()+0x304>
                    if (out_fn == MIDI_OUT_Y_AXIS) cc = 74;
   141fe:	f1b8 0f0b 	cmp.w	r8, #11
   14202:	bf14      	ite	ne
   14204:	2301      	movne	r3, #1
   14206:	234a      	moveq	r3, #74	; 0x4a
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14208:	69a2      	ldr	r2, [r4, #24]
                    if (cc == 64) value = (value >= 60) ? 127 : 0; // On or off for sustain pedal
   1420a:	2b40      	cmp	r3, #64	; 0x40
   1420c:	ea4f 3a82 	mov.w	sl, r2, lsl #14
   14210:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
   14214:	fb9a faf2 	sdiv	sl, sl, r2
        int scaled = simfloat2int(proportion * max_value);
   14218:	ebca 1aca 	rsb	sl, sl, sl, lsl #7
   1421c:	ea4f 3aaa 	mov.w	sl, sl, asr #14
   14220:	d05b      	beq.n	142da <CaptainMIDI::midi_out()+0x308>
   14222:	f38a 0a07 	usat	sl, #7, sl
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14226:	b2fa      	uxtb	r2, r7
   14228:	1e50      	subs	r0, r2, #1
   1422a:	0200      	lsls	r0, r0, #8
   1422c:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
   14230:	ea40 600a 	orr.w	r0, r0, sl, lsl #24
   14234:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14238:	f440 4030 	orr.w	r0, r0, #45056	; 0xb000
   1423c:	f040 000b 	orr.w	r0, r0, #11
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14240:	9206      	str	r2, [sp, #24]
			  | ((data2 & 0x7F) << 24));
   14242:	9305      	str	r3, [sp, #20]
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14244:	f006 fdb2 	bl	1adac <usb_midi_write_packed>
                    UpdateLog(0, ch, 2, out_ch, cc, value);
   14248:	9b05      	ldr	r3, [sp, #20]
   1424a:	9a06      	ldr	r2, [sp, #24]
   1424c:	9301      	str	r3, [sp, #4]
   1424e:	fa0f f18a 	sxth.w	r1, sl
   14252:	9102      	str	r1, [sp, #8]
   14254:	9200      	str	r2, [sp, #0]
   14256:	2302      	movs	r3, #2
   14258:	4632      	mov	r2, r6
   1425a:	2100      	movs	r1, #0
   1425c:	4628      	mov	r0, r5
   1425e:	f7f6 fdcb 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
                    indicator = 1;
   14262:	464b      	mov	r3, r9
                if (out_fn == MIDI_OUT_AFTERTOUCH) {
   14264:	f1b8 0f05 	cmp.w	r8, #5
   14268:	d13f      	bne.n	142ea <CaptainMIDI::midi_out()+0x318>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1426a:	69a3      	ldr	r3, [r4, #24]
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1426c:	b2ff      	uxtb	r7, r7
   1426e:	1e78      	subs	r0, r7, #1
   14270:	ea4f 3883 	mov.w	r8, r3, lsl #14
   14274:	0200      	lsls	r0, r0, #8
   14276:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   1427a:	fb98 f8f3 	sdiv	r8, r8, r3
        int scaled = simfloat2int(proportion * max_value);
   1427e:	ebc8 18c8 	rsb	r8, r8, r8, lsl #7
   14282:	f3a8 3887 	usat	r8, #7, r8, asr #14
   14286:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   1428a:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   1428e:	f440 4050 	orr.w	r0, r0, #53248	; 0xd000
   14292:	f040 000d 	orr.w	r0, r0, #13
   14296:	f006 fd89 	bl	1adac <usb_midi_write_packed>
                    UpdateLog(0, ch, 3, out_ch, 0, value);
   1429a:	fa0f f388 	sxth.w	r3, r8
   1429e:	2100      	movs	r1, #0
   142a0:	9302      	str	r3, [sp, #8]
   142a2:	9101      	str	r1, [sp, #4]
   142a4:	9700      	str	r7, [sp, #0]
   142a6:	2303      	movs	r3, #3
                    UpdateLog(0, ch, 4, out_ch, 0, bend - 8192);
   142a8:	4632      	mov	r2, r6
   142aa:	4628      	mov	r0, r5
   142ac:	f7f6 fda4 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
            if (indicator) indicator_out[ch] = MIDI_INDICATOR_COUNTDOWN;
   142b0:	f205 63b4 	addw	r3, r5, #1716	; 0x6b4
   142b4:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
   142b8:	f823 2016 	strh.w	r2, [r3, r6, lsl #1]
   142bc:	e055      	b.n	1436a <CaptainMIDI::midi_out()+0x398>
            bool indicator = 0;
   142be:	2300      	movs	r3, #0
   142c0:	e6f2      	b.n	140a8 <CaptainMIDI::midi_out()+0xd6>
   142c2:	2300      	movs	r3, #0
   142c4:	e783      	b.n	141ce <CaptainMIDI::midi_out()+0x1fc>
   142c6:	2301      	movs	r3, #1
   142c8:	e79e      	b.n	14208 <CaptainMIDI::midi_out()+0x236>
                    if (out_fn == MIDI_OUT_EXPRESSION) cc = 11;
   142ca:	230b      	movs	r3, #11
   142cc:	e79c      	b.n	14208 <CaptainMIDI::midi_out()+0x236>
                    if (out_fn == MIDI_OUT_PAN) cc = 10;
   142ce:	230a      	movs	r3, #10
   142d0:	e79a      	b.n	14208 <CaptainMIDI::midi_out()+0x236>
                    if (out_fn == MIDI_OUT_HOLD) cc = 64;
   142d2:	2340      	movs	r3, #64	; 0x40
   142d4:	e798      	b.n	14208 <CaptainMIDI::midi_out()+0x236>
                    if (out_fn == MIDI_OUT_BREATH) cc = 2;
   142d6:	2302      	movs	r3, #2
   142d8:	e796      	b.n	14208 <CaptainMIDI::midi_out()+0x236>
                    if (cc == 64) value = (value >= 60) ? 127 : 0; // On or off for sustain pedal
   142da:	f1ba 0f3b 	cmp.w	sl, #59	; 0x3b
   142de:	bfcc      	ite	gt
   142e0:	f04f 0a7f 	movgt.w	sl, #127	; 0x7f
   142e4:	f04f 0a00 	movle.w	sl, #0
   142e8:	e79d      	b.n	14226 <CaptainMIDI::midi_out()+0x254>
                if (out_fn == MIDI_OUT_PITCHBEND) {
   142ea:	f1b8 0f06 	cmp.w	r8, #6
   142ee:	d13a      	bne.n	14366 <CaptainMIDI::midi_out()+0x394>
                    int16_t bend = Proportion(In(ch) + HSAPPLICATION_3V, HSAPPLICATION_3V * 2, 16383);
   142f0:	69a3      	ldr	r3, [r4, #24]
   142f2:	f503 5890 	add.w	r8, r3, #4608	; 0x1200
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   142f6:	ea4f 3888 	mov.w	r8, r8, lsl #14
   142fa:	f44f 5310 	mov.w	r3, #9216	; 0x2400
   142fe:	fb98 f8f3 	sdiv	r8, r8, r3
        int scaled = simfloat2int(proportion * max_value);
   14302:	ebc8 3888 	rsb	r8, r8, r8, lsl #14
   14306:	f348 388f 	sbfx	r8, r8, #14, #16
                    bend = constrain(bend, 0, 16383);
   1430a:	f1b8 0f00 	cmp.w	r8, #0
   1430e:	db27      	blt.n	14360 <CaptainMIDI::midi_out()+0x38e>
   14310:	f643 73ff 	movw	r3, #16383	; 0x3fff
   14314:	4598      	cmp	r8, r3
   14316:	bfa8      	it	ge
   14318:	4698      	movge	r8, r3
		value += 8192;
   1431a:	f641 73ff 	movw	r3, #8191	; 0x1fff
   1431e:	4543      	cmp	r3, r8
   14320:	bfa8      	it	ge
   14322:	4643      	movge	r3, r8
   14324:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14328:	0418      	lsls	r0, r3, #16
   1432a:	b2ff      	uxtb	r7, r7
		send(0xE0, value, value >> 7, channel, cable);
   1432c:	11db      	asrs	r3, r3, #7
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1432e:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
			  | ((data2 & 0x7F) << 24));
   14332:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14336:	1e7b      	subs	r3, r7, #1
   14338:	021b      	lsls	r3, r3, #8
   1433a:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
   1433e:	4318      	orrs	r0, r3
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14340:	f440 4060 	orr.w	r0, r0, #57344	; 0xe000
   14344:	f040 000e 	orr.w	r0, r0, #14
                    UpdateLog(0, ch, 4, out_ch, 0, bend - 8192);
   14348:	f5a8 5800 	sub.w	r8, r8, #8192	; 0x2000
   1434c:	f006 fd2e 	bl	1adac <usb_midi_write_packed>
   14350:	fa0f f388 	sxth.w	r3, r8
   14354:	2100      	movs	r1, #0
   14356:	9302      	str	r3, [sp, #8]
   14358:	9101      	str	r1, [sp, #4]
   1435a:	9700      	str	r7, [sp, #0]
   1435c:	2304      	movs	r3, #4
   1435e:	e7a3      	b.n	142a8 <CaptainMIDI::midi_out()+0x2d6>
                    bend = constrain(bend, 0, 16383);
   14360:	f04f 0800 	mov.w	r8, #0
   14364:	e7d9      	b.n	1431a <CaptainMIDI::midi_out()+0x348>
            if (indicator) indicator_out[ch] = MIDI_INDICATOR_COUNTDOWN;
   14366:	2b00      	cmp	r3, #0
   14368:	d1a2      	bne.n	142b0 <CaptainMIDI::midi_out()+0x2de>
        for (int ch = 0; ch < 4; ch++)
   1436a:	3601      	adds	r6, #1
   1436c:	2e04      	cmp	r6, #4
   1436e:	f104 0404 	add.w	r4, r4, #4
   14372:	f10b 0b01 	add.w	fp, fp, #1
   14376:	f47f ae35 	bne.w	13fe4 <CaptainMIDI::midi_out()+0x12>
    }
   1437a:	b009      	add	sp, #36	; 0x24
   1437c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00014380 <CaptainMIDI::Controller()>:
    void Controller() {
   14380:	b510      	push	{r4, lr}
   14382:	4604      	mov	r4, r0
        midi_in();
   14384:	f7f6 fd7a 	bl	ae7c <CaptainMIDI::midi_in()>
        midi_out();
   14388:	4620      	mov	r0, r4
   1438a:	f7ff fe22 	bl	13fd2 <CaptainMIDI::midi_out()>
        for (int ch = 0; ch < 4; ch++)
   1438e:	f204 6372 	addw	r3, r4, #1650	; 0x672
   14392:	f204 647a 	addw	r4, r4, #1658	; 0x67a
            if (indicator_in[ch] > 0) --indicator_in[ch];
   14396:	f833 2f02 	ldrh.w	r2, [r3, #2]!
   1439a:	b10a      	cbz	r2, 143a0 <CaptainMIDI::Controller()+0x20>
   1439c:	3a01      	subs	r2, #1
   1439e:	801a      	strh	r2, [r3, #0]
            if (indicator_out[ch] > 0) --indicator_out[ch];
   143a0:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
   143a4:	b112      	cbz	r2, 143ac <CaptainMIDI::Controller()+0x2c>
   143a6:	3a01      	subs	r2, #1
   143a8:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
        for (int ch = 0; ch < 4; ch++)
   143ac:	42a3      	cmp	r3, r4
   143ae:	d1f2      	bne.n	14396 <CaptainMIDI::Controller()+0x16>
    }
   143b0:	bd10      	pop	{r4, pc}

000143b2 <non-virtual thunk to CaptainMIDI::Controller()>:
    void Controller() {
   143b2:	f1a0 0008 	sub.w	r0, r0, #8
   143b6:	e7e3      	b.n	14380 <CaptainMIDI::Controller()>

000143b8 <HemisphereApplet::Gate(int)>:
        if (hemisphere == 0) {
   143b8:	7900      	ldrb	r0, [r0, #4]
    bool Gate(int ch) {
   143ba:	b508      	push	{r3, lr}
        if (hemisphere == 0) {
   143bc:	b998      	cbnz	r0, 143e6 <HemisphereApplet::Gate(int)+0x2e>
            if (ch == 0) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_1>();
   143be:	b911      	cbnz	r1, 143c6 <HemisphereApplet::Gate(int)+0xe>
   143c0:	f7ff fd56 	bl	13e70 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)0>()>
    }
   143c4:	bd08      	pop	{r3, pc}
            if (ch == 1) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_2>();
   143c6:	2901      	cmp	r1, #1
   143c8:	d1fc      	bne.n	143c4 <HemisphereApplet::Gate(int)+0xc>
   143ca:	4b09      	ldr	r3, [pc, #36]	; (143f0 <HemisphereApplet::Gate(int)+0x38>)
   143cc:	f8d3 00d0 	ldr.w	r0, [r3, #208]	; 0xd0
   143d0:	43c0      	mvns	r0, r0
   143d2:	f000 0001 	and.w	r0, r0, #1
   143d6:	e7f5      	b.n	143c4 <HemisphereApplet::Gate(int)+0xc>
            if (ch == 1) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_4>();
   143d8:	2901      	cmp	r1, #1
   143da:	d102      	bne.n	143e2 <HemisphereApplet::Gate(int)+0x2a>
   143dc:	f7ff fd5c 	bl	13e98 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()>
   143e0:	e7f0      	b.n	143c4 <HemisphereApplet::Gate(int)+0xc>
        bool high = 0;
   143e2:	2000      	movs	r0, #0
        return high;
   143e4:	e7ee      	b.n	143c4 <HemisphereApplet::Gate(int)+0xc>
            if (ch == 0) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_3>();
   143e6:	2900      	cmp	r1, #0
   143e8:	d1f6      	bne.n	143d8 <HemisphereApplet::Gate(int)+0x20>
   143ea:	f7ff fd4b 	bl	13e84 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)2>()>
            if (ch == 1) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_4>();
   143ee:	e7e9      	b.n	143c4 <HemisphereApplet::Gate(int)+0xc>
   143f0:	400ff000 	.word	0x400ff000

000143f4 <hMIDIOut::Controller()>:
    void Controller() {
   143f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        bool read_gate = Gate(0);
   143f8:	2100      	movs	r1, #0
    void Controller() {
   143fa:	4604      	mov	r4, r0
        bool read_gate = Gate(0);
   143fc:	f7ff ffdc 	bl	143b8 <HemisphereApplet::Gate(int)>
        if (read_gate && !gated) StartADCLag();
   14400:	4606      	mov	r6, r0
   14402:	b120      	cbz	r0, 1440e <hMIDIOut::Controller()+0x1a>
   14404:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
   14408:	b90b      	cbnz	r3, 1440e <hMIDIOut::Controller()+0x1a>
        adc_lag_countdown[ch] = HEMISPHERE_ADC_LAG;
   1440a:	2321      	movs	r3, #33	; 0x21
   1440c:	64e3      	str	r3, [r4, #76]	; 0x4c
        return (--adc_lag_countdown[ch] == 0);
   1440e:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
   14410:	f894 808d 	ldrb.w	r8, [r4, #141]	; 0x8d
   14414:	3d01      	subs	r5, #1
   14416:	64e5      	str	r5, [r4, #76]	; 0x4c
        if (note_on || legato_on) {
   14418:	b115      	cbz	r5, 14420 <hMIDIOut::Controller()+0x2c>
   1441a:	f1b8 0f00 	cmp.w	r8, #0
   1441e:	d05d      	beq.n	144dc <hMIDIOut::Controller()+0xe8>
            uint8_t midi_note = MIDIQuantizer::NoteNumber(In(0), transpose);
   14420:	6f61      	ldr	r1, [r4, #116]	; 0x74
   14422:	6a20      	ldr	r0, [r4, #32]
   14424:	f7f1 faa3 	bl	596e <MIDIQuantizer::NoteNumber(int, int)>
   14428:	4607      	mov	r7, r0
            if (legato_on && midi_note != last_note) {
   1442a:	f1b8 0f00 	cmp.w	r8, #0
   1442e:	d053      	beq.n	144d8 <hMIDIOut::Controller()+0xe4>
   14430:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   14434:	4290      	cmp	r0, r2
   14436:	d04f      	beq.n	144d8 <hMIDIOut::Controller()+0xe4>
                usbMIDI.sendNoteOff(last_note, 0, last_channel + 1);
   14438:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   1443c:	1c58      	adds	r0, r3, #1
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1443e:	b2c0      	uxtb	r0, r0
   14440:	3801      	subs	r0, #1
   14442:	0200      	lsls	r0, r0, #8
   14444:	0412      	lsls	r2, r2, #16
   14446:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
   1444a:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   1444e:	4310      	orrs	r0, r2
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14450:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
   14454:	f040 0008 	orr.w	r0, r0, #8
   14458:	f006 fca8 	bl	1adac <usb_midi_write_packed>
                UpdateLog(HEM_MIDI_NOTE_OFF, midi_note, 0);
   1445c:	2300      	movs	r3, #0
   1445e:	463a      	mov	r2, r7
   14460:	4619      	mov	r1, r3
   14462:	4620      	mov	r0, r4
   14464:	f7fe fff6 	bl	13454 <hMIDIOut::UpdateLog(int, int, int)>
                if (function == HEM_MIDI_VEL_IN) {
   14468:	6f23      	ldr	r3, [r4, #112]	; 0x70
   1446a:	2b03      	cmp	r3, #3
   1446c:	f040 80ef 	bne.w	1464e <hMIDIOut::Controller()+0x25a>
                    velocity = ProportionCV(In(1), 127);
   14470:	6a60      	ldr	r0, [r4, #36]	; 0x24
   14472:	217f      	movs	r1, #127	; 0x7f
   14474:	f7f0 f8f6 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
   14478:	4680      	mov	r8, r0
                usbMIDI.sendNoteOn(midi_note, velocity, channel + 1);
   1447a:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
                last_velocity = velocity;
   1447c:	f8c4 8084 	str.w	r8, [r4, #132]	; 0x84
                usbMIDI.sendNoteOn(midi_note, velocity, channel + 1);
   14480:	3501      	adds	r5, #1
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14482:	b2ed      	uxtb	r5, r5
   14484:	3d01      	subs	r5, #1
   14486:	022d      	lsls	r5, r5, #8
			  | ((data2 & 0x7F) << 24));
   14488:	ea4f 6308 	mov.w	r3, r8, lsl #24
   1448c:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14490:	f405 6570 	and.w	r5, r5, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
   14494:	431d      	orrs	r5, r3
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14496:	043b      	lsls	r3, r7, #16
   14498:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
			  | ((data2 & 0x7F) << 24));
   1449c:	431d      	orrs	r5, r3
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   1449e:	f445 4010 	orr.w	r0, r5, #36864	; 0x9000
   144a2:	f040 0009 	orr.w	r0, r0, #9
   144a6:	f006 fc81 	bl	1adac <usb_midi_write_packed>
		usb_midi_flush_output();
   144aa:	f006 fd1b 	bl	1aee4 <usb_midi_flush_output>
                last_channel = channel;
   144ae:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   144b0:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
                last_tick = OC::CORE::ticks;
   144b4:	4b67      	ldr	r3, [pc, #412]	; (14654 <hMIDIOut::Controller()+0x260>)
                last_note = midi_note;
   144b6:	f8c4 7080 	str.w	r7, [r4, #128]	; 0x80
                last_tick = OC::CORE::ticks;
   144ba:	681b      	ldr	r3, [r3, #0]
   144bc:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
                if (legato) legato_on = 1;
   144c0:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   144c2:	b113      	cbz	r3, 144ca <hMIDIOut::Controller()+0xd6>
   144c4:	2301      	movs	r3, #1
   144c6:	f884 308d 	strb.w	r3, [r4, #141]	; 0x8d
                UpdateLog(HEM_MIDI_NOTE_ON, midi_note, velocity);
   144ca:	4643      	mov	r3, r8
   144cc:	463a      	mov	r2, r7
   144ce:	2101      	movs	r1, #1
   144d0:	4620      	mov	r0, r4
   144d2:	f7fe ffbf 	bl	13454 <hMIDIOut::UpdateLog(int, int, int)>
   144d6:	e001      	b.n	144dc <hMIDIOut::Controller()+0xe8>
            if (note_on) {
   144d8:	2d00      	cmp	r5, #0
   144da:	d0c5      	beq.n	14468 <hMIDIOut::Controller()+0x74>
        if (!read_gate && gated) { // A note off message should be sent
   144dc:	bb1e      	cbnz	r6, 14526 <hMIDIOut::Controller()+0x132>
   144de:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
   144e2:	b303      	cbz	r3, 14526 <hMIDIOut::Controller()+0x132>
            usbMIDI.sendNoteOff(last_note, 0, last_channel + 1);
   144e4:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   144e8:	1c58      	adds	r0, r3, #1
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   144ea:	b2c0      	uxtb	r0, r0
   144ec:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   144f0:	3801      	subs	r0, #1
   144f2:	0200      	lsls	r0, r0, #8
   144f4:	041b      	lsls	r3, r3, #16
   144f6:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
   144fa:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   144fe:	4318      	orrs	r0, r3
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14500:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
   14504:	f040 0008 	orr.w	r0, r0, #8
   14508:	f006 fc50 	bl	1adac <usb_midi_write_packed>
		usb_midi_flush_output();
   1450c:	f006 fcea 	bl	1aee4 <usb_midi_flush_output>
            UpdateLog(HEM_MIDI_NOTE_OFF, last_note, 0);
   14510:	4633      	mov	r3, r6
   14512:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   14516:	4631      	mov	r1, r6
   14518:	4620      	mov	r0, r4
   1451a:	f7fe ff9b 	bl	13454 <hMIDIOut::UpdateLog(int, int, int)>
            last_tick = OC::CORE::ticks;
   1451e:	4b4d      	ldr	r3, [pc, #308]	; (14654 <hMIDIOut::Controller()+0x260>)
   14520:	681b      	ldr	r3, [r3, #0]
   14522:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
        gated = read_gate;
   14526:	f884 608c 	strb.w	r6, [r4, #140]	; 0x8c
        if (!gated) legato_on = 0;
   1452a:	b90e      	cbnz	r6, 14530 <hMIDIOut::Controller()+0x13c>
   1452c:	f884 608d 	strb.w	r6, [r4, #141]	; 0x8d
        if (function != HEM_MIDI_VEL_IN) {
   14530:	6f26      	ldr	r6, [r4, #112]	; 0x70
   14532:	2e03      	cmp	r6, #3
   14534:	f000 8089 	beq.w	1464a <hMIDIOut::Controller()+0x256>
            if (Changed(1)) {
   14538:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
   1453c:	2b00      	cmp	r3, #0
   1453e:	f000 8084 	beq.w	1464a <hMIDIOut::Controller()+0x256>
                if (function == HEM_MIDI_CC_IN) {
   14542:	bb0e      	cbnz	r6, 14588 <hMIDIOut::Controller()+0x194>
                    int value = ProportionCV(In(1), 127);
   14544:	6a60      	ldr	r0, [r4, #36]	; 0x24
   14546:	217f      	movs	r1, #127	; 0x7f
   14548:	f7f0 f88c 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
                    usbMIDI.sendControlChange(1, value, channel + 1);
   1454c:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
   1454e:	3101      	adds	r1, #1
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14550:	b2c9      	uxtb	r1, r1
   14552:	3901      	subs	r1, #1
			  | ((data2 & 0x7F) << 24));
   14554:	0603      	lsls	r3, r0, #24
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14556:	0209      	lsls	r1, r1, #8
			  | ((data2 & 0x7F) << 24));
   14558:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1455c:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
   14560:	4319      	orrs	r1, r3
                    int value = ProportionCV(In(1), 127);
   14562:	4605      	mov	r5, r0
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14564:	f441 30d8 	orr.w	r0, r1, #110592	; 0x1b000
   14568:	f040 000b 	orr.w	r0, r0, #11
   1456c:	f006 fc1e 	bl	1adac <usb_midi_write_packed>
		usb_midi_flush_output();
   14570:	f006 fcb8 	bl	1aee4 <usb_midi_flush_output>
                    UpdateLog(HEM_MIDI_CC, value, 0);
   14574:	4633      	mov	r3, r6
   14576:	462a      	mov	r2, r5
   14578:	2103      	movs	r1, #3
   1457a:	4620      	mov	r0, r4
   1457c:	f7fe ff6a 	bl	13454 <hMIDIOut::UpdateLog(int, int, int)>
                    last_tick = OC::CORE::ticks;
   14580:	4b34      	ldr	r3, [pc, #208]	; (14654 <hMIDIOut::Controller()+0x260>)
   14582:	681b      	ldr	r3, [r3, #0]
   14584:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
                if (function == HEM_MIDI_AT_IN) {
   14588:	6f23      	ldr	r3, [r4, #112]	; 0x70
   1458a:	2b01      	cmp	r3, #1
   1458c:	d121      	bne.n	145d2 <hMIDIOut::Controller()+0x1de>
                    int value = ProportionCV(In(1), 127);
   1458e:	217f      	movs	r1, #127	; 0x7f
   14590:	6a60      	ldr	r0, [r4, #36]	; 0x24
   14592:	f7f0 f867 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
                    usbMIDI.sendAfterTouch(value, channel + 1);
   14596:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   14598:	3301      	adds	r3, #1
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1459a:	b2db      	uxtb	r3, r3
   1459c:	3b01      	subs	r3, #1
   1459e:	0402      	lsls	r2, r0, #16
   145a0:	021b      	lsls	r3, r3, #8
   145a2:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
   145a6:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
   145aa:	4313      	orrs	r3, r2
                    int value = ProportionCV(In(1), 127);
   145ac:	4605      	mov	r5, r0
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   145ae:	f443 4050 	orr.w	r0, r3, #53248	; 0xd000
   145b2:	f040 000d 	orr.w	r0, r0, #13
   145b6:	f006 fbf9 	bl	1adac <usb_midi_write_packed>
		usb_midi_flush_output();
   145ba:	f006 fc93 	bl	1aee4 <usb_midi_flush_output>
                    UpdateLog(HEM_MIDI_AFTERTOUCH, value, 0);
   145be:	2300      	movs	r3, #0
   145c0:	462a      	mov	r2, r5
   145c2:	2105      	movs	r1, #5
   145c4:	4620      	mov	r0, r4
   145c6:	f7fe ff45 	bl	13454 <hMIDIOut::UpdateLog(int, int, int)>
                    last_tick = OC::CORE::ticks;
   145ca:	4b22      	ldr	r3, [pc, #136]	; (14654 <hMIDIOut::Controller()+0x260>)
   145cc:	681b      	ldr	r3, [r3, #0]
   145ce:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
                if (function == HEM_MIDI_PB_IN) {
   145d2:	6f23      	ldr	r3, [r4, #112]	; 0x70
   145d4:	2b02      	cmp	r3, #2
   145d6:	d138      	bne.n	1464a <hMIDIOut::Controller()+0x256>
                    uint16_t bend = Proportion(In(1) + HEMISPHERE_3V_CV, HEMISPHERE_3V_CV * 2, 16383);
   145d8:	6a65      	ldr	r5, [r4, #36]	; 0x24
   145da:	f505 5590 	add.w	r5, r5, #4608	; 0x1200
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   145de:	f44f 5310 	mov.w	r3, #9216	; 0x2400
   145e2:	03ad      	lsls	r5, r5, #14
   145e4:	fb95 f5f3 	sdiv	r5, r5, r3
        int scaled = simfloat2int(proportion * max_value);
   145e8:	ebc5 3585 	rsb	r5, r5, r5, lsl #14
                    bend = constrain(bend, 0, 16383);
   145ec:	f3c5 358f 	ubfx	r5, r5, #14, #16
   145f0:	f643 73ff 	movw	r3, #16383	; 0x3fff
   145f4:	429d      	cmp	r5, r3
   145f6:	bfa8      	it	ge
   145f8:	461d      	movge	r5, r3
		value += 8192;
   145fa:	f641 72ff 	movw	r2, #8191	; 0x1fff
                    usbMIDI.sendPitchBend(bend, channel + 1);
   145fe:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   14600:	42aa      	cmp	r2, r5
   14602:	bfa8      	it	ge
   14604:	462a      	movge	r2, r5
   14606:	1c58      	adds	r0, r3, #1
   14608:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1460c:	b2c0      	uxtb	r0, r0
   1460e:	0413      	lsls	r3, r2, #16
   14610:	3801      	subs	r0, #1
		send(0xE0, value, value >> 7, channel, cable);
   14612:	11d2      	asrs	r2, r2, #7
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   14614:	0200      	lsls	r0, r0, #8
   14616:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
			  | ((data2 & 0x7F) << 24));
   1461a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   1461e:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
   14622:	4318      	orrs	r0, r3
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   14624:	f440 4060 	orr.w	r0, r0, #57344	; 0xe000
   14628:	f040 000e 	orr.w	r0, r0, #14
   1462c:	f006 fbbe 	bl	1adac <usb_midi_write_packed>
		usb_midi_flush_output();
   14630:	f006 fc58 	bl	1aee4 <usb_midi_flush_output>
                    UpdateLog(HEM_MIDI_PITCHBEND, bend - 8192, 0);
   14634:	2300      	movs	r3, #0
   14636:	f5a5 5200 	sub.w	r2, r5, #8192	; 0x2000
   1463a:	2106      	movs	r1, #6
   1463c:	4620      	mov	r0, r4
   1463e:	f7fe ff09 	bl	13454 <hMIDIOut::UpdateLog(int, int, int)>
                    last_tick = OC::CORE::ticks;
   14642:	4b04      	ldr	r3, [pc, #16]	; (14654 <hMIDIOut::Controller()+0x260>)
   14644:	681b      	ldr	r3, [r3, #0]
   14646:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    }
   1464a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                int velocity = 0x64;
   1464e:	f04f 0864 	mov.w	r8, #100	; 0x64
   14652:	e712      	b.n	1447a <hMIDIOut::Controller()+0x86>
   14654:	200046cc 	.word	0x200046cc

00014658 <Voltage::Controller()>:
    void Controller() {
   14658:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1465a:	4604      	mov	r4, r0
   1465c:	f100 076f 	add.w	r7, r0, #111	; 0x6f
   14660:	f100 0674 	add.w	r6, r0, #116	; 0x74
        ForEachChannel(ch)
   14664:	2500      	movs	r5, #0
            if (gate[ch]) { // Normally off
   14666:	7b7b      	ldrb	r3, [r7, #13]
                if (Gate(ch)) cv = voltage[ch] * VOLTAGE_INCREMENTS;
   14668:	4629      	mov	r1, r5
   1466a:	4620      	mov	r0, r4
            if (gate[ch]) { // Normally off
   1466c:	b193      	cbz	r3, 14694 <Voltage::Controller()+0x3c>
                if (Gate(ch)) cv = voltage[ch] * VOLTAGE_INCREMENTS;
   1466e:	f7ff fea3 	bl	143b8 <HemisphereApplet::Gate(int)>
   14672:	b998      	cbnz	r0, 1469c <Voltage::Controller()+0x44>
                else cv = 0;
   14674:	2200      	movs	r2, #0
            view[ch] = cv ? 1 : 0;
   14676:	1e13      	subs	r3, r2, #0
   14678:	bf18      	it	ne
   1467a:	2301      	movne	r3, #1
   1467c:	f807 3f01 	strb.w	r3, [r7, #1]!
            Out(ch, cv);
   14680:	4629      	mov	r1, r5
   14682:	2300      	movs	r3, #0
   14684:	4620      	mov	r0, r4
   14686:	f7f4 fc26 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
   1468a:	3604      	adds	r6, #4
   1468c:	b105      	cbz	r5, 14690 <Voltage::Controller()+0x38>
    }
   1468e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14690:	2501      	movs	r5, #1
   14692:	e7e8      	b.n	14666 <Voltage::Controller()+0xe>
                if (Gate(ch)) cv = 0;
   14694:	f7ff fe90 	bl	143b8 <HemisphereApplet::Gate(int)>
   14698:	2800      	cmp	r0, #0
   1469a:	d1eb      	bne.n	14674 <Voltage::Controller()+0x1c>
                else cv = voltage[ch] * VOLTAGE_INCREMENTS;
   1469c:	6832      	ldr	r2, [r6, #0]
   1469e:	01d2      	lsls	r2, r2, #7
   146a0:	e7e9      	b.n	14676 <Voltage::Controller()+0x1e>

000146a2 <VectorEG::Controller()>:
    void Controller() {
   146a2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   146a6:	4605      	mov	r5, r0
   146a8:	f100 08ff 	add.w	r8, r0, #255	; 0xff
   146ac:	f100 0470 	add.w	r4, r0, #112	; 0x70
        ForEachChannel(ch)
   146b0:	2700      	movs	r7, #0
            if (Gate(ch)) {
   146b2:	4639      	mov	r1, r7
   146b4:	4628      	mov	r0, r5
   146b6:	f7ff fe7f 	bl	143b8 <HemisphereApplet::Gate(int)>
   146ba:	4606      	mov	r6, r0
   146bc:	b1d0      	cbz	r0, 146f4 <VectorEG::Controller()+0x52>
                if (!gated[ch]) { // Gate wasn't on last time, so start the waveform
   146be:	f898 9001 	ldrb.w	r9, [r8, #1]
   146c2:	f1b9 0f00 	cmp.w	r9, #0
   146c6:	d104      	bne.n	146d2 <VectorEG::Controller()+0x30>
        Reset();
   146c8:	4620      	mov	r0, r4
   146ca:	f7f8 ffa6 	bl	d61a <VectorOscillator::Reset()>
        eoc = 0;
   146ce:	f884 9028 	strb.w	r9, [r4, #40]	; 0x28
            Out(ch, osc[ch].Next());
   146d2:	4620      	mov	r0, r4
                gated[ch] = 1;
   146d4:	f808 6f01 	strb.w	r6, [r8, #1]!
            Out(ch, osc[ch].Next());
   146d8:	f7f8 ffdd 	bl	d696 <VectorOscillator::Next()>
   146dc:	2300      	movs	r3, #0
   146de:	4602      	mov	r2, r0
   146e0:	4639      	mov	r1, r7
   146e2:	4628      	mov	r0, r5
   146e4:	f7f4 fbf7 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
   146e8:	3448      	adds	r4, #72	; 0x48
   146ea:	b10f      	cbz	r7, 146f0 <VectorEG::Controller()+0x4e>
    }
   146ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   146f0:	2701      	movs	r7, #1
   146f2:	e7de      	b.n	146b2 <VectorEG::Controller()+0x10>
                if (gated[ch]) { // Gate isn't on now, but was on last time, so release
   146f4:	f898 3001 	ldrb.w	r3, [r8, #1]
   146f8:	2b00      	cmp	r3, #0
   146fa:	d0ea      	beq.n	146d2 <VectorEG::Controller()+0x30>
        segment_index = segment_count - 1;
   146fc:	7e21      	ldrb	r1, [r4, #24]
        sustained = 0;
   146fe:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
        segment_index = segment_count - 1;
   14702:	3901      	subs	r1, #1
   14704:	b2c9      	uxtb	r1, r1
   14706:	f884 1029 	strb.w	r1, [r4, #41]	; 0x29
        rise = calculate_rise(segment_index);
   1470a:	4620      	mov	r0, r4
   1470c:	f7f8 ff36 	bl	d57c <VectorOscillator::calculate_rise(unsigned char)>
   14710:	62e0      	str	r0, [r4, #44]	; 0x2c
    }
   14712:	e7de      	b.n	146d2 <VectorEG::Controller()+0x30>

00014714 <TLNeuron::Controller()>:
    void Controller() {
   14714:	b538      	push	{r3, r4, r5, lr}
            if (Gate(ch)) {
   14716:	2100      	movs	r1, #0
    void Controller() {
   14718:	4604      	mov	r4, r0
            if (Gate(ch)) {
   1471a:	f7ff fe4d 	bl	143b8 <HemisphereApplet::Gate(int)>
   1471e:	2800      	cmp	r0, #0
   14720:	d033      	beq.n	1478a <TLNeuron::Controller()+0x76>
                sum += dendrite_weight[ch];
   14722:	6f25      	ldr	r5, [r4, #112]	; 0x70
                dendrite_activated[ch] = 1;
   14724:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
            if (Gate(ch)) {
   14728:	2101      	movs	r1, #1
   1472a:	4620      	mov	r0, r4
   1472c:	f7ff fe44 	bl	143b8 <HemisphereApplet::Gate(int)>
   14730:	b108      	cbz	r0, 14736 <TLNeuron::Controller()+0x22>
                sum += dendrite_weight[ch];
   14732:	6f63      	ldr	r3, [r4, #116]	; 0x74
   14734:	441d      	add	r5, r3
        if (In(0) > (HEMISPHERE_MAX_CV / 2)) {
   14736:	6a23      	ldr	r3, [r4, #32]
   14738:	f884 0081 	strb.w	r0, [r4, #129]	; 0x81
   1473c:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
            sum += dendrite_weight[2];
   14740:	bfc9      	itett	gt
   14742:	6fa3      	ldrgt	r3, [r4, #120]	; 0x78
            dendrite_activated[2] = 0;
   14744:	2300      	movle	r3, #0
            sum += dendrite_weight[2];
   14746:	18ed      	addgt	r5, r5, r3
            dendrite_activated[2] = 1;
   14748:	2301      	movgt	r3, #1
   1474a:	f884 3082 	strb.w	r3, [r4, #130]	; 0x82
        if (!axon_activated) axon_radius = 5;
   1474e:	f894 3083 	ldrb.w	r3, [r4, #131]	; 0x83
   14752:	b913      	cbnz	r3, 1475a <TLNeuron::Controller()+0x46>
   14754:	2305      	movs	r3, #5
   14756:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        axon_activated = (sum > threshold);
   1475a:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
   1475c:	42aa      	cmp	r2, r5
   1475e:	bfac      	ite	ge
   14760:	2500      	movge	r5, #0
   14762:	2501      	movlt	r5, #1
        ForEachChannel(ch) GateOut(ch, axon_activated);
   14764:	462a      	mov	r2, r5
   14766:	2100      	movs	r1, #0
   14768:	4620      	mov	r0, r4
        axon_activated = (sum > threshold);
   1476a:	f884 5083 	strb.w	r5, [r4, #131]	; 0x83
        ForEachChannel(ch) GateOut(ch, axon_activated);
   1476e:	f7f5 fbb0 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
   14772:	462a      	mov	r2, r5
   14774:	2101      	movs	r1, #1
   14776:	4620      	mov	r0, r4
   14778:	f7f5 fbab 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
        if (--axon_countdown < 0) {
   1477c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   14780:	3b01      	subs	r3, #1
   14782:	d404      	bmi.n	1478e <TLNeuron::Controller()+0x7a>
   14784:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    }
   14788:	bd38      	pop	{r3, r4, r5, pc}
        int sum = 0;
   1478a:	4605      	mov	r5, r0
   1478c:	e7ca      	b.n	14724 <TLNeuron::Controller()+0x10>
            axon_countdown = HEM_TLN_ACTIVE_TICKS;
   1478e:	f240 53dc 	movw	r3, #1500	; 0x5dc
   14792:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
            ++axon_radius;
   14796:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   1479a:	3301      	adds	r3, #1
            if (axon_radius > 14) axon_radius = 5;
   1479c:	2b0e      	cmp	r3, #14
   1479e:	bfc8      	it	gt
   147a0:	2305      	movgt	r3, #5
   147a2:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    }
   147a6:	e7ef      	b.n	14788 <TLNeuron::Controller()+0x74>

000147a8 <Slew::Controller()>:
    void Controller() {
   147a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   147ac:	f8df 808c 	ldr.w	r8, [pc, #140]	; 1483c <Slew::Controller()+0x94>
   147b0:	4604      	mov	r4, r0
   147b2:	f100 0570 	add.w	r5, r0, #112	; 0x70
        ForEachChannel(ch)
   147b6:	f04f 0900 	mov.w	r9, #0
   147ba:	26c8      	movs	r6, #200	; 0xc8
        int scaled = simfloat2int(proportion * max_value);
   147bc:	f44f 477a 	mov.w	r7, #64000	; 0xfa00
            simfloat input = int2simfloat(In(ch));
   147c0:	f855 2c50 	ldr.w	r2, [r5, #-80]
            if (Gate(ch)) signal[ch] = input; // Defeat slew when channel's gate is high
   147c4:	4649      	mov	r1, r9
   147c6:	4620      	mov	r0, r4
            simfloat input = int2simfloat(In(ch));
   147c8:	ea4f 3a82 	mov.w	sl, r2, lsl #14
            if (Gate(ch)) signal[ch] = input; // Defeat slew when channel's gate is high
   147cc:	f7ff fdf4 	bl	143b8 <HemisphereApplet::Gate(int)>
   147d0:	b108      	cbz	r0, 147d6 <Slew::Controller()+0x2e>
   147d2:	f8c5 a004 	str.w	sl, [r5, #4]
            if (input != signal[ch]) {
   147d6:	6869      	ldr	r1, [r5, #4]
   147d8:	4551      	cmp	r1, sl
   147da:	d01e      	beq.n	1481a <Slew::Controller()+0x72>
                int segment = (input > signal[ch]) ? rise : fall;
   147dc:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
   147de:	6f23      	ldr	r3, [r4, #112]	; 0x70
   147e0:	bfb8      	it	lt
   147e2:	4613      	movlt	r3, r2
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   147e4:	039b      	lsls	r3, r3, #14
   147e6:	fb93 f3f6 	sdiv	r3, r3, r6
        int scaled = simfloat2int(proportion * max_value);
   147ea:	437b      	muls	r3, r7
                simfloat remaining = input - signal[ch];
   147ec:	ebaa 0201 	sub.w	r2, sl, r1
   147f0:	139b      	asrs	r3, r3, #14
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   147f2:	ea02 0008 	and.w	r0, r2, r8
   147f6:	f44f 5cf0 	mov.w	ip, #7680	; 0x1e00
   147fa:	fb90 f0fc 	sdiv	r0, r0, ip
        int scaled = simfloat2int(proportion * max_value);
   147fe:	4343      	muls	r3, r0
                if (ticks_to_remaining <= 0) {
   14800:	139b      	asrs	r3, r3, #14
   14802:	d008      	beq.n	14816 <Slew::Controller()+0x6e>
   14804:	2b00      	cmp	r3, #0
   14806:	bfb8      	it	lt
   14808:	425b      	neglt	r3, r3
                    if (ch == 1) ticks_to_remaining /= 2;
   1480a:	f1b9 0f00 	cmp.w	r9, #0
   1480e:	d000      	beq.n	14812 <Slew::Controller()+0x6a>
   14810:	105b      	asrs	r3, r3, #1
                    delta = remaining / ticks_to_remaining;
   14812:	fb92 f2f3 	sdiv	r2, r2, r3
                signal[ch] += delta;
   14816:	4411      	add	r1, r2
   14818:	6069      	str	r1, [r5, #4]
            Out(ch, simfloat2int(signal[ch]));
   1481a:	f855 2f04 	ldr.w	r2, [r5, #4]!
   1481e:	2300      	movs	r3, #0
   14820:	1392      	asrs	r2, r2, #14
   14822:	4649      	mov	r1, r9
   14824:	4620      	mov	r0, r4
   14826:	f7f4 fb56 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
   1482a:	f1b9 0f00 	cmp.w	r9, #0
   1482e:	d001      	beq.n	14834 <Slew::Controller()+0x8c>
    }
   14830:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   14834:	f04f 0901 	mov.w	r9, #1
   14838:	e7c2      	b.n	147c0 <Slew::Controller()+0x18>
   1483a:	bf00      	nop
   1483c:	ffffc000 	.word	0xffffc000

00014840 <Logic::Controller()>:
    void Controller() {
   14840:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        bool s1 = Gate(0); // Set logical states
   14844:	2100      	movs	r1, #0
    void Controller() {
   14846:	4605      	mov	r5, r0
        bool s1 = Gate(0); // Set logical states
   14848:	f7ff fdb6 	bl	143b8 <HemisphereApplet::Gate(int)>
        bool s2 = Gate(1);
   1484c:	2101      	movs	r1, #1
        bool s1 = Gate(0); // Set logical states
   1484e:	4680      	mov	r8, r0
        bool s2 = Gate(1);
   14850:	4628      	mov	r0, r5
   14852:	f7ff fdb1 	bl	143b8 <HemisphereApplet::Gate(int)>
   14856:	f105 0620 	add.w	r6, r5, #32
   1485a:	4681      	mov	r9, r0
        ForEachChannel(ch)
   1485c:	f105 0aab 	add.w	sl, r5, #171	; 0xab
   14860:	2700      	movs	r7, #0
            int idx = operation[ch];
   14862:	f8d6 4084 	ldr.w	r4, [r6, #132]	; 0x84
            if (operation[ch] == HEMISPHERE_NUMBER_OF_LOGIC - 1) {
   14866:	2c06      	cmp	r4, #6
   14868:	d10b      	bne.n	14882 <Logic::Controller()+0x42>
                idx = constrain(ProportionCV(cv, 6), 0, 5);
   1486a:	6830      	ldr	r0, [r6, #0]
   1486c:	2800      	cmp	r0, #0
   1486e:	4621      	mov	r1, r4
   14870:	bfb8      	it	lt
   14872:	4240      	neglt	r0, r0
   14874:	f7ef fef6 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
   14878:	2805      	cmp	r0, #5
   1487a:	bfa8      	it	ge
   1487c:	2005      	movge	r0, #5
   1487e:	ea20 74e0 	bic.w	r4, r0, r0, asr #31
            result[ch] = logic_gate[idx](s1, s2);
   14882:	f104 0322 	add.w	r3, r4, #34	; 0x22
   14886:	4649      	mov	r1, r9
   14888:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   1488c:	4640      	mov	r0, r8
   1488e:	4798      	blx	r3
            GateOut(ch, result[ch]);
   14890:	4639      	mov	r1, r7
            result[ch] = logic_gate[idx](s1, s2);
   14892:	f80a 0f01 	strb.w	r0, [sl, #1]!
   14896:	4602      	mov	r2, r0
            source[ch] = idx; // In case it comes from CV, need to display the right icon
   14898:	f8c6 4090 	str.w	r4, [r6, #144]	; 0x90
            GateOut(ch, result[ch]);
   1489c:	4628      	mov	r0, r5
   1489e:	f7f5 fb18 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
        ForEachChannel(ch)
   148a2:	3604      	adds	r6, #4
   148a4:	b10f      	cbz	r7, 148aa <Logic::Controller()+0x6a>
    }
   148a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   148aa:	2701      	movs	r7, #1
   148ac:	e7d9      	b.n	14862 <Logic::Controller()+0x22>

000148ae <LoFiPCM::Controller()>:
    void Controller() {
   148ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        play = !Gate(0); // Continuously play unless gated
   148b0:	2100      	movs	r1, #0
    void Controller() {
   148b2:	4604      	mov	r4, r0
        play = !Gate(0); // Continuously play unless gated
   148b4:	f7ff fd80 	bl	143b8 <HemisphereApplet::Gate(int)>
   148b8:	f080 0601 	eor.w	r6, r0, #1
   148bc:	b2f6      	uxtb	r6, r6
   148be:	f884 686e 	strb.w	r6, [r4, #2158]	; 0x86e
        gated_record = Gate(1);
   148c2:	2101      	movs	r1, #1
   148c4:	4620      	mov	r0, r4
   148c6:	f7ff fd77 	bl	143b8 <HemisphereApplet::Gate(int)>
        countdown--;
   148ca:	f8d4 5874 	ldr.w	r5, [r4, #2164]	; 0x874
        gated_record = Gate(1);
   148ce:	f884 086d 	strb.w	r0, [r4, #2157]	; 0x86d
        countdown--;
   148d2:	3d01      	subs	r5, #1
        gated_record = Gate(1);
   148d4:	4607      	mov	r7, r0
        countdown--;
   148d6:	f8c4 5874 	str.w	r5, [r4, #2164]	; 0x874
        if (countdown == 0) {
   148da:	2d00      	cmp	r5, #0
   148dc:	d14b      	bne.n	14976 <LoFiPCM::Controller()+0xc8>
            if (play || record || gated_record) head++;
   148de:	b91e      	cbnz	r6, 148e8 <LoFiPCM::Controller()+0x3a>
   148e0:	f894 386c 	ldrb.w	r3, [r4, #2156]	; 0x86c
   148e4:	b903      	cbnz	r3, 148e8 <LoFiPCM::Controller()+0x3a>
   148e6:	b120      	cbz	r0, 148f2 <LoFiPCM::Controller()+0x44>
   148e8:	f8d4 3870 	ldr.w	r3, [r4, #2160]	; 0x870
   148ec:	3301      	adds	r3, #1
   148ee:	f8c4 3870 	str.w	r3, [r4, #2160]	; 0x870
            if (head >= length) {
   148f2:	f8d4 2870 	ldr.w	r2, [r4, #2160]	; 0x870
   148f6:	f8d4 3878 	ldr.w	r3, [r4, #2168]	; 0x878
   148fa:	429a      	cmp	r2, r3
   148fc:	db0b      	blt.n	14916 <LoFiPCM::Controller()+0x68>
                head = 0;
   148fe:	2300      	movs	r3, #0
   14900:	f8c4 3870 	str.w	r3, [r4, #2160]	; 0x870
                record = 0;
   14904:	f884 386c 	strb.w	r3, [r4, #2156]	; 0x86c
                ClockOut(1);
   14908:	2264      	movs	r2, #100	; 0x64
   1490a:	2101      	movs	r1, #1
   1490c:	4620      	mov	r0, r4
   1490e:	f7f5 f80a 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
            if (record || gated_record) {
   14912:	b927      	cbnz	r7, 1491e <LoFiPCM::Controller()+0x70>
   14914:	e00d      	b.n	14932 <LoFiPCM::Controller()+0x84>
   14916:	f894 386c 	ldrb.w	r3, [r4, #2156]	; 0x86c
   1491a:	2b00      	cmp	r3, #0
   1491c:	d0f9      	beq.n	14912 <LoFiPCM::Controller()+0x64>
                pcm[head] = (char)s;
   1491e:	f8d4 3870 	ldr.w	r3, [r4, #2160]	; 0x870
   14922:	18e2      	adds	r2, r4, r3
                uint32_t s = (In(0) + 32767) >> 8;
   14924:	6a23      	ldr	r3, [r4, #32]
   14926:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
   1492a:	337f      	adds	r3, #127	; 0x7f
   1492c:	121b      	asrs	r3, r3, #8
                pcm[head] = (char)s;
   1492e:	f882 306c 	strb.w	r3, [r2, #108]	; 0x6c
            uint32_t s = LOFI_PCM2CV(pcm[head]);
   14932:	f8d4 3870 	ldr.w	r3, [r4, #2160]	; 0x870
   14936:	6a27      	ldr	r7, [r4, #32]
   14938:	4423      	add	r3, r4
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1493a:	f44f 50f0 	mov.w	r0, #7680	; 0x1e00
   1493e:	f893 106c 	ldrb.w	r1, [r3, #108]	; 0x6c
        return inputs[ch];
   14942:	6a63      	ldr	r3, [r4, #36]	; 0x24
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14944:	039a      	lsls	r2, r3, #14
   14946:	fb92 f2f0 	sdiv	r2, r2, r0
        int scaled = simfloat2int(proportion * max_value);
   1494a:	437a      	muls	r2, r7
   1494c:	1392      	asrs	r2, r2, #14
            int loop = play ? Proportion(HEMISPHERE_MAX_CV - SOS, HEMISPHERE_MAX_CV, s) : 0;
   1494e:	b14e      	cbz	r6, 14964 <LoFiPCM::Controller()+0xb6>
            uint32_t s = LOFI_PCM2CV(pcm[head]);
   14950:	0209      	lsls	r1, r1, #8
   14952:	f5a1 41ff 	sub.w	r1, r1, #32640	; 0x7f80
            int loop = play ? Proportion(HEMISPHERE_MAX_CV - SOS, HEMISPHERE_MAX_CV, s) : 0;
   14956:	1ac3      	subs	r3, r0, r3
            uint32_t s = LOFI_PCM2CV(pcm[head]);
   14958:	397f      	subs	r1, #127	; 0x7f
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1495a:	039b      	lsls	r3, r3, #14
   1495c:	fb93 f3f0 	sdiv	r3, r3, r0
        int scaled = simfloat2int(proportion * max_value);
   14960:	434b      	muls	r3, r1
   14962:	139d      	asrs	r5, r3, #14
            Out(0, live + loop);
   14964:	2300      	movs	r3, #0
   14966:	4619      	mov	r1, r3
   14968:	442a      	add	r2, r5
   1496a:	4620      	mov	r0, r4
   1496c:	f7f4 fab3 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            countdown = HEM_LOFI_PCM_SPEED;
   14970:	2308      	movs	r3, #8
   14972:	f8c4 3874 	str.w	r3, [r4, #2164]	; 0x874
    }
   14976:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00014978 <GatedVCA::Controller()>:
    void Controller() {
   14978:	b538      	push	{r3, r4, r5, lr}
        int output = ProportionCV(amplitude, signal);
   1497a:	6a01      	ldr	r1, [r0, #32]
    void Controller() {
   1497c:	4604      	mov	r4, r0
        int output = ProportionCV(amplitude, signal);
   1497e:	6a40      	ldr	r0, [r0, #36]	; 0x24
   14980:	f7ef fe70 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
        output += amp_offset_cv;
   14984:	6f23      	ldr	r3, [r4, #112]	; 0x70
   14986:	18c5      	adds	r5, r0, r3
   14988:	f5b5 5ff0 	cmp.w	r5, #7680	; 0x1e00
   1498c:	4b12      	ldr	r3, [pc, #72]	; (149d8 <GatedVCA::Controller()+0x60>)
   1498e:	bfa8      	it	ge
   14990:	f44f 55f0 	movge.w	r5, #7680	; 0x1e00
   14994:	429d      	cmp	r5, r3
        if (Gate(0)) Out(0, output); // Normally-off gated VCA output on A
   14996:	f04f 0100 	mov.w	r1, #0
   1499a:	4620      	mov	r0, r4
   1499c:	bfb8      	it	lt
   1499e:	461d      	movlt	r5, r3
   149a0:	f7ff fd0a 	bl	143b8 <HemisphereApplet::Gate(int)>
   149a4:	4603      	mov	r3, r0
   149a6:	b190      	cbz	r0, 149ce <GatedVCA::Controller()+0x56>
   149a8:	2300      	movs	r3, #0
   149aa:	462a      	mov	r2, r5
        else Out(0, 0);
   149ac:	4619      	mov	r1, r3
   149ae:	4620      	mov	r0, r4
   149b0:	f7f4 fa91 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        if (Gate(1)) Out(1, 0); // Normally-on ungated VCA output on B
   149b4:	2101      	movs	r1, #1
   149b6:	4620      	mov	r0, r4
   149b8:	f7ff fcfe 	bl	143b8 <HemisphereApplet::Gate(int)>
   149bc:	4603      	mov	r3, r0
   149be:	b140      	cbz	r0, 149d2 <GatedVCA::Controller()+0x5a>
   149c0:	2300      	movs	r3, #0
   149c2:	461a      	mov	r2, r3
        else Out(1, output);
   149c4:	2101      	movs	r1, #1
   149c6:	4620      	mov	r0, r4
   149c8:	f7f4 fa85 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   149cc:	bd38      	pop	{r3, r4, r5, pc}
        else Out(0, 0);
   149ce:	4602      	mov	r2, r0
   149d0:	e7ec      	b.n	149ac <GatedVCA::Controller()+0x34>
        else Out(1, output);
   149d2:	462a      	mov	r2, r5
   149d4:	e7f6      	b.n	149c4 <GatedVCA::Controller()+0x4c>
   149d6:	bf00      	nop
   149d8:	ffffe200 	.word	0xffffe200

000149dc <GateDelay::Controller()>:
    void Controller() {
   149dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if (--ms_countdown < 0) {
   149e0:	f8b0 3282 	ldrh.w	r3, [r0, #642]	; 0x282
   149e4:	3b01      	subs	r3, #1
   149e6:	b21b      	sxth	r3, r3
   149e8:	2b00      	cmp	r3, #0
    void Controller() {
   149ea:	4604      	mov	r4, r0
        if (--ms_countdown < 0) {
   149ec:	f8a0 3282 	strh.w	r3, [r0, #642]	; 0x282
   149f0:	da5d      	bge.n	14aae <GateDelay::Controller()+0xd2>
   149f2:	f200 2772 	addw	r7, r0, #626	; 0x272
   149f6:	f500 781a 	add.w	r8, r0, #616	; 0x268
            ForEachChannel(ch)
   149fa:	f04f 0b00 	mov.w	fp, #0
            tape[ch][word] &= (0xffff ^ (0x01 << bit));
   149fe:	f04f 0901 	mov.w	r9, #1
   14a02:	f64f 7aff 	movw	sl, #65535	; 0xffff
                record(ch, Gate(ch));
   14a06:	4659      	mov	r1, fp
   14a08:	4620      	mov	r0, r4
   14a0a:	f7ff fcd5 	bl	143b8 <HemisphereApplet::Gate(int)>
        uint16_t word = location[ch] / 32;
   14a0e:	f837 5f02 	ldrh.w	r5, [r7, #2]!
   14a12:	ea4f 168b 	mov.w	r6, fp, lsl #6
   14a16:	096a      	lsrs	r2, r5, #5
        uint8_t bit = location[ch] % 32;
   14a18:	4432      	add	r2, r6
   14a1a:	f005 031f 	and.w	r3, r5, #31
        if (gate) {
   14a1e:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   14a22:	2800      	cmp	r0, #0
   14a24:	d048      	beq.n	14ab8 <GateDelay::Controller()+0xdc>
            tape[ch][word] |= (0x01 << bit);
   14a26:	fa09 f003 	lsl.w	r0, r9, r3
   14a2a:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
   14a2c:	4303      	orrs	r3, r0
            tape[ch][word] &= (0xffff ^ (0x01 << bit));
   14a2e:	66d3      	str	r3, [r2, #108]	; 0x6c
                int mod_time = Proportion(DetentedIn(ch), HEMISPHERE_MAX_CV, 1000) + time[ch];
   14a30:	4659      	mov	r1, fp
   14a32:	4620      	mov	r0, r4
   14a34:	f7f4 fa46 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
   14a38:	f858 2f04 	ldr.w	r2, [r8, #4]!
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14a3c:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   14a40:	0380      	lsls	r0, r0, #14
   14a42:	fb90 f0f3 	sdiv	r0, r0, r3
        int scaled = simfloat2int(proportion * max_value);
   14a46:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   14a4a:	4358      	muls	r0, r3
   14a4c:	eb02 32a0 	add.w	r2, r2, r0, asr #14
        int play_location = location[ch] - mod_time;
   14a50:	f5b2 6ffa 	cmp.w	r2, #2000	; 0x7d0
   14a54:	bfa8      	it	ge
   14a56:	f44f 62fa 	movge.w	r2, #2000	; 0x7d0
   14a5a:	2a00      	cmp	r2, #0
   14a5c:	bfac      	ite	ge
   14a5e:	1aab      	subge	r3, r5, r2
   14a60:	462b      	movlt	r3, r5
        if (play_location < 0) play_location += 2048;
   14a62:	2b00      	cmp	r3, #0
   14a64:	bfb8      	it	lt
   14a66:	f503 6300 	addlt.w	r3, r3, #2048	; 0x800
        return ((tape[ch][word] >> bit) & 0x01);
   14a6a:	eb06 1663 	add.w	r6, r6, r3, asr #5
   14a6e:	eb04 0686 	add.w	r6, r4, r6, lsl #2
        uint8_t bit = play_location % 32;
   14a72:	f003 031f 	and.w	r3, r3, #31
        return ((tape[ch][word] >> bit) & 0x01);
   14a76:	6ef2      	ldr	r2, [r6, #108]	; 0x6c
   14a78:	40da      	lsrs	r2, r3
                if (p) last_gate[ch] = OC::CORE::ticks;
   14a7a:	f012 0201 	ands.w	r2, r2, #1
   14a7e:	bf18      	it	ne
   14a80:	4b11      	ldrne	r3, [pc, #68]	; (14ac8 <GateDelay::Controller()+0xec>)
                if (++location[ch] > 2047) location[ch] = 0;
   14a82:	f105 0501 	add.w	r5, r5, #1
                if (p) last_gate[ch] = OC::CORE::ticks;
   14a86:	bf1c      	itt	ne
   14a88:	681b      	ldrne	r3, [r3, #0]
   14a8a:	f8c8 300c 	strne.w	r3, [r8, #12]
                if (++location[ch] > 2047) location[ch] = 0;
   14a8e:	b2ad      	uxth	r5, r5
                GateOut(ch, p);
   14a90:	4659      	mov	r1, fp
   14a92:	4620      	mov	r0, r4
   14a94:	f7f5 fa1d 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
                if (++location[ch] > 2047) location[ch] = 0;
   14a98:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
   14a9c:	bf28      	it	cs
   14a9e:	2500      	movcs	r5, #0
   14aa0:	803d      	strh	r5, [r7, #0]
            ForEachChannel(ch)
   14aa2:	f1bb 0f00 	cmp.w	fp, #0
   14aa6:	d004      	beq.n	14ab2 <GateDelay::Controller()+0xd6>
            ms_countdown = 16;
   14aa8:	2310      	movs	r3, #16
   14aaa:	f8a4 3282 	strh.w	r3, [r4, #642]	; 0x282
    }
   14aae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14ab2:	f04f 0b01 	mov.w	fp, #1
   14ab6:	e7a6      	b.n	14a06 <GateDelay::Controller()+0x2a>
            tape[ch][word] &= (0xffff ^ (0x01 << bit));
   14ab8:	fa09 f303 	lsl.w	r3, r9, r3
   14abc:	ea83 000a 	eor.w	r0, r3, sl
   14ac0:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
   14ac2:	4003      	ands	r3, r0
   14ac4:	e7b3      	b.n	14a2e <GateDelay::Controller()+0x52>
   14ac6:	bf00      	nop
   14ac8:	200046cc 	.word	0x200046cc

00014acc <DrCrusher::Controller()>:
    void Controller() {
   14acc:	b510      	push	{r4, lr}
        if (!Gate(0)) {
   14ace:	2100      	movs	r1, #0
    void Controller() {
   14ad0:	4604      	mov	r4, r0
        if (!Gate(0)) {
   14ad2:	f7ff fc71 	bl	143b8 <HemisphereApplet::Gate(int)>
   14ad6:	4603      	mov	r3, r0
   14ad8:	bb00      	cbnz	r0, 14b1c <DrCrusher::Controller()+0x50>
            if (++count >= crusher_ticks[rate]) {
   14ada:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
   14ade:	6f20      	ldr	r0, [r4, #112]	; 0x70
   14ae0:	4910      	ldr	r1, [pc, #64]	; (14b24 <DrCrusher::Controller()+0x58>)
   14ae2:	3201      	adds	r2, #1
   14ae4:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   14ae8:	b2d2      	uxtb	r2, r2
   14aea:	428a      	cmp	r2, r1
   14aec:	f884 2078 	strb.w	r2, [r4, #120]	; 0x78
   14af0:	db0d      	blt.n	14b0e <DrCrusher::Controller()+0x42>
        return inputs[ch];
   14af2:	6a22      	ldr	r2, [r4, #32]
                p_cv16 = p_cv16 & mask;
   14af4:	f8b4 107a 	ldrh.w	r1, [r4, #122]	; 0x7a
                count = 0;
   14af8:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
                int p_cv = cv + HEMISPHERE_MAX_CV;
   14afc:	f502 52f0 	add.w	r2, r2, #7680	; 0x1e00
                cv = static_cast<int>(p_cv16) - HEMISPHERE_MAX_CV;
   14b00:	400a      	ands	r2, r1
                Out(0, cv);
   14b02:	f5a2 52f0 	sub.w	r2, r2, #7680	; 0x1e00
        } else Out(0, In(0));
   14b06:	4619      	mov	r1, r3
   14b08:	4620      	mov	r0, r4
   14b0a:	f7f4 f9e4 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        Out(1, In(0));
   14b0e:	6a22      	ldr	r2, [r4, #32]
   14b10:	2300      	movs	r3, #0
   14b12:	2101      	movs	r1, #1
   14b14:	4620      	mov	r0, r4
   14b16:	f7f4 f9de 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   14b1a:	bd10      	pop	{r4, pc}
        } else Out(0, In(0));
   14b1c:	6a22      	ldr	r2, [r4, #32]
   14b1e:	2300      	movs	r3, #0
   14b20:	e7f1      	b.n	14b06 <DrCrusher::Controller()+0x3a>
   14b22:	bf00      	nop
   14b24:	00023e40 	.word	0x00023e40

00014b28 <Binary::Controller()>:
    void Controller() {
   14b28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        bit[0] = Gate(0);
   14b2c:	2100      	movs	r1, #0
    void Controller() {
   14b2e:	4604      	mov	r4, r0
        bit[0] = Gate(0);
   14b30:	f7ff fc42 	bl	143b8 <HemisphereApplet::Gate(int)>
        bit[1] = Gate(1);
   14b34:	2101      	movs	r1, #1
        bit[0] = Gate(0);
   14b36:	4680      	mov	r8, r0
   14b38:	f884 006c 	strb.w	r0, [r4, #108]	; 0x6c
        bit[1] = Gate(1);
   14b3c:	4620      	mov	r0, r4
   14b3e:	f7ff fc3b 	bl	143b8 <HemisphereApplet::Gate(int)>
        bit[2] = In(0) > HEMISPHERE_3V_CV;
   14b42:	6a26      	ldr	r6, [r4, #32]
   14b44:	6a63      	ldr	r3, [r4, #36]	; 0x24
        bit[1] = Gate(1);
   14b46:	f884 006d 	strb.w	r0, [r4, #109]	; 0x6d
        bit[2] = In(0) > HEMISPHERE_3V_CV;
   14b4a:	f5b6 5f90 	cmp.w	r6, #4608	; 0x1200
   14b4e:	bfd4      	ite	le
   14b50:	2600      	movle	r6, #0
   14b52:	2601      	movgt	r6, #1
        bit[3] = In(1) > HEMISPHERE_3V_CV;
   14b54:	f5b3 5f90 	cmp.w	r3, #4608	; 0x1200
        int sum = (bit[3] * B0Val)
   14b58:	6f63      	ldr	r3, [r4, #116]	; 0x74
        bit[2] = In(0) > HEMISPHERE_3V_CV;
   14b5a:	f884 606e 	strb.w	r6, [r4, #110]	; 0x6e
                + (bit[2] * (2 * B0Val))
   14b5e:	fb06 f203 	mul.w	r2, r6, r3
        int sum = (bit[3] * B0Val)
   14b62:	bfcc      	ite	gt
   14b64:	4619      	movgt	r1, r3
   14b66:	2100      	movle	r1, #0
                + (bit[2] * (2 * B0Val))
   14b68:	eb01 0142 	add.w	r1, r1, r2, lsl #1
                + (bit[1] * (4 * B0Val))
   14b6c:	fb00 f203 	mul.w	r2, r0, r3
        bit[3] = In(1) > HEMISPHERE_3V_CV;
   14b70:	bfcc      	ite	gt
   14b72:	2701      	movgt	r7, #1
   14b74:	2700      	movle	r7, #0
                + (bit[1] * (4 * B0Val))
   14b76:	eb01 0182 	add.w	r1, r1, r2, lsl #2
        bit[1] = Gate(1);
   14b7a:	4605      	mov	r5, r0
                + (bit[0] * (8 * B0Val));
   14b7c:	fb08 f203 	mul.w	r2, r8, r3
        Out(0, sum);
   14b80:	2300      	movs	r3, #0
   14b82:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   14b86:	4620      	mov	r0, r4
   14b88:	4619      	mov	r1, r3
        bit[3] = In(1) > HEMISPHERE_3V_CV;
   14b8a:	f884 706f 	strb.w	r7, [r4, #111]	; 0x6f
        int count = (static_cast<int>(bit[0] + bit[1] + bit[2] + bit[3])) * CVal;
   14b8e:	4445      	add	r5, r8
        Out(0, sum);
   14b90:	f7f4 f9a1 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        int count = (static_cast<int>(bit[0] + bit[1] + bit[2] + bit[3])) * CVal;
   14b94:	4435      	add	r5, r6
   14b96:	6f22      	ldr	r2, [r4, #112]	; 0x70
   14b98:	443d      	add	r5, r7
        Out(1, count);
   14b9a:	2300      	movs	r3, #0
   14b9c:	436a      	muls	r2, r5
   14b9e:	2101      	movs	r1, #1
   14ba0:	4620      	mov	r0, r4
   14ba2:	f7f4 f998 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   14ba6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14baa:	Address 0x0000000000014baa is out of bounds.


00014bac <ADSREG::Controller()>:
    void Controller() {
   14bac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        mod = Proportion(DetentedIn(in), HEMISPHERE_MAX_CV, HEM_EG_MAX_VALUE / 2);
   14bb0:	2100      	movs	r1, #0
    void Controller() {
   14bb2:	4605      	mov	r5, r0
        mod = Proportion(DetentedIn(in), HEMISPHERE_MAX_CV, HEM_EG_MAX_VALUE / 2);
   14bb4:	f7f4 f986 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14bb8:	f44f 54f0 	mov.w	r4, #7680	; 0x1e00
   14bbc:	0380      	lsls	r0, r0, #14
   14bbe:	fb90 f0f4 	sdiv	r0, r0, r4
        int scaled = simfloat2int(proportion * max_value);
   14bc2:	ebc0 10c0 	rsb	r0, r0, r0, lsl #7
   14bc6:	1380      	asrs	r0, r0, #14
        attack_mod = get_modification_with_input(0);
   14bc8:	f8c5 0080 	str.w	r0, [r5, #128]	; 0x80
        mod = Proportion(DetentedIn(in), HEMISPHERE_MAX_CV, HEM_EG_MAX_VALUE / 2);
   14bcc:	2101      	movs	r1, #1
   14bce:	4628      	mov	r0, r5
   14bd0:	f7f4 f978 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14bd4:	0380      	lsls	r0, r0, #14
   14bd6:	fb90 f0f4 	sdiv	r0, r0, r4
        int scaled = simfloat2int(proportion * max_value);
   14bda:	ebc0 10c0 	rsb	r0, r0, r0, lsl #7
   14bde:	1380      	asrs	r0, r0, #14
        amplitude[ch] = int2simfloat(Proportion(sustain - 1, HEM_EG_MAX_VALUE, HEMISPHERE_MAX_CV));
   14be0:	f8df 8138 	ldr.w	r8, [pc, #312]	; 14d1c <ADSREG::Controller()+0x170>
        release_mod = get_modification_with_input(1);
   14be4:	f8c5 0084 	str.w	r0, [r5, #132]	; 0x84
        ForEachChannel(ch)
   14be8:	f105 0488 	add.w	r4, r5, #136	; 0x88
   14bec:	f105 0902 	add.w	r9, r5, #2
        release_mod = get_modification_with_input(1);
   14bf0:	462e      	mov	r6, r5
            stage_ticks[ch] = 0;
   14bf2:	2700      	movs	r7, #0
   14bf4:	eba6 0a05 	sub.w	sl, r6, r5
            if (Gate(ch)) {
   14bf8:	4651      	mov	r1, sl
   14bfa:	4628      	mov	r0, r5
   14bfc:	f7ff fbdc 	bl	143b8 <HemisphereApplet::Gate(int)>
                if (!gated[ch]) { // The gate wasn't on last time, so this is a newly-gated EG
   14c00:	f896 3098 	ldrb.w	r3, [r6, #152]	; 0x98
            if (Gate(ch)) {
   14c04:	4683      	mov	fp, r0
   14c06:	2800      	cmp	r0, #0
   14c08:	d05a      	beq.n	14cc0 <ADSREG::Controller()+0x114>
                if (!gated[ch]) { // The gate wasn't on last time, so this is a newly-gated EG
   14c0a:	b9cb      	cbnz	r3, 14c40 <ADSREG::Controller()+0x94>
                    if (stage[ch] != HEM_EG_RELEASE) amplitude[ch] = 0;
   14c0c:	6822      	ldr	r2, [r4, #0]
                    stage_ticks[ch] = 0;
   14c0e:	60a3      	str	r3, [r4, #8]
                    if (stage[ch] != HEM_EG_RELEASE) amplitude[ch] = 0;
   14c10:	2a03      	cmp	r2, #3
   14c12:	bf18      	it	ne
   14c14:	6163      	strne	r3, [r4, #20]
                    stage[ch] = HEM_EG_ATTACK;
   14c16:	6027      	str	r7, [r4, #0]
                    AttackAmplitude(ch);
   14c18:	4651      	mov	r1, sl
   14c1a:	4628      	mov	r0, r5
   14c1c:	f7f9 fd62 	bl	e6e4 <ADSREG::AttackAmplitude(int)>
        return simfloat2int(amplitude[ch]);
   14c20:	6962      	ldr	r2, [r4, #20]
                gated[ch] = 1;
   14c22:	f886 b098 	strb.w	fp, [r6, #152]	; 0x98
            Out(ch, GetAmplitudeOf(ch));
   14c26:	2300      	movs	r3, #0
   14c28:	1392      	asrs	r2, r2, #14
   14c2a:	4651      	mov	r1, sl
   14c2c:	4628      	mov	r0, r5
        ForEachChannel(ch)
   14c2e:	3601      	adds	r6, #1
            Out(ch, GetAmplitudeOf(ch));
   14c30:	f7f4 f951 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        ForEachChannel(ch)
   14c34:	454e      	cmp	r6, r9
   14c36:	f104 0404 	add.w	r4, r4, #4
   14c3a:	d1db      	bne.n	14bf4 <ADSREG::Controller()+0x48>
    }
   14c3c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    stage_ticks[ch]++;
   14c40:	68a3      	ldr	r3, [r4, #8]
   14c42:	3301      	adds	r3, #1
   14c44:	60a3      	str	r3, [r4, #8]
                    if (stage[ch] == HEM_EG_ATTACK) AttackAmplitude(ch);
   14c46:	6823      	ldr	r3, [r4, #0]
   14c48:	b91b      	cbnz	r3, 14c52 <ADSREG::Controller()+0xa6>
   14c4a:	4651      	mov	r1, sl
   14c4c:	4628      	mov	r0, r5
   14c4e:	f7f9 fd49 	bl	e6e4 <ADSREG::AttackAmplitude(int)>
                    if (stage[ch] == HEM_EG_DECAY) DecayAmplitude(ch);
   14c52:	6823      	ldr	r3, [r4, #0]
   14c54:	2b01      	cmp	r3, #1
   14c56:	d130      	bne.n	14cba <ADSREG::Controller()+0x10e>
        simfloat amplitude_remaining = amplitude[ch] - int2simfloat(Proportion(sustain, HEM_EG_MAX_VALUE, HEMISPHERE_MAX_CV));
   14c58:	6fab      	ldr	r3, [r5, #120]	; 0x78
        int total_stage_ticks = Proportion(decay, HEM_EG_MAX_VALUE, HEM_EG_MAX_TICKS_AD);
   14c5a:	6f6a      	ldr	r2, [r5, #116]	; 0x74
        int ticks_remaining = total_stage_ticks - stage_ticks[ch];
   14c5c:	f8d4 c008 	ldr.w	ip, [r4, #8]
        simfloat amplitude_remaining = amplitude[ch] - int2simfloat(Proportion(sustain, HEM_EG_MAX_VALUE, HEMISPHERE_MAX_CV));
   14c60:	6961      	ldr	r1, [r4, #20]
        if (sustain == 1) ticks_remaining = 0;
   14c62:	2b01      	cmp	r3, #1
   14c64:	d00b      	beq.n	14c7e <ADSREG::Controller()+0xd2>
   14c66:	f248 2e35 	movw	lr, #33333	; 0x8235
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14c6a:	0392      	lsls	r2, r2, #14
   14c6c:	20ff      	movs	r0, #255	; 0xff
   14c6e:	fb92 f2f0 	sdiv	r2, r2, r0
        int scaled = simfloat2int(proportion * max_value);
   14c72:	fb0e f202 	mul.w	r2, lr, r2
        int ticks_remaining = total_stage_ticks - stage_ticks[ch];
   14c76:	ebcc 32a2 	rsb	r2, ip, r2, asr #14
        if (ticks_remaining <= 0) { // End of decay; move to sustain
   14c7a:	2a00      	cmp	r2, #0
   14c7c:	dc0f      	bgt.n	14c9e <ADSREG::Controller()+0xf2>
            stage[ch] = HEM_EG_SUSTAIN;
   14c7e:	2302      	movs	r3, #2
   14c80:	6023      	str	r3, [r4, #0]
            stage_ticks[ch] = 0;
   14c82:	60a7      	str	r7, [r4, #8]
        amplitude[ch] = int2simfloat(Proportion(sustain - 1, HEM_EG_MAX_VALUE, HEMISPHERE_MAX_CV));
   14c84:	6fab      	ldr	r3, [r5, #120]	; 0x78
   14c86:	3b01      	subs	r3, #1
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14c88:	22ff      	movs	r2, #255	; 0xff
   14c8a:	039b      	lsls	r3, r3, #14
   14c8c:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   14c90:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
   14c94:	4353      	muls	r3, r2
   14c96:	ea03 0308 	and.w	r3, r3, r8
            amplitude[ch] -= decrease;
   14c9a:	6163      	str	r3, [r4, #20]
                gated[ch] = 0;
   14c9c:	e7c0      	b.n	14c20 <ADSREG::Controller()+0x74>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14c9e:	039b      	lsls	r3, r3, #14
   14ca0:	fb93 f3f0 	sdiv	r3, r3, r0
        int scaled = simfloat2int(proportion * max_value);
   14ca4:	f44f 50f0 	mov.w	r0, #7680	; 0x1e00
   14ca8:	4343      	muls	r3, r0
        simfloat amplitude_remaining = amplitude[ch] - int2simfloat(Proportion(sustain, HEM_EG_MAX_VALUE, HEMISPHERE_MAX_CV));
   14caa:	ea03 0308 	and.w	r3, r3, r8
   14cae:	1acb      	subs	r3, r1, r3
            simfloat decrease = amplitude_remaining / ticks_remaining;
   14cb0:	fb93 f3f2 	sdiv	r3, r3, r2
            amplitude[ch] -= decrease;
   14cb4:	1ac9      	subs	r1, r1, r3
   14cb6:	6161      	str	r1, [r4, #20]
                    if (stage[ch] == HEM_EG_SUSTAIN) SustainAmplitude(ch);
   14cb8:	e7b2      	b.n	14c20 <ADSREG::Controller()+0x74>
   14cba:	2b02      	cmp	r3, #2
   14cbc:	d1b0      	bne.n	14c20 <ADSREG::Controller()+0x74>
   14cbe:	e7e1      	b.n	14c84 <ADSREG::Controller()+0xd8>
                if (gated[ch]) { // The gate was on last time, so this is a newly-released EG
   14cc0:	b323      	cbz	r3, 14d0c <ADSREG::Controller()+0x160>
                    stage[ch] = HEM_EG_RELEASE;
   14cc2:	2303      	movs	r3, #3
   14cc4:	6023      	str	r3, [r4, #0]
                    stage_ticks[ch] = 0;
   14cc6:	60a0      	str	r0, [r4, #8]
                    stage_ticks[ch]++;
   14cc8:	68a1      	ldr	r1, [r4, #8]
   14cca:	3101      	adds	r1, #1
   14ccc:	60a1      	str	r1, [r4, #8]
        int effective_release = constrain(release + release_mod, 1, HEM_EG_MAX_VALUE) - 1;
   14cce:	6feb      	ldr	r3, [r5, #124]	; 0x7c
   14cd0:	f8d5 2084 	ldr.w	r2, [r5, #132]	; 0x84
   14cd4:	4413      	add	r3, r2
   14cd6:	2bff      	cmp	r3, #255	; 0xff
   14cd8:	bfa8      	it	ge
   14cda:	23ff      	movge	r3, #255	; 0xff
   14cdc:	2b01      	cmp	r3, #1
   14cde:	bfb8      	it	lt
   14ce0:	2301      	movlt	r3, #1
        if (effective_release == 0) ticks_remaining = 0;
   14ce2:	3b01      	subs	r3, #1
   14ce4:	d00c      	beq.n	14d00 <ADSREG::Controller()+0x154>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14ce6:	22ff      	movs	r2, #255	; 0xff
   14ce8:	039b      	lsls	r3, r3, #14
   14cea:	fbb3 f3f2 	udiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   14cee:	4a0c      	ldr	r2, [pc, #48]	; (14d20 <ADSREG::Controller()+0x174>)
   14cf0:	4353      	muls	r3, r2
        int ticks_remaining = total_stage_ticks - stage_ticks[ch];
   14cf2:	ebc1 31a3 	rsb	r1, r1, r3, asr #14
        if (ticks_remaining <= 0 || amplitude[ch] <= 0) { // End of release; turn off envelope
   14cf6:	2900      	cmp	r1, #0
   14cf8:	dd02      	ble.n	14d00 <ADSREG::Controller()+0x154>
   14cfa:	6963      	ldr	r3, [r4, #20]
   14cfc:	2b00      	cmp	r3, #0
   14cfe:	dc09      	bgt.n	14d14 <ADSREG::Controller()+0x168>
            stage[ch] = HEM_EG_NO_STAGE;
   14d00:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14d04:	6023      	str	r3, [r4, #0]
            stage_ticks[ch] = 0;
   14d06:	60a7      	str	r7, [r4, #8]
            amplitude[ch] = 0;
   14d08:	6167      	str	r7, [r4, #20]
   14d0a:	e789      	b.n	14c20 <ADSREG::Controller()+0x74>
                if (stage[ch] == HEM_EG_RELEASE) { // Process the release stage, if necessary
   14d0c:	6823      	ldr	r3, [r4, #0]
   14d0e:	2b03      	cmp	r3, #3
   14d10:	d186      	bne.n	14c20 <ADSREG::Controller()+0x74>
   14d12:	e7d9      	b.n	14cc8 <ADSREG::Controller()+0x11c>
            simfloat decrease = amplitude[ch] / ticks_remaining;
   14d14:	fb93 f1f1 	sdiv	r1, r3, r1
            amplitude[ch] -= decrease;
   14d18:	1a5b      	subs	r3, r3, r1
   14d1a:	e7be      	b.n	14c9a <ADSREG::Controller()+0xee>
   14d1c:	ffffc000 	.word	0xffffc000
   14d20:	000208d5 	.word	0x000208d5

00014d24 <TM::DrawSelector()>:
    void DrawSelector() {
   14d24:	b573      	push	{r0, r1, r4, r5, r6, lr}
        gfxBitmap(1, 14, 8, LOOP_ICON);
   14d26:	4b3a      	ldr	r3, [pc, #232]	; (14e10 <TM::DrawSelector()+0xec>)
   14d28:	9300      	str	r3, [sp, #0]
    void DrawSelector() {
   14d2a:	4604      	mov	r4, r0
        gfxBitmap(1, 14, 8, LOOP_ICON);
   14d2c:	2308      	movs	r3, #8
   14d2e:	220e      	movs	r2, #14
   14d30:	6980      	ldr	r0, [r0, #24]
   14d32:	2101      	movs	r1, #1
   14d34:	f7ef fe2e 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(12 + pad(10, length), 15, length);
   14d38:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
   14d3a:	200a      	movs	r0, #10
   14d3c:	4629      	mov	r1, r5
   14d3e:	f7ef fca0 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   14d42:	462b      	mov	r3, r5
   14d44:	f100 010c 	add.w	r1, r0, #12
   14d48:	220f      	movs	r2, #15
   14d4a:	69a0      	ldr	r0, [r4, #24]
   14d4c:	f7ef fe90 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        gfxPrint(32, 15, "p=");
   14d50:	4b30      	ldr	r3, [pc, #192]	; (14e14 <TM::DrawSelector()+0xf0>)
   14d52:	220f      	movs	r2, #15
   14d54:	2120      	movs	r1, #32
   14d56:	4620      	mov	r0, r4
   14d58:	f7f3 fbc6 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor == 1 || Gate(1)) {
   14d5c:	6f26      	ldr	r6, [r4, #112]	; 0x70
   14d5e:	2e01      	cmp	r6, #1
   14d60:	d123      	bne.n	14daa <TM::DrawSelector()+0x86>
            int pCv = Proportion(DetentedIn(1), HEMISPHERE_MAX_CV, 100);
   14d62:	2101      	movs	r1, #1
   14d64:	4620      	mov	r0, r4
   14d66:	f7f4 f8ad 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14d6a:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
            int prob = constrain(p + pCv, 0, 100);
   14d6e:	f8d4 51b0 	ldr.w	r5, [r4, #432]	; 0x1b0
   14d72:	0380      	lsls	r0, r0, #14
   14d74:	fb90 f0f3 	sdiv	r0, r0, r3
        int scaled = simfloat2int(proportion * max_value);
   14d78:	2364      	movs	r3, #100	; 0x64
   14d7a:	4358      	muls	r0, r3
   14d7c:	eb05 35a0 	add.w	r5, r5, r0, asr #14
   14d80:	429d      	cmp	r5, r3
   14d82:	bfa8      	it	ge
   14d84:	461d      	movge	r5, r3
            if (cursor == 1) gfxCursor(45, 23, 18); // Probability Cursor
   14d86:	2e01      	cmp	r6, #1
   14d88:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
   14d8c:	d105      	bne.n	14d9a <TM::DrawSelector()+0x76>
   14d8e:	2312      	movs	r3, #18
   14d90:	2217      	movs	r2, #23
   14d92:	212d      	movs	r1, #45	; 0x2d
   14d94:	4620      	mov	r0, r4
   14d96:	f7f3 fb9b 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
            gfxPrint(pad(100, prob), prob);
   14d9a:	4629      	mov	r1, r5
   14d9c:	2064      	movs	r0, #100	; 0x64
   14d9e:	f7ef fc70 	bl	4682 <HemisphereApplet::pad(int, int) [clone .constprop.0]>
   14da2:	4629      	mov	r1, r5
   14da4:	f7ef fe48 	bl	4a38 <HemisphereApplet::gfxPrint(int, int) [clone .isra.0]>
   14da8:	e00d      	b.n	14dc6 <TM::DrawSelector()+0xa2>
        if (cursor == 1 || Gate(1)) {
   14daa:	2101      	movs	r1, #1
   14dac:	4620      	mov	r0, r4
   14dae:	f7ff fb03 	bl	143b8 <HemisphereApplet::Gate(int)>
   14db2:	2800      	cmp	r0, #0
   14db4:	d1d5      	bne.n	14d62 <TM::DrawSelector()+0x3e>
            gfxBitmap(49, 14, 8, LOCK_ICON);
   14db6:	4b18      	ldr	r3, [pc, #96]	; (14e18 <TM::DrawSelector()+0xf4>)
   14db8:	9300      	str	r3, [sp, #0]
   14dba:	69a0      	ldr	r0, [r4, #24]
   14dbc:	2308      	movs	r3, #8
   14dbe:	220e      	movs	r2, #14
   14dc0:	2131      	movs	r1, #49	; 0x31
   14dc2:	f7ef fde7 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        gfxBitmap(1, 24, 8, SCALE_ICON);
   14dc6:	4b15      	ldr	r3, [pc, #84]	; (14e1c <TM::DrawSelector()+0xf8>)
   14dc8:	69a0      	ldr	r0, [r4, #24]
   14dca:	9300      	str	r3, [sp, #0]
   14dcc:	2218      	movs	r2, #24
   14dce:	2308      	movs	r3, #8
   14dd0:	2101      	movs	r1, #1
   14dd2:	f7ef fddf 	bl	4994 <HemisphereApplet::gfxBitmap(int, int, int, unsigned char const*) [clone .isra.0]>
        gfxPrint(12, 25, OC::scale_names_short[scale]);
   14dd6:	f994 21b4 	ldrsb.w	r2, [r4, #436]	; 0x1b4
   14dda:	4b11      	ldr	r3, [pc, #68]	; (14e20 <TM::DrawSelector()+0xfc>)
   14ddc:	210c      	movs	r1, #12
   14dde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14de2:	4620      	mov	r0, r4
   14de4:	2219      	movs	r2, #25
   14de6:	f7f3 fb7f 	bl	84e8 <HemisphereApplet::gfxPrint(int, int, char const*)>
        if (cursor == 0) gfxCursor(13, 23, 12); // Length Cursor
   14dea:	6f23      	ldr	r3, [r4, #112]	; 0x70
   14dec:	b92b      	cbnz	r3, 14dfa <TM::DrawSelector()+0xd6>
   14dee:	230c      	movs	r3, #12
   14df0:	2217      	movs	r2, #23
   14df2:	210d      	movs	r1, #13
   14df4:	4620      	mov	r0, r4
   14df6:	f7f3 fb6b 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
        if (cursor == 2) gfxCursor(13, 33, 30); // Scale Cursor
   14dfa:	6f23      	ldr	r3, [r4, #112]	; 0x70
   14dfc:	2b02      	cmp	r3, #2
   14dfe:	d105      	bne.n	14e0c <TM::DrawSelector()+0xe8>
   14e00:	231e      	movs	r3, #30
   14e02:	2221      	movs	r2, #33	; 0x21
   14e04:	210d      	movs	r1, #13
   14e06:	4620      	mov	r0, r4
   14e08:	f7f3 fb62 	bl	84d0 <HemisphereApplet::gfxCursor(int, int, int)>
    }
   14e0c:	b002      	add	sp, #8
   14e0e:	bd70      	pop	{r4, r5, r6, pc}
   14e10:	00024218 	.word	0x00024218
   14e14:	00020fc5 	.word	0x00020fc5
   14e18:	00024210 	.word	0x00024210
   14e1c:	00023c90 	.word	0x00023c90
   14e20:	0001e600 	.word	0x0001e600

00014e24 <TM::View()>:
        gfxHeader(applet_name());
   14e24:	6803      	ldr	r3, [r0, #0]
    void View() {
   14e26:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   14e28:	681b      	ldr	r3, [r3, #0]
    void View() {
   14e2a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   14e2c:	4798      	blx	r3
   14e2e:	4601      	mov	r1, r0
   14e30:	4620      	mov	r0, r4
   14e32:	f7f3 fbe4 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawSelector();
   14e36:	4620      	mov	r0, r4
   14e38:	f7ff ff74 	bl	14d24 <TM::DrawSelector()>
        DrawIndicator();
   14e3c:	4620      	mov	r0, r4
   14e3e:	f7fc fd3f 	bl	118c0 <TM::DrawIndicator()>
    }
   14e42:	bd10      	pop	{r4, pc}

00014e44 <Slew::DrawIndicator()>:
    void DrawIndicator() {
   14e44:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
        gfxLine(0, 62, r_x, 33, cursor == 1);
   14e48:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14e4a:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
   14e4c:	1e5a      	subs	r2, r3, #1
   14e4e:	4253      	negs	r3, r2
   14e50:	4153      	adcs	r3, r2
   14e52:	2721      	movs	r7, #33	; 0x21
   14e54:	f04f 08c8 	mov.w	r8, #200	; 0xc8
   14e58:	03b6      	lsls	r6, r6, #14
   14e5a:	fb96 f6f8 	sdiv	r6, r6, r8
        int scaled = simfloat2int(proportion * max_value);
   14e5e:	ebc6 1646 	rsb	r6, r6, r6, lsl #5
    void DrawIndicator() {
   14e62:	4604      	mov	r4, r0
   14e64:	13b6      	asrs	r6, r6, #14
        gfxLine(0, 62, r_x, 33, cursor == 1);
   14e66:	9301      	str	r3, [sp, #4]
   14e68:	9700      	str	r7, [sp, #0]
   14e6a:	4633      	mov	r3, r6
   14e6c:	6980      	ldr	r0, [r0, #24]
   14e6e:	223e      	movs	r2, #62	; 0x3e
   14e70:	2100      	movs	r1, #0
   14e72:	f7ef fdaf 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14e76:	6f25      	ldr	r5, [r4, #112]	; 0x70
        gfxLine(f_x, 33, 62, 62, cursor == 0);
   14e78:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
   14e7a:	69a0      	ldr	r0, [r4, #24]
   14e7c:	03ad      	lsls	r5, r5, #14
   14e7e:	fab3 f383 	clz	r3, r3
   14e82:	fb95 f5f8 	sdiv	r5, r5, r8
        int scaled = simfloat2int(proportion * max_value);
   14e86:	ebc5 1545 	rsb	r5, r5, r5, lsl #5
   14e8a:	095b      	lsrs	r3, r3, #5
   14e8c:	13ad      	asrs	r5, r5, #14
        int f_x = 62 - Proportion(fall, 200, 31);
   14e8e:	f1c5 053e 	rsb	r5, r5, #62	; 0x3e
        gfxLine(f_x, 33, 62, 62, cursor == 0);
   14e92:	9301      	str	r3, [sp, #4]
   14e94:	233e      	movs	r3, #62	; 0x3e
   14e96:	4629      	mov	r1, r5
   14e98:	9300      	str	r3, [sp, #0]
   14e9a:	463a      	mov	r2, r7
   14e9c:	f7ef fd9a 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        gfxLine(r_x, 33, f_x, 33, 1);
   14ea0:	2301      	movs	r3, #1
   14ea2:	9301      	str	r3, [sp, #4]
   14ea4:	4631      	mov	r1, r6
   14ea6:	462b      	mov	r3, r5
   14ea8:	69a0      	ldr	r0, [r4, #24]
   14eaa:	9700      	str	r7, [sp, #0]
   14eac:	463a      	mov	r2, r7
   14eae:	f7ef fd91 	bl	49d4 <HemisphereApplet::gfxLine(int, int, int, int, bool) [clone .isra.0]>
        ForEachChannel(ch)
   14eb2:	f104 0628 	add.w	r6, r4, #40	; 0x28
   14eb6:	2500      	movs	r5, #0
            else gfxRect(1, 15 + (ch * 8), ProportionCV(ViewOut(ch), 62), 6);
   14eb8:	f04f 0806 	mov.w	r8, #6
            if (Gate(ch)) gfxFrame(1, 15 + (ch * 8), ProportionCV(ViewOut(ch), 62), 6);
   14ebc:	4629      	mov	r1, r5
   14ebe:	4620      	mov	r0, r4
   14ec0:	f7ff fa7a 	bl	143b8 <HemisphereApplet::Gate(int)>
   14ec4:	00ef      	lsls	r7, r5, #3
   14ec6:	370f      	adds	r7, #15
   14ec8:	213e      	movs	r1, #62	; 0x3e
   14eca:	b328      	cbz	r0, 14f18 <Slew::DrawIndicator()+0xd4>
   14ecc:	6830      	ldr	r0, [r6, #0]
   14ece:	f7ef fbc9 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
   14ed2:	f8cd 8000 	str.w	r8, [sp]
   14ed6:	4603      	mov	r3, r0
   14ed8:	463a      	mov	r2, r7
   14eda:	69a0      	ldr	r0, [r4, #24]
   14edc:	2101      	movs	r1, #1
   14ede:	f7ef fd95 	bl	4a0c <HemisphereApplet::gfxFrame(int, int, int, int) [clone .isra.0]>
        ForEachChannel(ch)
   14ee2:	3604      	adds	r6, #4
   14ee4:	b1b5      	cbz	r5, 14f14 <Slew::DrawIndicator()+0xd0>
        if (OC::CORE::ticks - last_change_ticks < 20000) {
   14ee6:	4b14      	ldr	r3, [pc, #80]	; (14f38 <Slew::DrawIndicator()+0xf4>)
   14ee8:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
   14eec:	681b      	ldr	r3, [r3, #0]
   14eee:	1a9b      	subs	r3, r3, r2
   14ef0:	f644 621f 	movw	r2, #19999	; 0x4e1f
   14ef4:	4293      	cmp	r3, r2
   14ef6:	d81b      	bhi.n	14f30 <Slew::DrawIndicator()+0xec>
            gfxPrint(15, 43, last_ms_value);
   14ef8:	69a0      	ldr	r0, [r4, #24]
   14efa:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   14efe:	222b      	movs	r2, #43	; 0x2b
   14f00:	210f      	movs	r1, #15
   14f02:	f7ef fdb5 	bl	4a70 <HemisphereApplet::gfxPrint(int, int, int) [clone .isra.0]>
        graphics.print(str);
   14f06:	490d      	ldr	r1, [pc, #52]	; (14f3c <Slew::DrawIndicator()+0xf8>)
   14f08:	480d      	ldr	r0, [pc, #52]	; (14f40 <Slew::DrawIndicator()+0xfc>)
    }
   14f0a:	b002      	add	sp, #8
   14f0c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   14f10:	f004 bde1 	b.w	19ad6 <weegfx::Graphics::print(char const*)>
   14f14:	2501      	movs	r5, #1
   14f16:	e7d1      	b.n	14ebc <Slew::DrawIndicator()+0x78>
            else gfxRect(1, 15 + (ch * 8), ProportionCV(ViewOut(ch), 62), 6);
   14f18:	6830      	ldr	r0, [r6, #0]
   14f1a:	f7ef fba3 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
   14f1e:	f8cd 8000 	str.w	r8, [sp]
   14f22:	4603      	mov	r3, r0
   14f24:	463a      	mov	r2, r7
   14f26:	69a0      	ldr	r0, [r4, #24]
   14f28:	2101      	movs	r1, #1
   14f2a:	f7ef fd69 	bl	4a00 <HemisphereApplet::gfxRect(int, int, int, int) [clone .isra.0]>
   14f2e:	e7d8      	b.n	14ee2 <Slew::DrawIndicator()+0x9e>
    }
   14f30:	b002      	add	sp, #8
   14f32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14f36:	bf00      	nop
   14f38:	200046cc 	.word	0x200046cc
   14f3c:	0001f236 	.word	0x0001f236
   14f40:	200065e0 	.word	0x200065e0

00014f44 <Slew::View()>:
        gfxHeader(applet_name());
   14f44:	6803      	ldr	r3, [r0, #0]
    void View() {
   14f46:	b510      	push	{r4, lr}
        gfxHeader(applet_name());
   14f48:	681b      	ldr	r3, [r3, #0]
    void View() {
   14f4a:	4604      	mov	r4, r0
        gfxHeader(applet_name());
   14f4c:	4798      	blx	r3
   14f4e:	4601      	mov	r1, r0
   14f50:	4620      	mov	r0, r4
   14f52:	f7f3 fb54 	bl	85fe <HemisphereApplet::gfxHeader(char const*)>
        DrawIndicator();
   14f56:	4620      	mov	r0, r4
   14f58:	f7ff ff74 	bl	14e44 <Slew::DrawIndicator()>
    }
   14f5c:	bd10      	pop	{r4, pc}

00014f5e <TM::Controller()>:
    void Controller() {
   14f5e:	b570      	push	{r4, r5, r6, lr}
        int lengthCv = DetentedIn(0);
   14f60:	2100      	movs	r1, #0
    void Controller() {
   14f62:	4604      	mov	r4, r0
        int lengthCv = DetentedIn(0);
   14f64:	f7f3 ffae 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        if (lengthCv < 0) length = TM_MIN_LENGTH;        
   14f68:	2800      	cmp	r0, #0
   14f6a:	da50      	bge.n	1500e <TM::Controller()+0xb0>
   14f6c:	2302      	movs	r3, #2
   14f6e:	66e3      	str	r3, [r4, #108]	; 0x6c
        int pCv = Proportion(DetentedIn(1), HEMISPHERE_MAX_CV, 100);
   14f70:	2101      	movs	r1, #1
   14f72:	4620      	mov	r0, r4
   14f74:	f7f3 ffa6 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        if (Clock(0)) {
   14f78:	2200      	movs	r2, #0
        int pCv = Proportion(DetentedIn(1), HEMISPHERE_MAX_CV, 100);
   14f7a:	4606      	mov	r6, r0
        if (Clock(0)) {
   14f7c:	4611      	mov	r1, r2
   14f7e:	4620      	mov	r0, r4
   14f80:	f7f4 fb00 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   14f84:	b320      	cbz	r0, 14fd0 <TM::Controller()+0x72>
            int prob = (cursor == 1 || Gate(1)) ? p + pCv : 0;
   14f86:	6f23      	ldr	r3, [r4, #112]	; 0x70
   14f88:	2b01      	cmp	r3, #1
   14f8a:	d14c      	bne.n	15026 <TM::Controller()+0xc8>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14f8c:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
   14f90:	f8d4 01b0 	ldr.w	r0, [r4, #432]	; 0x1b0
   14f94:	03b3      	lsls	r3, r6, #14
   14f96:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   14f9a:	2264      	movs	r2, #100	; 0x64
   14f9c:	4353      	muls	r3, r2
            prob = constrain(prob, 0, 100);
   14f9e:	eb10 35a3 	adds.w	r5, r0, r3, asr #14
   14fa2:	d547      	bpl.n	15034 <TM::Controller()+0xd6>
   14fa4:	2500      	movs	r5, #0
            int last = (reg >> (length - 1)) & 0x01;
   14fa6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   14fa8:	f8b4 61ac 	ldrh.w	r6, [r4, #428]	; 0x1ac
   14fac:	3b01      	subs	r3, #1
            if (random(0, 99) < prob) last = 1 - last;
   14fae:	2163      	movs	r1, #99	; 0x63
   14fb0:	2000      	movs	r0, #0
            int last = (reg >> (length - 1)) & 0x01;
   14fb2:	411e      	asrs	r6, r3
            if (random(0, 99) < prob) last = 1 - last;
   14fb4:	f004 ff9b 	bl	19eee <random(long, long)>
            int last = (reg >> (length - 1)) & 0x01;
   14fb8:	f006 0601 	and.w	r6, r6, #1
            reg = (reg << 1) + last;
   14fbc:	f8b4 31ac 	ldrh.w	r3, [r4, #428]	; 0x1ac
            if (random(0, 99) < prob) last = 1 - last;
   14fc0:	42a8      	cmp	r0, r5
   14fc2:	bfb8      	it	lt
   14fc4:	f1c6 0601 	rsblt	r6, r6, #1
            reg = (reg << 1) + last;
   14fc8:	eb06 0643 	add.w	r6, r6, r3, lsl #1
   14fcc:	f8a4 61ac 	strh.w	r6, [r4, #428]	; 0x1ac
        Out(0, quantizer.Lookup(note + 64));
   14fd0:	f8b4 11ac 	ldrh.w	r1, [r4, #428]	; 0x1ac
   14fd4:	f001 011f 	and.w	r1, r1, #31
   14fd8:	3140      	adds	r1, #64	; 0x40
   14fda:	f104 0074 	add.w	r0, r4, #116	; 0x74
   14fde:	f7ec fa51 	bl	1484 <braids::Quantizer::Lookup(long) const>
   14fe2:	2300      	movs	r3, #0
   14fe4:	4602      	mov	r2, r0
   14fe6:	4619      	mov	r1, r3
   14fe8:	4620      	mov	r0, r4
   14fea:	f7f3 ff74 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        int cv = Proportion(reg & 0x00ff, 255, HEMISPHERE_MAX_CV);
   14fee:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   14ff2:	23ff      	movs	r3, #255	; 0xff
   14ff4:	0392      	lsls	r2, r2, #14
   14ff6:	fbb2 f2f3 	udiv	r2, r2, r3
        int scaled = simfloat2int(proportion * max_value);
   14ffa:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   14ffe:	435a      	muls	r2, r3
        Out(1, cv);
   15000:	1392      	asrs	r2, r2, #14
   15002:	2300      	movs	r3, #0
   15004:	2101      	movs	r1, #1
   15006:	4620      	mov	r0, r4
   15008:	f7f3 ff65 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   1500c:	bd70      	pop	{r4, r5, r6, pc}
        if (lengthCv > 0) {
   1500e:	d0af      	beq.n	14f70 <TM::Controller()+0x12>
            length = constrain(ProportionCV(lengthCv, TM_MAX_LENGTH + 1), TM_MIN_LENGTH, TM_MAX_LENGTH);
   15010:	2111      	movs	r1, #17
   15012:	f7ef fb27 	bl	4664 <HemisphereApplet::ProportionCV(int, int) [clone .constprop.0]>
   15016:	2810      	cmp	r0, #16
   15018:	bfa8      	it	ge
   1501a:	2010      	movge	r0, #16
   1501c:	2802      	cmp	r0, #2
   1501e:	bfb8      	it	lt
   15020:	2002      	movlt	r0, #2
   15022:	66e0      	str	r0, [r4, #108]	; 0x6c
   15024:	e7a4      	b.n	14f70 <TM::Controller()+0x12>
            int prob = (cursor == 1 || Gate(1)) ? p + pCv : 0;
   15026:	2101      	movs	r1, #1
   15028:	4620      	mov	r0, r4
   1502a:	f7ff f9c5 	bl	143b8 <HemisphereApplet::Gate(int)>
   1502e:	4605      	mov	r5, r0
   15030:	2800      	cmp	r0, #0
   15032:	d1ab      	bne.n	14f8c <TM::Controller()+0x2e>
   15034:	2d64      	cmp	r5, #100	; 0x64
   15036:	bfa8      	it	ge
   15038:	2564      	movge	r5, #100	; 0x64
   1503a:	e7b4      	b.n	14fa6 <TM::Controller()+0x48>

0001503c <Switch::Controller()>:
        if (Clock(0)) {
   1503c:	2200      	movs	r2, #0
    void Controller() {
   1503e:	b510      	push	{r4, lr}
        if (Clock(0)) {
   15040:	4611      	mov	r1, r2
    void Controller() {
   15042:	4604      	mov	r4, r0
        if (Clock(0)) {
   15044:	f7f4 fa9e 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   15048:	b130      	cbz	r0, 15058 <Switch::Controller()+0x1c>
            step = 1 - step;
   1504a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   1504c:	f1c3 0201 	rsb	r2, r3, #1
            active[0] = step + 1;
   15050:	f1c3 0302 	rsb	r3, r3, #2
            step = 1 - step;
   15054:	66e2      	str	r2, [r4, #108]	; 0x6c
            active[0] = step + 1;
   15056:	6723      	str	r3, [r4, #112]	; 0x70
        return inputs[ch];
   15058:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   1505a:	f103 0208 	add.w	r2, r3, #8
        Out(0, In(step));
   1505e:	2300      	movs	r3, #0
   15060:	4619      	mov	r1, r3
   15062:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   15066:	4620      	mov	r0, r4
   15068:	f7f3 ff35 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
        if (Gate(1)) {
   1506c:	2101      	movs	r1, #1
   1506e:	4620      	mov	r0, r4
   15070:	f7ff f9a2 	bl	143b8 <HemisphereApplet::Gate(int)>
   15074:	4603      	mov	r3, r0
   15076:	b140      	cbz	r0, 1508a <Switch::Controller()+0x4e>
            active[1] = 2;
   15078:	2302      	movs	r3, #2
            Out(1, In(1));
   1507a:	6a62      	ldr	r2, [r4, #36]	; 0x24
            active[1] = 2;
   1507c:	6763      	str	r3, [r4, #116]	; 0x74
            Out(1, In(1));
   1507e:	2101      	movs	r1, #1
   15080:	2300      	movs	r3, #0
            Out(1, In(0));
   15082:	4620      	mov	r0, r4
   15084:	f7f3 ff27 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   15088:	bd10      	pop	{r4, pc}
            active[1] = 1;
   1508a:	2101      	movs	r1, #1
            Out(1, In(0));
   1508c:	6a22      	ldr	r2, [r4, #32]
            active[1] = 1;
   1508e:	6761      	str	r1, [r4, #116]	; 0x74
   15090:	e7f7      	b.n	15082 <Switch::Controller()+0x46>

00015092 <Squanch::Controller()>:
        if (Clock(0)) {
   15092:	2200      	movs	r2, #0
    void Controller() {
   15094:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        if (Clock(0)) {
   15098:	4611      	mov	r1, r2
    void Controller() {
   1509a:	4604      	mov	r4, r0
        if (Clock(0)) {
   1509c:	f7f4 fa72 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   150a0:	b150      	cbz	r0, 150b8 <Squanch::Controller()+0x26>
            continuous = 0; // Turn off continuous mode if there's a clock
   150a2:	2300      	movs	r3, #0
   150a4:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
        adc_lag_countdown[ch] = HEMISPHERE_ADC_LAG;
   150a8:	2321      	movs	r3, #33	; 0x21
   150aa:	64e3      	str	r3, [r4, #76]	; 0x4c
        return (--adc_lag_countdown[ch] == 0);
   150ac:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   150ae:	3b01      	subs	r3, #1
   150b0:	64e3      	str	r3, [r4, #76]	; 0x4c
        if (continuous || EndOfADCLag(0)) {
   150b2:	b12b      	cbz	r3, 150c0 <Squanch::Controller()+0x2e>
    }
   150b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (continuous || EndOfADCLag(0)) {
   150b8:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   150bc:	2b00      	cmp	r3, #0
   150be:	d0f5      	beq.n	150ac <Squanch::Controller()+0x1a>
                int32_t shift_alt = (ch == 1) ? DetentedIn(1) : Gate(1) * (12 << 7);
   150c0:	2101      	movs	r1, #1
   150c2:	4620      	mov	r0, r4
        return inputs[ch];
   150c4:	f8d4 9020 	ldr.w	r9, [r4, #32]
   150c8:	f7ff f976 	bl	143b8 <HemisphereApplet::Gate(int)>
   150cc:	f44f 63c0 	mov.w	r3, #1536	; 0x600
   150d0:	f504 78db 	add.w	r8, r4, #438	; 0x1b6
   150d4:	f104 0770 	add.w	r7, r4, #112	; 0x70
            ForEachChannel(ch)
   150d8:	2600      	movs	r6, #0
                int32_t shift_alt = (ch == 1) ? DetentedIn(1) : Gate(1) * (12 << 7);
   150da:	fb03 f500 	mul.w	r5, r3, r0
                int32_t quantized = quantizer.Process(pitch, 0, shift[ch]);
   150de:	f938 3f02 	ldrsh.w	r3, [r8, #2]!
   150e2:	2200      	movs	r2, #0
   150e4:	4649      	mov	r1, r9
   150e6:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   150ea:	f7ec f951 	bl	1390 <braids::Quantizer::Process(long, long, long)>
                Out(ch, quantized + shift_alt);
   150ee:	2300      	movs	r3, #0
                int32_t quantized = quantizer.Process(pitch, 0, shift[ch]);
   150f0:	4682      	mov	sl, r0
                Out(ch, quantized + shift_alt);
   150f2:	182a      	adds	r2, r5, r0
   150f4:	4631      	mov	r1, r6
   150f6:	4620      	mov	r0, r4
   150f8:	f7f3 feed 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
                last_note[ch] = quantized;
   150fc:	f847 af04 	str.w	sl, [r7, #4]!
            ForEachChannel(ch)
   15100:	2e00      	cmp	r6, #0
   15102:	d1d7      	bne.n	150b4 <Squanch::Controller()+0x22>
   15104:	2601      	movs	r6, #1
                int32_t shift_alt = (ch == 1) ? DetentedIn(1) : Gate(1) * (12 << 7);
   15106:	4631      	mov	r1, r6
   15108:	4620      	mov	r0, r4
   1510a:	f7f3 fedb 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
   1510e:	4605      	mov	r5, r0
   15110:	e7e5      	b.n	150de <Squanch::Controller()+0x4c>

00015112 <ScaleDuet::Controller()>:
        if (Clock(0)) StartADCLag();
   15112:	2200      	movs	r2, #0
    void Controller() {
   15114:	b570      	push	{r4, r5, r6, lr}
        if (Clock(0)) StartADCLag();
   15116:	4611      	mov	r1, r2
    void Controller() {
   15118:	4604      	mov	r4, r0
        if (Clock(0)) StartADCLag();
   1511a:	f7f4 fa33 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   1511e:	b108      	cbz	r0, 15124 <ScaleDuet::Controller()+0x12>
        adc_lag_countdown[ch] = HEMISPHERE_ADC_LAG;
   15120:	2321      	movs	r3, #33	; 0x21
   15122:	64e3      	str	r3, [r4, #76]	; 0x4c
        return (--adc_lag_countdown[ch] == 0);
   15124:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   15126:	3b01      	subs	r3, #1
   15128:	64e3      	str	r3, [r4, #76]	; 0x4c
        if (EndOfADCLag()) {
   1512a:	bb1b      	cbnz	r3, 15174 <ScaleDuet::Controller()+0x62>
            uint8_t scale = Gate(1);
   1512c:	2101      	movs	r1, #1
   1512e:	4620      	mov	r0, r4
   15130:	f7ff f942 	bl	143b8 <HemisphereApplet::Gate(int)>
            if (scale != last_scale) {
   15134:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   15138:	4283      	cmp	r3, r0
            uint8_t scale = Gate(1);
   1513a:	4605      	mov	r5, r0
                quantizer.Configure(OC::Scales::GetScale(5), mask[scale]);
   1513c:	f104 066c 	add.w	r6, r4, #108	; 0x6c
            if (scale != last_scale) {
   15140:	d00c      	beq.n	1515c <ScaleDuet::Controller()+0x4a>
                quantizer.Configure(OC::Scales::GetScale(5), mask[scale]);
   15142:	2005      	movs	r0, #5
   15144:	f7eb ff16 	bl	f74 <OC::Scales::GetScale(int)>
   15148:	eb04 0345 	add.w	r3, r4, r5, lsl #1
   1514c:	4601      	mov	r1, r0
   1514e:	f8b3 21a4 	ldrh.w	r2, [r3, #420]	; 0x1a4
   15152:	4630      	mov	r0, r6
   15154:	f7f0 ff52 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
                last_scale = scale;
   15158:	f884 51a9 	strb.w	r5, [r4, #425]	; 0x1a9
            int32_t quantized = quantizer.Process(pitch, 0, 0);
   1515c:	2300      	movs	r3, #0
   1515e:	461a      	mov	r2, r3
   15160:	6a21      	ldr	r1, [r4, #32]
   15162:	4630      	mov	r0, r6
   15164:	f7ec f914 	bl	1390 <braids::Quantizer::Process(long, long, long)>
            Out(0, quantized);
   15168:	2300      	movs	r3, #0
            int32_t quantized = quantizer.Process(pitch, 0, 0);
   1516a:	4602      	mov	r2, r0
            Out(0, quantized);
   1516c:	4619      	mov	r1, r3
   1516e:	4620      	mov	r0, r4
   15170:	f7f3 feb1 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   15174:	bd70      	pop	{r4, r5, r6, pc}

00015176 <RunglBook::Controller()>:
        if (Clock(0)) {
   15176:	2200      	movs	r2, #0
    void Controller() {
   15178:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (Clock(0)) {
   1517a:	4611      	mov	r1, r2
    void Controller() {
   1517c:	4605      	mov	r5, r0
        if (Clock(0)) {
   1517e:	f7f4 fa01 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   15182:	b330      	cbz	r0, 151d2 <RunglBook::Controller()+0x5c>
            if (Gate(1)) {
   15184:	2101      	movs	r1, #1
   15186:	4628      	mov	r0, r5
   15188:	f7ff f916 	bl	143b8 <HemisphereApplet::Gate(int)>
   1518c:	f895 406c 	ldrb.w	r4, [r5, #108]	; 0x6c
   15190:	b300      	cbz	r0, 151d4 <RunglBook::Controller()+0x5e>
                reg = (reg << 1) | ((reg >> 7) & 0x01);
   15192:	0063      	lsls	r3, r4, #1
   15194:	ea43 13d4 	orr.w	r3, r3, r4, lsr #7
   15198:	b2dc      	uxtb	r4, r3
        int scaled = simfloat2int(proportion * max_value);
   1519a:	f44f 56f0 	mov.w	r6, #7680	; 0x1e00
            int rungle = Proportion(reg & 0x07, 0x07, HEMISPHERE_MAX_CV);
   1519e:	f004 0207 	and.w	r2, r4, #7
            Out(0, rungle);
   151a2:	2300      	movs	r3, #0
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   151a4:	2707      	movs	r7, #7
   151a6:	0392      	lsls	r2, r2, #14
   151a8:	fbb2 f2f7 	udiv	r2, r2, r7
        int scaled = simfloat2int(proportion * max_value);
   151ac:	4372      	muls	r2, r6
   151ae:	4619      	mov	r1, r3
   151b0:	0b92      	lsrs	r2, r2, #14
   151b2:	4628      	mov	r0, r5
                reg = (reg << 1) | ((reg >> 7) & 0x01);
   151b4:	f885 406c 	strb.w	r4, [r5, #108]	; 0x6c
            Out(0, rungle);
   151b8:	f7f3 fe8d 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            int rungle_tap = Proportion((reg >> 5) & 0x07, 0x07, HEMISPHERE_MAX_CV);
   151bc:	0962      	lsrs	r2, r4, #5
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   151be:	0392      	lsls	r2, r2, #14
   151c0:	fbb2 f2f7 	udiv	r2, r2, r7
        int scaled = simfloat2int(proportion * max_value);
   151c4:	4372      	muls	r2, r6
            Out(1, rungle_tap);
   151c6:	2300      	movs	r3, #0
   151c8:	1392      	asrs	r2, r2, #14
   151ca:	2101      	movs	r1, #1
   151cc:	4628      	mov	r0, r5
   151ce:	f7f3 fe82 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   151d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                byte b0 = In(0) > threshold ? 0x01 : 0x00;
   151d4:	f8b5 206e 	ldrh.w	r2, [r5, #110]	; 0x6e
   151d8:	6a2b      	ldr	r3, [r5, #32]
                reg = (reg << 1) | b0;
   151da:	0064      	lsls	r4, r4, #1
   151dc:	429a      	cmp	r2, r3
   151de:	bfb8      	it	lt
   151e0:	f044 0401 	orrlt.w	r4, r4, #1
   151e4:	b2e4      	uxtb	r4, r4
   151e6:	e7d8      	b.n	1519a <RunglBook::Controller()+0x24>

000151e8 <Palimpsest::Controller()>:
    void Controller() {
   151e8:	b570      	push	{r4, r5, r6, lr}
        effective_decompose = decompose;
   151ea:	f8d0 50c8 	ldr.w	r5, [r0, #200]	; 0xc8
   151ee:	f8c0 50b4 	str.w	r5, [r0, #180]	; 0xb4
        if (DetentedIn(0)) {
   151f2:	2100      	movs	r1, #0
    void Controller() {
   151f4:	4604      	mov	r4, r0
        if (DetentedIn(0)) {
   151f6:	f7f3 fe65 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
   151fa:	b1c0      	cbz	r0, 1522e <Palimpsest::Controller()+0x46>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   151fc:	6a23      	ldr	r3, [r4, #32]
   151fe:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   15202:	039b      	lsls	r3, r3, #14
   15204:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   15208:	2232      	movs	r2, #50	; 0x32
   1520a:	4353      	muls	r3, r2
   1520c:	139b      	asrs	r3, r3, #14
            effective_decompose = constrain(decompose + mod, 0, HEM_PALIMPSEST_MAX_VALUE);
   1520e:	4293      	cmp	r3, r2
   15210:	bfa8      	it	ge
   15212:	4613      	movge	r3, r2
   15214:	f06f 0231 	mvn.w	r2, #49	; 0x31
   15218:	4293      	cmp	r3, r2
   1521a:	bfac      	ite	ge
   1521c:	18ed      	addge	r5, r5, r3
   1521e:	18ad      	addlt	r5, r5, r2
   15220:	2d64      	cmp	r5, #100	; 0x64
   15222:	bfa8      	it	ge
   15224:	2564      	movge	r5, #100	; 0x64
   15226:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
   1522a:	f8c4 50b4 	str.w	r5, [r4, #180]	; 0xb4
        effective_compose = compose;
   1522e:	f8d4 50c4 	ldr.w	r5, [r4, #196]	; 0xc4
   15232:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
        if (DetentedIn(1)) {
   15236:	2101      	movs	r1, #1
   15238:	4620      	mov	r0, r4
   1523a:	f7f3 fe43 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
   1523e:	b1c0      	cbz	r0, 15272 <Palimpsest::Controller()+0x8a>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   15240:	6a63      	ldr	r3, [r4, #36]	; 0x24
   15242:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   15246:	039b      	lsls	r3, r3, #14
   15248:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   1524c:	2232      	movs	r2, #50	; 0x32
   1524e:	4353      	muls	r3, r2
   15250:	139b      	asrs	r3, r3, #14
            effective_compose = constrain(compose + mod, 0, HEM_PALIMPSEST_MAX_VALUE);
   15252:	4293      	cmp	r3, r2
   15254:	bfa8      	it	ge
   15256:	4613      	movge	r3, r2
   15258:	f06f 0231 	mvn.w	r2, #49	; 0x31
   1525c:	4293      	cmp	r3, r2
   1525e:	bfac      	ite	ge
   15260:	18ed      	addge	r5, r5, r3
   15262:	18ad      	addlt	r5, r5, r2
   15264:	2d64      	cmp	r5, #100	; 0x64
   15266:	bfa8      	it	ge
   15268:	2564      	movge	r5, #100	; 0x64
   1526a:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
   1526e:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
        if (Gate(1)) {
   15272:	2101      	movs	r1, #1
   15274:	4620      	mov	r0, r4
   15276:	f7ff f89f 	bl	143b8 <HemisphereApplet::Gate(int)>
   1527a:	b1d8      	cbz	r0, 152b4 <Palimpsest::Controller()+0xcc>
            if (!brush && cursor != 2) {
   1527c:	f894 30bc 	ldrb.w	r3, [r4, #188]	; 0xbc
   15280:	b9c3      	cbnz	r3, 152b4 <Palimpsest::Controller()+0xcc>
   15282:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
   15286:	2b02      	cmp	r3, #2
   15288:	d014      	beq.n	152b4 <Palimpsest::Controller()+0xcc>
                accent[step] += (HEMISPHERE_MAX_CV / HEM_PALIMPSEST_MAX_VALUE) * effective_compose;
   1528a:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
   1528e:	f8d4 10b0 	ldr.w	r1, [r4, #176]	; 0xb0
   15292:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   15296:	204c      	movs	r0, #76	; 0x4c
   15298:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
   1529a:	fb00 3301 	mla	r3, r0, r1, r3
                accent[step] = constrain(accent[step], 0, HEMISPHERE_MAX_CV);
   1529e:	f5b3 5ff0 	cmp.w	r3, #7680	; 0x1e00
   152a2:	bfa8      	it	ge
   152a4:	f44f 53f0 	movge.w	r3, #7680	; 0x1e00
   152a8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   152ac:	66d3      	str	r3, [r2, #108]	; 0x6c
                brush = 1;
   152ae:	2301      	movs	r3, #1
   152b0:	f884 30bc 	strb.w	r3, [r4, #188]	; 0xbc
        if (Clock(0)) {
   152b4:	2200      	movs	r2, #0
   152b6:	4611      	mov	r1, r2
   152b8:	4620      	mov	r0, r4
   152ba:	f7f4 f963 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   152be:	f8d4 50ac 	ldr.w	r5, [r4, #172]	; 0xac
   152c2:	4603      	mov	r3, r0
   152c4:	b3a8      	cbz	r0, 15332 <Palimpsest::Controller()+0x14a>
            if (!brush && cursor != 2) {
   152c6:	f894 30bc 	ldrb.w	r3, [r4, #188]	; 0xbc
   152ca:	b9a3      	cbnz	r3, 152f6 <Palimpsest::Controller()+0x10e>
   152cc:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
   152d0:	2b02      	cmp	r3, #2
   152d2:	d010      	beq.n	152f6 <Palimpsest::Controller()+0x10e>
   152d4:	eb04 0285 	add.w	r2, r4, r5, lsl #2
                accent[step] -= (HEMISPHERE_MAX_CV / HEM_PALIMPSEST_MAX_VALUE) * effective_decompose;
   152d8:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
   152dc:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
   152de:	f06f 004b 	mvn.w	r0, #75	; 0x4b
   152e2:	fb00 3301 	mla	r3, r0, r1, r3
                accent[step] = constrain(accent[step], 0, HEMISPHERE_MAX_CV);
   152e6:	f5b3 5ff0 	cmp.w	r3, #7680	; 0x1e00
   152ea:	bfa8      	it	ge
   152ec:	f44f 53f0 	movge.w	r3, #7680	; 0x1e00
   152f0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   152f4:	66d3      	str	r3, [r2, #108]	; 0x6c
            Out(0, accent[step]);
   152f6:	eb04 0285 	add.w	r2, r4, r5, lsl #2
            brush = 0;
   152fa:	2300      	movs	r3, #0
            Out(0, accent[step]);
   152fc:	6ed6      	ldr	r6, [r2, #108]	; 0x6c
            brush = 0;
   152fe:	f884 30bc 	strb.w	r3, [r4, #188]	; 0xbc
            Out(0, accent[step]);
   15302:	4632      	mov	r2, r6
   15304:	4619      	mov	r1, r3
   15306:	4620      	mov	r0, r4
   15308:	f7f3 fde5 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            if (accent[step] > HEMISPHERE_3V_CV) ClockOut(1);
   1530c:	f5b6 5f90 	cmp.w	r6, #4608	; 0x1200
   15310:	dd04      	ble.n	1531c <Palimpsest::Controller()+0x134>
   15312:	2264      	movs	r2, #100	; 0x64
   15314:	2101      	movs	r1, #1
   15316:	4620      	mov	r0, r4
   15318:	f7f4 fb05 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
            if (++step >= length) step = 0;
   1531c:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
   15320:	3501      	adds	r5, #1
   15322:	429d      	cmp	r5, r3
   15324:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
   15328:	db02      	blt.n	15330 <Palimpsest::Controller()+0x148>
   1532a:	2300      	movs	r3, #0
   1532c:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
    }
   15330:	bd70      	pop	{r4, r5, r6, pc}
            Out(0, accent[step]);
   15332:	eb04 0585 	add.w	r5, r4, r5, lsl #2
   15336:	4601      	mov	r1, r0
   15338:	6eea      	ldr	r2, [r5, #108]	; 0x6c
   1533a:	4620      	mov	r0, r4
   1533c:	f7f3 fdcb 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   15340:	e7f6      	b.n	15330 <Palimpsest::Controller()+0x148>
   15342:	Address 0x0000000000015342 is out of bounds.


00015344 <LowerRenz::Controller()>:
    void Controller() {
   15344:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
        if (!Gate(1)) { // Freeze if gated
   15346:	2101      	movs	r1, #1
    void Controller() {
   15348:	4605      	mov	r5, r0
        if (!Gate(1)) { // Freeze if gated
   1534a:	f7ff f835 	bl	143b8 <HemisphereApplet::Gate(int)>
   1534e:	2800      	cmp	r0, #0
   15350:	f040 8087 	bne.w	15462 <LowerRenz::Controller()+0x11e>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   15354:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   15356:	6a2b      	ldr	r3, [r5, #32]
            lorenz_m->SetFreq(hemisphere, freq_h);
   15358:	6eee      	ldr	r6, [r5, #108]	; 0x6c
   1535a:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
   1535e:	0392      	lsls	r2, r2, #14
   15360:	039b      	lsls	r3, r3, #14
   15362:	fb92 f2f1 	sdiv	r2, r2, r1
   15366:	fb93 f3f1 	sdiv	r3, r3, r1
        int scaled = simfloat2int(proportion * max_value);
   1536a:	ebc3 1183 	rsb	r1, r3, r3, lsl #6
            int32_t freq_h = SCALE8_16(constrain(freq + freq_cv, 0, 255));
   1536e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
   15370:	eb03 33a1 	add.w	r3, r3, r1, asr #14
   15374:	f383 0308 	usat	r3, #8, r3
   15378:	3301      	adds	r3, #1
            lorenz_m->SetFreq(hemisphere, freq_h);
   1537a:	7929      	ldrb	r1, [r5, #4]
            int32_t freq_h = SCALE8_16(constrain(freq + freq_cv, 0, 255));
   1537c:	041b      	lsls	r3, r3, #16
   1537e:	121b      	asrs	r3, r3, #8
   15380:	3b01      	subs	r3, #1
}

inline uint32_t USAT16(int32_t value) __attribute__((always_inline));
inline uint32_t USAT16(int32_t value) {
  uint32_t result;
  __asm("usat %0, %1, %2" : "=r" (result) : "I" (16), "r" (value));
   15382:	f383 0310 	usat	r3, #16, r3
        if (hemisphere == 0) lorenz.set_rho1(rho);
        else lorenz.set_rho2(rho);
    }

    void SetFreq(bool hemisphere, uint32_t freq_) {
        freq[hemisphere] = freq_;
   15386:	f846 3021 	str.w	r3, [r6, r1, lsl #2]
            int32_t rho_h = SCALE8_16(constrain(rho + rho_cv, 4, 127));
   1538a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
   1538c:	ebc2 1242 	rsb	r2, r2, r2, lsl #5
   15390:	eb03 33a2 	add.w	r3, r3, r2, asr #14
   15394:	2b7f      	cmp	r3, #127	; 0x7f
   15396:	bfa8      	it	ge
   15398:	237f      	movge	r3, #127	; 0x7f
   1539a:	2b04      	cmp	r3, #4
   1539c:	bfb8      	it	lt
   1539e:	2304      	movlt	r3, #4
   153a0:	1c5c      	adds	r4, r3, #1
   153a2:	0424      	lsls	r4, r4, #16
   153a4:	1224      	asrs	r4, r4, #8
   153a6:	3c01      	subs	r4, #1
   153a8:	f384 0410 	usat	r4, #16, r4
            lorenz_m->SetRho(hemisphere, USAT16(rho_h));
   153ac:	b224      	sxth	r4, r4
        if (hemisphere == 0) lorenz.set_rho1(rho);
   153ae:	0364      	lsls	r4, r4, #13

 
  inline void set_rho1(int16_t rho) {
    // rho1_ = ((double)(rho) * (1 << 13)) + 24.0 * (1 << 24) ; // was 12
    // c1_ = (double)(rho + (6 << 3)) * (1 << 13) ; // was 13
    rho1_ = (rho * (1 << 13)) + 24.0 * (1 << 24) ; // was 12
   153b0:	4620      	mov	r0, r4
   153b2:	2900      	cmp	r1, #0
   153b4:	d157      	bne.n	15466 <LowerRenz::Controller()+0x122>
   153b6:	f007 fe7f 	bl	1d0b8 <__aeabi_i2f>
   153ba:	4932      	ldr	r1, [pc, #200]	; (15484 <LowerRenz::Controller()+0x140>)
   153bc:	f007 fdc8 	bl	1cf50 <__addsf3>
   153c0:	f008 f8d0 	bl	1d564 <__aeabi_f2lz>
    c1_ = (rho + (6 << 3)) * (1 << 13) ; // was 13
   153c4:	f504 24c0 	add.w	r4, r4, #393216	; 0x60000
   153c8:	17e3      	asrs	r3, r4, #31
    rho1_ = (rho * (1 << 13)) + 24.0 * (1 << 24) ; // was 12
   153ca:	e9c6 0114 	strd	r0, r1, [r6, #80]	; 0x50
    c1_ = (rho + (6 << 3)) * (1 << 13) ; // was 13
   153ce:	e9c6 431a 	strd	r4, r3, [r6, #104]	; 0x68
            if (Clock(0, true)) lorenz_m->Reset(hemisphere);
   153d2:	2201      	movs	r2, #1
   153d4:	2100      	movs	r1, #0
   153d6:	4628      	mov	r0, r5
   153d8:	f7f4 f8d4 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   153dc:	6eec      	ldr	r4, [r5, #108]	; 0x6c
   153de:	b118      	cbz	r0, 153e8 <LowerRenz::Controller()+0xa4>
    }

    void Reset(bool hemisphere) {
        reset[hemisphere] = 1;
   153e0:	792b      	ldrb	r3, [r5, #4]
   153e2:	4423      	add	r3, r4
   153e4:	2201      	movs	r2, #1
   153e6:	721a      	strb	r2, [r3, #8]
    }

    void Process() {
        if (OC::CORE::ticks - last_process_tick >= LORENZ_PROCESS_TICKS) {
   153e8:	4a27      	ldr	r2, [pc, #156]	; (15488 <LowerRenz::Controller()+0x144>)
   153ea:	68e1      	ldr	r1, [r4, #12]
   153ec:	6813      	ldr	r3, [r2, #0]
   153ee:	1a5b      	subs	r3, r3, r1
   153f0:	2b0f      	cmp	r3, #15
   153f2:	d90f      	bls.n	15414 <LowerRenz::Controller()+0xd0>
            last_process_tick = OC::CORE::ticks;
   153f4:	6813      	ldr	r3, [r2, #0]
   153f6:	60e3      	str	r3, [r4, #12]
            lorenz.Process(freq[0], freq[1], reset[0], reset[1], 2, 2);
   153f8:	2202      	movs	r2, #2
   153fa:	7a23      	ldrb	r3, [r4, #8]
   153fc:	9202      	str	r2, [sp, #8]
   153fe:	9201      	str	r2, [sp, #4]
   15400:	7a62      	ldrb	r2, [r4, #9]
   15402:	9200      	str	r2, [sp, #0]
   15404:	e9d4 1200 	ldrd	r1, r2, [r4]
   15408:	f104 0010 	add.w	r0, r4, #16
   1540c:	f002 ff20 	bl	18250 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)>
            reset[0] = 0;
   15410:	2300      	movs	r3, #0
   15412:	8123      	strh	r3, [r4, #8]
            int x = Proportion(lorenz_m->GetOut(0 + (hemisphere * 2)) - 17000, 25000, HEMISPHERE_MAX_CV);
   15414:	792b      	ldrb	r3, [r5, #4]
   15416:	6eea      	ldr	r2, [r5, #108]	; 0x6c
   15418:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   1541c:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
        return lorenz.dac_code(out);
   15420:	f8b2 307a 	ldrh.w	r3, [r2, #122]	; 0x7a
            int y = Proportion(lorenz_m->GetOut(1 + (hemisphere * 2)) - 17000, 25000, HEMISPHERE_MAX_CV);
   15424:	f5a3 4384 	sub.w	r3, r3, #16896	; 0x4200
   15428:	3b68      	subs	r3, #104	; 0x68
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   1542a:	039c      	lsls	r4, r3, #14
   1542c:	f8b2 3078 	ldrh.w	r3, [r2, #120]	; 0x78
            int x = Proportion(lorenz_m->GetOut(0 + (hemisphere * 2)) - 17000, 25000, HEMISPHERE_MAX_CV);
   15430:	f5a3 4384 	sub.w	r3, r3, #16896	; 0x4200
   15434:	3b68      	subs	r3, #104	; 0x68
   15436:	f246 10a8 	movw	r0, #25000	; 0x61a8
   1543a:	039a      	lsls	r2, r3, #14
   1543c:	fb94 f4f0 	sdiv	r4, r4, r0
            Out(0, x);
   15440:	2300      	movs	r3, #0
        int scaled = simfloat2int(proportion * max_value);
   15442:	434c      	muls	r4, r1
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   15444:	fb92 f2f0 	sdiv	r2, r2, r0
        int scaled = simfloat2int(proportion * max_value);
   15448:	434a      	muls	r2, r1
   1544a:	1392      	asrs	r2, r2, #14
   1544c:	4619      	mov	r1, r3
   1544e:	4628      	mov	r0, r5
   15450:	13a4      	asrs	r4, r4, #14
   15452:	f7f3 fd40 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            Out(1, y);
   15456:	2300      	movs	r3, #0
   15458:	4622      	mov	r2, r4
   1545a:	2101      	movs	r1, #1
   1545c:	4628      	mov	r0, r5
   1545e:	f7f3 fd3a 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
    }
   15462:	b004      	add	sp, #16
   15464:	bd70      	pop	{r4, r5, r6, pc}
  }

  inline void set_rho2(int16_t rho) {
    // rho2_ = ((double)(rho) * (1 << 13)) + 24.0 * (1 << 24) ; // was 12
    // c2_ = (double)(rho + (6 << 3)) * (1 << 13) ; // was 13
    rho2_ = (rho * (1 << 13)) + 24.0 * (1 << 24) ; // was 12
   15466:	f007 fe27 	bl	1d0b8 <__aeabi_i2f>
   1546a:	4906      	ldr	r1, [pc, #24]	; (15484 <LowerRenz::Controller()+0x140>)
   1546c:	f007 fd70 	bl	1cf50 <__addsf3>
   15470:	f008 f878 	bl	1d564 <__aeabi_f2lz>
    c2_ = (rho + (6 << 3)) * (1 << 13) ; // was 13
   15474:	f504 24c0 	add.w	r4, r4, #393216	; 0x60000
   15478:	17e3      	asrs	r3, r4, #31
    rho2_ = (rho * (1 << 13)) + 24.0 * (1 << 24) ; // was 12
   1547a:	e9c6 0116 	strd	r0, r1, [r6, #88]	; 0x58
    c2_ = (rho + (6 << 3)) * (1 << 13) ; // was 13
   1547e:	e9c6 431c 	strd	r4, r3, [r6, #112]	; 0x70
  }
   15482:	e7a6      	b.n	153d2 <LowerRenz::Controller()+0x8e>
   15484:	4dc00000 	.word	0x4dc00000
   15488:	200046cc 	.word	0x200046cc

0001548c <Brancher::Controller()>:
        if (Clock(0)) {
   1548c:	2200      	movs	r2, #0
    void Controller() {
   1548e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (Clock(0)) {
   15490:	4611      	mov	r1, r2
    }

    /* Master Clock Forwarding is activated. This is updated with each ISR cycle by the Hemisphere Manager */
    bool MasterClockForwarded() {return master_clock_bus;}
   15492:	f890 5054 	ldrb.w	r5, [r0, #84]	; 0x54
    void Controller() {
   15496:	4604      	mov	r4, r0
        if (Clock(0)) {
   15498:	f7f4 f874 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   1549c:	b338      	cbz	r0, 154ee <Brancher::Controller()+0x62>
            int prob = p + Proportion(DetentedIn(0), HEMISPHERE_MAX_CV, 100);
   1549e:	2100      	movs	r1, #0
   154a0:	4620      	mov	r0, r4
   154a2:	f7f3 fd0f 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        int scaled = simfloat2int(proportion * max_value);
   154a6:	2664      	movs	r6, #100	; 0x64
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   154a8:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   154ac:	0380      	lsls	r0, r0, #14
   154ae:	fb90 f0f3 	sdiv	r0, r0, r3
   154b2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
        int scaled = simfloat2int(proportion * max_value);
   154b4:	4370      	muls	r0, r6
            choice = (random(1, 100) <= prob) ? 0 : 1;
   154b6:	4631      	mov	r1, r6
            int prob = p + Proportion(DetentedIn(0), HEMISPHERE_MAX_CV, 100);
   154b8:	eb03 37a0 	add.w	r7, r3, r0, asr #14
            choice = (random(1, 100) <= prob) ? 0 : 1;
   154bc:	2001      	movs	r0, #1
   154be:	f004 fd16 	bl	19eee <random(long, long)>
   154c2:	42b8      	cmp	r0, r7
   154c4:	bfd4      	ite	le
   154c6:	2100      	movle	r1, #0
   154c8:	2101      	movgt	r1, #1
   154ca:	6721      	str	r1, [r4, #112]	; 0x70
            if (master_clock) ClockOut(choice);
   154cc:	b955      	cbnz	r5, 154e4 <Brancher::Controller()+0x58>
        if (!master_clock) GateOut(choice, Gate(0));
   154ce:	2100      	movs	r1, #0
   154d0:	4620      	mov	r0, r4
   154d2:	6f25      	ldr	r5, [r4, #112]	; 0x70
   154d4:	f7fe ff70 	bl	143b8 <HemisphereApplet::Gate(int)>
   154d8:	4629      	mov	r1, r5
   154da:	4602      	mov	r2, r0
   154dc:	4620      	mov	r0, r4
   154de:	f7f4 fcf8 	bl	9ed2 <HemisphereApplet::GateOut(int, bool)>
    }
   154e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if (master_clock) ClockOut(choice);
   154e4:	4632      	mov	r2, r6
   154e6:	4620      	mov	r0, r4
   154e8:	f7f4 fa1d 	bl	9926 <HemisphereApplet::ClockOut(int, int)>
        if (!master_clock) GateOut(choice, Gate(0));
   154ec:	e7f9      	b.n	154e2 <Brancher::Controller()+0x56>
   154ee:	2d00      	cmp	r5, #0
   154f0:	d1f7      	bne.n	154e2 <Brancher::Controller()+0x56>
   154f2:	e7ec      	b.n	154ce <Brancher::Controller()+0x42>

000154f4 <ASR::Controller()>:
        registered[hemisphere] = OC::CORE::ticks;
   154f4:	7901      	ldrb	r1, [r0, #4]
   154f6:	6f03      	ldr	r3, [r0, #112]	; 0x70
    void Controller() {
   154f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   154fc:	4f3f      	ldr	r7, [pc, #252]	; (155fc <ASR::Controller()+0x108>)
   154fe:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   15502:	683a      	ldr	r2, [r7, #0]
   15504:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
        if (Clock(0)) StartADCLag();
   15508:	2200      	movs	r2, #0
   1550a:	4611      	mov	r1, r2
    void Controller() {
   1550c:	4604      	mov	r4, r0
        if (Clock(0)) StartADCLag();
   1550e:	f7f4 f839 	bl	9584 <HemisphereApplet::Clock(int, bool)>
   15512:	b108      	cbz	r0, 15518 <ASR::Controller()+0x24>
        adc_lag_countdown[ch] = HEMISPHERE_ADC_LAG;
   15514:	2321      	movs	r3, #33	; 0x21
   15516:	64e3      	str	r3, [r4, #76]	; 0x4c
        return (--adc_lag_countdown[ch] == 0);
   15518:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   1551a:	3b01      	subs	r3, #1
   1551c:	64e3      	str	r3, [r4, #76]	; 0x4c
        if (EndOfADCLag() || buffer_m->Ready(hemisphere)) {
   1551e:	2b00      	cmp	r3, #0
   15520:	d15a      	bne.n	155d8 <ASR::Controller()+0xe4>
            if (!Gate(1) && !buffer_m->IsLinked(hemisphere)) {
   15522:	2101      	movs	r1, #1
   15524:	4620      	mov	r0, r4
   15526:	f7fe ff47 	bl	143b8 <HemisphereApplet::Gate(int)>
   1552a:	b988      	cbnz	r0, 15550 <ASR::Controller()+0x5c>
   1552c:	6f25      	ldr	r5, [r4, #112]	; 0x70
   1552e:	7926      	ldrb	r6, [r4, #4]
   15530:	4628      	mov	r0, r5
   15532:	4631      	mov	r1, r6
   15534:	f7f9 f902 	bl	e73c <RingBufferManager::IsLinked(bool)>
   15538:	b950      	cbnz	r0, 15550 <ASR::Controller()+0x5c>
        if (!IsLinked(hemisphere)) {
   1553a:	4631      	mov	r1, r6
   1553c:	4628      	mov	r0, r5
        return inputs[ch];
   1553e:	f8d4 8020 	ldr.w	r8, [r4, #32]
   15542:	f7f9 f8fb 	bl	e73c <RingBufferManager::IsLinked(bool)>
   15546:	b918      	cbnz	r0, 15550 <ASR::Controller()+0x5c>
            buffer[position] = cv;
   15548:	f895 3400 	ldrb.w	r3, [r5, #1024]	; 0x400
   1554c:	f845 8023 	str.w	r8, [r5, r3, lsl #2]
            index_mod = Proportion(DetentedIn(1), HEMISPHERE_MAX_CV, 32);
   15550:	2101      	movs	r1, #1
   15552:	4620      	mov	r0, r4
   15554:	f7f3 fcb6 	bl	8ec4 <HemisphereApplet::DetentedIn(int)>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   15558:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   1555c:	0380      	lsls	r0, r0, #14
   1555e:	fb90 f0f3 	sdiv	r0, r0, r3
        int scaled = simfloat2int(proportion * max_value);
   15562:	f340 2051 	sbfx	r0, r0, #9, #18
   15566:	f8c4 01b0 	str.w	r0, [r4, #432]	; 0x1b0
            ForEachChannel(ch)
   1556a:	2500      	movs	r5, #0
                int quantized = quantizer.Process(cv, 0, 0);
   1556c:	f104 0874 	add.w	r8, r4, #116	; 0x74
                int cv = buffer_m->ReadNextValue(ch, hemisphere, index_mod);
   15570:	6f26      	ldr	r6, [r4, #112]	; 0x70
        if (IsLinked(hemisphere)) output += 2;
   15572:	7921      	ldrb	r1, [r4, #4]
   15574:	f8d4 a1b0 	ldr.w	sl, [r4, #432]	; 0x1b0
   15578:	4630      	mov	r0, r6
   1557a:	fa5f f985 	uxtb.w	r9, r5
   1557e:	f7f9 f8dd 	bl	e73c <RingBufferManager::IsLinked(bool)>
   15582:	b108      	cbz	r0, 15588 <ASR::Controller()+0x94>
   15584:	f109 0902 	add.w	r9, r9, #2
        byte ix = position - (index * output) - index_mod;
   15588:	f896 1400 	ldrb.w	r1, [r6, #1024]	; 0x400
   1558c:	f896 3401 	ldrb.w	r3, [r6, #1025]	; 0x401
   15590:	eba1 010a 	sub.w	r1, r1, sl
   15594:	fb03 1119 	mls	r1, r3, r9, r1
        int cv = buffer[ix];
   15598:	b2c9      	uxtb	r1, r1
                int quantized = quantizer.Process(cv, 0, 0);
   1559a:	2300      	movs	r3, #0
   1559c:	461a      	mov	r2, r3
   1559e:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
   155a2:	4640      	mov	r0, r8
   155a4:	f7eb fef4 	bl	1390 <braids::Quantizer::Process(long, long, long)>
                Out(ch, quantized);
   155a8:	2300      	movs	r3, #0
                int quantized = quantizer.Process(cv, 0, 0);
   155aa:	4602      	mov	r2, r0
                Out(ch, quantized);
   155ac:	4629      	mov	r1, r5
   155ae:	4620      	mov	r0, r4
   155b0:	f7f3 fc91 	bl	8ed6 <HemisphereApplet::Out(int, int, int)>
            ForEachChannel(ch)
   155b4:	b1fd      	cbz	r5, 155f6 <ASR::Controller()+0x102>
            buffer_m->Advance();
   155b6:	6f23      	ldr	r3, [r4, #112]	; 0x70
        if (OC::CORE::ticks > last_advance_tick) {
   155b8:	683a      	ldr	r2, [r7, #0]
   155ba:	f8d3 140c 	ldr.w	r1, [r3, #1036]	; 0x40c
   155be:	4291      	cmp	r1, r2
   155c0:	d217      	bcs.n	155f2 <ASR::Controller()+0xfe>
            ++position; // No need to check range; 256 positions and an 8-bit counter
   155c2:	f893 2400 	ldrb.w	r2, [r3, #1024]	; 0x400
            ready = 1;
   155c6:	f883 5402 	strb.w	r5, [r3, #1026]	; 0x402
            ++position; // No need to check range; 256 positions and an 8-bit counter
   155ca:	3201      	adds	r2, #1
   155cc:	f883 2400 	strb.w	r2, [r3, #1024]	; 0x400
            last_advance_tick = OC::CORE::ticks;
   155d0:	683a      	ldr	r2, [r7, #0]
   155d2:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
    }
   155d6:	e00c      	b.n	155f2 <ASR::Controller()+0xfe>
        if (EndOfADCLag() || buffer_m->Ready(hemisphere)) {
   155d8:	6f25      	ldr	r5, [r4, #112]	; 0x70
        if (IsLinked(hemisphere)) {
   155da:	7921      	ldrb	r1, [r4, #4]
   155dc:	4628      	mov	r0, r5
   155de:	f7f9 f8ad 	bl	e73c <RingBufferManager::IsLinked(bool)>
   155e2:	b130      	cbz	r0, 155f2 <ASR::Controller()+0xfe>
            r = ready;
   155e4:	f895 3402 	ldrb.w	r3, [r5, #1026]	; 0x402
            ready = 0;
   155e8:	2200      	movs	r2, #0
   155ea:	f885 2402 	strb.w	r2, [r5, #1026]	; 0x402
   155ee:	2b00      	cmp	r3, #0
   155f0:	d197      	bne.n	15522 <ASR::Controller()+0x2e>
    }
   155f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   155f6:	2501      	movs	r5, #1
   155f8:	e7ba      	b.n	15570 <ASR::Controller()+0x7c>
   155fa:	bf00      	nop
   155fc:	200046cc 	.word	0x200046cc

00015600 <WaveformEditor::Controller()>:
    void Controller() {
   15600:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        int mod_range_low[4] = {10, 11000, 10, 10};
   15604:	4d43      	ldr	r5, [pc, #268]	; (15714 <WaveformEditor::Controller()+0x114>)
    void Controller() {
   15606:	4604      	mov	r4, r0
   15608:	b08b      	sub	sp, #44	; 0x2c
        ListenForSysEx();
   1560a:	3080      	adds	r0, #128	; 0x80
   1560c:	f7ef fe06 	bl	521c <SystemExclusiveHandler::ListenForSysEx()>
        int mod_range_low[4] = {10, 11000, 10, 10};
   15610:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   15614:	af02      	add	r7, sp, #8
        int mod_range_high[4] = {1500, 88000, 800, 800};
   15616:	3510      	adds	r5, #16
        int mod_range_low[4] = {10, 11000, 10, 10};
   15618:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
        int mod_range_high[4] = {1500, 88000, 800, 800};
   1561c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   15620:	f10d 0818 	add.w	r8, sp, #24
   15624:	f104 09d8 	add.w	r9, r4, #216	; 0xd8
   15628:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
        for (byte ch = 0; ch < 4; ch++)
   1562c:	f104 0a28 	add.w	sl, r4, #40	; 0x28
        int mod_range_high[4] = {1500, 88000, 800, 800};
   15630:	4648      	mov	r0, r9
   15632:	2500      	movs	r5, #0
        return changed_cv[ch];
   15634:	f104 0b4c 	add.w	fp, r4, #76	; 0x4c
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   15638:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
        return inputs[ch];
   1563c:	f85a 3f04 	ldr.w	r3, [sl, #4]!
        return (In(ch) > 64 || In(ch) < -64) ? In(ch) : 0;
   15640:	f103 0140 	add.w	r1, r3, #64	; 0x40
   15644:	2980      	cmp	r1, #128	; 0x80
   15646:	d843      	bhi.n	156d0 <WaveformEditor::Controller()+0xd0>
        for (byte ch = 0; ch < 4; ch++)
   15648:	3501      	adds	r5, #1
   1564a:	2d04      	cmp	r5, #4
   1564c:	f100 0048 	add.w	r0, r0, #72	; 0x48
   15650:	d1f4      	bne.n	1563c <WaveformEditor::Controller()+0x3c>
        if (Clock(2)) test[2].Start();
   15652:	2102      	movs	r1, #2
   15654:	4620      	mov	r0, r4
   15656:	f7f0 fb5b 	bl	5d10 <HSApplication::Clock(int)>
   1565a:	b130      	cbz	r0, 1566a <WaveformEditor::Controller()+0x6a>
        Reset();
   1565c:	f504 70b4 	add.w	r0, r4, #360	; 0x168
   15660:	f7f7 ffdb 	bl	d61a <VectorOscillator::Reset()>
        eoc = 0;
   15664:	2300      	movs	r3, #0
   15666:	f884 3190 	strb.w	r3, [r4, #400]	; 0x190
        if (ch == 3) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_4>();
   1566a:	f7fe fc15 	bl	13e98 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()>
        return high;
   1566e:	f894 51f8 	ldrb.w	r5, [r4, #504]	; 0x1f8
		if (Gate(3)) {
   15672:	b1e0      	cbz	r0, 156ae <WaveformEditor::Controller()+0xae>
			if (!gated) test[3].Start();
   15674:	b92d      	cbnz	r5, 15682 <WaveformEditor::Controller()+0x82>
        Reset();
   15676:	f504 70d8 	add.w	r0, r4, #432	; 0x1b0
   1567a:	f7f7 ffce 	bl	d61a <VectorOscillator::Reset()>
        eoc = 0;
   1567e:	f884 51d8 	strb.w	r5, [r4, #472]	; 0x1d8
        if (ch == 3) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_4>();
   15682:	f7fe fc09 	bl	13e98 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()>
		gated = Gate(3);
   15686:	2500      	movs	r5, #0
   15688:	f884 01f8 	strb.w	r0, [r4, #504]	; 0x1f8
		for (byte ch = 0; ch < 4; ch++) Out(ch, test[ch].Next());
   1568c:	4648      	mov	r0, r9
   1568e:	f7f8 f802 	bl	d696 <VectorOscillator::Next()>
   15692:	4629      	mov	r1, r5
   15694:	4602      	mov	r2, r0
   15696:	2300      	movs	r3, #0
   15698:	4620      	mov	r0, r4
   1569a:	3501      	adds	r5, #1
   1569c:	f7f0 fa96 	bl	5bcc <HSApplication::Out(int, int, int)>
   156a0:	2d04      	cmp	r5, #4
   156a2:	f109 0948 	add.w	r9, r9, #72	; 0x48
   156a6:	d1f1      	bne.n	1568c <WaveformEditor::Controller()+0x8c>
    }
   156a8:	b00b      	add	sp, #44	; 0x2c
   156aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (gated) test[3].Release();
   156ae:	2d00      	cmp	r5, #0
   156b0:	d0e7      	beq.n	15682 <WaveformEditor::Controller()+0x82>
        segment_index = segment_count - 1;
   156b2:	f894 11c8 	ldrb.w	r1, [r4, #456]	; 0x1c8
        sustained = 0;
   156b6:	f884 01f5 	strb.w	r0, [r4, #501]	; 0x1f5
        segment_index = segment_count - 1;
   156ba:	3901      	subs	r1, #1
   156bc:	b2c9      	uxtb	r1, r1
   156be:	f884 11d9 	strb.w	r1, [r4, #473]	; 0x1d9
        rise = calculate_rise(segment_index);
   156c2:	f504 70d8 	add.w	r0, r4, #432	; 0x1b0
   156c6:	f7f7 ff59 	bl	d57c <VectorOscillator::calculate_rise(unsigned char)>
   156ca:	f8c4 01dc 	str.w	r0, [r4, #476]	; 0x1dc
    }
   156ce:	e7d8      	b.n	15682 <WaveformEditor::Controller()+0x82>
            if (DetentedIn(ch) && Changed(ch)) {
   156d0:	f81b 1005 	ldrb.w	r1, [fp, r5]
   156d4:	2900      	cmp	r1, #0
   156d6:	d0b7      	beq.n	15648 <WaveformEditor::Controller()+0x48>
                int freq = Proportion(In(ch), HSAPPLICATION_5V, mod_range_high[ch] - mod_range_low[ch]) + mod_range_low[ch];
   156d8:	f857 6025 	ldr.w	r6, [r7, r5, lsl #2]
   156dc:	f858 1025 	ldr.w	r1, [r8, r5, lsl #2]
   156e0:	eba1 0c06 	sub.w	ip, r1, r6
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   156e4:	039b      	lsls	r3, r3, #14
   156e6:	fb93 f3f2 	sdiv	r3, r3, r2
        int scaled = simfloat2int(proportion * max_value);
   156ea:	fb0c f303 	mul.w	r3, ip, r3
   156ee:	eb06 33a3 	add.w	r3, r6, r3, asr #14
                freq = constrain(freq, mod_range_low[ch], mod_range_high[ch]);
   156f2:	429e      	cmp	r6, r3
   156f4:	dc03      	bgt.n	156fe <WaveformEditor::Controller()+0xfe>
   156f6:	4299      	cmp	r1, r3
   156f8:	bfa8      	it	ge
   156fa:	4619      	movge	r1, r3
   156fc:	460e      	mov	r6, r1
                test[ch].SetFrequency(freq);
   156fe:	4631      	mov	r1, r6
   15700:	9001      	str	r0, [sp, #4]
   15702:	f7f7 ff81 	bl	d608 <VectorOscillator::SetFrequency(unsigned long)>
                test_freq[ch] = freq;
   15706:	9801      	ldr	r0, [sp, #4]
   15708:	f8ca 61d0 	str.w	r6, [sl, #464]	; 0x1d0
   1570c:	f44f 52f0 	mov.w	r2, #7680	; 0x1e00
   15710:	e79a      	b.n	15648 <WaveformEditor::Controller()+0x48>
   15712:	bf00      	nop
   15714:	00022f0c 	.word	0x00022f0c

00015718 <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)>:
    void SendToDAC(C *app, uint16_t reg, int transpose = 0) {
   15718:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1571c:	4698      	mov	r8, r3
        if (ty <= EnigmaOutputType::NOTE7) {
   1571e:	f890 3145 	ldrb.w	r3, [r0, #325]	; 0x145
   15722:	2b04      	cmp	r3, #4
    void SendToDAC(C *app, uint16_t reg, int transpose = 0) {
   15724:	4604      	mov	r4, r0
   15726:	460e      	mov	r6, r1
   15728:	4617      	mov	r7, r2
        if (ty <= EnigmaOutputType::NOTE7) {
   1572a:	d822      	bhi.n	15772 <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)+0x5a>
            byte bits = ty + 3; // Number of bits
   1572c:	1cd9      	adds	r1, r3, #3
   1572e:	2200      	movs	r2, #0
   15730:	b2c9      	uxtb	r1, r1
            uint8_t mask = 0;
   15732:	4615      	mov	r5, r2
            for (byte s = 0; s < bits; s++) mask |= (0x01 << s);
   15734:	f04f 0c01 	mov.w	ip, #1
   15738:	fa0c f002 	lsl.w	r0, ip, r2
   1573c:	3201      	adds	r2, #1
   1573e:	4305      	orrs	r5, r0
   15740:	b2d0      	uxtb	r0, r2
   15742:	4281      	cmp	r1, r0
   15744:	b2ed      	uxtb	r5, r5
   15746:	d8f7      	bhi.n	15738 <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)+0x20>
            int note_shift = ty == EnigmaOutputType::NOTE7 ? 0 : 64; // Note types under 7-bit start at Middle C
   15748:	3b04      	subs	r3, #4
   1574a:	bf18      	it	ne
   1574c:	2301      	movne	r3, #1
            int note_number = (reg & mask) + note_shift;
   1574e:	403d      	ands	r5, r7
   15750:	eb05 1183 	add.w	r1, r5, r3, lsl #6
            app->Out(out, quantizer.Lookup(note_number) + transpose);
   15754:	4620      	mov	r0, r4
   15756:	297f      	cmp	r1, #127	; 0x7f
   15758:	f810 9b04 	ldrb.w	r9, [r0], #4
   1575c:	bfa8      	it	ge
   1575e:	217f      	movge	r1, #127	; 0x7f
   15760:	f7eb fe90 	bl	1484 <braids::Quantizer::Lookup(long) const>
   15764:	2300      	movs	r3, #0
   15766:	eb00 0208 	add.w	r2, r0, r8
   1576a:	4649      	mov	r1, r9
   1576c:	4630      	mov	r0, r6
   1576e:	f7f0 fa2d 	bl	5bcc <HSApplication::Out(int, int, int)>
        if (ty == EnigmaOutputType::MODULATION || ty == EnigmaOutputType::EXPRESSION) {
   15772:	f894 3145 	ldrb.w	r3, [r4, #325]	; 0x145
   15776:	3b05      	subs	r3, #5
   15778:	2b01      	cmp	r3, #1
   1577a:	d807      	bhi.n	1578c <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)+0x74>
            app->Out(out, (reg & 0x00ff) * 6);
   1577c:	2106      	movs	r1, #6
   1577e:	b2fa      	uxtb	r2, r7
   15780:	434a      	muls	r2, r1
   15782:	2300      	movs	r3, #0
   15784:	7821      	ldrb	r1, [r4, #0]
   15786:	4630      	mov	r0, r6
   15788:	f7f0 fa20 	bl	5bcc <HSApplication::Out(int, int, int)>
        if (ty == EnigmaOutputType::TRIGGER && clock) {
   1578c:	f894 3145 	ldrb.w	r3, [r4, #325]	; 0x145
   15790:	2b07      	cmp	r3, #7
   15792:	d106      	bne.n	157a2 <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)+0x8a>
   15794:	07fb      	lsls	r3, r7, #31
   15796:	d512      	bpl.n	157be <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)+0xa6>
            app->ClockOut(out);
   15798:	7821      	ldrb	r1, [r4, #0]
   1579a:	2264      	movs	r2, #100	; 0x64
   1579c:	4630      	mov	r0, r6
   1579e:	f7f0 fae7 	bl	5d70 <HSApplication::ClockOut(int, int)>
        if (ty == EnigmaOutputType::GATE) {
   157a2:	f894 3145 	ldrb.w	r3, [r4, #325]	; 0x145
   157a6:	2b08      	cmp	r3, #8
   157a8:	d109      	bne.n	157be <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)+0xa6>
        Out(ch, 0, (high ? PULSE_VOLTAGE : 0));
   157aa:	f017 0f01 	tst.w	r7, #1
   157ae:	7821      	ldrb	r1, [r4, #0]
   157b0:	bf14      	ite	ne
   157b2:	2305      	movne	r3, #5
   157b4:	2300      	moveq	r3, #0
   157b6:	2200      	movs	r2, #0
   157b8:	4630      	mov	r0, r6
   157ba:	f7f0 fa07 	bl	5bcc <HSApplication::Out(int, int, int)>
    }
   157be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000157c2 <EnigmaTMWS::LibraryController()>:
    void LibraryController() {
   157c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        if (Clock(0)) {
   157c6:	2100      	movs	r1, #0
    void LibraryController() {
   157c8:	4604      	mov	r4, r0
        if (Clock(0)) {
   157ca:	f7f0 faa1 	bl	5d10 <HSApplication::Clock(int)>
   157ce:	b348      	cbz	r0, 15824 <EnigmaTMWS::LibraryController()+0x62>
   157d0:	f8b4 72e4 	ldrh.w	r7, [r4, #740]	; 0x2e4
            for (byte o = 0; o < 4; o++)
   157d4:	f604 2564 	addw	r5, r4, #2660	; 0xa64
   157d8:	f604 7884 	addw	r8, r4, #3972	; 0xf84
            int deferred_note = -1;
   157dc:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
                output[o].SendToDAC<EnigmaTMWS>(this, reg);
   157e0:	4628      	mov	r0, r5
   157e2:	2300      	movs	r3, #0
   157e4:	463a      	mov	r2, r7
   157e6:	4621      	mov	r1, r4
   157e8:	f7ff ff96 	bl	15718 <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)>
                if (deferred_note > -1) output[o].SetDeferredNote(deferred_note);
   157ec:	1c73      	adds	r3, r6, #1
    void SetDeferredNote(int midi_note_) {deferred_note = midi_note_;}
   157ee:	bf18      	it	ne
   157f0:	f8c5 6140 	strne.w	r6, [r5, #320]	; 0x140
                output[o].SendToMIDI(reg);
   157f4:	4628      	mov	r0, r5
   157f6:	2200      	movs	r2, #0
   157f8:	4639      	mov	r1, r7
   157fa:	f7f0 fe5d 	bl	64b8 <EnigmaOutput::SendToMIDI(unsigned short, int)>
    int GetDeferredNote() {return deferred_note;}
   157fe:	f8d5 3140 	ldr.w	r3, [r5, #320]	; 0x140
            for (byte o = 0; o < 4; o++)
   15802:	f505 75a4 	add.w	r5, r5, #328	; 0x148
                if (output[o].GetDeferredNote() > -1) deferred_note = output[o].GetDeferredNote();
   15806:	ea16 0623 	ands.w	r6, r6, r3, asr #32
   1580a:	bf38      	it	cc
   1580c:	461e      	movcc	r6, r3
            for (byte o = 0; o < 4; o++)
   1580e:	4545      	cmp	r5, r8
   15810:	d1e6      	bne.n	157e0 <EnigmaTMWS::LibraryController()+0x1e>
            tm_state.Advance(state_prob[tm_cursor]);
   15812:	f994 3f8c 	ldrsb.w	r3, [r4, #3980]	; 0xf8c
   15816:	4423      	add	r3, r4
   15818:	f204 20e2 	addw	r0, r4, #738	; 0x2e2
   1581c:	f893 12ea 	ldrb.w	r1, [r3, #746]	; 0x2ea
   15820:	f7f0 fb36 	bl	5e90 <TuringMachineState::Advance(unsigned char)>
    }
   15824:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00015828 <EnigmaTMWS::SongController()>:
    void SongController() {
   15828:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if (Clock(1) || Clock(2)) ResetSong();
   1582c:	2101      	movs	r1, #1
    void SongController() {
   1582e:	b087      	sub	sp, #28
   15830:	4604      	mov	r4, r0
        if (Clock(1) || Clock(2)) ResetSong();
   15832:	f7f0 fa6d 	bl	5d10 <HSApplication::Clock(int)>
   15836:	2800      	cmp	r0, #0
   15838:	f000 808a 	beq.w	15950 <EnigmaTMWS::SongController()+0x128>
   1583c:	4620      	mov	r0, r4
   1583e:	f7f1 fe55 	bl	74ec <EnigmaTMWS::ResetSong()>
        if (Clock(2)) play = 1;
   15842:	2102      	movs	r1, #2
   15844:	4620      	mov	r0, r4
   15846:	f7f0 fa63 	bl	5d10 <HSApplication::Clock(int)>
   1584a:	b110      	cbz	r0, 15852 <EnigmaTMWS::SongController()+0x2a>
   1584c:	2301      	movs	r3, #1
   1584e:	f884 33e4 	strb.w	r3, [r4, #996]	; 0x3e4
        if (Clock(3)) play = 1 - play;
   15852:	2103      	movs	r1, #3
   15854:	4620      	mov	r0, r4
   15856:	f7f0 fa5b 	bl	5d10 <HSApplication::Clock(int)>
   1585a:	b128      	cbz	r0, 15868 <EnigmaTMWS::SongController()+0x40>
   1585c:	f894 33e4 	ldrb.w	r3, [r4, #996]	; 0x3e4
   15860:	f083 0301 	eor.w	r3, r3, #1
   15864:	f884 33e4 	strb.w	r3, [r4, #996]	; 0x3e4
        if (play && Clock(0)) {
   15868:	f894 33e4 	ldrb.w	r3, [r4, #996]	; 0x3e4
   1586c:	2b00      	cmp	r3, #0
   1586e:	f000 80ea 	beq.w	15a46 <EnigmaTMWS::SongController()+0x21e>
   15872:	2100      	movs	r1, #0
   15874:	4620      	mov	r0, r4
   15876:	f7f0 fa4b 	bl	5d10 <HSApplication::Clock(int)>
   1587a:	9000      	str	r0, [sp, #0]
   1587c:	2800      	cmp	r0, #0
   1587e:	f000 80e2 	beq.w	15a46 <EnigmaTMWS::SongController()+0x21e>
            clock_counter++;
   15882:	f8d4 33e8 	ldr.w	r3, [r4, #1000]	; 0x3e8
   15886:	3301      	adds	r3, #1
   15888:	f8c4 33e8 	str.w	r3, [r4, #1000]	; 0x3e8
   1588c:	f204 4324 	addw	r3, r4, #1060	; 0x424
   15890:	f504 757d 	add.w	r5, r4, #1012	; 0x3f4
   15894:	f204 4804 	addw	r8, r4, #1028	; 0x404
   15898:	f504 797b 	add.w	r9, r4, #1004	; 0x3ec
   1589c:	2700      	movs	r7, #0
            int deferred_note = -1;
   1589e:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
   158a2:	9304      	str	r3, [sp, #16]
                if (!playback_end[t] && clock_counter % track[t].divide() == 0) {
   158a4:	7b2b      	ldrb	r3, [r5, #12]
   158a6:	2b00      	cmp	r3, #0
   158a8:	f040 80a2 	bne.w	159f0 <EnigmaTMWS::SongController()+0x1c8>
    byte divide() {return (data & 0x1f) + 1;}
   158ac:	f895 3b90 	ldrb.w	r3, [r5, #2960]	; 0xb90
   158b0:	f8d4 23e8 	ldr.w	r2, [r4, #1000]	; 0x3e8
   158b4:	f003 031f 	and.w	r3, r3, #31
   158b8:	3301      	adds	r3, #1
   158ba:	fbb2 f1f3 	udiv	r1, r2, r3
   158be:	fb03 2b11 	mls	fp, r3, r1, r2
   158c2:	f1bb 0f00 	cmp.w	fp, #0
   158c6:	f040 8093 	bne.w	159f0 <EnigmaTMWS::SongController()+0x1c8>
                    uint16_t ssi = playback_step_index[t]; // song_step index
   158ca:	f8b9 6000 	ldrh.w	r6, [r9]
                    if (ssi != ENIGMA_NO_STEP_AVAILABLE) {
   158ce:	f64f 73ff 	movw	r3, #65535	; 0xffff
   158d2:	429e      	cmp	r6, r3
   158d4:	f000 80ce 	beq.w	15a74 <EnigmaTMWS::SongController()+0x24c>
                        if (playback_step_repeat[t] == 0 && playback_step_beat[t] == 0) {
   158d8:	792b      	ldrb	r3, [r5, #4]
   158da:	b96b      	cbnz	r3, 158f8 <EnigmaTMWS::SongController()+0xd0>
   158dc:	7a2b      	ldrb	r3, [r5, #8]
   158de:	b95b      	cbnz	r3, 158f8 <EnigmaTMWS::SongController()+0xd0>
    byte tm() {return (tk & 0x3f);} // Low six bits
   158e0:	eb04 0386 	add.w	r3, r4, r6, lsl #2
                            track_tm[t].Init(song_step[ssi].tm());
   158e4:	4640      	mov	r0, r8
   158e6:	f893 1424 	ldrb.w	r1, [r3, #1060]	; 0x424
   158ea:	f001 013f 	and.w	r1, r1, #63	; 0x3f
   158ee:	f7f0 faa1 	bl	5e34 <TuringMachineState::Init(unsigned char)>
                            playback_step_number[t]++;
   158f2:	782b      	ldrb	r3, [r5, #0]
   158f4:	3301      	adds	r3, #1
   158f6:	702b      	strb	r3, [r5, #0]
                        playback_step_beat[t]++;
   158f8:	7a2b      	ldrb	r3, [r5, #8]
   158fa:	3301      	adds	r3, #1
   158fc:	b2db      	uxtb	r3, r3
   158fe:	722b      	strb	r3, [r5, #8]
                        if (playback_step_beat[t] >= track_tm[t].GetLength()) {
   15900:	f898 2004 	ldrb.w	r2, [r8, #4]
   15904:	429a      	cmp	r2, r3
   15906:	d834      	bhi.n	15972 <EnigmaTMWS::SongController()+0x14a>
                            playback_step_repeat[t]++;
   15908:	792b      	ldrb	r3, [r5, #4]
   1590a:	3301      	adds	r3, #1
   1590c:	b2db      	uxtb	r3, r3
                            playback_step_beat[t] = 0;
   1590e:	2200      	movs	r2, #0
    byte repeats() {return re;}
   15910:	eb04 0186 	add.w	r1, r4, r6, lsl #2
   15914:	722a      	strb	r2, [r5, #8]
                            playback_step_repeat[t]++;
   15916:	712b      	strb	r3, [r5, #4]
                            if (playback_step_repeat[t] >= song_step[ssi].repeats()) {
   15918:	f891 1426 	ldrb.w	r1, [r1, #1062]	; 0x426
   1591c:	4299      	cmp	r1, r3
   1591e:	d828      	bhi.n	15972 <EnigmaTMWS::SongController()+0x14a>
                                playback_step_repeat[t] = 0;
   15920:	712a      	strb	r2, [r5, #4]
                                for (uint16_t s = ssi + 1; s < total_steps; s++)
   15922:	1c73      	adds	r3, r6, #1
   15924:	b29b      	uxth	r3, r3
   15926:	f8b4 13dc 	ldrh.w	r1, [r4, #988]	; 0x3dc
   1592a:	eb04 0283 	add.w	r2, r4, r3, lsl #2
                                    if (song_step[s].track() == t) {
   1592e:	b2f8      	uxtb	r0, r7
                                for (uint16_t s = ssi + 1; s < total_steps; s++)
   15930:	4299      	cmp	r1, r3
   15932:	d815      	bhi.n	15960 <EnigmaTMWS::SongController()+0x138>
                                    if (track[t].loop()) {
   15934:	f895 3b90 	ldrb.w	r3, [r5, #2960]	; 0xb90
   15938:	069b      	lsls	r3, r3, #26
   1593a:	f140 8098 	bpl.w	15a6e <EnigmaTMWS::SongController()+0x246>
            if (song_step[s].track() == track) {
   1593e:	b2fa      	uxtb	r2, r7
   15940:	fa1f f38b 	uxth.w	r3, fp
        for (uint16_t s = 0; s < total_steps; s++)
   15944:	4299      	cmp	r1, r3
   15946:	f200 8084 	bhi.w	15a52 <EnigmaTMWS::SongController()+0x22a>
        uint16_t step = ENIGMA_NO_STEP_AVAILABLE;
   1594a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1594e:	e089      	b.n	15a64 <EnigmaTMWS::SongController()+0x23c>
        if (Clock(1) || Clock(2)) ResetSong();
   15950:	2102      	movs	r1, #2
   15952:	4620      	mov	r0, r4
   15954:	f7f0 f9dc 	bl	5d10 <HSApplication::Clock(int)>
   15958:	2800      	cmp	r0, #0
   1595a:	f47f af6f 	bne.w	1583c <EnigmaTMWS::SongController()+0x14>
   1595e:	e770      	b.n	15842 <EnigmaTMWS::SongController()+0x1a>
    byte track() {return (tk >> 6) & 0x03;} // High two bits
   15960:	f892 c424 	ldrb.w	ip, [r2, #1060]	; 0x424
                                    if (song_step[s].track() == t) {
   15964:	ebb0 1f9c 	cmp.w	r0, ip, lsr #6
   15968:	f102 0204 	add.w	r2, r2, #4
   1596c:	d16e      	bne.n	15a4c <EnigmaTMWS::SongController()+0x224>
                                        playback_step_index[t] = s;
   1596e:	f8a9 3000 	strh.w	r3, [r9]
                                if (!found) {
   15972:	f604 7384 	addw	r3, r4, #3972	; 0xf84
   15976:	9302      	str	r3, [sp, #8]
                            if (output[o].track() == t) {
   15978:	b2fb      	uxtb	r3, r7
   1597a:	9303      	str	r3, [sp, #12]
   1597c:	eb04 0386 	add.w	r3, r4, r6, lsl #2
   15980:	f604 2064 	addw	r0, r4, #2660	; 0xa64
   15984:	9301      	str	r3, [sp, #4]
   15986:	f890 3144 	ldrb.w	r3, [r0, #324]	; 0x144
   1598a:	9a03      	ldr	r2, [sp, #12]
   1598c:	4293      	cmp	r3, r2
   1598e:	d123      	bne.n	159d8 <EnigmaTMWS::SongController()+0x1b0>
    int8_t transpose() {return static_cast<int8_t>(tr - 48);}
   15990:	9b01      	ldr	r3, [sp, #4]
   15992:	f8b8 b002 	ldrh.w	fp, [r8, #2]
   15996:	f893 3427 	ldrb.w	r3, [r3, #1063]	; 0x427
                                output[o].SendToDAC<EnigmaTMWS>(this, reg, song_step[ssi].transpose() * 128);
   1599a:	9005      	str	r0, [sp, #20]
   1599c:	3b30      	subs	r3, #48	; 0x30
   1599e:	b25b      	sxtb	r3, r3
   159a0:	01db      	lsls	r3, r3, #7
   159a2:	465a      	mov	r2, fp
   159a4:	4621      	mov	r1, r4
   159a6:	f7ff feb7 	bl	15718 <void EnigmaOutput::SendToDAC<EnigmaTMWS>(EnigmaTMWS*, unsigned short, int)>
   159aa:	9b01      	ldr	r3, [sp, #4]
                                if (deferred_note > -1) output[o].SetDeferredNote(deferred_note);
   159ac:	9805      	ldr	r0, [sp, #20]
   159ae:	f893 2427 	ldrb.w	r2, [r3, #1063]	; 0x427
                                output[o].SendToMIDI(reg, song_step[ssi].transpose() * 128);
   159b2:	9005      	str	r0, [sp, #20]
   159b4:	3a30      	subs	r2, #48	; 0x30
                                if (deferred_note > -1) output[o].SetDeferredNote(deferred_note);
   159b6:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
                                output[o].SendToMIDI(reg, song_step[ssi].transpose() * 128);
   159ba:	b252      	sxtb	r2, r2
    void SetDeferredNote(int midi_note_) {deferred_note = midi_note_;}
   159bc:	bf18      	it	ne
   159be:	f8c0 a140 	strne.w	sl, [r0, #320]	; 0x140
   159c2:	01d2      	lsls	r2, r2, #7
   159c4:	4659      	mov	r1, fp
   159c6:	f7f0 fd77 	bl	64b8 <EnigmaOutput::SendToMIDI(unsigned short, int)>
    int GetDeferredNote() {return deferred_note;}
   159ca:	9805      	ldr	r0, [sp, #20]
   159cc:	f8d0 3140 	ldr.w	r3, [r0, #320]	; 0x140
                                if (output[o].GetDeferredNote() > -1) deferred_note = output[o].GetDeferredNote();
   159d0:	ea1a 0a23 	ands.w	sl, sl, r3, asr #32
   159d4:	bf38      	it	cc
   159d6:	469a      	movcc	sl, r3
                        for (byte o = 0; o < 4; o++)
   159d8:	9b02      	ldr	r3, [sp, #8]
   159da:	f500 70a4 	add.w	r0, r0, #328	; 0x148
   159de:	4298      	cmp	r0, r3
   159e0:	d1d1      	bne.n	15986 <EnigmaTMWS::SongController()+0x15e>
    byte p() {return pr;}
   159e2:	eb04 0686 	add.w	r6, r4, r6, lsl #2
                        track_tm[t].Advance(song_step[ssi].p());
   159e6:	4640      	mov	r0, r8
   159e8:	f896 1425 	ldrb.w	r1, [r6, #1061]	; 0x425
   159ec:	f7f0 fa50 	bl	5e90 <TuringMachineState::Advance(unsigned char)>
            for (byte t = 0; t < 4; t++)
   159f0:	3701      	adds	r7, #1
   159f2:	2f04      	cmp	r7, #4
   159f4:	f105 0501 	add.w	r5, r5, #1
   159f8:	f108 0808 	add.w	r8, r8, #8
   159fc:	f109 0902 	add.w	r9, r9, #2
   15a00:	f47f af50 	bne.w	158a4 <EnigmaTMWS::SongController()+0x7c>
            if (In(0) > HSAPPLICATION_3V || In(1) > HSAPPLICATION_3V) {
   15a04:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   15a06:	f5b3 5f90 	cmp.w	r3, #4608	; 0x1200
   15a0a:	f204 4104 	addw	r1, r4, #1028	; 0x404
   15a0e:	f504 6380 	add.w	r3, r4, #1024	; 0x400
   15a12:	dc03      	bgt.n	15a1c <EnigmaTMWS::SongController()+0x1f4>
   15a14:	6b22      	ldr	r2, [r4, #48]	; 0x30
   15a16:	f5b2 5f90 	cmp.w	r2, #4608	; 0x1200
   15a1a:	dd2e      	ble.n	15a7a <EnigmaTMWS::SongController()+0x252>
                                if (output[o].GetDeferredNote() > -1) deferred_note = output[o].GetDeferredNote();
   15a1c:	2200      	movs	r2, #0
                for (byte t = 0; t < 4; t++) if (!track[t].loop() && !playback_end[t]) keep_going = 1;
   15a1e:	f893 0b84 	ldrb.w	r0, [r3, #2948]	; 0xb84
   15a22:	0685      	lsls	r5, r0, #26
   15a24:	d404      	bmi.n	15a30 <EnigmaTMWS::SongController()+0x208>
   15a26:	7818      	ldrb	r0, [r3, #0]
   15a28:	9d00      	ldr	r5, [sp, #0]
   15a2a:	2800      	cmp	r0, #0
   15a2c:	bf08      	it	eq
   15a2e:	462a      	moveq	r2, r5
   15a30:	3301      	adds	r3, #1
   15a32:	4299      	cmp	r1, r3
   15a34:	d1f3      	bne.n	15a1e <EnigmaTMWS::SongController()+0x1f6>
            if (!keep_going) {
   15a36:	b932      	cbnz	r2, 15a46 <EnigmaTMWS::SongController()+0x21e>
                if (In(1) > HSAPPLICATION_3V) ResetSong();
   15a38:	6b23      	ldr	r3, [r4, #48]	; 0x30
   15a3a:	f5b3 5f90 	cmp.w	r3, #4608	; 0x1200
   15a3e:	dd2b      	ble.n	15a98 <EnigmaTMWS::SongController()+0x270>
   15a40:	4620      	mov	r0, r4
   15a42:	f7f1 fd53 	bl	74ec <EnigmaTMWS::ResetSong()>
    }
   15a46:	b007      	add	sp, #28
   15a48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                for (uint16_t s = ssi + 1; s < total_steps; s++)
   15a4c:	3301      	adds	r3, #1
   15a4e:	b29b      	uxth	r3, r3
   15a50:	e76e      	b.n	15930 <EnigmaTMWS::SongController()+0x108>
    byte track() {return (tk >> 6) & 0x03;} // High two bits
   15a52:	9804      	ldr	r0, [sp, #16]
   15a54:	f810 002b 	ldrb.w	r0, [r0, fp, lsl #2]
            if (song_step[s].track() == track) {
   15a58:	ebb2 1f90 	cmp.w	r2, r0, lsr #6
   15a5c:	f10b 0b01 	add.w	fp, fp, #1
   15a60:	f47f af6e 	bne.w	15940 <EnigmaTMWS::SongController()+0x118>
                                        playback_step_index[t] = GetFirstStep(t);
   15a64:	f8a9 3000 	strh.w	r3, [r9]
                                        playback_step_number[t] = 0;
   15a68:	2300      	movs	r3, #0
   15a6a:	702b      	strb	r3, [r5, #0]
   15a6c:	e781      	b.n	15972 <EnigmaTMWS::SongController()+0x14a>
                                        playback_end[t] = 1;
   15a6e:	2301      	movs	r3, #1
   15a70:	732b      	strb	r3, [r5, #12]
   15a72:	e77e      	b.n	15972 <EnigmaTMWS::SongController()+0x14a>
                        playback_end[t] = 1;
   15a74:	2301      	movs	r3, #1
   15a76:	732b      	strb	r3, [r5, #12]
   15a78:	e7ba      	b.n	159f0 <EnigmaTMWS::SongController()+0x1c8>
            if (In(0) > HSAPPLICATION_3V || In(1) > HSAPPLICATION_3V) {
   15a7a:	2200      	movs	r2, #0
                for (byte t = 0; t < 4; t++) if (track[t].loop() || !playback_end[t]) keep_going = 1;
   15a7c:	f893 0b84 	ldrb.w	r0, [r3, #2948]	; 0xb84
   15a80:	0680      	lsls	r0, r0, #26
   15a82:	d40d      	bmi.n	15aa0 <EnigmaTMWS::SongController()+0x278>
   15a84:	7818      	ldrb	r0, [r3, #0]
   15a86:	9d00      	ldr	r5, [sp, #0]
   15a88:	2800      	cmp	r0, #0
   15a8a:	bf08      	it	eq
   15a8c:	462a      	moveq	r2, r5
   15a8e:	3301      	adds	r3, #1
   15a90:	4299      	cmp	r1, r3
   15a92:	d1f3      	bne.n	15a7c <EnigmaTMWS::SongController()+0x254>
            if (!keep_going) {
   15a94:	2a00      	cmp	r2, #0
   15a96:	d1d6      	bne.n	15a46 <EnigmaTMWS::SongController()+0x21e>
                else play = 0;
   15a98:	2300      	movs	r3, #0
   15a9a:	f884 33e4 	strb.w	r3, [r4, #996]	; 0x3e4
    }
   15a9e:	e7d2      	b.n	15a46 <EnigmaTMWS::SongController()+0x21e>
                for (byte t = 0; t < 4; t++) if (track[t].loop() || !playback_end[t]) keep_going = 1;
   15aa0:	9a00      	ldr	r2, [sp, #0]
   15aa2:	e7f4      	b.n	15a8e <EnigmaTMWS::SongController()+0x266>

00015aa4 <EnigmaTMWS::Controller()>:
    void Controller() {
   15aa4:	b510      	push	{r4, lr}
   15aa6:	4604      	mov	r4, r0
        ListenForSysEx();
   15aa8:	3080      	adds	r0, #128	; 0x80
   15aaa:	f7ef fbb7 	bl	521c <SystemExclusiveHandler::ListenForSysEx()>
        if (help_countdown) --help_countdown;
   15aae:	f8b4 33e0 	ldrh.w	r3, [r4, #992]	; 0x3e0
   15ab2:	b113      	cbz	r3, 15aba <EnigmaTMWS::Controller()+0x16>
   15ab4:	3b01      	subs	r3, #1
   15ab6:	f8a4 33e0 	strh.w	r3, [r4, #992]	; 0x3e0
        switch(mode) {
   15aba:	f894 3f88 	ldrb.w	r3, [r4, #3976]	; 0xf88
   15abe:	b11b      	cbz	r3, 15ac8 <EnigmaTMWS::Controller()+0x24>
   15ac0:	2b01      	cmp	r3, #1
   15ac2:	d005      	beq.n	15ad0 <EnigmaTMWS::Controller()+0x2c>
            case ENIGMA_MODE_PLAY    : SongController();
   15ac4:	4620      	mov	r0, r4
   15ac6:	e008      	b.n	15ada <EnigmaTMWS::Controller()+0x36>
            case ENIGMA_MODE_LIBRARY : LibraryController();
   15ac8:	4620      	mov	r0, r4
        else LibraryController();
   15aca:	f7ff fe7a 	bl	157c2 <EnigmaTMWS::LibraryController()>
    }
   15ace:	bd10      	pop	{r4, pc}
        if (assign_audition) SongController();
   15ad0:	f894 3312 	ldrb.w	r3, [r4, #786]	; 0x312
   15ad4:	4620      	mov	r0, r4
   15ad6:	2b00      	cmp	r3, #0
   15ad8:	d0f7      	beq.n	15aca <EnigmaTMWS::Controller()+0x26>
            case ENIGMA_MODE_PLAY    : SongController();
   15ada:	f7ff fea5 	bl	15828 <EnigmaTMWS::SongController()>
    }
   15ade:	e7f6      	b.n	15ace <EnigmaTMWS::Controller()+0x2a>

00015ae0 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()>:
    const storage_type *storage = reinterpret_cast<const storage_type*>(src);
    apply_value(index, *storage++);
    return reinterpret_cast<const uint8_t *>(storage);
  }

  static size_t calc_storage_size() {
   15ae0:	b510      	push	{r4, lr}
    size_t s = 0;
    unsigned nibbles = 0;
   15ae2:	2300      	movs	r3, #0
   15ae4:	4c10      	ldr	r4, [pc, #64]	; (15b28 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0x48>)
  static size_t calc_storage_size() {
   15ae6:	2196      	movs	r1, #150	; 0x96
    size_t s = 0;
   15ae8:	4618      	mov	r0, r3
    for (auto attr : value_attr_) {
   15aea:	7d22      	ldrb	r2, [r4, #20]
      if (STORAGE_TYPE_U4 == attr.storage_type) {
   15aec:	b952      	cbnz	r2, 15b04 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0x24>
        ++nibbles;
   15aee:	3301      	adds	r3, #1
    for (auto attr : value_attr_) {
   15af0:	3901      	subs	r1, #1
   15af2:	f104 0418 	add.w	r4, r4, #24
   15af6:	d1f8      	bne.n	15aea <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0xa>
          case STORAGE_TYPE_U32: s += sizeof(uint32_t); break;
          default: break;
        }
      }
    }
    if (nibbles & 1) ++nibbles;
   15af8:	07da      	lsls	r2, r3, #31
   15afa:	bf48      	it	mi
   15afc:	3301      	addmi	r3, #1
    s += nibbles >> 1;
    return s;
  }
   15afe:	eb00 0053 	add.w	r0, r0, r3, lsr #1
   15b02:	bd10      	pop	{r4, pc}
        if (nibbles & 1) ++nibbles;
   15b04:	f013 0f01 	tst.w	r3, #1
   15b08:	bf18      	it	ne
   15b0a:	3301      	addne	r3, #1
        switch(attr.storage_type) {
   15b0c:	2a04      	cmp	r2, #4
   15b0e:	d803      	bhi.n	15b18 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0x38>
   15b10:	2a02      	cmp	r2, #2
   15b12:	d806      	bhi.n	15b22 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0x42>
          case STORAGE_TYPE_U8: s += sizeof(uint8_t); break;
   15b14:	3001      	adds	r0, #1
   15b16:	e7eb      	b.n	15af0 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0x10>
        switch(attr.storage_type) {
   15b18:	3a05      	subs	r2, #5
   15b1a:	2a01      	cmp	r2, #1
   15b1c:	d8e8      	bhi.n	15af0 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U32: s += sizeof(uint32_t); break;
   15b1e:	3004      	adds	r0, #4
   15b20:	e7e6      	b.n	15af0 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U16: s += sizeof(uint16_t); break;
   15b22:	3002      	adds	r0, #2
   15b24:	e7e4      	b.n	15af0 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()+0x10>
   15b26:	bf00      	nop
   15b28:	00024270 	.word	0x00024270

00015b2c <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const>:
  size_t Save(void *storage) const {
   15b2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   15b30:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 15be4 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0xb8>
   15b34:	4e2c      	ldr	r6, [pc, #176]	; (15be8 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0xbc>)
    nibbles_ = 0;
   15b36:	2500      	movs	r5, #0
   15b38:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    for (size_t s = 0; s < num_settings; ++s) {
   15b3c:	4604      	mov	r4, r0
   15b3e:	f500 7716 	add.w	r7, r0, #600	; 0x258
    uint8_t *write_ptr = static_cast<uint8_t *>(storage);
   15b42:	460b      	mov	r3, r1
      switch(value_attr_[s].storage_type) {
   15b44:	7d32      	ldrb	r2, [r6, #20]
    if (nibbles_) {
   15b46:	f8b0 e258 	ldrh.w	lr, [r0, #600]	; 0x258
      switch(value_attr_[s].storage_type) {
   15b4a:	2a06      	cmp	r2, #6
   15b4c:	d811      	bhi.n	15b72 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x46>
   15b4e:	e8df f002 	tbb	[pc, r2]
   15b52:	2704      	.short	0x2704
   15b54:	3d323227 	.word	0x3d323227
   15b58:	3d          	.byte	0x3d
   15b59:	00          	.byte	0x00
      nibbles_ |= (values_[index] & 0x0f);
   15b5a:	6822      	ldr	r2, [r4, #0]
    if (nibbles_) {
   15b5c:	f1be 0f00 	cmp.w	lr, #0
   15b60:	d017      	beq.n	15b92 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x66>
      nibbles_ |= (values_[index] & 0x0f);
   15b62:	f002 020f 	and.w	r2, r2, #15
   15b66:	ea4e 0202 	orr.w	r2, lr, r2
    *dest++ = (nibbles_ & 0xff);
   15b6a:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   15b6e:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    for (size_t s = 0; s < num_settings; ++s) {
   15b72:	3404      	adds	r4, #4
   15b74:	42a7      	cmp	r7, r4
   15b76:	f106 0618 	add.w	r6, r6, #24
   15b7a:	d1e3      	bne.n	15b44 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x18>
    if (nibbles_)
   15b7c:	f8b0 2258 	ldrh.w	r2, [r0, #600]	; 0x258
   15b80:	b122      	cbz	r2, 15b8c <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x60>
    *dest++ = (nibbles_ & 0xff);
   15b82:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   15b86:	2200      	movs	r2, #0
   15b88:	f8a0 2258 	strh.w	r2, [r0, #600]	; 0x258
  }
   15b8c:	1a58      	subs	r0, r3, r1
   15b8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   15b92:	0112      	lsls	r2, r2, #4
   15b94:	b2d2      	uxtb	r2, r2
   15b96:	ea42 020c 	orr.w	r2, r2, ip
   15b9a:	f8a0 2258 	strh.w	r2, [r0, #600]	; 0x258
   15b9e:	e7e8      	b.n	15b72 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x46>
    if (nibbles_)
   15ba0:	f1be 0f00 	cmp.w	lr, #0
   15ba4:	d003      	beq.n	15bae <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x82>
    *dest++ = (nibbles_ & 0xff);
   15ba6:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   15baa:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    *storage++ = values_[index];
   15bae:	6822      	ldr	r2, [r4, #0]
   15bb0:	f803 2b01 	strb.w	r2, [r3], #1
        case STORAGE_TYPE_U8: write_ptr = write_setting<uint8_t>(write_ptr, s); break;
   15bb4:	e7dd      	b.n	15b72 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x46>
    if (nibbles_)
   15bb6:	f1be 0f00 	cmp.w	lr, #0
   15bba:	d003      	beq.n	15bc4 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x98>
    *dest++ = (nibbles_ & 0xff);
   15bbc:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   15bc0:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    *storage++ = values_[index];
   15bc4:	6822      	ldr	r2, [r4, #0]
   15bc6:	f823 2b02 	strh.w	r2, [r3], #2
        case STORAGE_TYPE_U16: write_ptr = write_setting<uint16_t>(write_ptr, s); break;
   15bca:	e7d2      	b.n	15b72 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x46>
    if (nibbles_)
   15bcc:	f1be 0f00 	cmp.w	lr, #0
   15bd0:	d003      	beq.n	15bda <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0xae>
    *dest++ = (nibbles_ & 0xff);
   15bd2:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   15bd6:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    *storage++ = values_[index];
   15bda:	6822      	ldr	r2, [r4, #0]
   15bdc:	f843 2b04 	str.w	r2, [r3], #4
        case STORAGE_TYPE_U32: write_ptr = write_setting<uint32_t>(write_ptr, s); break;
   15be0:	e7c7      	b.n	15b72 <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const+0x46>
   15be2:	bf00      	nop
   15be4:	fffff000 	.word	0xfffff000
   15be8:	00024270 	.word	0x00024270

00015bec <EnigmaTMWS_save(void*)>:
size_t EnigmaTMWS_save(void *storage) {
   15bec:	b508      	push	{r3, lr}
   15bee:	4601      	mov	r1, r0
    return EnigmaTMWS_instance.Save(storage);
   15bf0:	4801      	ldr	r0, [pc, #4]	; (15bf8 <EnigmaTMWS_save(void*)+0xc>)
   15bf2:	f7ff ff9b 	bl	15b2c <settings::SettingsBase<EnigmaTMWS, 150u>::Save(void*) const>
}
   15bf6:	bd08      	pop	{r3, pc}
   15bf8:	1fffda34 	.word	0x1fffda34

00015bfc <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)>:
  size_t Restore(const void *storage) {
   15bfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15bfe:	460e      	mov	r6, r1
   15c00:	4f1f      	ldr	r7, [pc, #124]	; (15c80 <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x84>)
    nibbles_ = 0;
   15c02:	2100      	movs	r1, #0
   15c04:	f8a0 1258 	strh.w	r1, [r0, #600]	; 0x258
    const uint8_t *read_ptr = static_cast<const uint8_t *>(storage);
   15c08:	4634      	mov	r4, r6
    nibbles_ = 0;
   15c0a:	460d      	mov	r5, r1
      switch(value_attr_[s].storage_type) {
   15c0c:	7d3b      	ldrb	r3, [r7, #20]
   15c0e:	2b06      	cmp	r3, #6
   15c10:	d80f      	bhi.n	15c32 <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x36>
   15c12:	e8df f003 	tbb	[pc, r3]
   15c16:	1b04      	.short	0x1b04
   15c18:	2f2a2520 	.word	0x2f2a2520
   15c1c:	2f          	.byte	0x2f
   15c1d:	00          	.byte	0x00
    if (nibbles_) {
   15c1e:	f8b0 2258 	ldrh.w	r2, [r0, #600]	; 0x258
   15c22:	b16a      	cbz	r2, 15c40 <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x44>
      value = nibbles_ & 0x0f;
   15c24:	f002 020f 	and.w	r2, r2, #15
      nibbles_ = 0;
   15c28:	2300      	movs	r3, #0
   15c2a:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
    apply_value(index, *storage++);
   15c2e:	f7ef f8bb 	bl	4da8 <settings::SettingsBase<EnigmaTMWS, 150u>::apply_value(unsigned int, int) [clone .isra.0]>
    for (size_t s = 0; s < num_settings; ++s) {
   15c32:	3101      	adds	r1, #1
   15c34:	2996      	cmp	r1, #150	; 0x96
   15c36:	f107 0718 	add.w	r7, r7, #24
   15c3a:	d1e7      	bne.n	15c0c <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x10>
  }
   15c3c:	1ba0      	subs	r0, r4, r6
   15c3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      value = *src++;
   15c40:	f814 2b01 	ldrb.w	r2, [r4], #1
      nibbles_ = kNibbleValid | value;
   15c44:	f442 4370 	orr.w	r3, r2, #61440	; 0xf000
      value >>= 4;
   15c48:	0912      	lsrs	r2, r2, #4
   15c4a:	e7ee      	b.n	15c2a <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x2e>
    nibbles_ = 0;
   15c4c:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    apply_value(index, *storage++);
   15c50:	f914 2b01 	ldrsb.w	r2, [r4], #1
   15c54:	e7eb      	b.n	15c2e <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x32>
    nibbles_ = 0;
   15c56:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    apply_value(index, *storage++);
   15c5a:	f814 2b01 	ldrb.w	r2, [r4], #1
   15c5e:	e7e6      	b.n	15c2e <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x32>
    nibbles_ = 0;
   15c60:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    apply_value(index, *storage++);
   15c64:	f934 2b02 	ldrsh.w	r2, [r4], #2
   15c68:	e7e1      	b.n	15c2e <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x32>
    nibbles_ = 0;
   15c6a:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
    apply_value(index, *storage++);
   15c6e:	f834 2b02 	ldrh.w	r2, [r4], #2
   15c72:	e7dc      	b.n	15c2e <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x32>
   15c74:	f854 2b04 	ldr.w	r2, [r4], #4
    nibbles_ = 0;
   15c78:	f8a0 5258 	strh.w	r5, [r0, #600]	; 0x258
   15c7c:	e7d7      	b.n	15c2e <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)+0x32>
   15c7e:	bf00      	nop
   15c80:	00024270 	.word	0x00024270

00015c84 <EnigmaTMWS_restore(void const*)>:
size_t EnigmaTMWS_restore(const void *storage) {
   15c84:	b508      	push	{r3, lr}
   15c86:	4601      	mov	r1, r0
    return EnigmaTMWS_instance.Restore(storage);
   15c88:	4801      	ldr	r0, [pc, #4]	; (15c90 <EnigmaTMWS_restore(void const*)+0xc>)
   15c8a:	f7ff ffb7 	bl	15bfc <settings::SettingsBase<EnigmaTMWS, 150u>::Restore(void const*)>
}
   15c8e:	bd08      	pop	{r3, pc}
   15c90:	1fffda34 	.word	0x1fffda34

00015c94 <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()>:
  static size_t calc_storage_size() {
   15c94:	b510      	push	{r4, lr}
    unsigned nibbles = 0;
   15c96:	2300      	movs	r3, #0
   15c98:	4c10      	ldr	r4, [pc, #64]	; (15cdc <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0x48>)
  static size_t calc_storage_size() {
   15c9a:	2106      	movs	r1, #6
    size_t s = 0;
   15c9c:	4618      	mov	r0, r3
    for (auto attr : value_attr_) {
   15c9e:	7d22      	ldrb	r2, [r4, #20]
      if (STORAGE_TYPE_U4 == attr.storage_type) {
   15ca0:	b952      	cbnz	r2, 15cb8 <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0x24>
        ++nibbles;
   15ca2:	3301      	adds	r3, #1
    for (auto attr : value_attr_) {
   15ca4:	3901      	subs	r1, #1
   15ca6:	f104 0418 	add.w	r4, r4, #24
   15caa:	d1f8      	bne.n	15c9e <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0xa>
    if (nibbles & 1) ++nibbles;
   15cac:	07da      	lsls	r2, r3, #31
   15cae:	bf48      	it	mi
   15cb0:	3301      	addmi	r3, #1
  }
   15cb2:	eb00 0053 	add.w	r0, r0, r3, lsr #1
   15cb6:	bd10      	pop	{r4, pc}
        if (nibbles & 1) ++nibbles;
   15cb8:	f013 0f01 	tst.w	r3, #1
   15cbc:	bf18      	it	ne
   15cbe:	3301      	addne	r3, #1
        switch(attr.storage_type) {
   15cc0:	2a04      	cmp	r2, #4
   15cc2:	d803      	bhi.n	15ccc <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0x38>
   15cc4:	2a02      	cmp	r2, #2
   15cc6:	d806      	bhi.n	15cd6 <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0x42>
          case STORAGE_TYPE_U8: s += sizeof(uint8_t); break;
   15cc8:	3001      	adds	r0, #1
   15cca:	e7eb      	b.n	15ca4 <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0x10>
        switch(attr.storage_type) {
   15ccc:	3a05      	subs	r2, #5
   15cce:	2a01      	cmp	r2, #1
   15cd0:	d8e8      	bhi.n	15ca4 <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U32: s += sizeof(uint32_t); break;
   15cd2:	3004      	adds	r0, #4
   15cd4:	e7e6      	b.n	15ca4 <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U16: s += sizeof(uint16_t); break;
   15cd6:	3002      	adds	r0, #2
   15cd8:	e7e4      	b.n	15ca4 <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()+0x10>
   15cda:	bf00      	nop
   15cdc:	000273d8 	.word	0x000273d8

00015ce0 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const>:
  size_t Save(void *storage) const {
   15ce0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   15ce4:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 15d88 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0xa8>
   15ce8:	4e28      	ldr	r6, [pc, #160]	; (15d8c <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0xac>)
    nibbles_ = 0;
   15cea:	2500      	movs	r5, #0
   15cec:	8305      	strh	r5, [r0, #24]
    for (size_t s = 0; s < num_settings; ++s) {
   15cee:	4604      	mov	r4, r0
   15cf0:	f100 0718 	add.w	r7, r0, #24
    uint8_t *write_ptr = static_cast<uint8_t *>(storage);
   15cf4:	460b      	mov	r3, r1
      switch(value_attr_[s].storage_type) {
   15cf6:	7d32      	ldrb	r2, [r6, #20]
    if (nibbles_) {
   15cf8:	f8b0 e018 	ldrh.w	lr, [r0, #24]
      switch(value_attr_[s].storage_type) {
   15cfc:	2a06      	cmp	r2, #6
   15cfe:	d810      	bhi.n	15d22 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x42>
   15d00:	e8df f002 	tbb	[pc, r2]
   15d04:	2d232304 	.word	0x2d232304
   15d08:	372d      	.short	0x372d
   15d0a:	37          	.byte	0x37
   15d0b:	00          	.byte	0x00
      nibbles_ |= (values_[index] & 0x0f);
   15d0c:	6822      	ldr	r2, [r4, #0]
    if (nibbles_) {
   15d0e:	f1be 0f00 	cmp.w	lr, #0
   15d12:	d014      	beq.n	15d3e <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x5e>
      nibbles_ |= (values_[index] & 0x0f);
   15d14:	f002 020f 	and.w	r2, r2, #15
   15d18:	ea4e 0202 	orr.w	r2, lr, r2
    *dest++ = (nibbles_ & 0xff);
   15d1c:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   15d20:	8305      	strh	r5, [r0, #24]
    for (size_t s = 0; s < num_settings; ++s) {
   15d22:	3404      	adds	r4, #4
   15d24:	42a7      	cmp	r7, r4
   15d26:	f106 0618 	add.w	r6, r6, #24
   15d2a:	d1e4      	bne.n	15cf6 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x16>
    if (nibbles_)
   15d2c:	8b02      	ldrh	r2, [r0, #24]
   15d2e:	b11a      	cbz	r2, 15d38 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x58>
    *dest++ = (nibbles_ & 0xff);
   15d30:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   15d34:	2200      	movs	r2, #0
   15d36:	8302      	strh	r2, [r0, #24]
  }
   15d38:	1a58      	subs	r0, r3, r1
   15d3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   15d3e:	0112      	lsls	r2, r2, #4
   15d40:	b2d2      	uxtb	r2, r2
   15d42:	ea42 020c 	orr.w	r2, r2, ip
   15d46:	8302      	strh	r2, [r0, #24]
   15d48:	e7eb      	b.n	15d22 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x42>
    if (nibbles_)
   15d4a:	f1be 0f00 	cmp.w	lr, #0
   15d4e:	d002      	beq.n	15d56 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x76>
    *dest++ = (nibbles_ & 0xff);
   15d50:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   15d54:	8305      	strh	r5, [r0, #24]
    *storage++ = values_[index];
   15d56:	6822      	ldr	r2, [r4, #0]
   15d58:	f803 2b01 	strb.w	r2, [r3], #1
        case STORAGE_TYPE_U8: write_ptr = write_setting<uint8_t>(write_ptr, s); break;
   15d5c:	e7e1      	b.n	15d22 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x42>
    if (nibbles_)
   15d5e:	f1be 0f00 	cmp.w	lr, #0
   15d62:	d002      	beq.n	15d6a <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x8a>
    *dest++ = (nibbles_ & 0xff);
   15d64:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   15d68:	8305      	strh	r5, [r0, #24]
    *storage++ = values_[index];
   15d6a:	6822      	ldr	r2, [r4, #0]
   15d6c:	f823 2b02 	strh.w	r2, [r3], #2
        case STORAGE_TYPE_U16: write_ptr = write_setting<uint16_t>(write_ptr, s); break;
   15d70:	e7d7      	b.n	15d22 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x42>
    if (nibbles_)
   15d72:	f1be 0f00 	cmp.w	lr, #0
   15d76:	d002      	beq.n	15d7e <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x9e>
    *dest++ = (nibbles_ & 0xff);
   15d78:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   15d7c:	8305      	strh	r5, [r0, #24]
    *storage++ = values_[index];
   15d7e:	6822      	ldr	r2, [r4, #0]
   15d80:	f843 2b04 	str.w	r2, [r3], #4
        case STORAGE_TYPE_U32: write_ptr = write_setting<uint32_t>(write_ptr, s); break;
   15d84:	e7cd      	b.n	15d22 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const+0x42>
   15d86:	bf00      	nop
   15d88:	fffff000 	.word	0xfffff000
   15d8c:	000273d8 	.word	0x000273d8

00015d90 <HEMISPHERE_save(void*)>:
size_t HEMISPHERE_save(void *storage) {
   15d90:	b538      	push	{r3, r4, r5, lr}
    manager.RequestAppletData();
   15d92:	4d05      	ldr	r5, [pc, #20]	; (15da8 <HEMISPHERE_save(void*)+0x18>)
size_t HEMISPHERE_save(void *storage) {
   15d94:	4604      	mov	r4, r0
    manager.RequestAppletData();
   15d96:	4628      	mov	r0, r5
   15d98:	f7f4 fb6c 	bl	a474 <HemisphereManager::RequestAppletData()>
    return manager.Save(storage);
   15d9c:	4621      	mov	r1, r4
   15d9e:	f105 0008 	add.w	r0, r5, #8
   15da2:	f7ff ff9d 	bl	15ce0 <settings::SettingsBase<HemisphereManager, 6u>::Save(void*) const>
}
   15da6:	bd38      	pop	{r3, r4, r5, pc}
   15da8:	200051b8 	.word	0x200051b8

00015dac <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)>:
  size_t Restore(const void *storage) {
   15dac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15dae:	460e      	mov	r6, r1
   15db0:	4f1b      	ldr	r7, [pc, #108]	; (15e20 <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x74>)
    nibbles_ = 0;
   15db2:	2100      	movs	r1, #0
   15db4:	8301      	strh	r1, [r0, #24]
    const uint8_t *read_ptr = static_cast<const uint8_t *>(storage);
   15db6:	4634      	mov	r4, r6
    nibbles_ = 0;
   15db8:	460d      	mov	r5, r1
      switch(value_attr_[s].storage_type) {
   15dba:	7d3b      	ldrb	r3, [r7, #20]
   15dbc:	2b06      	cmp	r3, #6
   15dbe:	d80d      	bhi.n	15ddc <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x30>
   15dc0:	e8df f003 	tbb	[pc, r3]
   15dc4:	211d1904 	.word	0x211d1904
   15dc8:	2925      	.short	0x2925
   15dca:	29          	.byte	0x29
   15dcb:	00          	.byte	0x00
    if (nibbles_) {
   15dcc:	8b02      	ldrh	r2, [r0, #24]
   15dce:	b162      	cbz	r2, 15dea <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x3e>
      value = nibbles_ & 0x0f;
   15dd0:	f002 020f 	and.w	r2, r2, #15
      nibbles_ = 0;
   15dd4:	2300      	movs	r3, #0
   15dd6:	8303      	strh	r3, [r0, #24]
    apply_value(index, *storage++);
   15dd8:	f7ee ffce 	bl	4d78 <settings::SettingsBase<HemisphereManager, 6u>::apply_value(unsigned int, int) [clone .isra.0]>
    for (size_t s = 0; s < num_settings; ++s) {
   15ddc:	3101      	adds	r1, #1
   15dde:	2906      	cmp	r1, #6
   15de0:	f107 0718 	add.w	r7, r7, #24
   15de4:	d1e9      	bne.n	15dba <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0xe>
  }
   15de6:	1ba0      	subs	r0, r4, r6
   15de8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      value = *src++;
   15dea:	f814 2b01 	ldrb.w	r2, [r4], #1
      nibbles_ = kNibbleValid | value;
   15dee:	f442 4370 	orr.w	r3, r2, #61440	; 0xf000
      value >>= 4;
   15df2:	0912      	lsrs	r2, r2, #4
   15df4:	e7ef      	b.n	15dd6 <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x2a>
    nibbles_ = 0;
   15df6:	8305      	strh	r5, [r0, #24]
    apply_value(index, *storage++);
   15df8:	f914 2b01 	ldrsb.w	r2, [r4], #1
   15dfc:	e7ec      	b.n	15dd8 <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x2c>
    nibbles_ = 0;
   15dfe:	8305      	strh	r5, [r0, #24]
    apply_value(index, *storage++);
   15e00:	f814 2b01 	ldrb.w	r2, [r4], #1
   15e04:	e7e8      	b.n	15dd8 <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x2c>
    nibbles_ = 0;
   15e06:	8305      	strh	r5, [r0, #24]
    apply_value(index, *storage++);
   15e08:	f934 2b02 	ldrsh.w	r2, [r4], #2
   15e0c:	e7e4      	b.n	15dd8 <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x2c>
    nibbles_ = 0;
   15e0e:	8305      	strh	r5, [r0, #24]
    apply_value(index, *storage++);
   15e10:	f834 2b02 	ldrh.w	r2, [r4], #2
   15e14:	e7e0      	b.n	15dd8 <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x2c>
   15e16:	f854 2b04 	ldr.w	r2, [r4], #4
    nibbles_ = 0;
   15e1a:	8305      	strh	r5, [r0, #24]
   15e1c:	e7dc      	b.n	15dd8 <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)+0x2c>
   15e1e:	bf00      	nop
   15e20:	000273d8 	.word	0x000273d8

00015e24 <HEMISPHERE_restore(void const*)>:
size_t HEMISPHERE_restore(const void *storage) {
   15e24:	b538      	push	{r3, r4, r5, lr}
    size_t s = manager.Restore(storage);
   15e26:	4d06      	ldr	r5, [pc, #24]	; (15e40 <HEMISPHERE_restore(void const*)+0x1c>)
size_t HEMISPHERE_restore(const void *storage) {
   15e28:	4601      	mov	r1, r0
    size_t s = manager.Restore(storage);
   15e2a:	f105 0008 	add.w	r0, r5, #8
   15e2e:	f7ff ffbd 	bl	15dac <settings::SettingsBase<HemisphereManager, 6u>::Restore(void const*)>
   15e32:	4604      	mov	r4, r0
    manager.Resume();
   15e34:	4628      	mov	r0, r5
   15e36:	f7f4 fb93 	bl	a560 <HemisphereManager::Resume()>
}
   15e3a:	4620      	mov	r0, r4
   15e3c:	bd38      	pop	{r3, r4, r5, pc}
   15e3e:	bf00      	nop
   15e40:	200051b8 	.word	0x200051b8

00015e44 <OC::menu::ScreenCursor<4, true>::Scroll(int)>:
    int pos = cursor_pos_ + amount;
   15e44:	68c2      	ldr	r2, [r0, #12]
  void Scroll(int amount) {
   15e46:	b510      	push	{r4, lr}
    CONSTRAIN(pos, start_, end_);
   15e48:	6844      	ldr	r4, [r0, #4]
    int pos = cursor_pos_ + amount;
   15e4a:	440a      	add	r2, r1
    CONSTRAIN(pos, start_, end_);
   15e4c:	4294      	cmp	r4, r2
   15e4e:	dc10      	bgt.n	15e72 <OC::menu::ScreenCursor<4, true>::Scroll(int)+0x2e>
   15e50:	6883      	ldr	r3, [r0, #8]
   15e52:	429a      	cmp	r2, r3
   15e54:	bfa8      	it	ge
   15e56:	461a      	movge	r2, r3
    int screen_line = screen_line_ + amount;
   15e58:	6903      	ldr	r3, [r0, #16]
    cursor_pos_ = pos;
   15e5a:	60c2      	str	r2, [r0, #12]
      if (amount < 0) {
   15e5c:	2900      	cmp	r1, #0
    int screen_line = screen_line_ + amount;
   15e5e:	440b      	add	r3, r1
      if (amount < 0) {
   15e60:	da09      	bge.n	15e76 <OC::menu::ScreenCursor<4, true>::Scroll(int)+0x32>
        if (screen_line < 2) {
   15e62:	2b01      	cmp	r3, #1
   15e64:	dc03      	bgt.n	15e6e <OC::menu::ScreenCursor<4, true>::Scroll(int)+0x2a>
          if (pos >= start_ + 1)
   15e66:	4294      	cmp	r4, r2
   15e68:	bfac      	ite	ge
   15e6a:	2300      	movge	r3, #0
   15e6c:	2301      	movlt	r3, #1
    screen_line_ = screen_line;
   15e6e:	6103      	str	r3, [r0, #16]
  }
   15e70:	bd10      	pop	{r4, pc}
   15e72:	4622      	mov	r2, r4
   15e74:	e7f0      	b.n	15e58 <OC::menu::ScreenCursor<4, true>::Scroll(int)+0x14>
        if (screen_line >= screen_lines - 2) {
   15e76:	2b01      	cmp	r3, #1
   15e78:	ddf9      	ble.n	15e6e <OC::menu::ScreenCursor<4, true>::Scroll(int)+0x2a>
          if (pos <= end_ - 1)
   15e7a:	6883      	ldr	r3, [r0, #8]
            screen_line = screen_lines - 1;
   15e7c:	4293      	cmp	r3, r2
   15e7e:	bfcc      	ite	gt
   15e80:	2302      	movgt	r3, #2
   15e82:	2303      	movle	r3, #3
   15e84:	e7f3      	b.n	15e6e <OC::menu::ScreenCursor<4, true>::Scroll(int)+0x2a>

00015e86 <CaptainMIDI::SelectSetup(int, int)>:
    void SelectSetup(int setup_number, int new_screen = -1) {
   15e86:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        return values_[MIDI_CURRENT_SETUP];
   15e88:	f8d0 5308 	ldr.w	r5, [r0, #776]	; 0x308
        if (new_screen == -1) new_screen = screen;
   15e8c:	1c53      	adds	r3, r2, #1
    void SelectSetup(int setup_number, int new_screen = -1) {
   15e8e:	4616      	mov	r6, r2
        if (new_screen == -1) new_screen = screen;
   15e90:	bf08      	it	eq
   15e92:	f8d0 6324 	ldreq.w	r6, [r0, #804]	; 0x324
        if (setup_number != get_setup_number()) Reset();
   15e96:	42a9      	cmp	r1, r5
    void SelectSetup(int setup_number, int new_screen = -1) {
   15e98:	4604      	mov	r4, r0
   15e9a:	460f      	mov	r7, r1
        if (setup_number != get_setup_number()) Reset();
   15e9c:	d001      	beq.n	15ea2 <CaptainMIDI::SelectSetup(int, int)+0x1c>
   15e9e:	f7f4 fcef 	bl	a880 <CaptainMIDI::Reset()>
        int prev_cursor = cursor.cursor_pos() - ((screen * 8) + (get_setup_number() * MIDI_PARAMETER_COUNT));
   15ea2:	f8d4 3324 	ldr.w	r3, [r4, #804]	; 0x324
   15ea6:	f8d4 131c 	ldr.w	r1, [r4, #796]	; 0x31c
   15eaa:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   15eae:	441d      	add	r5, r3
        int start = (new_screen * 8) + (setup_number * MIDI_PARAMETER_COUNT);
   15eb0:	eb07 0387 	add.w	r3, r7, r7, lsl #2
   15eb4:	4433      	add	r3, r6
   15eb6:	00db      	lsls	r3, r3, #3
    editing_ = false;
   15eb8:	2200      	movs	r2, #0
        int end = (new_screen * 8) + (setup_number * MIDI_PARAMETER_COUNT) + 7;
   15eba:	1dd8      	adds	r0, r3, #7
    end_ = end;
   15ebc:	f8c4 0318 	str.w	r0, [r4, #792]	; 0x318
    editing_ = false;
   15ec0:	f884 2310 	strb.w	r2, [r4, #784]	; 0x310
    start_ = start;
   15ec4:	f8c4 3314 	str.w	r3, [r4, #788]	; 0x314
    cursor_pos_ = start;
   15ec8:	f8c4 331c 	str.w	r3, [r4, #796]	; 0x31c
    screen_line_ = 0;
   15ecc:	f8c4 2320 	str.w	r2, [r4, #800]	; 0x320
        cursor.Scroll(prev_cursor);
   15ed0:	eba1 01c5 	sub.w	r1, r1, r5, lsl #3
   15ed4:	f504 7044 	add.w	r0, r4, #784	; 0x310
   15ed8:	f7ff ffb4 	bl	15e44 <OC::menu::ScreenCursor<4, true>::Scroll(int)>
        values_[MIDI_CURRENT_SETUP] = setup_number;
   15edc:	f8c4 7308 	str.w	r7, [r4, #776]	; 0x308
        screen = new_screen;
   15ee0:	f8c4 6324 	str.w	r6, [r4, #804]	; 0x324
    }
   15ee4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00015ee6 <CaptainMIDI::Resume()>:
    void Resume() {
   15ee6:	b508      	push	{r3, lr}
        SelectSetup(get_setup_number(), 0);
   15ee8:	f8d0 1308 	ldr.w	r1, [r0, #776]	; 0x308
   15eec:	2200      	movs	r2, #0
   15eee:	f7ff ffca 	bl	15e86 <CaptainMIDI::SelectSetup(int, int)>
    }
   15ef2:	bd08      	pop	{r3, pc}

00015ef4 <non-virtual thunk to CaptainMIDI::Resume()>:
    void Resume() {
   15ef4:	f1a0 0008 	sub.w	r0, r0, #8
   15ef8:	e7f5      	b.n	15ee6 <CaptainMIDI::Resume()>

00015efa <CaptainMIDI::ToggleCursor()>:
   void ToggleCursor() {
   15efa:	b538      	push	{r3, r4, r5, lr}
       if (copy_mode) CopySetup(copy_setup_target, copy_setup_source);
   15efc:	f890 3329 	ldrb.w	r3, [r0, #809]	; 0x329
   void ToggleCursor() {
   15f00:	4604      	mov	r4, r0
       if (copy_mode) CopySetup(copy_setup_target, copy_setup_source);
   15f02:	b36b      	cbz	r3, 15f60 <CaptainMIDI::ToggleCursor()+0x66>
   15f04:	f8d0 1330 	ldr.w	r1, [r0, #816]	; 0x330
   15f08:	f8d0 232c 	ldr.w	r2, [r0, #812]	; 0x32c
       if (source == target) {
   15f0c:	4291      	cmp	r1, r2
   15f0e:	d106      	bne.n	15f1e <CaptainMIDI::ToggleCursor()+0x24>
           OnSendSysEx();
   15f10:	6803      	ldr	r3, [r0, #0]
   15f12:	681b      	ldr	r3, [r3, #0]
           Resume();
   15f14:	4798      	blx	r3
       copy_mode = 0;
   15f16:	2300      	movs	r3, #0
   15f18:	f884 3329 	strb.w	r3, [r4, #809]	; 0x329
   }
   15f1c:	bd38      	pop	{r3, r4, r5, pc}
           int source_offset = MIDI_PARAMETER_COUNT * source;
   15f1e:	2328      	movs	r3, #40	; 0x28
   15f20:	fb03 f002 	mul.w	r0, r3, r2
           int target_offset = MIDI_PARAMETER_COUNT * target;
   15f24:	434b      	muls	r3, r1
   15f26:	f100 4280 	add.w	r2, r0, #1073741824	; 0x40000000
   15f2a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   15f2e:	3221      	adds	r2, #33	; 0x21
   15f30:	3321      	adds	r3, #33	; 0x21
   15f32:	f504 7592 	add.w	r5, r4, #292	; 0x124
   15f36:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   15f3a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   15f3e:	eb05 0080 	add.w	r0, r5, r0, lsl #2
               values_[target_offset + c] = values_[source_offset + c];
   15f42:	f852 5f04 	ldr.w	r5, [r2, #4]!
   15f46:	f843 5f04 	str.w	r5, [r3, #4]!
           for (int c = 0; c < MIDI_PARAMETER_COUNT; c++)
   15f4a:	4282      	cmp	r2, r0
   15f4c:	d1f9      	bne.n	15f42 <CaptainMIDI::ToggleCursor()+0x48>
           SelectSetup(target);
   15f4e:	4620      	mov	r0, r4
   15f50:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15f54:	f7ff ff97 	bl	15e86 <CaptainMIDI::SelectSetup(int, int)>
           Resume();
   15f58:	6823      	ldr	r3, [r4, #0]
   15f5a:	4620      	mov	r0, r4
   15f5c:	68db      	ldr	r3, [r3, #12]
   15f5e:	e7d9      	b.n	15f14 <CaptainMIDI::ToggleCursor()+0x1a>
    editing_ = !editing_;
   15f60:	f890 3310 	ldrb.w	r3, [r0, #784]	; 0x310
   15f64:	f083 0301 	eor.w	r3, r3, #1
   15f68:	f880 3310 	strb.w	r3, [r0, #784]	; 0x310
   }
   15f6c:	e7d6      	b.n	15f1c <CaptainMIDI::ToggleCursor()+0x22>

00015f6e <CaptainMIDI::SwitchSetup(int)>:
        if (copy_mode) {
   15f6e:	f890 2329 	ldrb.w	r2, [r0, #809]	; 0x329
    void SwitchSetup(int dir) {
   15f72:	b508      	push	{r3, lr}
        if (copy_mode) {
   15f74:	b13a      	cbz	r2, 15f86 <CaptainMIDI::SwitchSetup(int)+0x18>
            copy_setup_target = constrain(copy_setup_target + dir, 0, 3);
   15f76:	f8d0 2330 	ldr.w	r2, [r0, #816]	; 0x330
   15f7a:	440a      	add	r2, r1
   15f7c:	f382 0202 	usat	r2, #2, r2
   15f80:	f8c0 2330 	str.w	r2, [r0, #816]	; 0x330
    }
   15f84:	bd08      	pop	{r3, pc}
            int new_setup = constrain(get_setup_number() + dir, 0, 3);
   15f86:	f8d0 3308 	ldr.w	r3, [r0, #776]	; 0x308
   15f8a:	4419      	add	r1, r3
            SelectSetup(new_setup);
   15f8c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15f90:	f381 0102 	usat	r1, #2, r1
   15f94:	f7ff ff77 	bl	15e86 <CaptainMIDI::SelectSetup(int, int)>
    }
   15f98:	e7f4      	b.n	15f84 <CaptainMIDI::SwitchSetup(int)+0x16>
   15f9a:	Address 0x0000000000015f9a is out of bounds.


00015f9c <MIDI_handleButtonEvent(UI::Event const&)>:

void MIDI_screensaver() {}

void MIDI_handleButtonEvent(const UI::Event &event) {
   15f9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (event.control == OC::CONTROL_BUTTON_R && event.type == UI::EVENT_BUTTON_PRESS)
   15f9e:	8843      	ldrh	r3, [r0, #2]
   15fa0:	2b08      	cmp	r3, #8
void MIDI_handleButtonEvent(const UI::Event &event) {
   15fa2:	4604      	mov	r4, r0
    if (event.control == OC::CONTROL_BUTTON_R && event.type == UI::EVENT_BUTTON_PRESS)
   15fa4:	d105      	bne.n	15fb2 <MIDI_handleButtonEvent(UI::Event const&)+0x16>
   15fa6:	7803      	ldrb	r3, [r0, #0]
   15fa8:	2b01      	cmp	r3, #1
   15faa:	d11e      	bne.n	15fea <MIDI_handleButtonEvent(UI::Event const&)+0x4e>
        captain_midi_instance.ToggleCursor();
   15fac:	4828      	ldr	r0, [pc, #160]	; (16050 <MIDI_handleButtonEvent(UI::Event const&)+0xb4>)
   15fae:	f7ff ffa4 	bl	15efa <CaptainMIDI::ToggleCursor()>
    if (event.control == OC::CONTROL_BUTTON_L) {
   15fb2:	8863      	ldrh	r3, [r4, #2]
   15fb4:	2b04      	cmp	r3, #4
   15fb6:	d118      	bne.n	15fea <MIDI_handleButtonEvent(UI::Event const&)+0x4e>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) captain_midi_instance.Panic();
   15fb8:	7823      	ldrb	r3, [r4, #0]
   15fba:	2b02      	cmp	r3, #2
   15fbc:	d11c      	bne.n	15ff8 <MIDI_handleButtonEvent(UI::Event const&)+0x5c>
        Reset();
   15fbe:	4824      	ldr	r0, [pc, #144]	; (16050 <MIDI_handleButtonEvent(UI::Event const&)+0xb4>)
   15fc0:	f7f4 fc5e 	bl	a880 <CaptainMIDI::Reset()>
   15fc4:	2600      	movs	r6, #0
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   15fc6:	f248 0708 	movw	r7, #32776	; 0x8008
void MIDI_handleButtonEvent(const UI::Event &event) {
   15fca:	2500      	movs	r5, #0
   15fcc:	ea46 0005 	orr.w	r0, r6, r5
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   15fd0:	4338      	orrs	r0, r7
            for (int channel = 1; channel <= 16; channel++)
   15fd2:	f505 7580 	add.w	r5, r5, #256	; 0x100
   15fd6:	f004 fee9 	bl	1adac <usb_midi_write_packed>
   15fda:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   15fde:	d1f5      	bne.n	15fcc <MIDI_handleButtonEvent(UI::Event const&)+0x30>
        for (int note = 0; note < 128; note++)
   15fe0:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
   15fe4:	f5b6 0f00 	cmp.w	r6, #8388608	; 0x800000
   15fe8:	d1ef      	bne.n	15fca <MIDI_handleButtonEvent(UI::Event const&)+0x2e>
        else captain_midi_instance.ToggleDisplay();
    }

    if (event.control == OC::CONTROL_BUTTON_UP) captain_midi_instance.SwitchSetup(1);
   15fea:	8861      	ldrh	r1, [r4, #2]
   15fec:	2901      	cmp	r1, #1
   15fee:	d112      	bne.n	16016 <MIDI_handleButtonEvent(UI::Event const&)+0x7a>
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
        if (event.type == UI::EVENT_BUTTON_PRESS) captain_midi_instance.SwitchSetup(-1);
   15ff0:	4817      	ldr	r0, [pc, #92]	; (16050 <MIDI_handleButtonEvent(UI::Event const&)+0xb4>)
   15ff2:	f7ff ffbc 	bl	15f6e <CaptainMIDI::SwitchSetup(int)>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) captain_midi_instance.ToggleCopyMode();
    }
}
   15ff6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (copy_mode) copy_mode = 0;
   15ff8:	4b15      	ldr	r3, [pc, #84]	; (16050 <MIDI_handleButtonEvent(UI::Event const&)+0xb4>)
   15ffa:	f893 2329 	ldrb.w	r2, [r3, #809]	; 0x329
   15ffe:	b11a      	cbz	r2, 16008 <MIDI_handleButtonEvent(UI::Event const&)+0x6c>
   16000:	2200      	movs	r2, #0
   16002:	f883 2329 	strb.w	r2, [r3, #809]	; 0x329
   16006:	e7f0      	b.n	15fea <MIDI_handleButtonEvent(UI::Event const&)+0x4e>
        else display = 1 - display;
   16008:	f893 2328 	ldrb.w	r2, [r3, #808]	; 0x328
   1600c:	f082 0201 	eor.w	r2, r2, #1
   16010:	f883 2328 	strb.w	r2, [r3, #808]	; 0x328
   16014:	e7e9      	b.n	15fea <MIDI_handleButtonEvent(UI::Event const&)+0x4e>
    if (event.control == OC::CONTROL_BUTTON_DOWN) {
   16016:	2902      	cmp	r1, #2
   16018:	d1ed      	bne.n	15ff6 <MIDI_handleButtonEvent(UI::Event const&)+0x5a>
        if (event.type == UI::EVENT_BUTTON_PRESS) captain_midi_instance.SwitchSetup(-1);
   1601a:	7823      	ldrb	r3, [r4, #0]
   1601c:	2b01      	cmp	r3, #1
   1601e:	d102      	bne.n	16026 <MIDI_handleButtonEvent(UI::Event const&)+0x8a>
   16020:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   16024:	e7e4      	b.n	15ff0 <MIDI_handleButtonEvent(UI::Event const&)+0x54>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) captain_midi_instance.ToggleCopyMode();
   16026:	2b02      	cmp	r3, #2
   16028:	d1e5      	bne.n	15ff6 <MIDI_handleButtonEvent(UI::Event const&)+0x5a>
       copy_mode = 1 - copy_mode;
   1602a:	4b09      	ldr	r3, [pc, #36]	; (16050 <MIDI_handleButtonEvent(UI::Event const&)+0xb4>)
   1602c:	f893 2329 	ldrb.w	r2, [r3, #809]	; 0x329
   16030:	f082 0201 	eor.w	r2, r2, #1
   16034:	f883 2329 	strb.w	r2, [r3, #809]	; 0x329
        return values_[MIDI_CURRENT_SETUP];
   16038:	f8d3 2308 	ldr.w	r2, [r3, #776]	; 0x308
       copy_setup_source = get_setup_number();
   1603c:	f8c3 232c 	str.w	r2, [r3, #812]	; 0x32c
       copy_setup_target = copy_setup_source + 1;
   16040:	3201      	adds	r2, #1
       if (copy_setup_target > 3) copy_setup_target = 0;
   16042:	2a03      	cmp	r2, #3
   16044:	bfc8      	it	gt
   16046:	2200      	movgt	r2, #0
   16048:	f8c3 2330 	str.w	r2, [r3, #816]	; 0x330
}
   1604c:	e7d3      	b.n	15ff6 <MIDI_handleButtonEvent(UI::Event const&)+0x5a>
   1604e:	bf00      	nop
   16050:	200046ec 	.word	0x200046ec

00016054 <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)>:
    if (index < num_settings) {
   16054:	29a0      	cmp	r1, #160	; 0xa0
  bool apply_value(size_t index, int value) {
   16056:	b510      	push	{r4, lr}
    if (index < num_settings) {
   16058:	d812      	bhi.n	16080 <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)+0x2c>
    if (value < min_) return min_;
   1605a:	4c0a      	ldr	r4, [pc, #40]	; (16084 <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)+0x30>)
   1605c:	2318      	movs	r3, #24
   1605e:	fb03 4401 	mla	r4, r3, r1, r4
   16062:	6863      	ldr	r3, [r4, #4]
   16064:	429a      	cmp	r2, r3
   16066:	db03      	blt.n	16070 <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)+0x1c>
    else if (value > max_) return max_;
   16068:	68a3      	ldr	r3, [r4, #8]
   1606a:	4293      	cmp	r3, r2
   1606c:	bfa8      	it	ge
   1606e:	4613      	movge	r3, r2
      if (values_[index] != clamped) {
   16070:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
   16074:	429a      	cmp	r2, r3
   16076:	d003      	beq.n	16080 <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)+0x2c>
        values_[index] = clamped;
   16078:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
        return true;
   1607c:	2001      	movs	r0, #1
  }
   1607e:	bd10      	pop	{r4, pc}
    return false;
   16080:	2000      	movs	r0, #0
   16082:	e7fc      	b.n	1607e <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)+0x2a>
   16084:	00025080 	.word	0x00025080

00016088 <CaptainMIDI::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
   16088:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1608c:	b08e      	sub	sp, #56	; 0x38
        if (ExtractSysExData(V, 'M')) {
   1608e:	224d      	movs	r2, #77	; 0x4d
   16090:	a904      	add	r1, sp, #16
    void OnReceiveSysEx() {
   16092:	4604      	mov	r4, r0
        if (ExtractSysExData(V, 'M')) {
   16094:	f7ef fb34 	bl	5700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>
   16098:	4602      	mov	r2, r0
   1609a:	b340      	cbz	r0, 160ee <CaptainMIDI::OnReceiveSysEx()+0x66>
            uint8_t offset = MIDI_PARAMETER_COUNT * get_setup_number();
   1609c:	f8d4 3308 	ldr.w	r3, [r4, #776]	; 0x308
   160a0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   160a4:	00dd      	lsls	r5, r3, #3
   160a6:	b2ed      	uxtb	r5, r5
            for (int i = 0; i < MIDI_PARAMETER_COUNT; i++)
   160a8:	af04      	add	r7, sp, #16
   160aa:	2600      	movs	r6, #0
                apply_value(i + offset, p);
   160ac:	f104 0888 	add.w	r8, r4, #136	; 0x88
                if (i > 15 && i < 24) p -= 24; // Restore the sign removed in OnSendSysEx()
   160b0:	f1a6 0310 	sub.w	r3, r6, #16
                int p = (int)V[i];
   160b4:	f817 2b01 	ldrb.w	r2, [r7], #1
                if (i > 15 && i < 24) p -= 24; // Restore the sign removed in OnSendSysEx()
   160b8:	2b07      	cmp	r3, #7
   160ba:	bf98      	it	ls
   160bc:	3a18      	subls	r2, #24
                apply_value(i + offset, p);
   160be:	19a9      	adds	r1, r5, r6
   160c0:	4640      	mov	r0, r8
            for (int i = 0; i < MIDI_PARAMETER_COUNT; i++)
   160c2:	3601      	adds	r6, #1
                apply_value(i + offset, p);
   160c4:	f7ff ffc6 	bl	16054 <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)>
            for (int i = 0; i < MIDI_PARAMETER_COUNT; i++)
   160c8:	2e28      	cmp	r6, #40	; 0x28
   160ca:	d1f1      	bne.n	160b0 <CaptainMIDI::OnReceiveSysEx()+0x28>
            UpdateLog(1, 0, 5, 0, 'M', 0);
   160cc:	2200      	movs	r2, #0
   160ce:	9202      	str	r2, [sp, #8]
   160d0:	234d      	movs	r3, #77	; 0x4d
            UpdateLog(1, 0, 5, 0, app_code, 0);
   160d2:	e9cd 2300 	strd	r2, r3, [sp]
   160d6:	4620      	mov	r0, r4
   160d8:	2305      	movs	r3, #5
   160da:	2101      	movs	r1, #1
   160dc:	f7f4 fe8c 	bl	adf8 <CaptainMIDI::UpdateLog(bool, int, unsigned char, unsigned char, short, short)>
        Resume();
   160e0:	6823      	ldr	r3, [r4, #0]
   160e2:	68db      	ldr	r3, [r3, #12]
   160e4:	4620      	mov	r0, r4
    }
   160e6:	b00e      	add	sp, #56	; 0x38
   160e8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        Resume();
   160ec:	4718      	bx	r3
            UpdateLog(1, 0, 5, 0, app_code, 0);
   160ee:	7923      	ldrb	r3, [r4, #4]
   160f0:	9002      	str	r0, [sp, #8]
   160f2:	e7ee      	b.n	160d2 <CaptainMIDI::OnReceiveSysEx()+0x4a>

000160f4 <MIDI_handleEncoderEvent(UI::Event const&)>:

void MIDI_handleEncoderEvent(const UI::Event &event) {
   160f4:	b538      	push	{r3, r4, r5, lr}
    if (event.control == OC::CONTROL_ENCODER_R) {
   160f6:	8843      	ldrh	r3, [r0, #2]
   160f8:	2b40      	cmp	r3, #64	; 0x40
   160fa:	d135      	bne.n	16168 <MIDI_handleEncoderEvent(UI::Event const&)+0x74>
    return editing_;
   160fc:	4d2d      	ldr	r5, [pc, #180]	; (161b4 <MIDI_handleEncoderEvent(UI::Event const&)+0xc0>)
        if (captain_midi_instance.cursor.editing()) {
            captain_midi_instance.change_value(captain_midi_instance.cursor.cursor_pos(), event.value);
   160fe:	f9b0 1004 	ldrsh.w	r1, [r0, #4]
        if (captain_midi_instance.cursor.editing()) {
   16102:	f895 3310 	ldrb.w	r3, [r5, #784]	; 0x310
   16106:	b353      	cbz	r3, 1615e <MIDI_handleEncoderEvent(UI::Event const&)+0x6a>
    return cursor_pos_;
   16108:	f8d5 431c 	ldr.w	r4, [r5, #796]	; 0x31c
    return apply_value(index, values_[index] + delta);
   1610c:	eb05 0384 	add.w	r3, r5, r4, lsl #2
   16110:	f105 0088 	add.w	r0, r5, #136	; 0x88
   16114:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   16118:	440a      	add	r2, r1
   1611a:	4621      	mov	r1, r4
   1611c:	f7ff ff9a 	bl	16054 <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)>
       int page = ix / 8; // Page within a Setup
   16120:	2c00      	cmp	r4, #0
   16122:	4623      	mov	r3, r4
   16124:	bfb8      	it	lt
   16126:	1de3      	addlt	r3, r4, #7
   16128:	10db      	asrs	r3, r3, #3
       if (page == 4 && values_[ix] < values_[ix - 8]) values_[ix] = values_[ix - 8];
   1612a:	2b04      	cmp	r3, #4
   1612c:	d10b      	bne.n	16146 <MIDI_handleEncoderEvent(UI::Event const&)+0x52>
   1612e:	f104 031a 	add.w	r3, r4, #26
   16132:	3422      	adds	r4, #34	; 0x22
   16134:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   16138:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   1613c:	429a      	cmp	r2, r3
   1613e:	da0d      	bge.n	1615c <MIDI_handleEncoderEvent(UI::Event const&)+0x68>
       if (page == 3 && values_[ix] > values_[ix + 8]) values_[ix] = values_[ix + 8];
   16140:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
   16144:	e00a      	b.n	1615c <MIDI_handleEncoderEvent(UI::Event const&)+0x68>
   16146:	2b03      	cmp	r3, #3
   16148:	d108      	bne.n	1615c <MIDI_handleEncoderEvent(UI::Event const&)+0x68>
   1614a:	f104 032a 	add.w	r3, r4, #42	; 0x2a
   1614e:	3422      	adds	r4, #34	; 0x22
   16150:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   16154:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   16158:	429a      	cmp	r2, r3
   1615a:	dcf1      	bgt.n	16140 <MIDI_handleEncoderEvent(UI::Event const&)+0x4c>
        }
    }
    if (event.control == OC::CONTROL_ENCODER_L) {
        captain_midi_instance.SwitchScreenOrLogView(event.value);
    }
}
   1615c:	bd38      	pop	{r3, r4, r5, pc}
            captain_midi_instance.cursor.Scroll(event.value);
   1615e:	f505 7044 	add.w	r0, r5, #784	; 0x310
   16162:	f7ff fe6f 	bl	15e44 <OC::menu::ScreenCursor<4, true>::Scroll(int)>
   16166:	e7f9      	b.n	1615c <MIDI_handleEncoderEvent(UI::Event const&)+0x68>
    if (event.control == OC::CONTROL_ENCODER_L) {
   16168:	2b20      	cmp	r3, #32
   1616a:	d1f7      	bne.n	1615c <MIDI_handleEncoderEvent(UI::Event const&)+0x68>
        captain_midi_instance.SwitchScreenOrLogView(event.value);
   1616c:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
        if (display == 0) {
   16170:	4810      	ldr	r0, [pc, #64]	; (161b4 <MIDI_handleEncoderEvent(UI::Event const&)+0xc0>)
   16172:	f890 3328 	ldrb.w	r3, [r0, #808]	; 0x328
   16176:	b963      	cbnz	r3, 16192 <MIDI_handleEncoderEvent(UI::Event const&)+0x9e>
            int new_screen = constrain(screen + dir, 0, 4);
   16178:	f8d0 3324 	ldr.w	r3, [r0, #804]	; 0x324
            SelectSetup(get_setup_number(), new_screen);
   1617c:	f8d0 1308 	ldr.w	r1, [r0, #776]	; 0x308
            int new_screen = constrain(screen + dir, 0, 4);
   16180:	441a      	add	r2, r3
            SelectSetup(get_setup_number(), new_screen);
   16182:	2a04      	cmp	r2, #4
   16184:	bfa8      	it	ge
   16186:	2204      	movge	r2, #4
   16188:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   1618c:	f7ff fe7b 	bl	15e86 <CaptainMIDI::SelectSetup(int, int)>
    }
   16190:	e7e4      	b.n	1615c <MIDI_handleEncoderEvent(UI::Event const&)+0x68>
            if (log_index > 6) log_view = constrain(log_view + dir, 0, log_index - 6);
   16192:	f8d0 365c 	ldr.w	r3, [r0, #1628]	; 0x65c
   16196:	2b06      	cmp	r3, #6
   16198:	dde0      	ble.n	1615c <MIDI_handleEncoderEvent(UI::Event const&)+0x68>
   1619a:	f8d0 1660 	ldr.w	r1, [r0, #1632]	; 0x660
   1619e:	1852      	adds	r2, r2, r1
   161a0:	d406      	bmi.n	161b0 <MIDI_handleEncoderEvent(UI::Event const&)+0xbc>
   161a2:	3b06      	subs	r3, #6
   161a4:	4293      	cmp	r3, r2
   161a6:	bfa8      	it	ge
   161a8:	4613      	movge	r3, r2
   161aa:	f8c0 3660 	str.w	r3, [r0, #1632]	; 0x660
}
   161ae:	e7d5      	b.n	1615c <MIDI_handleEncoderEvent(UI::Event const&)+0x68>
            if (log_index > 6) log_view = constrain(log_view + dir, 0, log_index - 6);
   161b0:	2300      	movs	r3, #0
   161b2:	e7fa      	b.n	161aa <MIDI_handleEncoderEvent(UI::Event const&)+0xb6>
   161b4:	200046ec 	.word	0x200046ec

000161b8 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()>:
  static size_t calc_storage_size() {
   161b8:	b510      	push	{r4, lr}
    unsigned nibbles = 0;
   161ba:	2300      	movs	r3, #0
   161bc:	4c10      	ldr	r4, [pc, #64]	; (16200 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0x48>)
  static size_t calc_storage_size() {
   161be:	21a1      	movs	r1, #161	; 0xa1
    size_t s = 0;
   161c0:	4618      	mov	r0, r3
    for (auto attr : value_attr_) {
   161c2:	7d22      	ldrb	r2, [r4, #20]
      if (STORAGE_TYPE_U4 == attr.storage_type) {
   161c4:	b952      	cbnz	r2, 161dc <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0x24>
        ++nibbles;
   161c6:	3301      	adds	r3, #1
    for (auto attr : value_attr_) {
   161c8:	3901      	subs	r1, #1
   161ca:	f104 0418 	add.w	r4, r4, #24
   161ce:	d1f8      	bne.n	161c2 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0xa>
    if (nibbles & 1) ++nibbles;
   161d0:	07da      	lsls	r2, r3, #31
   161d2:	bf48      	it	mi
   161d4:	3301      	addmi	r3, #1
  }
   161d6:	eb00 0053 	add.w	r0, r0, r3, lsr #1
   161da:	bd10      	pop	{r4, pc}
        if (nibbles & 1) ++nibbles;
   161dc:	f013 0f01 	tst.w	r3, #1
   161e0:	bf18      	it	ne
   161e2:	3301      	addne	r3, #1
        switch(attr.storage_type) {
   161e4:	2a04      	cmp	r2, #4
   161e6:	d803      	bhi.n	161f0 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0x38>
   161e8:	2a02      	cmp	r2, #2
   161ea:	d806      	bhi.n	161fa <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0x42>
          case STORAGE_TYPE_U8: s += sizeof(uint8_t); break;
   161ec:	3001      	adds	r0, #1
   161ee:	e7eb      	b.n	161c8 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0x10>
        switch(attr.storage_type) {
   161f0:	3a05      	subs	r2, #5
   161f2:	2a01      	cmp	r2, #1
   161f4:	d8e8      	bhi.n	161c8 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U32: s += sizeof(uint32_t); break;
   161f6:	3004      	adds	r0, #4
   161f8:	e7e6      	b.n	161c8 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U16: s += sizeof(uint16_t); break;
   161fa:	3002      	adds	r0, #2
   161fc:	e7e4      	b.n	161c8 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()+0x10>
   161fe:	bf00      	nop
   16200:	00025080 	.word	0x00025080

00016204 <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const>:
  size_t Save(void *storage) const {
   16204:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   16208:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 162bc <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0xb8>
   1620c:	4e2c      	ldr	r6, [pc, #176]	; (162c0 <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0xbc>)
    nibbles_ = 0;
   1620e:	2500      	movs	r5, #0
   16210:	f8a0 5284 	strh.w	r5, [r0, #644]	; 0x284
    for (size_t s = 0; s < num_settings; ++s) {
   16214:	4604      	mov	r4, r0
   16216:	f500 7721 	add.w	r7, r0, #644	; 0x284
    uint8_t *write_ptr = static_cast<uint8_t *>(storage);
   1621a:	460b      	mov	r3, r1
      switch(value_attr_[s].storage_type) {
   1621c:	7d32      	ldrb	r2, [r6, #20]
    if (nibbles_) {
   1621e:	f8b0 e284 	ldrh.w	lr, [r0, #644]	; 0x284
      switch(value_attr_[s].storage_type) {
   16222:	2a06      	cmp	r2, #6
   16224:	d811      	bhi.n	1624a <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x46>
   16226:	e8df f002 	tbb	[pc, r2]
   1622a:	2704      	.short	0x2704
   1622c:	3d323227 	.word	0x3d323227
   16230:	3d          	.byte	0x3d
   16231:	00          	.byte	0x00
      nibbles_ |= (values_[index] & 0x0f);
   16232:	6822      	ldr	r2, [r4, #0]
    if (nibbles_) {
   16234:	f1be 0f00 	cmp.w	lr, #0
   16238:	d017      	beq.n	1626a <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x66>
      nibbles_ |= (values_[index] & 0x0f);
   1623a:	f002 020f 	and.w	r2, r2, #15
   1623e:	ea4e 0202 	orr.w	r2, lr, r2
    *dest++ = (nibbles_ & 0xff);
   16242:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   16246:	f8a0 5284 	strh.w	r5, [r0, #644]	; 0x284
    for (size_t s = 0; s < num_settings; ++s) {
   1624a:	3404      	adds	r4, #4
   1624c:	42a7      	cmp	r7, r4
   1624e:	f106 0618 	add.w	r6, r6, #24
   16252:	d1e3      	bne.n	1621c <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x18>
    if (nibbles_)
   16254:	f8b0 2284 	ldrh.w	r2, [r0, #644]	; 0x284
   16258:	b122      	cbz	r2, 16264 <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x60>
    *dest++ = (nibbles_ & 0xff);
   1625a:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   1625e:	2200      	movs	r2, #0
   16260:	f8a0 2284 	strh.w	r2, [r0, #644]	; 0x284
  }
   16264:	1a58      	subs	r0, r3, r1
   16266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   1626a:	0112      	lsls	r2, r2, #4
   1626c:	b2d2      	uxtb	r2, r2
   1626e:	ea42 020c 	orr.w	r2, r2, ip
   16272:	f8a0 2284 	strh.w	r2, [r0, #644]	; 0x284
   16276:	e7e8      	b.n	1624a <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x46>
    if (nibbles_)
   16278:	f1be 0f00 	cmp.w	lr, #0
   1627c:	d003      	beq.n	16286 <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x82>
    *dest++ = (nibbles_ & 0xff);
   1627e:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   16282:	f8a0 5284 	strh.w	r5, [r0, #644]	; 0x284
    *storage++ = values_[index];
   16286:	6822      	ldr	r2, [r4, #0]
   16288:	f803 2b01 	strb.w	r2, [r3], #1
        case STORAGE_TYPE_U8: write_ptr = write_setting<uint8_t>(write_ptr, s); break;
   1628c:	e7dd      	b.n	1624a <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x46>
    if (nibbles_)
   1628e:	f1be 0f00 	cmp.w	lr, #0
   16292:	d003      	beq.n	1629c <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x98>
    *dest++ = (nibbles_ & 0xff);
   16294:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   16298:	f8a0 5284 	strh.w	r5, [r0, #644]	; 0x284
    *storage++ = values_[index];
   1629c:	6822      	ldr	r2, [r4, #0]
   1629e:	f823 2b02 	strh.w	r2, [r3], #2
        case STORAGE_TYPE_U16: write_ptr = write_setting<uint16_t>(write_ptr, s); break;
   162a2:	e7d2      	b.n	1624a <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x46>
    if (nibbles_)
   162a4:	f1be 0f00 	cmp.w	lr, #0
   162a8:	d003      	beq.n	162b2 <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0xae>
    *dest++ = (nibbles_ & 0xff);
   162aa:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   162ae:	f8a0 5284 	strh.w	r5, [r0, #644]	; 0x284
    *storage++ = values_[index];
   162b2:	6822      	ldr	r2, [r4, #0]
   162b4:	f843 2b04 	str.w	r2, [r3], #4
        case STORAGE_TYPE_U32: write_ptr = write_setting<uint32_t>(write_ptr, s); break;
   162b8:	e7c7      	b.n	1624a <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const+0x46>
   162ba:	bf00      	nop
   162bc:	fffff000 	.word	0xfffff000
   162c0:	00025080 	.word	0x00025080

000162c4 <MIDI_save(void*)>:
size_t MIDI_save(void *storage) {
   162c4:	b508      	push	{r3, lr}
   162c6:	4601      	mov	r1, r0
    return captain_midi_instance.Save(storage);
   162c8:	4801      	ldr	r0, [pc, #4]	; (162d0 <MIDI_save(void*)+0xc>)
   162ca:	f7ff ff9b 	bl	16204 <settings::SettingsBase<CaptainMIDI, 161u>::Save(void*) const>
}
   162ce:	bd08      	pop	{r3, pc}
   162d0:	20004774 	.word	0x20004774

000162d4 <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)>:
  size_t Restore(const void *storage) {
   162d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    nibbles_ = 0;
   162d8:	f04f 0900 	mov.w	r9, #0
   162dc:	4f22      	ldr	r7, [pc, #136]	; (16368 <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x94>)
   162de:	f8a0 9284 	strh.w	r9, [r0, #644]	; 0x284
  size_t Restore(const void *storage) {
   162e2:	4680      	mov	r8, r0
   162e4:	460e      	mov	r6, r1
    const uint8_t *read_ptr = static_cast<const uint8_t *>(storage);
   162e6:	460c      	mov	r4, r1
    nibbles_ = 0;
   162e8:	464d      	mov	r5, r9
      switch(value_attr_[s].storage_type) {
   162ea:	7d3b      	ldrb	r3, [r7, #20]
   162ec:	2b06      	cmp	r3, #6
   162ee:	d811      	bhi.n	16314 <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x40>
   162f0:	e8df f003 	tbb	[pc, r3]
   162f4:	2a252004 	.word	0x2a252004
   162f8:	342f      	.short	0x342f
   162fa:	34          	.byte	0x34
   162fb:	00          	.byte	0x00
    if (nibbles_) {
   162fc:	f8b8 2284 	ldrh.w	r2, [r8, #644]	; 0x284
   16300:	b192      	cbz	r2, 16328 <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x54>
      value = nibbles_ & 0x0f;
   16302:	f002 020f 	and.w	r2, r2, #15
      nibbles_ = 0;
   16306:	2300      	movs	r3, #0
   16308:	f8a8 3284 	strh.w	r3, [r8, #644]	; 0x284
    apply_value(index, *storage++);
   1630c:	4649      	mov	r1, r9
   1630e:	4640      	mov	r0, r8
   16310:	f7ff fea0 	bl	16054 <settings::SettingsBase<CaptainMIDI, 161u>::apply_value(unsigned int, int)>
    for (size_t s = 0; s < num_settings; ++s) {
   16314:	f109 0901 	add.w	r9, r9, #1
   16318:	f1b9 0fa1 	cmp.w	r9, #161	; 0xa1
   1631c:	f107 0718 	add.w	r7, r7, #24
   16320:	d1e3      	bne.n	162ea <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x16>
  }
   16322:	1ba0      	subs	r0, r4, r6
   16324:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      value = *src++;
   16328:	f814 2b01 	ldrb.w	r2, [r4], #1
      nibbles_ = kNibbleValid | value;
   1632c:	f442 4370 	orr.w	r3, r2, #61440	; 0xf000
      value >>= 4;
   16330:	0912      	lsrs	r2, r2, #4
   16332:	e7e9      	b.n	16308 <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x34>
    nibbles_ = 0;
   16334:	f8a8 5284 	strh.w	r5, [r8, #644]	; 0x284
    apply_value(index, *storage++);
   16338:	f914 2b01 	ldrsb.w	r2, [r4], #1
   1633c:	e7e6      	b.n	1630c <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x38>
    nibbles_ = 0;
   1633e:	f8a8 5284 	strh.w	r5, [r8, #644]	; 0x284
    apply_value(index, *storage++);
   16342:	f814 2b01 	ldrb.w	r2, [r4], #1
   16346:	e7e1      	b.n	1630c <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x38>
    nibbles_ = 0;
   16348:	f8a8 5284 	strh.w	r5, [r8, #644]	; 0x284
    apply_value(index, *storage++);
   1634c:	f934 2b02 	ldrsh.w	r2, [r4], #2
   16350:	e7dc      	b.n	1630c <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x38>
    nibbles_ = 0;
   16352:	f8a8 5284 	strh.w	r5, [r8, #644]	; 0x284
    apply_value(index, *storage++);
   16356:	f834 2b02 	ldrh.w	r2, [r4], #2
   1635a:	e7d7      	b.n	1630c <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x38>
   1635c:	f854 2b04 	ldr.w	r2, [r4], #4
    nibbles_ = 0;
   16360:	f8a8 5284 	strh.w	r5, [r8, #644]	; 0x284
   16364:	e7d2      	b.n	1630c <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)+0x38>
   16366:	bf00      	nop
   16368:	00025080 	.word	0x00025080

0001636c <MIDI_restore(void const*)>:
size_t MIDI_restore(const void *storage) {
   1636c:	b538      	push	{r3, r4, r5, lr}
    size_t s = captain_midi_instance.Restore(storage);
   1636e:	4d06      	ldr	r5, [pc, #24]	; (16388 <MIDI_restore(void const*)+0x1c>)
size_t MIDI_restore(const void *storage) {
   16370:	4601      	mov	r1, r0
    size_t s = captain_midi_instance.Restore(storage);
   16372:	f105 0088 	add.w	r0, r5, #136	; 0x88
   16376:	f7ff ffad 	bl	162d4 <settings::SettingsBase<CaptainMIDI, 161u>::Restore(void const*)>
   1637a:	4604      	mov	r4, r0
    captain_midi_instance.Resume();
   1637c:	4628      	mov	r0, r5
   1637e:	f7ff fdb2 	bl	15ee6 <CaptainMIDI::Resume()>
}
   16382:	4620      	mov	r0, r4
   16384:	bd38      	pop	{r3, r4, r5, pc}
   16386:	bf00      	nop
   16388:	200046ec 	.word	0x200046ec

0001638c <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()>:
  static size_t calc_storage_size() {
   1638c:	b510      	push	{r4, lr}
    unsigned nibbles = 0;
   1638e:	2300      	movs	r3, #0
   16390:	4c10      	ldr	r4, [pc, #64]	; (163d4 <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0x48>)
  static size_t calc_storage_size() {
   16392:	21d8      	movs	r1, #216	; 0xd8
    size_t s = 0;
   16394:	4618      	mov	r0, r3
    for (auto attr : value_attr_) {
   16396:	7d22      	ldrb	r2, [r4, #20]
      if (STORAGE_TYPE_U4 == attr.storage_type) {
   16398:	b952      	cbnz	r2, 163b0 <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0x24>
        ++nibbles;
   1639a:	3301      	adds	r3, #1
    for (auto attr : value_attr_) {
   1639c:	3901      	subs	r1, #1
   1639e:	f104 0418 	add.w	r4, r4, #24
   163a2:	d1f8      	bne.n	16396 <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0xa>
    if (nibbles & 1) ++nibbles;
   163a4:	07da      	lsls	r2, r3, #31
   163a6:	bf48      	it	mi
   163a8:	3301      	addmi	r3, #1
  }
   163aa:	eb00 0053 	add.w	r0, r0, r3, lsr #1
   163ae:	bd10      	pop	{r4, pc}
        if (nibbles & 1) ++nibbles;
   163b0:	f013 0f01 	tst.w	r3, #1
   163b4:	bf18      	it	ne
   163b6:	3301      	addne	r3, #1
        switch(attr.storage_type) {
   163b8:	2a04      	cmp	r2, #4
   163ba:	d803      	bhi.n	163c4 <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0x38>
   163bc:	2a02      	cmp	r2, #2
   163be:	d806      	bhi.n	163ce <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0x42>
          case STORAGE_TYPE_U8: s += sizeof(uint8_t); break;
   163c0:	3001      	adds	r0, #1
   163c2:	e7eb      	b.n	1639c <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0x10>
        switch(attr.storage_type) {
   163c4:	3a05      	subs	r2, #5
   163c6:	2a01      	cmp	r2, #1
   163c8:	d8e8      	bhi.n	1639c <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U32: s += sizeof(uint32_t); break;
   163ca:	3004      	adds	r0, #4
   163cc:	e7e6      	b.n	1639c <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U16: s += sizeof(uint16_t); break;
   163ce:	3002      	adds	r0, #2
   163d0:	e7e4      	b.n	1639c <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()+0x10>
   163d2:	bf00      	nop
   163d4:	00025f98 	.word	0x00025f98

000163d8 <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const>:
  size_t Save(void *storage) const {
   163d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   163dc:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 16490 <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0xb8>
   163e0:	4e2c      	ldr	r6, [pc, #176]	; (16494 <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0xbc>)
    nibbles_ = 0;
   163e2:	2500      	movs	r5, #0
   163e4:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    for (size_t s = 0; s < num_settings; ++s) {
   163e8:	4604      	mov	r4, r0
   163ea:	f500 7758 	add.w	r7, r0, #864	; 0x360
    uint8_t *write_ptr = static_cast<uint8_t *>(storage);
   163ee:	460b      	mov	r3, r1
      switch(value_attr_[s].storage_type) {
   163f0:	7d32      	ldrb	r2, [r6, #20]
    if (nibbles_) {
   163f2:	f8b0 e360 	ldrh.w	lr, [r0, #864]	; 0x360
      switch(value_attr_[s].storage_type) {
   163f6:	2a06      	cmp	r2, #6
   163f8:	d811      	bhi.n	1641e <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x46>
   163fa:	e8df f002 	tbb	[pc, r2]
   163fe:	2704      	.short	0x2704
   16400:	3d323227 	.word	0x3d323227
   16404:	3d          	.byte	0x3d
   16405:	00          	.byte	0x00
      nibbles_ |= (values_[index] & 0x0f);
   16406:	6822      	ldr	r2, [r4, #0]
    if (nibbles_) {
   16408:	f1be 0f00 	cmp.w	lr, #0
   1640c:	d017      	beq.n	1643e <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x66>
      nibbles_ |= (values_[index] & 0x0f);
   1640e:	f002 020f 	and.w	r2, r2, #15
   16412:	ea4e 0202 	orr.w	r2, lr, r2
    *dest++ = (nibbles_ & 0xff);
   16416:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   1641a:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    for (size_t s = 0; s < num_settings; ++s) {
   1641e:	3404      	adds	r4, #4
   16420:	42a7      	cmp	r7, r4
   16422:	f106 0618 	add.w	r6, r6, #24
   16426:	d1e3      	bne.n	163f0 <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x18>
    if (nibbles_)
   16428:	f8b0 2360 	ldrh.w	r2, [r0, #864]	; 0x360
   1642c:	b122      	cbz	r2, 16438 <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x60>
    *dest++ = (nibbles_ & 0xff);
   1642e:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   16432:	2200      	movs	r2, #0
   16434:	f8a0 2360 	strh.w	r2, [r0, #864]	; 0x360
  }
   16438:	1a58      	subs	r0, r3, r1
   1643a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   1643e:	0112      	lsls	r2, r2, #4
   16440:	b2d2      	uxtb	r2, r2
   16442:	ea42 020c 	orr.w	r2, r2, ip
   16446:	f8a0 2360 	strh.w	r2, [r0, #864]	; 0x360
   1644a:	e7e8      	b.n	1641e <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x46>
    if (nibbles_)
   1644c:	f1be 0f00 	cmp.w	lr, #0
   16450:	d003      	beq.n	1645a <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x82>
    *dest++ = (nibbles_ & 0xff);
   16452:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   16456:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    *storage++ = values_[index];
   1645a:	6822      	ldr	r2, [r4, #0]
   1645c:	f803 2b01 	strb.w	r2, [r3], #1
        case STORAGE_TYPE_U8: write_ptr = write_setting<uint8_t>(write_ptr, s); break;
   16460:	e7dd      	b.n	1641e <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x46>
    if (nibbles_)
   16462:	f1be 0f00 	cmp.w	lr, #0
   16466:	d003      	beq.n	16470 <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x98>
    *dest++ = (nibbles_ & 0xff);
   16468:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   1646c:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    *storage++ = values_[index];
   16470:	6822      	ldr	r2, [r4, #0]
   16472:	f823 2b02 	strh.w	r2, [r3], #2
        case STORAGE_TYPE_U16: write_ptr = write_setting<uint16_t>(write_ptr, s); break;
   16476:	e7d2      	b.n	1641e <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x46>
    if (nibbles_)
   16478:	f1be 0f00 	cmp.w	lr, #0
   1647c:	d003      	beq.n	16486 <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0xae>
    *dest++ = (nibbles_ & 0xff);
   1647e:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   16482:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    *storage++ = values_[index];
   16486:	6822      	ldr	r2, [r4, #0]
   16488:	f843 2b04 	str.w	r2, [r3], #4
        case STORAGE_TYPE_U32: write_ptr = write_setting<uint32_t>(write_ptr, s); break;
   1648c:	e7c7      	b.n	1641e <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const+0x46>
   1648e:	bf00      	nop
   16490:	fffff000 	.word	0xfffff000
   16494:	00025f98 	.word	0x00025f98

00016498 <NeuralNetwork_save(void*)>:
size_t NeuralNetwork_save(void *storage) {return NeuralNetwork_instance.Save(storage);}
   16498:	b508      	push	{r3, lr}
   1649a:	4601      	mov	r1, r0
   1649c:	4801      	ldr	r0, [pc, #4]	; (164a4 <NeuralNetwork_save(void*)+0xc>)
   1649e:	f7ff ff9b 	bl	163d8 <settings::SettingsBase<NeuralNetwork, 216u>::Save(void*) const>
   164a2:	bd08      	pop	{r3, pc}
   164a4:	20000614 	.word	0x20000614

000164a8 <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)>:
  size_t Restore(const void *storage) {
   164a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   164aa:	460e      	mov	r6, r1
   164ac:	4f1f      	ldr	r7, [pc, #124]	; (1652c <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x84>)
    nibbles_ = 0;
   164ae:	2100      	movs	r1, #0
   164b0:	f8a0 1360 	strh.w	r1, [r0, #864]	; 0x360
    const uint8_t *read_ptr = static_cast<const uint8_t *>(storage);
   164b4:	4634      	mov	r4, r6
    nibbles_ = 0;
   164b6:	460d      	mov	r5, r1
      switch(value_attr_[s].storage_type) {
   164b8:	7d3b      	ldrb	r3, [r7, #20]
   164ba:	2b06      	cmp	r3, #6
   164bc:	d80f      	bhi.n	164de <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x36>
   164be:	e8df f003 	tbb	[pc, r3]
   164c2:	1b04      	.short	0x1b04
   164c4:	2f2a2520 	.word	0x2f2a2520
   164c8:	2f          	.byte	0x2f
   164c9:	00          	.byte	0x00
    if (nibbles_) {
   164ca:	f8b0 2360 	ldrh.w	r2, [r0, #864]	; 0x360
   164ce:	b16a      	cbz	r2, 164ec <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x44>
      value = nibbles_ & 0x0f;
   164d0:	f002 020f 	and.w	r2, r2, #15
      nibbles_ = 0;
   164d4:	2300      	movs	r3, #0
   164d6:	f8a0 3360 	strh.w	r3, [r0, #864]	; 0x360
    apply_value(index, *storage++);
   164da:	f7ee fc7d 	bl	4dd8 <settings::SettingsBase<NeuralNetwork, 216u>::apply_value(unsigned int, int) [clone .isra.0]>
    for (size_t s = 0; s < num_settings; ++s) {
   164de:	3101      	adds	r1, #1
   164e0:	29d8      	cmp	r1, #216	; 0xd8
   164e2:	f107 0718 	add.w	r7, r7, #24
   164e6:	d1e7      	bne.n	164b8 <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x10>
  }
   164e8:	1ba0      	subs	r0, r4, r6
   164ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      value = *src++;
   164ec:	f814 2b01 	ldrb.w	r2, [r4], #1
      nibbles_ = kNibbleValid | value;
   164f0:	f442 4370 	orr.w	r3, r2, #61440	; 0xf000
      value >>= 4;
   164f4:	0912      	lsrs	r2, r2, #4
   164f6:	e7ee      	b.n	164d6 <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x2e>
    nibbles_ = 0;
   164f8:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    apply_value(index, *storage++);
   164fc:	f914 2b01 	ldrsb.w	r2, [r4], #1
   16500:	e7eb      	b.n	164da <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x32>
    nibbles_ = 0;
   16502:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    apply_value(index, *storage++);
   16506:	f814 2b01 	ldrb.w	r2, [r4], #1
   1650a:	e7e6      	b.n	164da <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x32>
    nibbles_ = 0;
   1650c:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    apply_value(index, *storage++);
   16510:	f934 2b02 	ldrsh.w	r2, [r4], #2
   16514:	e7e1      	b.n	164da <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x32>
    nibbles_ = 0;
   16516:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
    apply_value(index, *storage++);
   1651a:	f834 2b02 	ldrh.w	r2, [r4], #2
   1651e:	e7dc      	b.n	164da <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x32>
   16520:	f854 2b04 	ldr.w	r2, [r4], #4
    nibbles_ = 0;
   16524:	f8a0 5360 	strh.w	r5, [r0, #864]	; 0x360
   16528:	e7d7      	b.n	164da <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)+0x32>
   1652a:	bf00      	nop
   1652c:	00025f98 	.word	0x00025f98

00016530 <NeuralNetwork_restore(void const*)>:
size_t NeuralNetwork_restore(const void *storage) {return NeuralNetwork_instance.Restore(storage);}
   16530:	b508      	push	{r3, lr}
   16532:	4601      	mov	r1, r0
   16534:	4801      	ldr	r0, [pc, #4]	; (1653c <NeuralNetwork_restore(void const*)+0xc>)
   16536:	f7ff ffb7 	bl	164a8 <settings::SettingsBase<NeuralNetwork, 216u>::Restore(void const*)>
   1653a:	bd08      	pop	{r3, pc}
   1653c:	20000614 	.word	0x20000614

00016540 <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)>:
    if (index < num_settings) {
   16540:	2907      	cmp	r1, #7
  bool apply_value(size_t index, int value) {
   16542:	b510      	push	{r4, lr}
    if (index < num_settings) {
   16544:	d812      	bhi.n	1656c <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)+0x2c>
    if (value < min_) return min_;
   16546:	4c0a      	ldr	r4, [pc, #40]	; (16570 <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)+0x30>)
   16548:	2318      	movs	r3, #24
   1654a:	fb03 4401 	mla	r4, r3, r1, r4
   1654e:	6863      	ldr	r3, [r4, #4]
   16550:	429a      	cmp	r2, r3
   16552:	db03      	blt.n	1655c <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)+0x1c>
    else if (value > max_) return max_;
   16554:	68a3      	ldr	r3, [r4, #8]
   16556:	4293      	cmp	r3, r2
   16558:	bfa8      	it	ge
   1655a:	4613      	movge	r3, r2
      if (values_[index] != clamped) {
   1655c:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
   16560:	429a      	cmp	r2, r3
   16562:	d003      	beq.n	1656c <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)+0x2c>
        values_[index] = clamped;
   16564:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
        return true;
   16568:	2001      	movs	r0, #1
  }
   1656a:	bd10      	pop	{r4, pc}
    return false;
   1656c:	2000      	movs	r0, #0
   1656e:	e7fc      	b.n	1656a <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)+0x2a>
   16570:	1fff9d94 	.word	0x1fff9d94

00016574 <TheDarkestTimeline::Controller()>:
    void Controller() {
   16574:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16578:	4604      	mov	r4, r0
   1657a:	b085      	sub	sp, #20
		return usb_midi_read(channel);
   1657c:	2000      	movs	r0, #0
   1657e:	f004 fcc9 	bl	1af14 <usb_midi_read>
        if (usbMIDI.read()) {
   16582:	4606      	mov	r6, r0
   16584:	b188      	cbz	r0, 165aa <TheDarkestTimeline::Controller()+0x36>
                return usb_midi_msg_type;
   16586:	4bab      	ldr	r3, [pc, #684]	; (16834 <TheDarkestTimeline::Controller()+0x2c0>)
                return usb_midi_msg_data1;
   16588:	4aab      	ldr	r2, [pc, #684]	; (16838 <TheDarkestTimeline::Controller()+0x2c4>)
            int message = usbMIDI.getType();
   1658a:	f893 8000 	ldrb.w	r8, [r3]
   1658e:	f892 a000 	ldrb.w	sl, [r2]
                return usb_midi_msg_channel;
   16592:	4baa      	ldr	r3, [pc, #680]	; (1683c <TheDarkestTimeline::Controller()+0x2c8>)
                return usb_midi_msg_data2;
   16594:	4aaa      	ldr	r2, [pc, #680]	; (16840 <TheDarkestTimeline::Controller()+0x2cc>)
                return usb_midi_msg_channel;
   16596:	781b      	ldrb	r3, [r3, #0]
                return usb_midi_msg_data2;
   16598:	7816      	ldrb	r6, [r2, #0]
            if (message == MIDI_MSG_SYSEX) OnReceiveSysEx();
   1659a:	f1b8 0f07 	cmp.w	r8, #7
   1659e:	d107      	bne.n	165b0 <TheDarkestTimeline::Controller()+0x3c>
   165a0:	6823      	ldr	r3, [r4, #0]
   165a2:	4620      	mov	r0, r4
   165a4:	695b      	ldr	r3, [r3, #20]
   165a6:	4798      	blx	r3
        uint8_t in_velocity = 0;
   165a8:	2600      	movs	r6, #0
        uint8_t in_note_number = 0;
   165aa:	46b2      	mov	sl, r6
        bool note_on = 0;
   165ac:	46b0      	mov	r8, r6
   165ae:	e006      	b.n	165be <TheDarkestTimeline::Controller()+0x4a>
            if (message == MIDI_MSG_NOTE_ON && channel == midi_channel_in()) {
   165b0:	f1b8 0f01 	cmp.w	r8, #1
   165b4:	d1f8      	bne.n	165a8 <TheDarkestTimeline::Controller()+0x34>
   165b6:	f894 20a0 	ldrb.w	r2, [r4, #160]	; 0xa0
   165ba:	429a      	cmp	r2, r3
   165bc:	d1f4      	bne.n	165a8 <TheDarkestTimeline::Controller()+0x34>
        if (Clock(0)) {
   165be:	2100      	movs	r1, #0
   165c0:	4620      	mov	r0, r4
   165c2:	f7ef fba5 	bl	5d10 <HSApplication::Clock(int)>
   165c6:	2800      	cmp	r0, #0
   165c8:	f000 80c6 	beq.w	16758 <TheDarkestTimeline::Controller()+0x1e4>
            last_tempo = OC::CORE::ticks - last_clock_event;
   165cc:	4b9d      	ldr	r3, [pc, #628]	; (16844 <TheDarkestTimeline::Controller()+0x2d0>)
   165ce:	f8d4 11f4 	ldr.w	r1, [r4, #500]	; 0x1f4
   165d2:	681a      	ldr	r2, [r3, #0]
            last_clock_event = OC::CORE::ticks;
   165d4:	681b      	ldr	r3, [r3, #0]
   165d6:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
    uint8_t gate_time() {return values_[DT_GATE_TIME];}
   165da:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
            last_tempo = OC::CORE::ticks - last_clock_event;
   165de:	1a52      	subs	r2, r2, r1
            if (gate_time() > 0) {
   165e0:	b2d9      	uxtb	r1, r3
            last_tempo = OC::CORE::ticks - last_clock_event;
   165e2:	f8c4 21f8 	str.w	r2, [r4, #504]	; 0x1f8
    uint8_t gate_time() {return values_[DT_GATE_TIME];}
   165e6:	f04f 0964 	mov.w	r9, #100	; 0x64
            if (gate_time() > 0) {
   165ea:	b139      	cbz	r1, 165fc <TheDarkestTimeline::Controller()+0x88>
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   165ec:	039b      	lsls	r3, r3, #14
   165ee:	f403 137f 	and.w	r3, r3, #4177920	; 0x3fc000
   165f2:	fbb3 f3f9 	udiv	r3, r3, r9
        int scaled = simfloat2int(proportion * max_value);
   165f6:	4353      	muls	r3, r2
   165f8:	ea4f 39a3 	mov.w	r9, r3, asr #14
   165fc:	4b92      	ldr	r3, [pc, #584]	; (16848 <TheDarkestTimeline::Controller()+0x2d4>)
   165fe:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
            move_cursor(Gate(1) ? -1 : 1);
   16602:	f013 0f01 	tst.w	r3, #1
   16606:	bf0c      	ite	eq
   16608:	f04f 31ff 	moveq.w	r1, #4294967295	; 0xffffffff
   1660c:	2101      	movne	r1, #1
   1660e:	4620      	mov	r0, r4
   16610:	f7f6 fd92 	bl	d138 <TheDarkestTimeline::move_cursor(int)>
            clocked = 1;
   16614:	2301      	movs	r3, #1
   16616:	f884 31f0 	strb.w	r3, [r4, #496]	; 0x1f0
        if (Clock(2)) {
   1661a:	2102      	movs	r1, #2
   1661c:	4620      	mov	r0, r4
   1661e:	f7ef fb77 	bl	5d10 <HSApplication::Clock(int)>
   16622:	b178      	cbz	r0, 16644 <TheDarkestTimeline::Controller()+0xd0>
            last_tempo = OC::CORE::ticks - last_clock_event;
   16624:	4a87      	ldr	r2, [pc, #540]	; (16844 <TheDarkestTimeline::Controller()+0x2d0>)
   16626:	f8d4 11f4 	ldr.w	r1, [r4, #500]	; 0x1f4
   1662a:	6813      	ldr	r3, [r2, #0]
   1662c:	1a5b      	subs	r3, r3, r1
   1662e:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
            last_clock_event = OC::CORE::ticks;
   16632:	6813      	ldr	r3, [r2, #0]
   16634:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
            cursor = 0;
   16638:	2300      	movs	r3, #0
   1663a:	f884 30aa 	strb.w	r3, [r4, #170]	; 0xaa
            clocked = 1;
   1663e:	2301      	movs	r3, #1
   16640:	f884 31f0 	strb.w	r3, [r4, #496]	; 0x1f0
        if (!index_edit_enabled) {
   16644:	f894 30ad 	ldrb.w	r3, [r4, #173]	; 0xad
   16648:	b953      	cbnz	r3, 16660 <TheDarkestTimeline::Controller()+0xec>
        return inputs[ch];
   1664a:	6b63      	ldr	r3, [r4, #52]	; 0x34
        return (In(ch) > 64 || In(ch) < -64) ? In(ch) : 0;
   1664c:	2b40      	cmp	r3, #64	; 0x40
   1664e:	dd07      	ble.n	16660 <TheDarkestTimeline::Controller()+0xec>
                apply_value(DT_INDEX, cv_index);
   16650:	22f0      	movs	r2, #240	; 0xf0
   16652:	2101      	movs	r1, #1
   16654:	f104 0088 	add.w	r0, r4, #136	; 0x88
   16658:	fb93 f2f2 	sdiv	r2, r3, r2
   1665c:	f7ff ff70 	bl	16540 <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)>
        int idx = (((position + cursor) % length()) + index()) % 32;
   16660:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
   16664:	f994 50aa 	ldrsb.w	r5, [r4, #170]	; 0xaa
   16668:	fb95 f2f3 	sdiv	r2, r5, r3
   1666c:	fb03 5512 	mls	r5, r3, r2, r5
   16670:	f994 308c 	ldrsb.w	r3, [r4, #140]	; 0x8c
   16674:	441d      	add	r5, r3
   16676:	426b      	negs	r3, r5
   16678:	f003 031f 	and.w	r3, r3, #31
   1667c:	f005 051f 	and.w	r5, r5, #31
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   16680:	ea4f 3686 	mov.w	r6, r6, lsl #14
   16684:	bf58      	it	pl
   16686:	425d      	negpl	r5, r3
   16688:	237f      	movs	r3, #127	; 0x7f
   1668a:	fbb6 f6f3 	udiv	r6, r6, r3
        int scaled = simfloat2int(proportion * max_value);
   1668e:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   16692:	435e      	muls	r6, r3
   16694:	13b3      	asrs	r3, r6, #14
   16696:	9301      	str	r3, [sp, #4]
   16698:	f104 03aa 	add.w	r3, r4, #170	; 0xaa
   1669c:	9300      	str	r3, [sp, #0]
        return inputs[ch];
   1669e:	f104 032c 	add.w	r3, r4, #44	; 0x2c
        uint8_t idx = data_index_at_position(0);
   166a2:	b2ed      	uxtb	r5, r5
        int scaled = simfloat2int(proportion * max_value);
   166a4:	2600      	movs	r6, #0
        return inputs[ch];
   166a6:	9302      	str	r3, [sp, #8]
            if (record[tl]) {
   166a8:	9a00      	ldr	r2, [sp, #0]
   166aa:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   166ae:	9200      	str	r2, [sp, #0]
   166b0:	4637      	mov	r7, r6
   166b2:	b193      	cbz	r3, 166da <TheDarkestTimeline::Controller()+0x166>
                if (midi_channel_in()) {
   166b4:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
   166b8:	2b00      	cmp	r3, #0
   166ba:	d052      	beq.n	16762 <TheDarkestTimeline::Controller()+0x1ee>
                    if (note_on) {
   166bc:	f1b8 0f00 	cmp.w	r8, #0
   166c0:	d00b      	beq.n	166da <TheDarkestTimeline::Controller()+0x166>
                        if (tl == 0) { // Write to CV Timeline based on note number
   166c2:	2e00      	cmp	r6, #0
   166c4:	d14b      	bne.n	1675e <TheDarkestTimeline::Controller()+0x1ea>
                            write_cv = MIDIQuantizer::CV(in_note_number);
   166c6:	4631      	mov	r1, r6
   166c8:	4650      	mov	r0, sl
   166ca:	f7ef f96c 	bl	59a6 <MIDIQuantizer::CV(unsigned char, int)>
                        write_data_at(idx, tl, write_cv);
   166ce:	b283      	uxth	r3, r0
                    write_data_at(idx, tl, cv);
   166d0:	463a      	mov	r2, r7
   166d2:	4629      	mov	r1, r5
   166d4:	4620      	mov	r0, r4
   166d6:	f7f6 fdcf 	bl	d278 <TheDarkestTimeline::write_data_at(int, bool, unsigned short)>
            cv = get_data_at(idx, tl);
   166da:	463a      	mov	r2, r7
   166dc:	4629      	mov	r1, r5
   166de:	4620      	mov	r0, r4
   166e0:	f7f6 fd42 	bl	d168 <TheDarkestTimeline::get_data_at(int, bool)>
   166e4:	6ba7      	ldr	r7, [r4, #56]	; 0x38
        return (In(ch) > 64 || In(ch) < -64) ? In(ch) : 0;
   166e6:	f107 0340 	add.w	r3, r7, #64	; 0x40
   166ea:	2b80      	cmp	r3, #128	; 0x80
   166ec:	bf98      	it	ls
   166ee:	2700      	movls	r7, #0
            int transpose = transpose_cv / 128;
   166f0:	2f00      	cmp	r7, #0
   166f2:	bfb8      	it	lt
   166f4:	377f      	addlt	r7, #127	; 0x7f
            cv = get_data_at(idx, tl);
   166f6:	4683      	mov	fp, r0
            int transpose = transpose_cv / 128;
   166f8:	11ff      	asrs	r7, r7, #7
            if (tl == 0) {
   166fa:	2e00      	cmp	r6, #0
   166fc:	d13d      	bne.n	1677a <TheDarkestTimeline::Controller()+0x206>
                int32_t pitch = quantizer.Process(cv, root() << 7, transpose);
   166fe:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   16702:	01d2      	lsls	r2, r2, #7
   16704:	4659      	mov	r1, fp
   16706:	f104 00b0 	add.w	r0, r4, #176	; 0xb0
   1670a:	463b      	mov	r3, r7
   1670c:	f402 42ff 	and.w	r2, r2, #32640	; 0x7f80
   16710:	4683      	mov	fp, r0
   16712:	f7ea fe3d 	bl	1390 <braids::Quantizer::Process(long, long, long)>
                Out(0, pitch);
   16716:	4633      	mov	r3, r6
                int32_t pitch = quantizer.Process(cv, root() << 7, transpose);
   16718:	4602      	mov	r2, r0
                Out(0, pitch);
   1671a:	4631      	mov	r1, r6
   1671c:	4620      	mov	r0, r4
   1671e:	f7ef fa55 	bl	5bcc <HSApplication::Out(int, int, int)>
    uint8_t length() {return values_[DT_LENGTH];}
   16722:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
                uint8_t alt_idx = (idx + length()) % 32;
   16726:	4429      	add	r1, r5
                int alt_cv = get_data_at(alt_idx, tl);
   16728:	4632      	mov	r2, r6
   1672a:	f001 011f 	and.w	r1, r1, #31
   1672e:	4620      	mov	r0, r4
   16730:	f7f6 fd1a 	bl	d168 <TheDarkestTimeline::get_data_at(int, bool)>
                pitch = quantizer.Process(alt_cv, root() << 7, transpose);
   16734:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   16738:	01d2      	lsls	r2, r2, #7
                int alt_cv = get_data_at(alt_idx, tl);
   1673a:	4601      	mov	r1, r0
                pitch = quantizer.Process(alt_cv, root() << 7, transpose);
   1673c:	463b      	mov	r3, r7
   1673e:	f402 42ff 	and.w	r2, r2, #32640	; 0x7f80
   16742:	4658      	mov	r0, fp
   16744:	f7ea fe24 	bl	1390 <braids::Quantizer::Process(long, long, long)>
                Out(1, pitch);
   16748:	4633      	mov	r3, r6
                pitch = quantizer.Process(alt_cv, root() << 7, transpose);
   1674a:	4602      	mov	r2, r0
                Out(1, pitch);
   1674c:	2101      	movs	r1, #1
   1674e:	4620      	mov	r0, r4
   16750:	f7ef fa3c 	bl	5bcc <HSApplication::Out(int, int, int)>
   16754:	2601      	movs	r6, #1
   16756:	e7a7      	b.n	166a8 <TheDarkestTimeline::Controller()+0x134>
        int gate_ticks = HEMISPHERE_CLOCK_TICKS;
   16758:	f04f 0964 	mov.w	r9, #100	; 0x64
   1675c:	e75d      	b.n	1661a <TheDarkestTimeline::Controller()+0xa6>
                            write_cv = Proportion(in_velocity, 127, HSAPPLICATION_5V);
   1675e:	9801      	ldr	r0, [sp, #4]
   16760:	e7b5      	b.n	166ce <TheDarkestTimeline::Controller()+0x15a>
                    write_data_at(idx, tl, cv);
   16762:	9b02      	ldr	r3, [sp, #8]
   16764:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   16768:	f5b3 5ff0 	cmp.w	r3, #7680	; 0x1e00
   1676c:	bfa8      	it	ge
   1676e:	f44f 53f0 	movge.w	r3, #7680	; 0x1e00
   16772:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   16776:	b29b      	uxth	r3, r3
   16778:	e7aa      	b.n	166d0 <TheDarkestTimeline::Controller()+0x15c>
            } else if (clocked) {
   1677a:	f894 31f0 	ldrb.w	r3, [r4, #496]	; 0x1f0
   1677e:	2b00      	cmp	r3, #0
   16780:	f000 80cf 	beq.w	16922 <TheDarkestTimeline::Controller()+0x3ae>
                clocked = 0; // Reset the clock
   16784:	2000      	movs	r0, #0
   16786:	f884 01f0 	strb.w	r0, [r4, #496]	; 0x1f0
                int prob = random(0, HSAPPLICATION_5V);
   1678a:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
   1678e:	f003 fbae 	bl	19eee <random(long, long)>
                if (prob < cv || Gate(3)) { // Gate at digital 4 makes all probabilities certainties
   16792:	4583      	cmp	fp, r0
   16794:	dd5a      	ble.n	1684c <TheDarkestTimeline::Controller()+0x2d8>
                    ClockOut(2, gate_ticks);
   16796:	464a      	mov	r2, r9
   16798:	2102      	movs	r1, #2
   1679a:	4620      	mov	r0, r4
   1679c:	f7ef fae8 	bl	5d70 <HSApplication::ClockOut(int, int)>
                    if (last_midi_note[0] > -1) usbMIDI.sendNoteOff(last_midi_note[0], 0, last_midi_channel[0]);
   167a0:	f994 31fc 	ldrsb.w	r3, [r4, #508]	; 0x1fc
   167a4:	2b00      	cmp	r3, #0
   167a6:	db0d      	blt.n	167c4 <TheDarkestTimeline::Controller()+0x250>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   167a8:	f894 01fe 	ldrb.w	r0, [r4, #510]	; 0x1fe
   167ac:	3801      	subs	r0, #1
   167ae:	0200      	lsls	r0, r0, #8
   167b0:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   167b4:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   167b8:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
   167bc:	f040 0008 	orr.w	r0, r0, #8
   167c0:	f004 faf4 	bl	1adac <usb_midi_write_packed>
    uint8_t midi_channel() {return values_[DT_MIDI_CHANNEL];}
   167c4:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
                    if (midi_channel()) {
   167c8:	2b00      	cmp	r3, #0
   167ca:	d043      	beq.n	16854 <TheDarkestTimeline::Controller()+0x2e0>
                        last_midi_channel[0] = midi_channel();
   167cc:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
                        last_midi_note[0] = MIDIQuantizer::NoteNumber(get_data_at(idx, DT_CV_TIMELINE), transpose);
   167d0:	2200      	movs	r2, #0
   167d2:	4629      	mov	r1, r5
   167d4:	4620      	mov	r0, r4
                        last_midi_channel[0] = midi_channel();
   167d6:	9303      	str	r3, [sp, #12]
                        last_midi_note[0] = MIDIQuantizer::NoteNumber(get_data_at(idx, DT_CV_TIMELINE), transpose);
   167d8:	f7f6 fcc6 	bl	d168 <TheDarkestTimeline::get_data_at(int, bool)>
   167dc:	4639      	mov	r1, r7
   167de:	f7ef f8c6 	bl	596e <MIDIQuantizer::NoteNumber(int, int)>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   167e2:	9b03      	ldr	r3, [sp, #12]
   167e4:	f884 01fc 	strb.w	r0, [r4, #508]	; 0x1fc
   167e8:	3b01      	subs	r3, #1
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   167ea:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
   167ee:	021b      	lsls	r3, r3, #8
   167f0:	0400      	lsls	r0, r0, #16
   167f2:	ea4f 328b 	mov.w	r2, fp, lsl #14
   167f6:	fbb2 f2f1 	udiv	r2, r2, r1
        int scaled = simfloat2int(proportion * max_value);
   167fa:	ebc2 12c2 	rsb	r2, r2, r2, lsl #7
   167fe:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
   16802:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
			  | ((data2 & 0x7F) << 24));
   16806:	0292      	lsls	r2, r2, #10
   16808:	4303      	orrs	r3, r0
   1680a:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
   1680e:	ea43 0002 	orr.w	r0, r3, r2
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   16812:	f440 4010 	orr.w	r0, r0, #36864	; 0x9000
   16816:	f040 0009 	orr.w	r0, r0, #9
   1681a:	f004 fac7 	bl	1adac <usb_midi_write_packed>
                        last_length[0] = OC::CORE::ticks - last_clock[0];
   1681e:	4909      	ldr	r1, [pc, #36]	; (16844 <TheDarkestTimeline::Controller()+0x2d0>)
   16820:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
   16824:	680b      	ldr	r3, [r1, #0]
   16826:	1a9b      	subs	r3, r3, r2
   16828:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
                        last_clock[0] = OC::CORE::ticks;
   1682c:	680b      	ldr	r3, [r1, #0]
   1682e:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
   16832:	e00f      	b.n	16854 <TheDarkestTimeline::Controller()+0x2e0>
   16834:	20006884 	.word	0x20006884
   16838:	2000675e 	.word	0x2000675e
   1683c:	2000675d 	.word	0x2000675d
   16840:	2000675f 	.word	0x2000675f
   16844:	200046cc 	.word	0x200046cc
   16848:	400ff000 	.word	0x400ff000
        if (ch == 3) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_4>();
   1684c:	f7fd fb24 	bl	13e98 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()>
                if (prob < cv || Gate(3)) { // Gate at digital 4 makes all probabilities certainties
   16850:	2800      	cmp	r0, #0
   16852:	d1a0      	bne.n	16796 <TheDarkestTimeline::Controller()+0x222>
                prob = random(0, HSAPPLICATION_5V);
   16854:	f44f 51f0 	mov.w	r1, #7680	; 0x1e00
   16858:	2000      	movs	r0, #0
   1685a:	f003 fb48 	bl	19eee <random(long, long)>
                if (prob < (HSAPPLICATION_5V - cv) || Gate(3)) {
   1685e:	f5cb 5bf0 	rsb	fp, fp, #7680	; 0x1e00
   16862:	4583      	cmp	fp, r0
   16864:	dd59      	ble.n	1691a <TheDarkestTimeline::Controller()+0x3a6>
                    ClockOut(3, gate_ticks);
   16866:	464a      	mov	r2, r9
   16868:	2103      	movs	r1, #3
   1686a:	4620      	mov	r0, r4
   1686c:	f7ef fa80 	bl	5d70 <HSApplication::ClockOut(int, int)>
                    if (last_midi_note[1] > -1) usbMIDI.sendNoteOff(last_midi_note[1], 0, last_midi_channel[1]);
   16870:	f994 31fd 	ldrsb.w	r3, [r4, #509]	; 0x1fd
   16874:	2b00      	cmp	r3, #0
   16876:	db0d      	blt.n	16894 <TheDarkestTimeline::Controller()+0x320>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   16878:	f894 01ff 	ldrb.w	r0, [r4, #511]	; 0x1ff
   1687c:	3801      	subs	r0, #1
   1687e:	0200      	lsls	r0, r0, #8
   16880:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   16884:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   16888:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
   1688c:	f040 0008 	orr.w	r0, r0, #8
   16890:	f004 fa8c 	bl	1adac <usb_midi_write_packed>
    uint8_t midi_channel_alt() {return values_[DT_MIDI_CHANNEL_ALT];}
   16894:	f894 709c 	ldrb.w	r7, [r4, #156]	; 0x9c
                    if (midi_channel_alt()) {
   16898:	2f00      	cmp	r7, #0
   1689a:	d042      	beq.n	16922 <TheDarkestTimeline::Controller()+0x3ae>
    uint8_t length() {return values_[DT_LENGTH];}
   1689c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
                        last_midi_channel[1] = midi_channel_alt();
   168a0:	f884 71ff 	strb.w	r7, [r4, #511]	; 0x1ff
                        uint8_t alt_idx = (idx + length()) % 32;
   168a4:	442b      	add	r3, r5
                        last_midi_note[1] = MIDIQuantizer::NoteNumber(get_data_at(alt_idx, DT_CV_TIMELINE));
   168a6:	f003 031f 	and.w	r3, r3, #31
   168aa:	4619      	mov	r1, r3
   168ac:	2200      	movs	r2, #0
   168ae:	4620      	mov	r0, r4
   168b0:	9303      	str	r3, [sp, #12]
   168b2:	f7f6 fc59 	bl	d168 <TheDarkestTimeline::get_data_at(int, bool)>
   168b6:	2100      	movs	r1, #0
   168b8:	f7ef f859 	bl	596e <MIDIQuantizer::NoteNumber(int, int)>
                        vel = Proportion(get_data_at(alt_idx, DT_PROBABILITY_TIMELINE), HSAPPLICATION_5V, 127);
   168bc:	9b03      	ldr	r3, [sp, #12]
                        last_midi_note[1] = MIDIQuantizer::NoteNumber(get_data_at(alt_idx, DT_CV_TIMELINE));
   168be:	f884 01fd 	strb.w	r0, [r4, #509]	; 0x1fd
                        vel = Proportion(get_data_at(alt_idx, DT_PROBABILITY_TIMELINE), HSAPPLICATION_5V, 127);
   168c2:	4619      	mov	r1, r3
   168c4:	2201      	movs	r2, #1
                        last_midi_note[1] = MIDIQuantizer::NoteNumber(get_data_at(alt_idx, DT_CV_TIMELINE));
   168c6:	4683      	mov	fp, r0
                        vel = Proportion(get_data_at(alt_idx, DT_PROBABILITY_TIMELINE), HSAPPLICATION_5V, 127);
   168c8:	4620      	mov	r0, r4
   168ca:	f7f6 fc4d 	bl	d168 <TheDarkestTimeline::get_data_at(int, bool)>
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   168ce:	3f01      	subs	r7, #1
        simfloat proportion = int2simfloat((int32_t)numerator) / (int32_t)denominator;
   168d0:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
   168d4:	0380      	lsls	r0, r0, #14
   168d6:	fbb0 f0f3 	udiv	r0, r0, r3
        int scaled = simfloat2int(proportion * max_value);
   168da:	ebc0 10c0 	rsb	r0, r0, r0, lsl #7
			  | ((data2 & 0x7F) << 24));
   168de:	0280      	lsls	r0, r0, #10
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   168e0:	023f      	lsls	r7, r7, #8
			  | ((data2 & 0x7F) << 24));
   168e2:	f000 40fe 	and.w	r0, r0, #2130706432	; 0x7f000000
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   168e6:	f407 6770 	and.w	r7, r7, #3840	; 0xf00
   168ea:	ea4f 4b0b 	mov.w	fp, fp, lsl #16
			  | ((data2 & 0x7F) << 24));
   168ee:	4338      	orrs	r0, r7
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   168f0:	f40b 0bfe 	and.w	fp, fp, #8323072	; 0x7f0000
			  | ((data2 & 0x7F) << 24));
   168f4:	ea40 000b 	orr.w	r0, r0, fp
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   168f8:	f440 4010 	orr.w	r0, r0, #36864	; 0x9000
   168fc:	f040 0009 	orr.w	r0, r0, #9
   16900:	f004 fa54 	bl	1adac <usb_midi_write_packed>
                        last_length[1] = OC::CORE::ticks - last_clock[1];
   16904:	492a      	ldr	r1, [pc, #168]	; (169b0 <TheDarkestTimeline::Controller()+0x43c>)
   16906:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
   1690a:	680b      	ldr	r3, [r1, #0]
   1690c:	1a9b      	subs	r3, r3, r2
   1690e:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
                        last_clock[1] = OC::CORE::ticks;
   16912:	680b      	ldr	r3, [r1, #0]
   16914:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
   16918:	e003      	b.n	16922 <TheDarkestTimeline::Controller()+0x3ae>
        if (ch == 3) high = OC::DigitalInputs::read_immediate<OC::DIGITAL_INPUT_4>();
   1691a:	f7fd fabd 	bl	13e98 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()>
                if (prob < (HSAPPLICATION_5V - cv) || Gate(3)) {
   1691e:	2800      	cmp	r0, #0
   16920:	d1a1      	bne.n	16866 <TheDarkestTimeline::Controller()+0x2f2>
        for (uint8_t tl = 0; tl < 2; tl++)
   16922:	2e00      	cmp	r6, #0
   16924:	f43f af16 	beq.w	16754 <TheDarkestTimeline::Controller()+0x1e0>
            if (last_midi_note[ch] > -1 && (OC::CORE::ticks - last_clock[ch]) > (last_length[ch]) * 2) {
   16928:	f8df 9084 	ldr.w	r9, [pc, #132]	; 169b0 <TheDarkestTimeline::Controller()+0x43c>
   1692c:	f204 15fb 	addw	r5, r4, #507	; 0x1fb
   16930:	f504 7600 	add.w	r6, r4, #512	; 0x200
   16934:	f204 17fd 	addw	r7, r4, #509	; 0x1fd
			  | (((channel - 1) & 0x0F) << 8) | ((data1 & 0x7F) << 16)
   16938:	f248 0a08 	movw	sl, #32776	; 0x8008
                last_midi_note[ch] = -1;
   1693c:	f04f 0bff 	mov.w	fp, #255	; 0xff
            if (last_midi_note[ch] > -1 && (OC::CORE::ticks - last_clock[ch]) > (last_length[ch]) * 2) {
   16940:	f915 2f01 	ldrsb.w	r2, [r5, #1]!
   16944:	2a00      	cmp	r2, #0
   16946:	db14      	blt.n	16972 <TheDarkestTimeline::Controller()+0x3fe>
   16948:	6833      	ldr	r3, [r6, #0]
   1694a:	f8d9 1000 	ldr.w	r1, [r9]
   1694e:	1ac9      	subs	r1, r1, r3
   16950:	68b3      	ldr	r3, [r6, #8]
   16952:	ebb1 0f43 	cmp.w	r1, r3, lsl #1
   16956:	d90c      	bls.n	16972 <TheDarkestTimeline::Controller()+0x3fe>
   16958:	78a8      	ldrb	r0, [r5, #2]
   1695a:	3801      	subs	r0, #1
   1695c:	0200      	lsls	r0, r0, #8
   1695e:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   16962:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
   16966:	ea40 000a 	orr.w	r0, r0, sl
   1696a:	f004 fa1f 	bl	1adac <usb_midi_write_packed>
                last_midi_note[ch] = -1;
   1696e:	f885 b000 	strb.w	fp, [r5]
        for (uint8_t ch = 0; ch < 2; ch++)
   16972:	42af      	cmp	r7, r5
   16974:	f106 0604 	add.w	r6, r6, #4
   16978:	d1e2      	bne.n	16940 <TheDarkestTimeline::Controller()+0x3cc>
        if (--setup_screen_timeout_countdown < 0) {}
   1697a:	f8d4 31ec 	ldr.w	r3, [r4, #492]	; 0x1ec
   1697e:	3b01      	subs	r3, #1
   16980:	f8c4 31ec 	str.w	r3, [r4, #492]	; 0x1ec
        if (!Clock(0) && note_on && (record[0] || record[1])) move_cursor(1);
   16984:	2100      	movs	r1, #0
   16986:	4620      	mov	r0, r4
   16988:	f7ef f9c2 	bl	5d10 <HSApplication::Clock(int)>
   1698c:	b960      	cbnz	r0, 169a8 <TheDarkestTimeline::Controller()+0x434>
   1698e:	f1b8 0f00 	cmp.w	r8, #0
   16992:	d009      	beq.n	169a8 <TheDarkestTimeline::Controller()+0x434>
   16994:	f894 30ab 	ldrb.w	r3, [r4, #171]	; 0xab
   16998:	b913      	cbnz	r3, 169a0 <TheDarkestTimeline::Controller()+0x42c>
   1699a:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
   1699e:	b11b      	cbz	r3, 169a8 <TheDarkestTimeline::Controller()+0x434>
   169a0:	2101      	movs	r1, #1
   169a2:	4620      	mov	r0, r4
   169a4:	f7f6 fbc8 	bl	d138 <TheDarkestTimeline::move_cursor(int)>
    }
   169a8:	b005      	add	sp, #20
   169aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   169ae:	bf00      	nop
   169b0:	200046cc 	.word	0x200046cc

000169b4 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)>:

void TheDarkestTimeline_handleEncoderEvent(const UI::Event &event) {
   169b4:	b538      	push	{r3, r4, r5, lr}
    // Left encoder turned
    if (event.control == OC::CONTROL_ENCODER_L) TheDarkestTimeline_instance.OnLeftEncoderMove(event.value);
   169b6:	8843      	ldrh	r3, [r0, #2]
   169b8:	2b20      	cmp	r3, #32
void TheDarkestTimeline_handleEncoderEvent(const UI::Event &event) {
   169ba:	4605      	mov	r5, r0
    if (event.control == OC::CONTROL_ENCODER_L) TheDarkestTimeline_instance.OnLeftEncoderMove(event.value);
   169bc:	d125      	bne.n	16a0a <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x56>
        if (setup_screen == 0) change_value(DT_LENGTH, -direction);
   169be:	4c2c      	ldr	r4, [pc, #176]	; (16a70 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0xbc>)
    if (event.control == OC::CONTROL_ENCODER_L) TheDarkestTimeline_instance.OnLeftEncoderMove(event.value);
   169c0:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
        if (setup_screen == 0) change_value(DT_LENGTH, -direction);
   169c4:	f894 11e8 	ldrb.w	r1, [r4, #488]	; 0x1e8
   169c8:	2900      	cmp	r1, #0
   169ca:	d13f      	bne.n	16a4c <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x98>
    return apply_value(index, values_[index] + delta);
   169cc:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    if (value < min_) return min_;
   169d0:	4828      	ldr	r0, [pc, #160]	; (16a74 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0xc0>)
   169d2:	1aca      	subs	r2, r1, r3
   169d4:	6843      	ldr	r3, [r0, #4]
   169d6:	429a      	cmp	r2, r3
   169d8:	db03      	blt.n	169e2 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x2e>
    else if (value > max_) return max_;
   169da:	6883      	ldr	r3, [r0, #8]
   169dc:	4293      	cmp	r3, r2
   169de:	bfa8      	it	ge
   169e0:	4613      	movge	r3, r2
      if (values_[index] != clamped) {
   169e2:	4299      	cmp	r1, r3
   169e4:	d001      	beq.n	169ea <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x36>
        values_[index] = clamped;
   169e6:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
        quantizer.Configure(OC::Scales::GetScale(scale()), 0xffff);
   169ea:	f894 0090 	ldrb.w	r0, [r4, #144]	; 0x90
   169ee:	f7ea fac1 	bl	f74 <OC::Scales::GetScale(int)>
   169f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   169f6:	4601      	mov	r1, r0
   169f8:	481f      	ldr	r0, [pc, #124]	; (16a78 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0xc4>)
   169fa:	f7ef faff 	bl	5ffc <braids::Quantizer::Configure(braids::Scale const&, unsigned short)>
        if (setup_screen > 0) setup_screen_timeout_countdown = DT_SETUP_SCREEN_TIMEOUT;
   169fe:	f894 31e8 	ldrb.w	r3, [r4, #488]	; 0x1e8
   16a02:	b113      	cbz	r3, 16a0a <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x56>
   16a04:	4b1d      	ldr	r3, [pc, #116]	; (16a7c <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0xc8>)
   16a06:	f8c4 31ec 	str.w	r3, [r4, #492]	; 0x1ec

    // Right encoder turned
    if (event.control == OC::CONTROL_ENCODER_R) TheDarkestTimeline_instance.OnRightEncoderMove(event.value);
   16a0a:	886b      	ldrh	r3, [r5, #2]
   16a0c:	2b40      	cmp	r3, #64	; 0x40
   16a0e:	d11c      	bne.n	16a4a <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x96>
        if (index_edit_enabled) move_index(direction);
   16a10:	4c17      	ldr	r4, [pc, #92]	; (16a70 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0xbc>)
    if (event.control == OC::CONTROL_ENCODER_R) TheDarkestTimeline_instance.OnRightEncoderMove(event.value);
   16a12:	f9b5 1004 	ldrsh.w	r1, [r5, #4]
        if (index_edit_enabled) move_index(direction);
   16a16:	f894 30ad 	ldrb.w	r3, [r4, #173]	; 0xad
   16a1a:	b323      	cbz	r3, 16a66 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0xb2>
        values_[DT_INDEX] += direction;
   16a1c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   16a20:	4419      	add	r1, r3
        if (index() < 0) values_[DT_INDEX] = 31;
   16a22:	b24b      	sxtb	r3, r1
   16a24:	2b00      	cmp	r3, #0
   16a26:	db1c      	blt.n	16a62 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0xae>
        if (index() >= 32) values_[DT_INDEX] = 0;
   16a28:	2b20      	cmp	r3, #32
   16a2a:	bfa8      	it	ge
   16a2c:	2100      	movge	r1, #0
   16a2e:	f8c4 108c 	str.w	r1, [r4, #140]	; 0x8c
        if (OC::CORE::ticks - last_clock_event > last_tempo) clocked = 1;
   16a32:	4b13      	ldr	r3, [pc, #76]	; (16a80 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0xcc>)
   16a34:	f8d4 21f4 	ldr.w	r2, [r4, #500]	; 0x1f4
   16a38:	681b      	ldr	r3, [r3, #0]
   16a3a:	1a9b      	subs	r3, r3, r2
   16a3c:	f8d4 21f8 	ldr.w	r2, [r4, #504]	; 0x1f8
   16a40:	4293      	cmp	r3, r2
   16a42:	bf84      	itt	hi
   16a44:	2301      	movhi	r3, #1
   16a46:	f884 31f0 	strbhi.w	r3, [r4, #496]	; 0x1f0
}
   16a4a:	bd38      	pop	{r3, r4, r5, pc}
        else change_value(setup_screen + 1, direction);
   16a4c:	3101      	adds	r1, #1
    return apply_value(index, values_[index] + delta);
   16a4e:	eb04 0281 	add.w	r2, r4, r1, lsl #2
   16a52:	f104 0088 	add.w	r0, r4, #136	; 0x88
   16a56:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
   16a5a:	441a      	add	r2, r3
   16a5c:	f7ff fd70 	bl	16540 <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)>
   16a60:	e7c3      	b.n	169ea <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x36>
        if (index() < 0) values_[DT_INDEX] = 31;
   16a62:	211f      	movs	r1, #31
   16a64:	e7e3      	b.n	16a2e <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x7a>
        else move_cursor(direction);
   16a66:	4620      	mov	r0, r4
   16a68:	f7f6 fb66 	bl	d138 <TheDarkestTimeline::move_cursor(int)>
   16a6c:	e7e1      	b.n	16a32 <TheDarkestTimeline_handleEncoderEvent(UI::Event const&)+0x7e>
   16a6e:	bf00      	nop
   16a70:	20002444 	.word	0x20002444
   16a74:	1fff9d94 	.word	0x1fff9d94
   16a78:	200024f4 	.word	0x200024f4
   16a7c:	00028b0b 	.word	0x00028b0b
   16a80:	200046cc 	.word	0x200046cc

00016a84 <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()>:
  static size_t calc_storage_size() {
   16a84:	b510      	push	{r4, lr}
    unsigned nibbles = 0;
   16a86:	2300      	movs	r3, #0
   16a88:	4c10      	ldr	r4, [pc, #64]	; (16acc <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0x48>)
  static size_t calc_storage_size() {
   16a8a:	2108      	movs	r1, #8
    size_t s = 0;
   16a8c:	4618      	mov	r0, r3
    for (auto attr : value_attr_) {
   16a8e:	7d22      	ldrb	r2, [r4, #20]
      if (STORAGE_TYPE_U4 == attr.storage_type) {
   16a90:	b952      	cbnz	r2, 16aa8 <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0x24>
        ++nibbles;
   16a92:	3301      	adds	r3, #1
    for (auto attr : value_attr_) {
   16a94:	3901      	subs	r1, #1
   16a96:	f104 0418 	add.w	r4, r4, #24
   16a9a:	d1f8      	bne.n	16a8e <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0xa>
    if (nibbles & 1) ++nibbles;
   16a9c:	07da      	lsls	r2, r3, #31
   16a9e:	bf48      	it	mi
   16aa0:	3301      	addmi	r3, #1
  }
   16aa2:	eb00 0053 	add.w	r0, r0, r3, lsr #1
   16aa6:	bd10      	pop	{r4, pc}
        if (nibbles & 1) ++nibbles;
   16aa8:	f013 0f01 	tst.w	r3, #1
   16aac:	bf18      	it	ne
   16aae:	3301      	addne	r3, #1
        switch(attr.storage_type) {
   16ab0:	2a04      	cmp	r2, #4
   16ab2:	d803      	bhi.n	16abc <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0x38>
   16ab4:	2a02      	cmp	r2, #2
   16ab6:	d806      	bhi.n	16ac6 <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0x42>
          case STORAGE_TYPE_U8: s += sizeof(uint8_t); break;
   16ab8:	3001      	adds	r0, #1
   16aba:	e7eb      	b.n	16a94 <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0x10>
        switch(attr.storage_type) {
   16abc:	3a05      	subs	r2, #5
   16abe:	2a01      	cmp	r2, #1
   16ac0:	d8e8      	bhi.n	16a94 <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U32: s += sizeof(uint32_t); break;
   16ac2:	3004      	adds	r0, #4
   16ac4:	e7e6      	b.n	16a94 <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0x10>
          case STORAGE_TYPE_U16: s += sizeof(uint16_t); break;
   16ac6:	3002      	adds	r0, #2
   16ac8:	e7e4      	b.n	16a94 <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()+0x10>
   16aca:	bf00      	nop
   16acc:	1fff9d94 	.word	0x1fff9d94

00016ad0 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const>:
  size_t Save(void *storage) const {
   16ad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   16ad4:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 16b78 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0xa8>
   16ad8:	4e28      	ldr	r6, [pc, #160]	; (16b7c <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0xac>)
    nibbles_ = 0;
   16ada:	2500      	movs	r5, #0
   16adc:	8405      	strh	r5, [r0, #32]
    for (size_t s = 0; s < num_settings; ++s) {
   16ade:	4604      	mov	r4, r0
   16ae0:	f100 0720 	add.w	r7, r0, #32
    uint8_t *write_ptr = static_cast<uint8_t *>(storage);
   16ae4:	460b      	mov	r3, r1
      switch(value_attr_[s].storage_type) {
   16ae6:	7d32      	ldrb	r2, [r6, #20]
    if (nibbles_) {
   16ae8:	f8b0 e020 	ldrh.w	lr, [r0, #32]
      switch(value_attr_[s].storage_type) {
   16aec:	2a06      	cmp	r2, #6
   16aee:	d810      	bhi.n	16b12 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x42>
   16af0:	e8df f002 	tbb	[pc, r2]
   16af4:	2d232304 	.word	0x2d232304
   16af8:	372d      	.short	0x372d
   16afa:	37          	.byte	0x37
   16afb:	00          	.byte	0x00
      nibbles_ |= (values_[index] & 0x0f);
   16afc:	6822      	ldr	r2, [r4, #0]
    if (nibbles_) {
   16afe:	f1be 0f00 	cmp.w	lr, #0
   16b02:	d014      	beq.n	16b2e <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x5e>
      nibbles_ |= (values_[index] & 0x0f);
   16b04:	f002 020f 	and.w	r2, r2, #15
   16b08:	ea4e 0202 	orr.w	r2, lr, r2
    *dest++ = (nibbles_ & 0xff);
   16b0c:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   16b10:	8405      	strh	r5, [r0, #32]
    for (size_t s = 0; s < num_settings; ++s) {
   16b12:	3404      	adds	r4, #4
   16b14:	42a7      	cmp	r7, r4
   16b16:	f106 0618 	add.w	r6, r6, #24
   16b1a:	d1e4      	bne.n	16ae6 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x16>
    if (nibbles_)
   16b1c:	8c02      	ldrh	r2, [r0, #32]
   16b1e:	b11a      	cbz	r2, 16b28 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x58>
    *dest++ = (nibbles_ & 0xff);
   16b20:	f803 2b01 	strb.w	r2, [r3], #1
    nibbles_ = 0;
   16b24:	2200      	movs	r2, #0
   16b26:	8402      	strh	r2, [r0, #32]
  }
   16b28:	1a58      	subs	r0, r3, r1
   16b2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      nibbles_ = kNibbleValid | ((values_[index] & 0x0f) << 4);
   16b2e:	0112      	lsls	r2, r2, #4
   16b30:	b2d2      	uxtb	r2, r2
   16b32:	ea42 020c 	orr.w	r2, r2, ip
   16b36:	8402      	strh	r2, [r0, #32]
   16b38:	e7eb      	b.n	16b12 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x42>
    if (nibbles_)
   16b3a:	f1be 0f00 	cmp.w	lr, #0
   16b3e:	d002      	beq.n	16b46 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x76>
    *dest++ = (nibbles_ & 0xff);
   16b40:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   16b44:	8405      	strh	r5, [r0, #32]
    *storage++ = values_[index];
   16b46:	6822      	ldr	r2, [r4, #0]
   16b48:	f803 2b01 	strb.w	r2, [r3], #1
        case STORAGE_TYPE_U8: write_ptr = write_setting<uint8_t>(write_ptr, s); break;
   16b4c:	e7e1      	b.n	16b12 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x42>
    if (nibbles_)
   16b4e:	f1be 0f00 	cmp.w	lr, #0
   16b52:	d002      	beq.n	16b5a <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x8a>
    *dest++ = (nibbles_ & 0xff);
   16b54:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   16b58:	8405      	strh	r5, [r0, #32]
    *storage++ = values_[index];
   16b5a:	6822      	ldr	r2, [r4, #0]
   16b5c:	f823 2b02 	strh.w	r2, [r3], #2
        case STORAGE_TYPE_U16: write_ptr = write_setting<uint16_t>(write_ptr, s); break;
   16b60:	e7d7      	b.n	16b12 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x42>
    if (nibbles_)
   16b62:	f1be 0f00 	cmp.w	lr, #0
   16b66:	d002      	beq.n	16b6e <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x9e>
    *dest++ = (nibbles_ & 0xff);
   16b68:	f803 eb01 	strb.w	lr, [r3], #1
    nibbles_ = 0;
   16b6c:	8405      	strh	r5, [r0, #32]
    *storage++ = values_[index];
   16b6e:	6822      	ldr	r2, [r4, #0]
   16b70:	f843 2b04 	str.w	r2, [r3], #4
        case STORAGE_TYPE_U32: write_ptr = write_setting<uint32_t>(write_ptr, s); break;
   16b74:	e7cd      	b.n	16b12 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const+0x42>
   16b76:	bf00      	nop
   16b78:	fffff000 	.word	0xfffff000
   16b7c:	1fff9d94 	.word	0x1fff9d94

00016b80 <TheDarkestTimeline_save(void*)>:
size_t TheDarkestTimeline_save(void *storage) {
   16b80:	b508      	push	{r3, lr}
   16b82:	4601      	mov	r1, r0
    return TheDarkestTimeline_instance.Save(storage);
   16b84:	4801      	ldr	r0, [pc, #4]	; (16b8c <TheDarkestTimeline_save(void*)+0xc>)
   16b86:	f7ff ffa3 	bl	16ad0 <settings::SettingsBase<TheDarkestTimeline, 8u>::Save(void*) const>
}
   16b8a:	bd08      	pop	{r3, pc}
   16b8c:	200024cc 	.word	0x200024cc

00016b90 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)>:
  size_t Restore(const void *storage) {
   16b90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    nibbles_ = 0;
   16b94:	f04f 0900 	mov.w	r9, #0
   16b98:	4f22      	ldr	r7, [pc, #136]	; (16c24 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x94>)
   16b9a:	f8a0 9020 	strh.w	r9, [r0, #32]
  size_t Restore(const void *storage) {
   16b9e:	4680      	mov	r8, r0
   16ba0:	460e      	mov	r6, r1
    const uint8_t *read_ptr = static_cast<const uint8_t *>(storage);
   16ba2:	460c      	mov	r4, r1
    nibbles_ = 0;
   16ba4:	464d      	mov	r5, r9
      switch(value_attr_[s].storage_type) {
   16ba6:	7d3b      	ldrb	r3, [r7, #20]
   16ba8:	2b06      	cmp	r3, #6
   16baa:	d811      	bhi.n	16bd0 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x40>
   16bac:	e8df f003 	tbb	[pc, r3]
   16bb0:	2a252004 	.word	0x2a252004
   16bb4:	342f      	.short	0x342f
   16bb6:	34          	.byte	0x34
   16bb7:	00          	.byte	0x00
    if (nibbles_) {
   16bb8:	f8b8 2020 	ldrh.w	r2, [r8, #32]
   16bbc:	b192      	cbz	r2, 16be4 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x54>
      value = nibbles_ & 0x0f;
   16bbe:	f002 020f 	and.w	r2, r2, #15
      nibbles_ = 0;
   16bc2:	2300      	movs	r3, #0
   16bc4:	f8a8 3020 	strh.w	r3, [r8, #32]
    apply_value(index, *storage++);
   16bc8:	4649      	mov	r1, r9
   16bca:	4640      	mov	r0, r8
   16bcc:	f7ff fcb8 	bl	16540 <settings::SettingsBase<TheDarkestTimeline, 8u>::apply_value(unsigned int, int)>
    for (size_t s = 0; s < num_settings; ++s) {
   16bd0:	f109 0901 	add.w	r9, r9, #1
   16bd4:	f1b9 0f08 	cmp.w	r9, #8
   16bd8:	f107 0718 	add.w	r7, r7, #24
   16bdc:	d1e3      	bne.n	16ba6 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x16>
  }
   16bde:	1ba0      	subs	r0, r4, r6
   16be0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      value = *src++;
   16be4:	f814 2b01 	ldrb.w	r2, [r4], #1
      nibbles_ = kNibbleValid | value;
   16be8:	f442 4370 	orr.w	r3, r2, #61440	; 0xf000
      value >>= 4;
   16bec:	0912      	lsrs	r2, r2, #4
   16bee:	e7e9      	b.n	16bc4 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x34>
    nibbles_ = 0;
   16bf0:	f8a8 5020 	strh.w	r5, [r8, #32]
    apply_value(index, *storage++);
   16bf4:	f914 2b01 	ldrsb.w	r2, [r4], #1
   16bf8:	e7e6      	b.n	16bc8 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x38>
    nibbles_ = 0;
   16bfa:	f8a8 5020 	strh.w	r5, [r8, #32]
    apply_value(index, *storage++);
   16bfe:	f814 2b01 	ldrb.w	r2, [r4], #1
   16c02:	e7e1      	b.n	16bc8 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x38>
    nibbles_ = 0;
   16c04:	f8a8 5020 	strh.w	r5, [r8, #32]
    apply_value(index, *storage++);
   16c08:	f934 2b02 	ldrsh.w	r2, [r4], #2
   16c0c:	e7dc      	b.n	16bc8 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x38>
    nibbles_ = 0;
   16c0e:	f8a8 5020 	strh.w	r5, [r8, #32]
    apply_value(index, *storage++);
   16c12:	f834 2b02 	ldrh.w	r2, [r4], #2
   16c16:	e7d7      	b.n	16bc8 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x38>
   16c18:	f854 2b04 	ldr.w	r2, [r4], #4
    nibbles_ = 0;
   16c1c:	f8a8 5020 	strh.w	r5, [r8, #32]
   16c20:	e7d2      	b.n	16bc8 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)+0x38>
   16c22:	bf00      	nop
   16c24:	1fff9d94 	.word	0x1fff9d94

00016c28 <TheDarkestTimeline_restore(void const*)>:
size_t TheDarkestTimeline_restore(const void *storage) {
   16c28:	b508      	push	{r3, lr}
   16c2a:	4601      	mov	r1, r0
    return TheDarkestTimeline_instance.Restore(storage);
   16c2c:	4801      	ldr	r0, [pc, #4]	; (16c34 <TheDarkestTimeline_restore(void const*)+0xc>)
   16c2e:	f7ff ffaf 	bl	16b90 <settings::SettingsBase<TheDarkestTimeline, 8u>::Restore(void const*)>
}
   16c32:	bd08      	pop	{r3, pc}
   16c34:	200024cc 	.word	0x200024cc

00016c38 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)>:
  bool Load(DATA_TYPE &data) {
   16c38:	b5f0      	push	{r4, r5, r6, r7, lr}
    page_index_ = -1;
   16c3a:	4605      	mov	r5, r0
   16c3c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   16c40:	f845 7b04 	str.w	r7, [r5], #4
  bool Load(DATA_TYPE &data) {
   16c44:	4604      	mov	r4, r0
   16c46:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
    memset(&page_, 0, sizeof(page_));
   16c4a:	f44f 724e 	mov.w	r2, #824	; 0x338
  bool Load(DATA_TYPE &data) {
   16c4e:	460e      	mov	r6, r1
    memset(&page_, 0, sizeof(page_));
   16c50:	4628      	mov	r0, r5
   16c52:	2100      	movs	r1, #0
   16c54:	f003 faa0 	bl	1a198 <memset>
      STORAGE::read(BASE_ADDR + i * PAGESIZE, &next_page, sizeof(next_page));
   16c58:	4669      	mov	r1, sp
    page_.header.generation = -1;
   16c5a:	60a7      	str	r7, [r4, #8]
      STORAGE::read(BASE_ADDR + i * PAGESIZE, &next_page, sizeof(next_page));
   16c5c:	f44f 724e 	mov.w	r2, #824	; 0x338
   16c60:	2080      	movs	r0, #128	; 0x80
   16c62:	f7ee f9c7 	bl	4ff4 <EEPROMStorage::read(unsigned int, void*, unsigned int)>
          (next_page.header.checksum != checksum(next_page)) ||
   16c66:	491e      	ldr	r1, [pc, #120]	; (16ce0 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0xa8>)
   16c68:	9b00      	ldr	r3, [sp, #0]
   16c6a:	428b      	cmp	r3, r1
   16c6c:	d12c      	bne.n	16cc8 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0x90>
      if ((DATA_TYPE::FOURCC != next_page.header.fourcc) ||
   16c6e:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   16c72:	f5b3 7f4b 	cmp.w	r3, #812	; 0x32c
   16c76:	d127      	bne.n	16cc8 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0x90>
          (next_page.header.checksum != checksum(next_page)) ||
   16c78:	f8bd 700a 	ldrh.w	r7, [sp, #10]
    while (length--) {
   16c7c:	f240 322d 	movw	r2, #813	; 0x32d
    const uint8_t *p = (const uint8_t *)&page.data;
   16c80:	a803      	add	r0, sp, #12
    uint16_t c = 0;
   16c82:	2300      	movs	r3, #0
    while (length--) {
   16c84:	3a01      	subs	r2, #1
   16c86:	d11a      	bne.n	16cbe <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0x86>
    return c ^ 0xffff;
   16c88:	43db      	mvns	r3, r3
          (sizeof(DATA_TYPE) != next_page.header.size) ||
   16c8a:	b29b      	uxth	r3, r3
   16c8c:	429f      	cmp	r7, r3
   16c8e:	d11b      	bne.n	16cc8 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0x90>
          (next_page.header.generation < page_.header.generation && (int32_t)page_.header.generation != -1)) {
   16c90:	68a3      	ldr	r3, [r4, #8]
          (next_page.header.checksum != checksum(next_page)) ||
   16c92:	9a01      	ldr	r2, [sp, #4]
   16c94:	429a      	cmp	r2, r3
   16c96:	d201      	bcs.n	16c9c <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0x64>
          (next_page.header.generation < page_.header.generation && (int32_t)page_.header.generation != -1)) {
   16c98:	3301      	adds	r3, #1
   16c9a:	d115      	bne.n	16cc8 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0x90>
      page_index_ = i;
   16c9c:	2300      	movs	r3, #0
   16c9e:	6023      	str	r3, [r4, #0]
      memcpy(&page_, &next_page, sizeof(page_));
   16ca0:	f44f 724e 	mov.w	r2, #824	; 0x338
   16ca4:	4669      	mov	r1, sp
   16ca6:	4628      	mov	r0, r5
   16ca8:	f003 f9a2 	bl	19ff0 <memcpy>
      memcpy(&data, &page_.data, sizeof(DATA_TYPE));
   16cac:	f44f 724b 	mov.w	r2, #812	; 0x32c
   16cb0:	f104 0110 	add.w	r1, r4, #16
   16cb4:	4630      	mov	r0, r6
   16cb6:	f003 f99b 	bl	19ff0 <memcpy>
      return true;
   16cba:	2001      	movs	r0, #1
   16cbc:	e00c      	b.n	16cd8 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0xa0>
      c += *p++;
   16cbe:	f810 cb01 	ldrb.w	ip, [r0], #1
   16cc2:	4463      	add	r3, ip
   16cc4:	b29b      	uxth	r3, r3
   16cc6:	e7dd      	b.n	16c84 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0x4c>
    if (-1 == page_index_) {
   16cc8:	6823      	ldr	r3, [r4, #0]
   16cca:	3301      	adds	r3, #1
   16ccc:	d1ee      	bne.n	16cac <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)+0x74>
      page_.header.size = sizeof(DATA_TYPE);
   16cce:	f44f 734b 	mov.w	r3, #812	; 0x32c
      page_.header.fourcc = DATA_TYPE::FOURCC;
   16cd2:	6061      	str	r1, [r4, #4]
      page_.header.size = sizeof(DATA_TYPE);
   16cd4:	81a3      	strh	r3, [r4, #12]
      return false;
   16cd6:	2000      	movs	r0, #0
  }
   16cd8:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
   16cdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16cde:	bf00      	nop
   16ce0:	4f435302 	.word	0x4f435302

00016ce4 <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)>:
  bool Load(DATA_TYPE &data) {
   16ce4:	b5f0      	push	{r4, r5, r6, r7, lr}
    page_index_ = -1;
   16ce6:	4605      	mov	r5, r0
   16ce8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   16cec:	f845 7b04 	str.w	r7, [r5], #4
  bool Load(DATA_TYPE &data) {
   16cf0:	4604      	mov	r4, r0
   16cf2:	f5ad 7d7f 	sub.w	sp, sp, #1020	; 0x3fc
    memset(&page_, 0, sizeof(page_));
   16cf6:	f44f 727d 	mov.w	r2, #1012	; 0x3f4
  bool Load(DATA_TYPE &data) {
   16cfa:	460e      	mov	r6, r1
    memset(&page_, 0, sizeof(page_));
   16cfc:	4628      	mov	r0, r5
   16cfe:	2100      	movs	r1, #0
   16d00:	f003 fa4a 	bl	1a198 <memset>
      STORAGE::read(BASE_ADDR + i * PAGESIZE, &next_page, sizeof(next_page));
   16d04:	a901      	add	r1, sp, #4
    page_.header.generation = -1;
   16d06:	60a7      	str	r7, [r4, #8]
      STORAGE::read(BASE_ADDR + i * PAGESIZE, &next_page, sizeof(next_page));
   16d08:	f44f 727d 	mov.w	r2, #1012	; 0x3f4
   16d0c:	f44f 7070 	mov.w	r0, #960	; 0x3c0
   16d10:	f7ee f970 	bl	4ff4 <EEPROMStorage::read(unsigned int, void*, unsigned int)>
          (next_page.header.checksum != checksum(next_page)) ||
   16d14:	491d      	ldr	r1, [pc, #116]	; (16d8c <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0xa8>)
   16d16:	9b01      	ldr	r3, [sp, #4]
   16d18:	428b      	cmp	r3, r1
   16d1a:	d12c      	bne.n	16d76 <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0x92>
      if ((DATA_TYPE::FOURCC != next_page.header.fourcc) ||
   16d1c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   16d20:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   16d24:	d127      	bne.n	16d76 <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0x92>
          (next_page.header.checksum != checksum(next_page)) ||
   16d26:	f8bd 700e 	ldrh.w	r7, [sp, #14]
    while (length--) {
   16d2a:	f240 32e9 	movw	r2, #1001	; 0x3e9
    const uint8_t *p = (const uint8_t *)&page.data;
   16d2e:	a804      	add	r0, sp, #16
    uint16_t c = 0;
   16d30:	2300      	movs	r3, #0
    while (length--) {
   16d32:	3a01      	subs	r2, #1
   16d34:	d11a      	bne.n	16d6c <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0x88>
    return c ^ 0xffff;
   16d36:	43db      	mvns	r3, r3
          (sizeof(DATA_TYPE) != next_page.header.size) ||
   16d38:	b29b      	uxth	r3, r3
   16d3a:	429f      	cmp	r7, r3
   16d3c:	d11b      	bne.n	16d76 <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0x92>
          (next_page.header.generation < page_.header.generation && (int32_t)page_.header.generation != -1)) {
   16d3e:	68a3      	ldr	r3, [r4, #8]
          (next_page.header.checksum != checksum(next_page)) ||
   16d40:	9a02      	ldr	r2, [sp, #8]
   16d42:	429a      	cmp	r2, r3
   16d44:	d201      	bcs.n	16d4a <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0x66>
          (next_page.header.generation < page_.header.generation && (int32_t)page_.header.generation != -1)) {
   16d46:	3301      	adds	r3, #1
   16d48:	d115      	bne.n	16d76 <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0x92>
      page_index_ = i;
   16d4a:	2300      	movs	r3, #0
   16d4c:	6023      	str	r3, [r4, #0]
      memcpy(&page_, &next_page, sizeof(page_));
   16d4e:	f44f 727d 	mov.w	r2, #1012	; 0x3f4
   16d52:	a901      	add	r1, sp, #4
   16d54:	4628      	mov	r0, r5
   16d56:	f003 f94b 	bl	19ff0 <memcpy>
      memcpy(&data, &page_.data, sizeof(DATA_TYPE));
   16d5a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   16d5e:	f104 0110 	add.w	r1, r4, #16
   16d62:	4630      	mov	r0, r6
   16d64:	f003 f944 	bl	19ff0 <memcpy>
      return true;
   16d68:	2001      	movs	r0, #1
   16d6a:	e00c      	b.n	16d86 <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0xa2>
      c += *p++;
   16d6c:	f810 cb01 	ldrb.w	ip, [r0], #1
   16d70:	4463      	add	r3, ip
   16d72:	b29b      	uxth	r3, r3
   16d74:	e7dd      	b.n	16d32 <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0x4e>
    if (-1 == page_index_) {
   16d76:	6823      	ldr	r3, [r4, #0]
   16d78:	3301      	adds	r3, #1
   16d7a:	d1ee      	bne.n	16d5a <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)+0x76>
      page_.header.size = sizeof(DATA_TYPE);
   16d7c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      page_.header.fourcc = DATA_TYPE::FOURCC;
   16d80:	6061      	str	r1, [r4, #4]
      page_.header.size = sizeof(DATA_TYPE);
   16d82:	81a3      	strh	r3, [r4, #12]
      return false;
   16d84:	2000      	movs	r0, #0
  }
   16d86:	f50d 7d7f 	add.w	sp, sp, #1020	; 0x3fc
   16d8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16d8c:	4f434104 	.word	0x4f434104

00016d90 <OC::apps::Init(bool)>:
void Init(bool reset_settings) {
   16d90:	b570      	push	{r4, r5, r6, lr}
   16d92:	4606      	mov	r6, r0
  Scales::Init();
   16d94:	f7ea f8d6 	bl	f44 <OC::Scales::Init()>
  AUTOTUNE::Init();
   16d98:	f7e9 fe82 	bl	aa0 <OC::AUTOTUNE::Init()>
  for (auto &app : available_apps)
   16d9c:	4d3a      	ldr	r5, [pc, #232]	; (16e88 <OC::apps::Init(bool)+0xf8>)
  AUTOTUNE::Init();
   16d9e:	240a      	movs	r4, #10
    app.Init();
   16da0:	68ab      	ldr	r3, [r5, #8]
   16da2:	4798      	blx	r3
  for (auto &app : available_apps)
   16da4:	3c01      	subs	r4, #1
   16da6:	f105 0534 	add.w	r5, r5, #52	; 0x34
   16daa:	d1f9      	bne.n	16da0 <OC::apps::Init(bool)+0x10>
  global_settings.current_app_id = DEFAULT_APP_ID;
   16dac:	4b37      	ldr	r3, [pc, #220]	; (16e8c <OC::apps::Init(bool)+0xfc>)
   16dae:	4d38      	ldr	r5, [pc, #224]	; (16e90 <OC::apps::Init(bool)+0x100>)
   16db0:	881b      	ldrh	r3, [r3, #0]
   16db2:	812b      	strh	r3, [r5, #8]
  global_settings.encoders_enable_acceleration = OC_ENCODERS_ENABLE_ACCELERATION_DEFAULT;
   16db4:	2301      	movs	r3, #1
   16db6:	802b      	strh	r3, [r5, #0]
  global_settings.reserved1 = false;
   16db8:	70ac      	strb	r4, [r5, #2]
  global_settings.DAC_scaling = VOLTAGE_SCALING_1V_PER_OCT; 
   16dba:	606c      	str	r4, [r5, #4]
  if (reset_settings) {
   16dbc:	2e00      	cmp	r6, #0
   16dbe:	d036      	beq.n	16e2e <OC::apps::Init(bool)+0x9e>
    if (ui.ConfirmReset()) {
   16dc0:	4834      	ldr	r0, [pc, #208]	; (16e94 <OC::apps::Init(bool)+0x104>)
   16dc2:	f7fc feaf 	bl	13b24 <OC::Ui::ConfirmReset()>
   16dc6:	2800      	cmp	r0, #0
   16dc8:	d031      	beq.n	16e2e <OC::apps::Init(bool)+0x9e>
   16dca:	2480      	movs	r4, #128	; 0x80
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
   16dcc:	4620      	mov	r0, r4
   16dce:	2100      	movs	r1, #0
   16dd0:	3401      	adds	r4, #1
   16dd2:	f003 f8e7 	bl	19fa4 <eeprom_write_byte>
      while (len--)
   16dd6:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
   16dda:	d1f7      	bne.n	16dcc <OC::apps::Init(bool)+0x3c>
    page_index_ = -1;
   16ddc:	4b2e      	ldr	r3, [pc, #184]	; (16e98 <OC::apps::Init(bool)+0x108>)
    page_.header.fourcc = DATA_TYPE::FOURCC;
   16dde:	492f      	ldr	r1, [pc, #188]	; (16e9c <OC::apps::Init(bool)+0x10c>)
   16de0:	6059      	str	r1, [r3, #4]
    page_index_ = -1;
   16de2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    page_.header.size = sizeof(DATA_TYPE);
   16de6:	f44f 714b 	mov.w	r1, #812	; 0x32c
    page_index_ = -1;
   16dea:	601a      	str	r2, [r3, #0]
    page_.header.size = sizeof(DATA_TYPE);
   16dec:	8199      	strh	r1, [r3, #12]
    page_index_ = -1;
   16dee:	4b2c      	ldr	r3, [pc, #176]	; (16ea0 <OC::apps::Init(bool)+0x110>)
   16df0:	601a      	str	r2, [r3, #0]
    page_.header.fourcc = DATA_TYPE::FOURCC;
   16df2:	4a2c      	ldr	r2, [pc, #176]	; (16ea4 <OC::apps::Init(bool)+0x114>)
   16df4:	605a      	str	r2, [r3, #4]
    page_.header.size = sizeof(DATA_TYPE);
   16df6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   16dfa:	819a      	strh	r2, [r3, #12]
  int current_app_index = apps::index_of(global_settings.current_app_id);
   16dfc:	8928      	ldrh	r0, [r5, #8]
   16dfe:	f7fc fdcf 	bl	139a0 <OC::apps::index_of(unsigned short)>
  if (current_app_index < 0 || current_app_index >= NUM_AVAILABLE_APPS) {
   16e02:	2809      	cmp	r0, #9
  int current_app_index = apps::index_of(global_settings.current_app_id);
   16e04:	4604      	mov	r4, r0
  ui.encoders_enable_acceleration(global_settings.encoders_enable_acceleration);
   16e06:	7829      	ldrb	r1, [r5, #0]
   16e08:	4822      	ldr	r0, [pc, #136]	; (16e94 <OC::apps::Init(bool)+0x104>)
    global_settings.current_app_id = DEFAULT_APP_INDEX;
   16e0a:	bf84      	itt	hi
   16e0c:	2400      	movhi	r4, #0
   16e0e:	812c      	strhhi	r4, [r5, #8]
  ui.encoders_enable_acceleration(global_settings.encoders_enable_acceleration);
   16e10:	f7ee f922 	bl	5058 <OC::Ui::encoders_enable_acceleration(bool)>
  set_current_app(current_app_index);
   16e14:	4620      	mov	r0, r4
   16e16:	f7fc fd6b 	bl	138f0 <OC::apps::set_current_app(int)>
  current_app->HandleAppEvent(APP_EVENT_RESUME);
   16e1a:	4b23      	ldr	r3, [pc, #140]	; (16ea8 <OC::apps::Init(bool)+0x118>)
   16e1c:	681b      	ldr	r3, [r3, #0]
   16e1e:	2001      	movs	r0, #1
   16e20:	699b      	ldr	r3, [r3, #24]
   16e22:	4798      	blx	r3
}
   16e24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  delay(100);
   16e28:	2064      	movs	r0, #100	; 0x64
   16e2a:	f003 bb2d 	b.w	1a488 <delay>
    if (!global_settings_storage.Load(global_settings)) {
   16e2e:	4918      	ldr	r1, [pc, #96]	; (16e90 <OC::apps::Init(bool)+0x100>)
   16e30:	4819      	ldr	r0, [pc, #100]	; (16e98 <OC::apps::Init(bool)+0x108>)
   16e32:	f7ff ff01 	bl	16c38 <PageStorage<EEPROMStorage, 128u, 960u, OC::GlobalSettings, (EStorageMode)0, true>::Load(OC::GlobalSettings&)>
   16e36:	b1f0      	cbz	r0, 16e76 <OC::apps::Init(bool)+0xe6>
      memcpy(user_scales, global_settings.user_scales, sizeof(user_scales));
   16e38:	491c      	ldr	r1, [pc, #112]	; (16eac <OC::apps::Init(bool)+0x11c>)
   16e3a:	481d      	ldr	r0, [pc, #116]	; (16eb0 <OC::apps::Init(bool)+0x120>)
   16e3c:	22a0      	movs	r2, #160	; 0xa0
   16e3e:	f003 f8d7 	bl	19ff0 <memcpy>
      memcpy(user_patterns, global_settings.user_patterns, sizeof(user_patterns));
   16e42:	491c      	ldr	r1, [pc, #112]	; (16eb4 <OC::apps::Init(bool)+0x124>)
   16e44:	481c      	ldr	r0, [pc, #112]	; (16eb8 <OC::apps::Init(bool)+0x128>)
   16e46:	f44f 7280 	mov.w	r2, #256	; 0x100
   16e4a:	f003 f8d1 	bl	19ff0 <memcpy>
      memcpy(HS::user_turing_machines, global_settings.user_turing_machines, sizeof(HS::user_turing_machines));
   16e4e:	491b      	ldr	r1, [pc, #108]	; (16ebc <OC::apps::Init(bool)+0x12c>)
   16e50:	481b      	ldr	r0, [pc, #108]	; (16ec0 <OC::apps::Init(bool)+0x130>)
   16e52:	22a0      	movs	r2, #160	; 0xa0
   16e54:	f003 f8cc 	bl	19ff0 <memcpy>
      memcpy(HS::user_waveforms, global_settings.user_waveforms, sizeof(HS::user_waveforms));
   16e58:	491a      	ldr	r1, [pc, #104]	; (16ec4 <OC::apps::Init(bool)+0x134>)
   16e5a:	481b      	ldr	r0, [pc, #108]	; (16ec8 <OC::apps::Init(bool)+0x138>)
   16e5c:	2280      	movs	r2, #128	; 0x80
   16e5e:	f003 f8c7 	bl	19ff0 <memcpy>
      memcpy(auto_calibration_data, global_settings.auto_calibration_data, sizeof(auto_calibration_data));
   16e62:	491a      	ldr	r1, [pc, #104]	; (16ecc <OC::apps::Init(bool)+0x13c>)
   16e64:	481a      	ldr	r0, [pc, #104]	; (16ed0 <OC::apps::Init(bool)+0x140>)
   16e66:	2260      	movs	r2, #96	; 0x60
   16e68:	f003 f8c2 	bl	19ff0 <memcpy>
      DAC::choose_calibration_data(); // either use default data, or auto_calibration_data
   16e6c:	f7e9 fb94 	bl	598 <OC::DAC::choose_calibration_data()>
      DAC::restore_scaling(global_settings.DAC_scaling); // recover output scaling settings
   16e70:	6868      	ldr	r0, [r5, #4]
   16e72:	f7e9 fbb3 	bl	5dc <OC::DAC::restore_scaling(unsigned long)>
    if (!app_data_storage.Load(app_settings)) {
   16e76:	4917      	ldr	r1, [pc, #92]	; (16ed4 <OC::apps::Init(bool)+0x144>)
   16e78:	4809      	ldr	r0, [pc, #36]	; (16ea0 <OC::apps::Init(bool)+0x110>)
   16e7a:	f7ff ff33 	bl	16ce4 <PageStorage<EEPROMStorage, 960u, 2048u, OC::AppData, (EStorageMode)0, true>::Load(OC::AppData&)>
   16e7e:	2800      	cmp	r0, #0
   16e80:	d0bc      	beq.n	16dfc <OC::apps::Init(bool)+0x6c>
      restore_app_data();
   16e82:	f7fc fd53 	bl	1392c <OC::restore_app_data()>
   16e86:	e7b9      	b.n	16dfc <OC::apps::Init(bool)+0x6c>
   16e88:	1fff9e54 	.word	0x1fff9e54
   16e8c:	200046d0 	.word	0x200046d0
   16e90:	20003b70 	.word	0x20003b70
   16e94:	1fffa7cc 	.word	0x1fffa7cc
   16e98:	2000438c 	.word	0x2000438c
   16e9c:	4f435302 	.word	0x4f435302
   16ea0:	20003e9c 	.word	0x20003e9c
   16ea4:	4f434104 	.word	0x4f434104
   16ea8:	1fff9d90 	.word	0x1fff9d90
   16eac:	20003b7c 	.word	0x20003b7c
   16eb0:	1fffa728 	.word	0x1fffa728
   16eb4:	20003c1c 	.word	0x20003c1c
   16eb8:	1fffa628 	.word	0x1fffa628
   16ebc:	20003d1c 	.word	0x20003d1c
   16ec0:	200036e8 	.word	0x200036e8
   16ec4:	20003dbc 	.word	0x20003dbc
   16ec8:	20003668 	.word	0x20003668
   16ecc:	20003e3c 	.word	0x20003e3c
   16ed0:	1fffa528 	.word	0x1fffa528
   16ed4:	20003788 	.word	0x20003788

00016ed8 <Backup::OnReceiveSysEx()>:
    void OnReceiveSysEx() {
   16ed8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16edc:	b08a      	sub	sp, #40	; 0x28
        if (ExtractSysExData(V, 'B')) {
   16ede:	2242      	movs	r2, #66	; 0x42
   16ee0:	a901      	add	r1, sp, #4
    void OnReceiveSysEx() {
   16ee2:	4606      	mov	r6, r0
        if (ExtractSysExData(V, 'B')) {
   16ee4:	f7ee fc0c 	bl	5700 <SystemExclusiveHandler::ExtractSysExData(unsigned char*, char)>
   16ee8:	b1d0      	cbz	r0, 16f20 <Backup::OnReceiveSysEx()+0x48>
            uint8_t p = V[ix++]; // Get packet number
   16eea:	f89d 7004 	ldrb.w	r7, [sp, #4]
            packet = p;
   16eee:	71f7      	strb	r7, [r6, #7]
            uint16_t address = p * 32;
   16ef0:	017c      	lsls	r4, r7, #5
            for (byte b = 0; b < 32; b++) EEPROM.write(address++, V[ix++]);
   16ef2:	ad01      	add	r5, sp, #4
   16ef4:	f104 0820 	add.w	r8, r4, #32
   16ef8:	4620      	mov	r0, r4
   16efa:	3401      	adds	r4, #1
   16efc:	f815 1f01 	ldrb.w	r1, [r5, #1]!
   16f00:	b2a4      	uxth	r4, r4
   16f02:	f003 f84f 	bl	19fa4 <eeprom_write_byte>
   16f06:	4544      	cmp	r4, r8
   16f08:	d1f6      	bne.n	16ef8 <Backup::OnReceiveSysEx()+0x20>
            if (p == ((EEPROM_CALIBRATIONDATA_END / 32) - 1) || p == 63) {
   16f0a:	2f03      	cmp	r7, #3
   16f0c:	d001      	beq.n	16f12 <Backup::OnReceiveSysEx()+0x3a>
   16f0e:	2f3f      	cmp	r7, #63	; 0x3f
   16f10:	d106      	bne.n	16f20 <Backup::OnReceiveSysEx()+0x48>
                receiving = 0;
   16f12:	2000      	movs	r0, #0
   16f14:	71b0      	strb	r0, [r6, #6]
    }
   16f16:	b00a      	add	sp, #40	; 0x28
   16f18:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
                OC::apps::Init(0);
   16f1c:	f7ff bf38 	b.w	16d90 <OC::apps::Init(bool)>
    }
   16f20:	b00a      	add	sp, #40	; 0x28
   16f22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00016f26 <OC::menu::ScreenCursor<5, true>::Scroll(int)>:
    int pos = cursor_pos_ + amount;
   16f26:	68c2      	ldr	r2, [r0, #12]
  void Scroll(int amount) {
   16f28:	b510      	push	{r4, lr}
    CONSTRAIN(pos, start_, end_);
   16f2a:	6844      	ldr	r4, [r0, #4]
    int pos = cursor_pos_ + amount;
   16f2c:	440a      	add	r2, r1
    CONSTRAIN(pos, start_, end_);
   16f2e:	4294      	cmp	r4, r2
   16f30:	dc10      	bgt.n	16f54 <OC::menu::ScreenCursor<5, true>::Scroll(int)+0x2e>
   16f32:	6883      	ldr	r3, [r0, #8]
   16f34:	429a      	cmp	r2, r3
   16f36:	bfa8      	it	ge
   16f38:	461a      	movge	r2, r3
    int screen_line = screen_line_ + amount;
   16f3a:	6903      	ldr	r3, [r0, #16]
    cursor_pos_ = pos;
   16f3c:	60c2      	str	r2, [r0, #12]
      if (amount < 0) {
   16f3e:	2900      	cmp	r1, #0
    int screen_line = screen_line_ + amount;
   16f40:	440b      	add	r3, r1
      if (amount < 0) {
   16f42:	da09      	bge.n	16f58 <OC::menu::ScreenCursor<5, true>::Scroll(int)+0x32>
        if (screen_line < 2) {
   16f44:	2b01      	cmp	r3, #1
   16f46:	dc03      	bgt.n	16f50 <OC::menu::ScreenCursor<5, true>::Scroll(int)+0x2a>
          if (pos >= start_ + 1)
   16f48:	4294      	cmp	r4, r2
   16f4a:	bfac      	ite	ge
   16f4c:	2300      	movge	r3, #0
   16f4e:	2301      	movlt	r3, #1
    screen_line_ = screen_line;
   16f50:	6103      	str	r3, [r0, #16]
  }
   16f52:	bd10      	pop	{r4, pc}
   16f54:	4622      	mov	r2, r4
   16f56:	e7f0      	b.n	16f3a <OC::menu::ScreenCursor<5, true>::Scroll(int)+0x14>
        if (screen_line >= screen_lines - 2) {
   16f58:	2b02      	cmp	r3, #2
   16f5a:	ddf9      	ble.n	16f50 <OC::menu::ScreenCursor<5, true>::Scroll(int)+0x2a>
          if (pos <= end_ - 1)
   16f5c:	6883      	ldr	r3, [r0, #8]
            screen_line = screen_lines - 1;
   16f5e:	4293      	cmp	r3, r2
   16f60:	bfcc      	ite	gt
   16f62:	2303      	movgt	r3, #3
   16f64:	2304      	movle	r3, #4
   16f66:	e7f3      	b.n	16f50 <OC::menu::ScreenCursor<5, true>::Scroll(int)+0x2a>

00016f68 <OC::Ui::AppSettings()>:
void Ui::AppSettings() {
   16f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  apps::current_app->HandleAppEvent(APP_EVENT_SUSPEND);
   16f6c:	f8df 9170 	ldr.w	r9, [pc, #368]	; 170e0 <OC::Ui::AppSettings()+0x178>
   16f70:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
   16f74:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
   16f78:	f8d9 3000 	ldr.w	r3, [r9]
  cursor.Scroll(apps::index_of(global_settings.current_app_id));
   16f7c:	4f59      	ldr	r7, [pc, #356]	; (170e4 <OC::Ui::AppSettings()+0x17c>)
  apps::current_app->HandleAppEvent(APP_EVENT_SUSPEND);
   16f7e:	699b      	ldr	r3, [r3, #24]
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
   16f80:	f8df 8164 	ldr.w	r8, [pc, #356]	; 170e8 <OC::Ui::AppSettings()+0x180>
        ui.encoders_enable_acceleration(enabled);
   16f84:	4d59      	ldr	r5, [pc, #356]	; (170ec <OC::Ui::AppSettings()+0x184>)
void Ui::AppSettings() {
   16f86:	b08d      	sub	sp, #52	; 0x34
   16f88:	4604      	mov	r4, r0
  apps::current_app->HandleAppEvent(APP_EVENT_SUSPEND);
   16f8a:	2000      	movs	r0, #0
   16f8c:	4798      	blx	r3
  ScreenCursor() { }
   16f8e:	2600      	movs	r6, #0
    end_ = end;
   16f90:	2309      	movs	r3, #9
  cursor.Scroll(apps::index_of(global_settings.current_app_id));
   16f92:	8938      	ldrh	r0, [r7, #8]
   16f94:	9309      	str	r3, [sp, #36]	; 0x24
  ScreenCursor() { }
   16f96:	9607      	str	r6, [sp, #28]
    start_ = start;
   16f98:	9608      	str	r6, [sp, #32]
    cursor_pos_ = start;
   16f9a:	960a      	str	r6, [sp, #40]	; 0x28
    screen_line_ = 0;
   16f9c:	960b      	str	r6, [sp, #44]	; 0x2c
   16f9e:	f7fc fcff 	bl	139a0 <OC::apps::index_of(unsigned short)>
   16fa2:	4601      	mov	r1, r0
   16fa4:	a807      	add	r0, sp, #28
   16fa6:	f7ff ffbe 	bl	16f26 <OC::menu::ScreenCursor<5, true>::Scroll(int)>
   16faa:	f8d8 3000 	ldr.w	r3, [r8]
   16fae:	9304      	str	r3, [sp, #16]
    return millis() - last_event_time_;
   16fb0:	f8d4 20f8 	ldr.w	r2, [r4, #248]	; 0xf8
	return ret;
   16fb4:	9b04      	ldr	r3, [sp, #16]
   16fb6:	1a9b      	subs	r3, r3, r2
  while (!change_app && idle_time() < APP_SELECTION_TIMEOUT_MS) {
   16fb8:	f246 12a7 	movw	r2, #24999	; 0x61a7
   16fbc:	4293      	cmp	r3, r2
   16fbe:	f04f 0b00 	mov.w	fp, #0
   16fc2:	d830      	bhi.n	17026 <OC::Ui::AppSettings()+0xbe>
    T value = buffer_[read_ptr & (size - 1)];
   16fc4:	f104 0a6c 	add.w	sl, r4, #108	; 0x6c
   16fc8:	e021      	b.n	1700e <OC::Ui::AppSettings()+0xa6>
    size_t read_ptr = read_ptr_;
   16fca:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
    T value = buffer_[read_ptr & (size - 1)];
   16fce:	f000 020f 	and.w	r2, r0, #15
   16fd2:	eb0a 01c2 	add.w	r1, sl, r2, lsl #3
   16fd6:	f81a 3032 	ldrb.w	r3, [sl, r2, lsl #3]
   16fda:	8849      	ldrh	r1, [r1, #2]
   16fdc:	9303      	str	r3, [sp, #12]
   16fde:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    read_ptr_ = read_ptr + 1;
   16fe2:	3001      	adds	r0, #1
    T value = buffer_[read_ptr & (size - 1)];
   16fe4:	f9b2 2070 	ldrsh.w	r2, [r2, #112]	; 0x70
    read_ptr_ = read_ptr + 1;
   16fe8:	f8c4 00f0 	str.w	r0, [r4, #240]	; 0xf0
      if (IgnoreEvent(event))
   16fec:	4620      	mov	r0, r4
    T value = buffer_[read_ptr & (size - 1)];
   16fee:	9202      	str	r2, [sp, #8]
   16ff0:	9101      	str	r1, [sp, #4]
   16ff2:	f7ed fde7 	bl	4bc4 <OC::Ui::IgnoreEvent(UI::Event const&) [clone .isra.0]>
   16ff6:	b950      	cbnz	r0, 1700e <OC::Ui::AppSettings()+0xa6>
      if (UI::EVENT_ENCODER == event.type && CONTROL_ENCODER_R == event.control) {
   16ff8:	9b03      	ldr	r3, [sp, #12]
   16ffa:	9901      	ldr	r1, [sp, #4]
   16ffc:	9a02      	ldr	r2, [sp, #8]
   16ffe:	2b03      	cmp	r3, #3
   17000:	d135      	bne.n	1706e <OC::Ui::AppSettings()+0x106>
   17002:	2940      	cmp	r1, #64	; 0x40
   17004:	d133      	bne.n	1706e <OC::Ui::AppSettings()+0x106>
        cursor.Scroll(event.value);
   17006:	4611      	mov	r1, r2
   17008:	a807      	add	r0, sp, #28
   1700a:	f7ff ff8c 	bl	16f26 <OC::menu::ScreenCursor<5, true>::Scroll(int)>
    return write_ptr_ - read_ptr_;
   1700e:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
   17012:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    while (event_queue_.available()) {
   17016:	429a      	cmp	r2, r3
   17018:	d1d7      	bne.n	16fca <OC::Ui::AppSettings()+0x62>
    draw_app_menu(cursor);
   1701a:	a807      	add	r0, sp, #28
   1701c:	f7fc fcd0 	bl	139c0 <OC::draw_app_menu(OC::menu::ScreenCursor<5, true> const&)>
  while (!change_app && idle_time() < APP_SELECTION_TIMEOUT_MS) {
   17020:	f1bb 0f00 	cmp.w	fp, #0
   17024:	d0c1      	beq.n	16faa <OC::Ui::AppSettings()+0x42>
    write_ptr_ = read_ptr_ = 0;
   17026:	2500      	movs	r5, #0
   17028:	f8c4 50f0 	str.w	r5, [r4, #240]	; 0xf0
   1702c:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
   17030:	f8d8 3000 	ldr.w	r3, [r8]
   17034:	9305      	str	r3, [sp, #20]
	return ret;
   17036:	9b05      	ldr	r3, [sp, #20]
  CORE::app_isr_enabled = false;
   17038:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 170f0 <OC::Ui::AppSettings()+0x188>
    last_event_time_ = millis();
   1703c:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
  delay(1);
   17040:	2001      	movs	r0, #1
  CORE::app_isr_enabled = false;
   17042:	f88a 5000 	strb.w	r5, [sl]
  delay(1);
   17046:	f003 fa1f 	bl	1a488 <delay>
  if (change_app) {
   1704a:	f1bb 0f00 	cmp.w	fp, #0
   1704e:	d128      	bne.n	170a2 <OC::Ui::AppSettings()+0x13a>
  OC::ui.encoders_enable_acceleration(global_settings.encoders_enable_acceleration);
   17050:	7839      	ldrb	r1, [r7, #0]
   17052:	4826      	ldr	r0, [pc, #152]	; (170ec <OC::Ui::AppSettings()+0x184>)
   17054:	f7ee f800 	bl	5058 <OC::Ui::encoders_enable_acceleration(bool)>
  apps::current_app->HandleAppEvent(APP_EVENT_RESUME);
   17058:	f8d9 3000 	ldr.w	r3, [r9]
   1705c:	2001      	movs	r0, #1
   1705e:	699b      	ldr	r3, [r3, #24]
   17060:	4798      	blx	r3
  CORE::app_isr_enabled = true;
   17062:	2301      	movs	r3, #1
   17064:	f88a 3000 	strb.w	r3, [sl]
}
   17068:	b00d      	add	sp, #52	; 0x34
   1706a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      } else if (CONTROL_BUTTON_R == event.control) {
   1706e:	2908      	cmp	r1, #8
   17070:	d105      	bne.n	1707e <OC::Ui::AppSettings()+0x116>
        save = event.type == UI::EVENT_BUTTON_LONG_PRESS;
   17072:	3b02      	subs	r3, #2
   17074:	425e      	negs	r6, r3
   17076:	415e      	adcs	r6, r3
        change_app = true;
   17078:	f04f 0b01 	mov.w	fp, #1
   1707c:	e7c7      	b.n	1700e <OC::Ui::AppSettings()+0xa6>
      } else if (CONTROL_BUTTON_L == event.control) {
   1707e:	2904      	cmp	r1, #4
   17080:	d103      	bne.n	1708a <OC::Ui::AppSettings()+0x122>
        ui.DebugStats();
   17082:	4628      	mov	r0, r5
   17084:	f7e9 fe42 	bl	d0c <OC::Ui::DebugStats()>
   17088:	e7c1      	b.n	1700e <OC::Ui::AppSettings()+0xa6>
      } else if (CONTROL_BUTTON_UP == event.control) {
   1708a:	2901      	cmp	r1, #1
   1708c:	d1bf      	bne.n	1700e <OC::Ui::AppSettings()+0xa6>
        bool enabled = !global_settings.encoders_enable_acceleration;
   1708e:	7839      	ldrb	r1, [r7, #0]
        ui.encoders_enable_acceleration(enabled);
   17090:	4628      	mov	r0, r5
        bool enabled = !global_settings.encoders_enable_acceleration;
   17092:	f081 0101 	eor.w	r1, r1, #1
        ui.encoders_enable_acceleration(enabled);
   17096:	9101      	str	r1, [sp, #4]
   17098:	f7ed ffde 	bl	5058 <OC::Ui::encoders_enable_acceleration(bool)>
        global_settings.encoders_enable_acceleration = enabled;
   1709c:	9901      	ldr	r1, [sp, #4]
   1709e:	7039      	strb	r1, [r7, #0]
   170a0:	e7b5      	b.n	1700e <OC::Ui::AppSettings()+0xa6>
    apps::set_current_app(cursor.cursor_pos());
   170a2:	980a      	ldr	r0, [sp, #40]	; 0x28
   170a4:	f7fc fc24 	bl	138f0 <OC::apps::set_current_app(int)>
    FreqMeasure.end();
   170a8:	f001 fefe 	bl	18ea8 <FreqMeasureClass::end()>
    OC::DigitalInputs::reInit();
   170ac:	f7e9 fee2 	bl	e74 <OC::DigitalInputs::reInit()>
    if (save) {
   170b0:	2e00      	cmp	r6, #0
   170b2:	d0cd      	beq.n	17050 <OC::Ui::AppSettings()+0xe8>
      save_global_settings();
   170b4:	f7fc fb44 	bl	13740 <OC::save_global_settings()>
      save_app_data();
   170b8:	f7fc fba2 	bl	13800 <OC::save_app_data()>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
   170bc:	f8d8 3000 	ldr.w	r3, [r8]
   170c0:	9306      	str	r3, [sp, #24]
	return ret;
   170c2:	9b06      	ldr	r3, [sp, #24]
    return millis() - last_event_time_;
   170c4:	f8d4 20f8 	ldr.w	r2, [r4, #248]	; 0xf8
   170c8:	1a9b      	subs	r3, r3, r2
      while(idle_time() < SETTINGS_SAVE_TIMEOUT_MS)
   170ca:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   170ce:	d2bf      	bcs.n	17050 <OC::Ui::AppSettings()+0xe8>
        draw_save_message((cnt++) >> 4);
   170d0:	f3c5 1007 	ubfx	r0, r5, #4, #8
   170d4:	1c6e      	adds	r6, r5, #1
   170d6:	f7fc fce7 	bl	13aa8 <OC::draw_save_message(unsigned char)>
   170da:	4635      	mov	r5, r6
   170dc:	e7ee      	b.n	170bc <OC::Ui::AppSettings()+0x154>
   170de:	bf00      	nop
   170e0:	1fff9d90 	.word	0x1fff9d90
   170e4:	20003b70 	.word	0x20003b70
   170e8:	20006600 	.word	0x20006600
   170ec:	1fffa7cc 	.word	0x1fffa7cc
   170f0:	200046c8 	.word	0x200046c8

000170f4 <OC::menu::TitleBar<0, 1, 2>::Draw()>:
  inline static void Draw() {
   170f4:	b508      	push	{r3, lr}
    if (OC::DAC::get_voltage_scaling(DAC_CHANNEL_A) || OC::DAC::get_voltage_scaling(DAC_CHANNEL_B) || OC::DAC::get_voltage_scaling(DAC_CHANNEL_C) || OC::DAC::get_voltage_scaling(DAC_CHANNEL_D))
   170f6:	2000      	movs	r0, #0
   170f8:	f7e9 fa62 	bl	5c0 <OC::DAC::get_voltage_scaling(unsigned char)>
   170fc:	b150      	cbz	r0, 17114 <OC::menu::TitleBar<0, 1, 2>::Draw()+0x20>
      graphics.drawHLineDots(start_x, kMenuLineH, kDisplayWidth - start_x);
   170fe:	4810      	ldr	r0, [pc, #64]	; (17140 <OC::menu::TitleBar<0, 1, 2>::Draw()+0x4c>)
   17100:	2380      	movs	r3, #128	; 0x80
   17102:	220c      	movs	r2, #12
   17104:	2100      	movs	r1, #0
   17106:	f002 fa0d 	bl	19524 <weegfx::Graphics::drawHLineDots(int, int, int)>
  text_x_ = x;
   1710a:	4b0d      	ldr	r3, [pc, #52]	; (17140 <OC::menu::TitleBar<0, 1, 2>::Draw()+0x4c>)
   1710c:	2202      	movs	r2, #2
   1710e:	605a      	str	r2, [r3, #4]
  text_y_ = y;
   17110:	609a      	str	r2, [r3, #8]
  }
   17112:	bd08      	pop	{r3, pc}
    if (OC::DAC::get_voltage_scaling(DAC_CHANNEL_A) || OC::DAC::get_voltage_scaling(DAC_CHANNEL_B) || OC::DAC::get_voltage_scaling(DAC_CHANNEL_C) || OC::DAC::get_voltage_scaling(DAC_CHANNEL_D))
   17114:	2001      	movs	r0, #1
   17116:	f7e9 fa53 	bl	5c0 <OC::DAC::get_voltage_scaling(unsigned char)>
   1711a:	2800      	cmp	r0, #0
   1711c:	d1ef      	bne.n	170fe <OC::menu::TitleBar<0, 1, 2>::Draw()+0xa>
   1711e:	2002      	movs	r0, #2
   17120:	f7e9 fa4e 	bl	5c0 <OC::DAC::get_voltage_scaling(unsigned char)>
   17124:	2800      	cmp	r0, #0
   17126:	d1ea      	bne.n	170fe <OC::menu::TitleBar<0, 1, 2>::Draw()+0xa>
   17128:	2003      	movs	r0, #3
   1712a:	f7e9 fa49 	bl	5c0 <OC::DAC::get_voltage_scaling(unsigned char)>
   1712e:	4601      	mov	r1, r0
   17130:	2800      	cmp	r0, #0
   17132:	d1e4      	bne.n	170fe <OC::menu::TitleBar<0, 1, 2>::Draw()+0xa>
      graphics.drawHLine(start_x, kMenuLineH, kDisplayWidth - start_x);
   17134:	4802      	ldr	r0, [pc, #8]	; (17140 <OC::menu::TitleBar<0, 1, 2>::Draw()+0x4c>)
   17136:	2380      	movs	r3, #128	; 0x80
   17138:	220c      	movs	r2, #12
   1713a:	f002 f9d0 	bl	194de <weegfx::Graphics::drawHLine(int, int, int)>
   1713e:	e7e4      	b.n	1710a <OC::menu::TitleBar<0, 1, 2>::Draw()+0x16>
   17140:	200065e0 	.word	0x200065e0

00017144 <calibration_draw(CalibrationState const&)>:
void calibration_draw(const CalibrationState &state) {
   17144:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    return write_ptr_ - read_ptr_;
   17148:	4f89      	ldr	r7, [pc, #548]	; (17370 <calibration_draw(CalibrationState const&)+0x22c>)
   1714a:	4606      	mov	r6, r0
   1714c:	f8d7 2808 	ldr.w	r2, [r7, #2056]	; 0x808
   17150:	f8d7 380c 	ldr.w	r3, [r7, #2060]	; 0x80c
  GRAPHICS_BEGIN_FRAME(true);
   17154:	1a9b      	subs	r3, r3, r2
   17156:	3302      	adds	r3, #2
   17158:	d0f8      	beq.n	1714c <calibration_draw(CalibrationState const&)+0x8>
    return frame_buffers_[write_ptr_ % frames];
   1715a:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
   1715e:	f003 0301 	and.w	r3, r3, #1
   17162:	f503 7300 	add.w	r3, r3, #512	; 0x200
   17166:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
   1716a:	2900      	cmp	r1, #0
   1716c:	d0ee      	beq.n	1714c <calibration_draw(CalibrationState const&)+0x8>
   1716e:	4d81      	ldr	r5, [pc, #516]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   17170:	2201      	movs	r2, #1
   17172:	4628      	mov	r0, r5
   17174:	f002 f87d 	bl	19272 <weegfx::Graphics::Begin(unsigned char*, bool)>
  const CalibrationStep *step = state.current_step;
   17178:	6874      	ldr	r4, [r6, #4]
  menu::DefaultTitleBar::Draw();
   1717a:	f7ff ffbb 	bl	170f4 <OC::menu::TitleBar<0, 1, 2>::Draw()>
  graphics.print(step->title);
   1717e:	6861      	ldr	r1, [r4, #4]
   17180:	4628      	mov	r0, r5
   17182:	f002 fca8 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
   17186:	2302      	movs	r3, #2
   17188:	606b      	str	r3, [r5, #4]
  text_y_ = y;
   1718a:	2311      	movs	r3, #17
   1718c:	60ab      	str	r3, [r5, #8]
  switch (step->calibration_type) {
   1718e:	7d23      	ldrb	r3, [r4, #20]
   17190:	3b01      	subs	r3, #1
   17192:	2b07      	cmp	r3, #7
   17194:	f200 80b2 	bhi.w	172fc <calibration_draw(CalibrationState const&)+0x1b8>
   17198:	e8df f003 	tbb	[pc, r3]
   1719c:	63040404 	.word	0x63040404
   171a0:	04739c9c 	.word	0x04739c9c
      graphics.print(step->message);
   171a4:	68a1      	ldr	r1, [r4, #8]
   171a6:	4873      	ldr	r0, [pc, #460]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   171a8:	f002 fc95 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
   171ac:	2362      	movs	r3, #98	; 0x62
   171ae:	606b      	str	r3, [r5, #4]
      graphics.print((int)state.encoder_value, 5);
   171b0:	68b1      	ldr	r1, [r6, #8]
  text_y_ = y;
   171b2:	2311      	movs	r3, #17
   171b4:	60ab      	str	r3, [r5, #8]
   171b6:	2205      	movs	r2, #5
      graphics.print((int)OC::ADC::value(static_cast<ADC_CHANNEL>(step->index)), 5);
   171b8:	486e      	ldr	r0, [pc, #440]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   171ba:	f002 fd0d 	bl	19bd8 <weegfx::Graphics::print(int, unsigned int)>
      menu::DrawEditIcon(kValueX, y, state.encoder_value, step->min, step->max);
   171be:	68b2      	ldr	r2, [r6, #8]
  if (value == max_value)
   171c0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   171c2:	6a20      	ldr	r0, [r4, #32]
   171c4:	429a      	cmp	r2, r3
   171c6:	d05a      	beq.n	1727e <calibration_draw(CalibrationState const&)+0x13a>
    src += OC::kBitmapEditIndicatorW;
   171c8:	4b6b      	ldr	r3, [pc, #428]	; (17378 <calibration_draw(CalibrationState const&)+0x234>)
   171ca:	1d59      	adds	r1, r3, #5
   171cc:	4282      	cmp	r2, r0
   171ce:	bf08      	it	eq
   171d0:	460b      	moveq	r3, r1
  graphics.drawBitmap8(x - 5, y + 1, OC::kBitmapEditIndicatorW, src);
   171d2:	9300      	str	r3, [sp, #0]
   171d4:	4867      	ldr	r0, [pc, #412]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   171d6:	2305      	movs	r3, #5
   171d8:	2210      	movs	r2, #16
   171da:	215d      	movs	r1, #93	; 0x5d
   171dc:	f002 fa32 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
  weegfx::coord_t y = menu::CalcLineY(0);
   171e0:	230f      	movs	r3, #15
  if (step->help)
   171e2:	68e1      	ldr	r1, [r4, #12]
  text_x_ = x;
   171e4:	2202      	movs	r2, #2
  graphics.setPrintPos(menu::kIndentDx, y + 2);
   171e6:	330e      	adds	r3, #14
   171e8:	606a      	str	r2, [r5, #4]
  text_y_ = y;
   171ea:	60ab      	str	r3, [r5, #8]
  if (step->help)
   171ec:	b111      	cbz	r1, 171f4 <calibration_draw(CalibrationState const&)+0xb0>
    graphics.print(step->help);
   171ee:	4861      	ldr	r0, [pc, #388]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   171f0:	f002 fc71 	bl	19ad6 <weegfx::Graphics::print(char const*)>
   171f4:	f8df 8184 	ldr.w	r8, [pc, #388]	; 1737c <calibration_draw(CalibrationState const&)+0x238>
      graphics.drawBitmap8(x, y, 4, OC::bitmap_gate_indicators_8 + (state << 2));
   171f8:	f8df 9184 	ldr.w	r9, [pc, #388]	; 17380 <calibration_draw(CalibrationState const&)+0x23c>
   171fc:	f8df a174 	ldr.w	sl, [pc, #372]	; 17374 <calibration_draw(CalibrationState const&)+0x230>
  weegfx::coord_t y = menu::CalcLineY(0);
   17200:	256a      	movs	r5, #106	; 0x6a

  uint8_t getState() const {
    return phase_ >> 28;
   17202:	f858 3b04 	ldr.w	r3, [r8], #4
   17206:	0f1b      	lsrs	r3, r3, #28
    uint8_t state = (digital_input_displays[input].getState() + 3) >> 2;
   17208:	3303      	adds	r3, #3
    if (state)
   1720a:	089a      	lsrs	r2, r3, #2
   1720c:	d009      	beq.n	17222 <calibration_draw(CalibrationState const&)+0xde>
      graphics.drawBitmap8(x, y, 4, OC::bitmap_gate_indicators_8 + (state << 2));
   1720e:	f023 0303 	bic.w	r3, r3, #3
   17212:	444b      	add	r3, r9
   17214:	9300      	str	r3, [sp, #0]
   17216:	2202      	movs	r2, #2
   17218:	2304      	movs	r3, #4
   1721a:	4629      	mov	r1, r5
   1721c:	4650      	mov	r0, sl
   1721e:	f002 fa11 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
    x += 5;
   17222:	3505      	adds	r5, #5
  for (int input = OC::DIGITAL_INPUT_1; input < OC::DIGITAL_INPUT_LAST; ++input) {
   17224:	2d7e      	cmp	r5, #126	; 0x7e
   17226:	d1ec      	bne.n	17202 <calibration_draw(CalibrationState const&)+0xbe>
  graphics.drawStr(1, menu::kDisplayHeight - menu::kFontHeight - 3, step->footer);
   17228:	6923      	ldr	r3, [r4, #16]
   1722a:	4852      	ldr	r0, [pc, #328]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   1722c:	2235      	movs	r2, #53	; 0x35
   1722e:	2101      	movs	r1, #1
   17230:	f002 fc91 	bl	19b56 <weegfx::Graphics::drawStr(int, int, char const*)>
  graphics.drawRect(0, menu::kDisplayHeight - 2, (state.step * step_width) >> 8, 2);
   17234:	7833      	ldrb	r3, [r6, #0]
   17236:	484f      	ldr	r0, [pc, #316]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   17238:	f240 2253 	movw	r2, #595	; 0x253
   1723c:	4353      	muls	r3, r2
   1723e:	2202      	movs	r2, #2
   17240:	9200      	str	r2, [sp, #0]
   17242:	0a1b      	lsrs	r3, r3, #8
   17244:	223e      	movs	r2, #62	; 0x3e
   17246:	2100      	movs	r1, #0
   17248:	f002 f824 	bl	19294 <weegfx::Graphics::drawRect(int, int, int, int)>
  GRAPHICS_END_FRAME();
   1724c:	4849      	ldr	r0, [pc, #292]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   1724e:	f002 f81e 	bl	1928e <weegfx::Graphics::End()>
    ++write_ptr_;
   17252:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
   17256:	3301      	adds	r3, #1
   17258:	f8c7 3808 	str.w	r3, [r7, #2056]	; 0x808
}
   1725c:	b002      	add	sp, #8
   1725e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      graphics.print(step->message);
   17262:	68a1      	ldr	r1, [r4, #8]
   17264:	4843      	ldr	r0, [pc, #268]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   17266:	f002 fc36 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
   1726a:	2362      	movs	r3, #98	; 0x62
   1726c:	606b      	str	r3, [r5, #4]
      graphics.print((int)OC::ADC::value(static_cast<ADC_CHANNEL>(step->index)), 5);
   1726e:	7e20      	ldrb	r0, [r4, #24]
  text_y_ = y;
   17270:	2311      	movs	r3, #17
   17272:	60ab      	str	r3, [r5, #8]
   17274:	f7ed fe8a 	bl	4f8c <OC::ADC::value(ADC_CHANNEL)>
   17278:	2205      	movs	r2, #5
   1727a:	4601      	mov	r1, r0
   1727c:	e79c      	b.n	171b8 <calibration_draw(CalibrationState const&)+0x74>
    src += OC::kBitmapEditIndicatorW * 2;
   1727e:	4b41      	ldr	r3, [pc, #260]	; (17384 <calibration_draw(CalibrationState const&)+0x240>)
   17280:	e7a7      	b.n	171d2 <calibration_draw(CalibrationState const&)+0x8e>
      graphics.print(step->message);
   17282:	68a1      	ldr	r1, [r4, #8]
   17284:	483b      	ldr	r0, [pc, #236]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   17286:	f002 fc26 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
   1728a:	2362      	movs	r3, #98	; 0x62
      graphics.pretty_print((int)state.encoder_value, 2);
   1728c:	4839      	ldr	r0, [pc, #228]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   1728e:	606b      	str	r3, [r5, #4]
   17290:	2202      	movs	r2, #2
  text_y_ = y;
   17292:	2311      	movs	r3, #17
   17294:	68b1      	ldr	r1, [r6, #8]
   17296:	60ab      	str	r3, [r5, #8]
   17298:	f002 fcdd 	bl	19c56 <weegfx::Graphics::pretty_print(int, unsigned int)>
      menu::DrawEditIcon(kValueX, y, state.encoder_value, step->min, step->max);
   1729c:	68b2      	ldr	r2, [r6, #8]
  if (value == max_value)
   1729e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   172a0:	6a20      	ldr	r0, [r4, #32]
   172a2:	429a      	cmp	r2, r3
   172a4:	d014      	beq.n	172d0 <calibration_draw(CalibrationState const&)+0x18c>
    src += OC::kBitmapEditIndicatorW;
   172a6:	4b34      	ldr	r3, [pc, #208]	; (17378 <calibration_draw(CalibrationState const&)+0x234>)
   172a8:	1d59      	adds	r1, r3, #5
   172aa:	4282      	cmp	r2, r0
   172ac:	bf08      	it	eq
   172ae:	460b      	moveq	r3, r1
  graphics.drawBitmap8(x - 5, y + 1, OC::kBitmapEditIndicatorW, src);
   172b0:	9300      	str	r3, [sp, #0]
   172b2:	4830      	ldr	r0, [pc, #192]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   172b4:	2305      	movs	r3, #5
   172b6:	2210      	movs	r2, #16
   172b8:	215d      	movs	r1, #93	; 0x5d
   172ba:	f002 f9c3 	bl	19644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>
      graphics.drawFrame(0, 0, 128, 64);
   172be:	2340      	movs	r3, #64	; 0x40
   172c0:	2200      	movs	r2, #0
   172c2:	9300      	str	r3, [sp, #0]
   172c4:	482b      	ldr	r0, [pc, #172]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   172c6:	2380      	movs	r3, #128	; 0x80
   172c8:	4611      	mov	r1, r2
   172ca:	f002 f996 	bl	195fa <weegfx::Graphics::drawFrame(int, int, int, int)>
      break;
   172ce:	e787      	b.n	171e0 <calibration_draw(CalibrationState const&)+0x9c>
    src += OC::kBitmapEditIndicatorW * 2;
   172d0:	4b2c      	ldr	r3, [pc, #176]	; (17384 <calibration_draw(CalibrationState const&)+0x240>)
   172d2:	e7ed      	b.n	172b0 <calibration_draw(CalibrationState const&)+0x16c>
      graphics.print(step->message);
   172d4:	68a1      	ldr	r1, [r4, #8]
   172d6:	4827      	ldr	r0, [pc, #156]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   172d8:	f002 fbfd 	bl	19ad6 <weegfx::Graphics::print(char const*)>
  text_x_ = x;
   172dc:	f04f 0802 	mov.w	r8, #2
  text_y_ = y;
   172e0:	231d      	movs	r3, #29
      graphics.print((int)OC::ADC::value(ADC_CHANNEL_1), 2);
   172e2:	2000      	movs	r0, #0
  text_x_ = x;
   172e4:	f8c5 8004 	str.w	r8, [r5, #4]
  text_y_ = y;
   172e8:	60ab      	str	r3, [r5, #8]
   172ea:	f7ed fe4f 	bl	4f8c <OC::ADC::value(ADC_CHANNEL)>
   172ee:	4642      	mov	r2, r8
   172f0:	4601      	mov	r1, r0
   172f2:	4820      	ldr	r0, [pc, #128]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   172f4:	f002 fc70 	bl	19bd8 <weegfx::Graphics::print(int, unsigned int)>
          y += menu::kMenuLineH;
   172f8:	231b      	movs	r3, #27
   172fa:	e772      	b.n	171e2 <calibration_draw(CalibrationState const&)+0x9e>
      if (CALIBRATION_EXIT != step->step) {
   172fc:	7823      	ldrb	r3, [r4, #0]
   172fe:	2b37      	cmp	r3, #55	; 0x37
   17300:	d00e      	beq.n	17320 <calibration_draw(CalibrationState const&)+0x1dc>
        graphics.print(step->message);
   17302:	68a1      	ldr	r1, [r4, #8]
   17304:	481b      	ldr	r0, [pc, #108]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   17306:	f002 fbe6 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (step->value_str)
   1730a:	69e3      	ldr	r3, [r4, #28]
   1730c:	2b00      	cmp	r3, #0
   1730e:	f43f af67 	beq.w	171e0 <calibration_draw(CalibrationState const&)+0x9c>
          graphics.print(step->value_str[state.encoder_value]);
   17312:	68b2      	ldr	r2, [r6, #8]
   17314:	4817      	ldr	r0, [pc, #92]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   17316:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   1731a:	f002 fbdc 	bl	19ad6 <weegfx::Graphics::print(char const*)>
   1731e:	e75f      	b.n	171e0 <calibration_draw(CalibrationState const&)+0x9c>
        if (calibration_data_loaded && state.used_defaults)
   17320:	f8df 8064 	ldr.w	r8, [pc, #100]	; 17388 <calibration_draw(CalibrationState const&)+0x244>
   17324:	f898 3000 	ldrb.w	r3, [r8]
   17328:	b1fb      	cbz	r3, 1736a <calibration_draw(CalibrationState const&)+0x226>
   1732a:	7d33      	ldrb	r3, [r6, #20]
   1732c:	b1eb      	cbz	r3, 1736a <calibration_draw(CalibrationState const&)+0x226>
            graphics.print("Overwrite? ");
   1732e:	4917      	ldr	r1, [pc, #92]	; (1738c <calibration_draw(CalibrationState const&)+0x248>)
          graphics.print("Save? ");
   17330:	4810      	ldr	r0, [pc, #64]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   17332:	f002 fbd0 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (step->value_str)
   17336:	69e3      	ldr	r3, [r4, #28]
   17338:	b12b      	cbz	r3, 17346 <calibration_draw(CalibrationState const&)+0x202>
          graphics.print(step->value_str[state.encoder_value]);
   1733a:	68b2      	ldr	r2, [r6, #8]
   1733c:	480d      	ldr	r0, [pc, #52]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
   1733e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   17342:	f002 fbc8 	bl	19ad6 <weegfx::Graphics::print(char const*)>
        if (state.used_defaults && calibration_data_loaded) {
   17346:	7d33      	ldrb	r3, [r6, #20]
   17348:	2b00      	cmp	r3, #0
   1734a:	f43f af49 	beq.w	171e0 <calibration_draw(CalibrationState const&)+0x9c>
   1734e:	f898 3000 	ldrb.w	r3, [r8]
   17352:	2b00      	cmp	r3, #0
   17354:	f43f af44 	beq.w	171e0 <calibration_draw(CalibrationState const&)+0x9c>
  text_x_ = x;
   17358:	2302      	movs	r3, #2
   1735a:	606b      	str	r3, [r5, #4]
          graphics.print("NB replaces existing!");
   1735c:	490c      	ldr	r1, [pc, #48]	; (17390 <calibration_draw(CalibrationState const&)+0x24c>)
   1735e:	4805      	ldr	r0, [pc, #20]	; (17374 <calibration_draw(CalibrationState const&)+0x230>)
  text_y_ = y;
   17360:	231d      	movs	r3, #29
   17362:	60ab      	str	r3, [r5, #8]
   17364:	f002 fbb7 	bl	19ad6 <weegfx::Graphics::print(char const*)>
   17368:	e7c6      	b.n	172f8 <calibration_draw(CalibrationState const&)+0x1b4>
          graphics.print("Save? ");
   1736a:	490a      	ldr	r1, [pc, #40]	; (17394 <calibration_draw(CalibrationState const&)+0x250>)
   1736c:	e7e0      	b.n	17330 <calibration_draw(CalibrationState const&)+0x1ec>
   1736e:	bf00      	nop
   17370:	20005dc8 	.word	0x20005dc8
   17374:	200065e0 	.word	0x200065e0
   17378:	0001dfe8 	.word	0x0001dfe8
   1737c:	20004da8 	.word	0x20004da8
   17380:	0001dff7 	.word	0x0001dff7
   17384:	0001dff2 	.word	0x0001dff2
   17388:	200046e8 	.word	0x200046e8
   1738c:	0002139c 	.word	0x0002139c
   17390:	000213af 	.word	0x000213af
   17394:	000213a8 	.word	0x000213a8

00017398 <OC::Ui::Calibrate()>:
void OC::Ui::Calibrate() {
   17398:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    calibration_data_loaded ? 0 : 1, // "use defaults: no" if data loaded
   1739c:	f8df b260 	ldr.w	fp, [pc, #608]	; 17600 <OC::Ui::Calibrate()+0x268>
  CalibrationState calibration_state = {
   173a0:	4f98      	ldr	r7, [pc, #608]	; (17604 <OC::Ui::Calibrate()+0x26c>)
void OC::Ui::Calibrate() {
   173a2:	b08b      	sub	sp, #44	; 0x2c
   173a4:	4605      	mov	r5, r0
  CalibrationState calibration_state = {
   173a6:	2218      	movs	r2, #24
   173a8:	2100      	movs	r1, #0
   173aa:	a804      	add	r0, sp, #16
   173ac:	f002 fef4 	bl	1a198 <memset>
    calibration_data_loaded ? 0 : 1, // "use defaults: no" if data loaded
   173b0:	f89b 3000 	ldrb.w	r3, [fp]
    phase_ = 0;
   173b4:	4894      	ldr	r0, [pc, #592]	; (17608 <OC::Ui::Calibrate()+0x270>)
  CalibrationState calibration_state = {
   173b6:	9705      	str	r7, [sp, #20]
    calibration_data_loaded ? 0 : 1, // "use defaults: no" if data loaded
   173b8:	f083 0301 	eor.w	r3, r3, #1
   173bc:	9306      	str	r3, [sp, #24]
   173be:	2210      	movs	r2, #16
  void push(T value) {
    value_ = (value_ * (smoothing - 1) + value) / smoothing;
  }

  void set(T value) {
    value_ = value;
   173c0:	f640 23aa 	movw	r3, #2730	; 0xaaa
   173c4:	2100      	movs	r1, #0
   173c6:	9307      	str	r3, [sp, #28]
   173c8:	f002 fee6 	bl	1a198 <memset>
    if (b != acceleration_enabled_) {
   173cc:	f895 304c 	ldrb.w	r3, [r5, #76]	; 0x4c
   173d0:	b91b      	cbnz	r3, 173da <OC::Ui::Calibrate()+0x42>
      acceleration_enabled_ = b;
   173d2:	2201      	movs	r2, #1
   173d4:	f885 204c 	strb.w	r2, [r5, #76]	; 0x4c
      acceleration_ = 0;
   173d8:	656b      	str	r3, [r5, #84]	; 0x54
  EncoderConfig encoder_config() const {
  	return static_cast<EncoderConfig>(flags & CALIBRATION_FLAG_ENCODER_MASK);
  }

  EncoderConfig next_encoder_config() {
    uint32_t raw_config = ((flags & CALIBRATION_FLAG_ENCODER_MASK) + 1) % ENCODER_CONFIG_LAST;
   173da:	4e8c      	ldr	r6, [pc, #560]	; (1760c <OC::Ui::Calibrate()+0x274>)
void OC::Ui::Calibrate() {
   173dc:	f04f 0900 	mov.w	r9, #0
    void Init() {
      last_ticks = 0;
    }

    uint32_t Update() {
      uint32_t now = OC::CORE::ticks;
   173e0:	4b8b      	ldr	r3, [pc, #556]	; (17610 <OC::Ui::Calibrate()+0x278>)
   173e2:	464c      	mov	r4, r9
   173e4:	f8d3 9000 	ldr.w	r9, [r3]
    digital_input_displays[0].Update(ticks, DigitalInputs::read_immediate<DIGITAL_INPUT_1>());
   173e8:	f7fc fd42 	bl	13e70 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)0>()>
      uint32_t ticks = now - last_ticks;
   173ec:	eba9 0404 	sub.w	r4, r9, r4
   173f0:	4602      	mov	r2, r0
   173f2:	4621      	mov	r1, r4
   173f4:	4884      	ldr	r0, [pc, #528]	; (17608 <OC::Ui::Calibrate()+0x270>)
   173f6:	f7ed fe0b 	bl	5010 <OC::DigitalInputDisplay::Update(unsigned long, bool)>
			return (CORE_PIN2_PINREG & CORE_PIN2_BITMASK) ? 1 : 0;
   173fa:	4b86      	ldr	r3, [pc, #536]	; (17614 <OC::Ui::Calibrate()+0x27c>)
    digital_input_displays[1].Update(ticks, DigitalInputs::read_immediate<DIGITAL_INPUT_2>());
   173fc:	4886      	ldr	r0, [pc, #536]	; (17618 <OC::Ui::Calibrate()+0x280>)
   173fe:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
    return !digitalReadFast(InputPinDesc<input>::PIN);
   17402:	43d2      	mvns	r2, r2
   17404:	f002 0201 	and.w	r2, r2, #1
   17408:	4621      	mov	r1, r4
   1740a:	f7ed fe01 	bl	5010 <OC::DigitalInputDisplay::Update(unsigned long, bool)>
    digital_input_displays[2].Update(ticks, DigitalInputs::read_immediate<DIGITAL_INPUT_3>());
   1740e:	f7fc fd39 	bl	13e84 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)2>()>
   17412:	4621      	mov	r1, r4
   17414:	4602      	mov	r2, r0
   17416:	4881      	ldr	r0, [pc, #516]	; (1761c <OC::Ui::Calibrate()+0x284>)
   17418:	f7ed fdfa 	bl	5010 <OC::DigitalInputDisplay::Update(unsigned long, bool)>
    digital_input_displays[3].Update(ticks, DigitalInputs::read_immediate<DIGITAL_INPUT_4>());
   1741c:	f7fc fd3c 	bl	13e98 <bool OC::DigitalInputs::read_immediate<(OC::DigitalInput)3>()>
   17420:	4621      	mov	r1, r4
   17422:	4602      	mov	r2, r0
   17424:	487e      	ldr	r0, [pc, #504]	; (17620 <OC::Ui::Calibrate()+0x288>)
   17426:	f7ed fdf3 	bl	5010 <OC::DigitalInputDisplay::Update(unsigned long, bool)>
    while (event_queue_.available()) {
   1742a:	f04f 0a00 	mov.w	sl, #0
    T value = buffer_[read_ptr & (size - 1)];
   1742e:	f105 086c 	add.w	r8, r5, #108	; 0x6c
    return write_ptr_ - read_ptr_;
   17432:	f8d5 10ec 	ldr.w	r1, [r5, #236]	; 0xec
   17436:	f8d5 20f0 	ldr.w	r2, [r5, #240]	; 0xf0
            switch (calibration_state.current_step->step) {
   1743a:	9b05      	ldr	r3, [sp, #20]
          if (calibration_state.step > CENTER_DISPLAY)
   1743c:	f89d 4010 	ldrb.w	r4, [sp, #16]
    while (event_queue_.available()) {
   17440:	4291      	cmp	r1, r2
   17442:	d11a      	bne.n	1747a <OC::Ui::Calibrate()+0xe2>
    const CalibrationStep *next_step = &calibration_steps[calibration_state.step];
   17444:	f04f 0828 	mov.w	r8, #40	; 0x28
   17448:	fb08 7804 	mla	r8, r8, r4, r7
    if (next_step != calibration_state.current_step) {
   1744c:	4598      	cmp	r8, r3
   1744e:	f000 80a6 	beq.w	1759e <OC::Ui::Calibrate()+0x206>
      switch (calibration_state.current_step->step) {
   17452:	781b      	ldrb	r3, [r3, #0]
   17454:	2b00      	cmp	r3, #0
   17456:	d07a      	beq.n	1754e <OC::Ui::Calibrate()+0x1b6>
   17458:	2b35      	cmp	r3, #53	; 0x35
   1745a:	f000 8081 	beq.w	17560 <OC::Ui::Calibrate()+0x1c8>
      switch (next_step->calibration_type) {
   1745e:	2328      	movs	r3, #40	; 0x28
   17460:	fb03 7204 	mla	r2, r3, r4, r7
   17464:	7d12      	ldrb	r2, [r2, #20]
   17466:	3a01      	subs	r2, #1
   17468:	2a07      	cmp	r2, #7
   1746a:	f200 80b7 	bhi.w	175dc <OC::Ui::Calibrate()+0x244>
   1746e:	e8df f002 	tbb	[pc, r2]
   17472:	9184      	.short	0x9184
   17474:	9494aaa7 	.word	0x9494aaa7
   17478:	b2af      	.short	0xb2af
    size_t read_ptr = read_ptr_;
   1747a:	f8d5 00f0 	ldr.w	r0, [r5, #240]	; 0xf0
   1747e:	9303      	str	r3, [sp, #12]
    T value = buffer_[read_ptr & (size - 1)];
   17480:	f000 020f 	and.w	r2, r0, #15
   17484:	eb08 01c2 	add.w	r1, r8, r2, lsl #3
   17488:	f818 3032 	ldrb.w	r3, [r8, r2, lsl #3]
   1748c:	8849      	ldrh	r1, [r1, #2]
   1748e:	9300      	str	r3, [sp, #0]
   17490:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
    read_ptr_ = read_ptr + 1;
   17494:	3001      	adds	r0, #1
    T value = buffer_[read_ptr & (size - 1)];
   17496:	f9b2 2070 	ldrsh.w	r2, [r2, #112]	; 0x70
    read_ptr_ = read_ptr + 1;
   1749a:	f8c5 00f0 	str.w	r0, [r5, #240]	; 0xf0
      if (IgnoreEvent(event))
   1749e:	4628      	mov	r0, r5
    T value = buffer_[read_ptr & (size - 1)];
   174a0:	9202      	str	r2, [sp, #8]
   174a2:	9101      	str	r1, [sp, #4]
   174a4:	f7ed fb8e 	bl	4bc4 <OC::Ui::IgnoreEvent(UI::Event const&) [clone .isra.0]>
   174a8:	2800      	cmp	r0, #0
   174aa:	d1c2      	bne.n	17432 <OC::Ui::Calibrate()+0x9a>
      switch (event.control) {
   174ac:	9901      	ldr	r1, [sp, #4]
   174ae:	9b03      	ldr	r3, [sp, #12]
   174b0:	2908      	cmp	r1, #8
   174b2:	d021      	beq.n	174f8 <OC::Ui::Calibrate()+0x160>
   174b4:	9a02      	ldr	r2, [sp, #8]
   174b6:	d817      	bhi.n	174e8 <OC::Ui::Calibrate()+0x150>
   174b8:	2902      	cmp	r1, #2
   174ba:	d80d      	bhi.n	174d8 <OC::Ui::Calibrate()+0x140>
   174bc:	2900      	cmp	r1, #0
   174be:	d0b8      	beq.n	17432 <OC::Ui::Calibrate()+0x9a>
   174c0:	6eb3      	ldr	r3, [r6, #104]	; 0x68
   174c2:	1c59      	adds	r1, r3, #1
   174c4:	f001 0103 	and.w	r1, r1, #3
    flags = (flags & ~CALIBRATION_FLAG_ENCODER_MASK) | raw_config;
   174c8:	f023 0303 	bic.w	r3, r3, #3
   174cc:	430b      	orrs	r3, r1
          configure_encoders(calibration_data.next_encoder_config());
   174ce:	4628      	mov	r0, r5
   174d0:	66b3      	str	r3, [r6, #104]	; 0x68
   174d2:	f7e9 fd73 	bl	fbc <OC::Ui::configure_encoders(OC::EncoderConfig)>
          break;
   174d6:	e7ac      	b.n	17432 <OC::Ui::Calibrate()+0x9a>
      switch (event.control) {
   174d8:	2904      	cmp	r1, #4
   174da:	d1aa      	bne.n	17432 <OC::Ui::Calibrate()+0x9a>
          if (calibration_state.step > CENTER_DISPLAY)
   174dc:	2c01      	cmp	r4, #1
   174de:	d9a8      	bls.n	17432 <OC::Ui::Calibrate()+0x9a>
            calibration_state.step = static_cast<CALIBRATION_STEP>(calibration_state.step - 1);
   174e0:	3c01      	subs	r4, #1
            calibration_state.step = static_cast<CALIBRATION_STEP>(calibration_state.step + 1);
   174e2:	f88d 4010 	strb.w	r4, [sp, #16]
   174e6:	e7a4      	b.n	17432 <OC::Ui::Calibrate()+0x9a>
      switch (event.control) {
   174e8:	2920      	cmp	r1, #32
   174ea:	d01b      	beq.n	17524 <OC::Ui::Calibrate()+0x18c>
   174ec:	2940      	cmp	r1, #64	; 0x40
   174ee:	d1a0      	bne.n	17432 <OC::Ui::Calibrate()+0x9a>
          calibration_state.encoder_value += event.value;
   174f0:	9b06      	ldr	r3, [sp, #24]
   174f2:	4413      	add	r3, r2
   174f4:	9306      	str	r3, [sp, #24]
          break;
   174f6:	e79c      	b.n	17432 <OC::Ui::Calibrate()+0x9a>
          if (UI::EVENT_BUTTON_LONG_PRESS == event.type) {
   174f8:	9a00      	ldr	r2, [sp, #0]
   174fa:	2a02      	cmp	r2, #2
   174fc:	d104      	bne.n	17508 <OC::Ui::Calibrate()+0x170>
            switch (calibration_state.current_step->step) {
   174fe:	781b      	ldrb	r3, [r3, #0]
   17500:	2b34      	cmp	r3, #52	; 0x34
   17502:	d005      	beq.n	17510 <OC::Ui::Calibrate()+0x178>
   17504:	2b35      	cmp	r3, #53	; 0x35
   17506:	d008      	beq.n	1751a <OC::Ui::Calibrate()+0x182>
          if (calibration_state.step < CALIBRATION_EXIT)
   17508:	2c36      	cmp	r4, #54	; 0x36
   1750a:	d81d      	bhi.n	17548 <OC::Ui::Calibrate()+0x1b0>
            calibration_state.step = static_cast<CALIBRATION_STEP>(calibration_state.step + 1);
   1750c:	3401      	adds	r4, #1
   1750e:	e7e8      	b.n	174e2 <OC::Ui::Calibrate()+0x14a>
                calibration_state.adc_1v = OC::ADC::value(ADC_CHANNEL_1);
   17510:	f7ed fd3c 	bl	4f8c <OC::ADC::value(ADC_CHANNEL)>
   17514:	f8ad 0020 	strh.w	r0, [sp, #32]
                break;
   17518:	e7f6      	b.n	17508 <OC::Ui::Calibrate()+0x170>
                calibration_state.adc_3v = OC::ADC::value(ADC_CHANNEL_1);
   1751a:	f7ed fd37 	bl	4f8c <OC::ADC::value(ADC_CHANNEL)>
   1751e:	f8ad 0022 	strh.w	r0, [sp, #34]	; 0x22
                break;
   17522:	e7f1      	b.n	17508 <OC::Ui::Calibrate()+0x170>
          if (calibration_state.step > HELLO) {
   17524:	2c00      	cmp	r4, #0
   17526:	d084      	beq.n	17432 <OC::Ui::Calibrate()+0x9a>
            calibration_state.step = static_cast<CALIBRATION_STEP>(calibration_state.step + event.value);
   17528:	4422      	add	r2, r4
            CONSTRAIN(calibration_state.step, CENTER_DISPLAY, CALIBRATION_EXIT);
   1752a:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
   1752e:	d104      	bne.n	1753a <OC::Ui::Calibrate()+0x1a2>
   17530:	f04f 0301 	mov.w	r3, #1
   17534:	f88d 3010 	strb.w	r3, [sp, #16]
   17538:	e77b      	b.n	17432 <OC::Ui::Calibrate()+0x9a>
   1753a:	2a37      	cmp	r2, #55	; 0x37
   1753c:	d802      	bhi.n	17544 <OC::Ui::Calibrate()+0x1ac>
            calibration_state.step = static_cast<CALIBRATION_STEP>(calibration_state.step + event.value);
   1753e:	f88d 2010 	strb.w	r2, [sp, #16]
   17542:	e776      	b.n	17432 <OC::Ui::Calibrate()+0x9a>
            CONSTRAIN(calibration_state.step, CENTER_DISPLAY, CALIBRATION_EXIT);
   17544:	2337      	movs	r3, #55	; 0x37
   17546:	e7f5      	b.n	17534 <OC::Ui::Calibrate()+0x19c>
            calibration_complete = true;
   17548:	f04f 0a01 	mov.w	sl, #1
   1754c:	e771      	b.n	17432 <OC::Ui::Calibrate()+0x9a>
          if (calibration_state.encoder_value) {
   1754e:	9b06      	ldr	r3, [sp, #24]
   17550:	2b00      	cmp	r3, #0
   17552:	d084      	beq.n	1745e <OC::Ui::Calibrate()+0xc6>
            calibration_reset();
   17554:	f7fc fb78 	bl	13c48 <calibration_reset()>
            calibration_state.used_defaults = true;
   17558:	2301      	movs	r3, #1
   1755a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   1755e:	e77e      	b.n	1745e <OC::Ui::Calibrate()+0xc6>
          if (calibration_state.adc_1v && calibration_state.adc_3v) {
   17560:	f8bd 0020 	ldrh.w	r0, [sp, #32]
   17564:	2800      	cmp	r0, #0
   17566:	f43f af7a 	beq.w	1745e <OC::Ui::Calibrate()+0xc6>
   1756a:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
   1756e:	2900      	cmp	r1, #0
   17570:	f43f af75 	beq.w	1745e <OC::Ui::Calibrate()+0xc6>
            OC::ADC::CalibratePitch(calibration_state.adc_1v, calibration_state.adc_3v);
   17574:	f7e8 ffc2 	bl	4fc <OC::ADC::CalibratePitch(long, long)>
                           OC::calibration_data.adc.pitch_cv_scale);
   17578:	e771      	b.n	1745e <OC::Ui::Calibrate()+0xc6>
            OC::calibration_data.dac.calibrated_octaves[step_to_channel(next_step->step)][next_step->index + DAC::kOctaveZero];
   1757a:	4363      	muls	r3, r4
   1757c:	18fa      	adds	r2, r7, r3
   1757e:	5cf8      	ldrb	r0, [r7, r3]
   17580:	f7fc fc02 	bl	13d88 <step_to_channel(int)>
   17584:	6993      	ldr	r3, [r2, #24]
   17586:	220b      	movs	r2, #11
   17588:	3305      	adds	r3, #5
   1758a:	fb02 3300 	mla	r3, r2, r0, r3
        calibration_state.encoder_value = OC::calibration_data.adc.offset[next_step->index];
   1758e:	f836 3013 	ldrh.w	r3, [r6, r3, lsl #1]
   17592:	e001      	b.n	17598 <OC::Ui::Calibrate()+0x200>
        calibration_state.encoder_value = (0xFFFF & OC::calibration_data.v_bias); // bipolar = lower 2 bytes
   17594:	f8b6 3070 	ldrh.w	r3, [r6, #112]	; 0x70
            calibration_state.encoder_value = 1;
   17598:	9306      	str	r3, [sp, #24]
      calibration_state.current_step = next_step;
   1759a:	f8cd 8014 	str.w	r8, [sp, #20]
    calibration_update(calibration_state);
   1759e:	a804      	add	r0, sp, #16
   175a0:	f7fc fc00 	bl	13da4 <calibration_update(CalibrationState&)>
    calibration_draw(calibration_state);
   175a4:	a804      	add	r0, sp, #16
   175a6:	f7ff fdcd 	bl	17144 <calibration_draw(CalibrationState const&)>
  while (!calibration_complete) {
   175aa:	f1ba 0f00 	cmp.w	sl, #0
   175ae:	f43f af17 	beq.w	173e0 <OC::Ui::Calibrate()+0x48>
  if (calibration_state.encoder_value) {
   175b2:	9b06      	ldr	r3, [sp, #24]
   175b4:	b30b      	cbz	r3, 175fa <OC::Ui::Calibrate()+0x262>
}
   175b6:	b00b      	add	sp, #44	; 0x2c
   175b8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    calibration_save();
   175bc:	f7fc bbb4 	b.w	13d28 <calibration_save()>
        calibration_state.encoder_value = (OC::calibration_data.v_bias >> 16);  // asymmetric = upper 2 bytes
   175c0:	f8b6 3072 	ldrh.w	r3, [r6, #114]	; 0x72
   175c4:	e7e8      	b.n	17598 <OC::Ui::Calibrate()+0x200>
        calibration_state.encoder_value = OC::calibration_data.adc.offset[next_step->index];
   175c6:	fb03 7304 	mla	r3, r3, r4, r7
   175ca:	699b      	ldr	r3, [r3, #24]
   175cc:	332c      	adds	r3, #44	; 0x2c
   175ce:	e7de      	b.n	1758e <OC::Ui::Calibrate()+0x1f6>
        calibration_state.encoder_value = OC::calibration_data.display_offset;
   175d0:	f896 3064 	ldrb.w	r3, [r6, #100]	; 0x64
   175d4:	e7e0      	b.n	17598 <OC::Ui::Calibrate()+0x200>
        calibration_state.encoder_value = OC::calibration_data.screensaver_timeout;
   175d6:	f896 306c 	ldrb.w	r3, [r6, #108]	; 0x6c
   175da:	e7dd      	b.n	17598 <OC::Ui::Calibrate()+0x200>
        if (CALIBRATION_EXIT != next_step->step) {
   175dc:	435c      	muls	r4, r3
   175de:	5d3b      	ldrb	r3, [r7, r4]
   175e0:	2b37      	cmp	r3, #55	; 0x37
   175e2:	d001      	beq.n	175e8 <OC::Ui::Calibrate()+0x250>
          calibration_state.encoder_value = 0;
   175e4:	2300      	movs	r3, #0
   175e6:	e7d7      	b.n	17598 <OC::Ui::Calibrate()+0x200>
          if (calibration_state.used_defaults && calibration_data_loaded)
   175e8:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   175ec:	b11b      	cbz	r3, 175f6 <OC::Ui::Calibrate()+0x25e>
   175ee:	f89b 3000 	ldrb.w	r3, [fp]
   175f2:	2b00      	cmp	r3, #0
   175f4:	d1f6      	bne.n	175e4 <OC::Ui::Calibrate()+0x24c>
            calibration_state.encoder_value = 1;
   175f6:	2301      	movs	r3, #1
   175f8:	e7ce      	b.n	17598 <OC::Ui::Calibrate()+0x200>
}
   175fa:	b00b      	add	sp, #44	; 0x2c
   175fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   17600:	200046e8 	.word	0x200046e8
   17604:	1fff9328 	.word	0x1fff9328
   17608:	20004da8 	.word	0x20004da8
   1760c:	20004294 	.word	0x20004294
   17610:	200046cc 	.word	0x200046cc
   17614:	400ff000 	.word	0x400ff000
   17618:	20004dac 	.word	0x20004dac
   1761c:	20004db0 	.word	0x20004db0
   17620:	20004db4 	.word	0x20004db4

00017624 <setup>:
  OC_DEBUG_RESET_CYCLES(OC::CORE::ticks, 16384, OC::DEBUG::ISR_cycles);
}

/*       ---------------------------------------------------------         */

void setup() {
   17624:	b537      	push	{r0, r1, r2, r4, r5, lr}
  delay(50);
   17626:	2032      	movs	r0, #50	; 0x32
   17628:	f002 ff2e 	bl	1a488 <delay>
  NVIC_SET_PRIORITY(IRQ_PORTB, 0); // TR1 = 0 = PTB16
   1762c:	4b45      	ldr	r3, [pc, #276]	; (17744 <setup+0x120>)
    return write_ptr_ - read_ptr_;
   1762e:	4c46      	ldr	r4, [pc, #280]	; (17748 <setup+0x124>)
   17630:	2200      	movs	r2, #0
   17632:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
  SPI_init();
   17636:	f7e9 fa03 	bl	a40 <SPI_init()>
  SERIAL_PRINTLN("* O&C BOOTING...");
  SERIAL_PRINTLN("* %s", OC_VERSION);

  OC::DEBUG::Init();
   1763a:	f7e9 fb33 	bl	ca4 <OC::DEBUG::Init()>
  OC::DigitalInputs::Init();
   1763e:	f7e9 fbeb 	bl	e18 <OC::DigitalInputs::Init()>
  delay(400); 
   17642:	f44f 70c8 	mov.w	r0, #400	; 0x190
   17646:	f002 ff1f 	bl	1a488 <delay>
  OC::ADC::Init(&OC::calibration_data.adc); // Yes, it's using the calibration_data before it's loaded...
   1764a:	4840      	ldr	r0, [pc, #256]	; (1774c <setup+0x128>)
   1764c:	f7e8 ff04 	bl	458 <OC::ADC::Init(OC::ADC::CalibrationData*)>
  OC::DAC::Init(&OC::calibration_data.dac);
   17650:	483f      	ldr	r0, [pc, #252]	; (17750 <setup+0x12c>)
   17652:	f7e9 f979 	bl	948 <OC::DAC::Init(OC::DAC::CalibrationData*)>

  display::Init();
   17656:	f001 fde1 	bl	1921c <display::Init()>
   1765a:	f8d4 2808 	ldr.w	r2, [r4, #2056]	; 0x808
   1765e:	f8d4 380c 	ldr.w	r3, [r4, #2060]	; 0x80c

  GRAPHICS_BEGIN_FRAME(true);
   17662:	1a9b      	subs	r3, r3, r2
   17664:	3302      	adds	r3, #2
   17666:	d0f8      	beq.n	1765a <setup+0x36>
    return frame_buffers_[write_ptr_ % frames];
   17668:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
   1766c:	f003 0301 	and.w	r3, r3, #1
   17670:	f503 7300 	add.w	r3, r3, #512	; 0x200
   17674:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
   17678:	2900      	cmp	r1, #0
   1767a:	d0ee      	beq.n	1765a <setup+0x36>
   1767c:	2201      	movs	r2, #1
   1767e:	4835      	ldr	r0, [pc, #212]	; (17754 <setup+0x130>)
	bool begin(void (*funct)(), unsigned int microseconds) {
		if (microseconds == 0 || microseconds > MAX_PERIOD) return false;
		uint32_t cycles = (F_BUS / 1000000) * microseconds - 1;
		if (cycles < 36) return false;
		return beginCycles(funct, cycles);
   17680:	4d35      	ldr	r5, [pc, #212]	; (17758 <setup+0x134>)
   17682:	f001 fdf6 	bl	19272 <weegfx::Graphics::Begin(unsigned char*, bool)>
  GRAPHICS_END_FRAME();
   17686:	4833      	ldr	r0, [pc, #204]	; (17754 <setup+0x130>)
   17688:	f001 fe01 	bl	1928e <weegfx::Graphics::End()>
    ++write_ptr_;
   1768c:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
   17690:	3301      	adds	r3, #1
   17692:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808

  calibration_load();
  
  display::AdjustOffset(OC::calibration_data.display_offset);
   17696:	4c2e      	ldr	r4, [pc, #184]	; (17750 <setup+0x12c>)
  calibration_load();
   17698:	f7fc fae2 	bl	13c60 <calibration_load()>
  display::AdjustOffset(OC::calibration_data.display_offset);
   1769c:	f894 0064 	ldrb.w	r0, [r4, #100]	; 0x64
   176a0:	f001 fde0 	bl	19264 <display::AdjustOffset(unsigned char)>

  OC::menu::Init();
   176a4:	f7e9 fc18 	bl	ed8 <OC::menu::Init()>
  OC::ui.Init();
   176a8:	482c      	ldr	r0, [pc, #176]	; (1775c <setup+0x138>)
   176aa:	f7e9 fdd9 	bl	1260 <OC::Ui::Init()>
  	return static_cast<EncoderConfig>(flags & CALIBRATION_FLAG_ENCODER_MASK);
   176ae:	6ea1      	ldr	r1, [r4, #104]	; 0x68
  OC::ui.configure_encoders(OC::calibration_data.encoder_config());
   176b0:	482a      	ldr	r0, [pc, #168]	; (1775c <setup+0x138>)
   176b2:	f001 0103 	and.w	r1, r1, #3
   176b6:	f7e9 fc81 	bl	fbc <OC::Ui::configure_encoders(OC::EncoderConfig)>
   176ba:	4929      	ldr	r1, [pc, #164]	; (17760 <setup+0x13c>)
   176bc:	f640 620f 	movw	r2, #3599	; 0xe0f
   176c0:	4628      	mov	r0, r5
   176c2:	f002 fb4d 	bl	19d60 <IntervalTimer::beginCycles(void (*)(), unsigned long)>
	}
	void end();
	void priority(uint8_t n) {
		nvic_priority = n;
		#if defined(KINETISK)
		if (channel) {
   176c6:	6829      	ldr	r1, [r5, #0]
		nvic_priority = n;
   176c8:	2250      	movs	r2, #80	; 0x50
   176ca:	712a      	strb	r2, [r5, #4]
		if (channel) {
   176cc:	b121      	cbz	r1, 176d8 <setup+0xb4>
			int index = channel - KINETISK_PIT_CHANNELS;
   176ce:	4b25      	ldr	r3, [pc, #148]	; (17764 <setup+0x140>)
   176d0:	440b      	add	r3, r1
   176d2:	111b      	asrs	r3, r3, #4
			NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
   176d4:	4924      	ldr	r1, [pc, #144]	; (17768 <setup+0x144>)
   176d6:	545a      	strb	r2, [r3, r1]
		return beginCycles(funct, cycles);
   176d8:	4d24      	ldr	r5, [pc, #144]	; (1776c <setup+0x148>)
   176da:	4925      	ldr	r1, [pc, #148]	; (17770 <setup+0x14c>)
   176dc:	f64e 225f 	movw	r2, #59999	; 0xea5f
   176e0:	4628      	mov	r0, r5
   176e2:	f002 fb3d 	bl	19d60 <IntervalTimer::beginCycles(void (*)(), unsigned long)>
		if (channel) {
   176e6:	6829      	ldr	r1, [r5, #0]
		nvic_priority = n;
   176e8:	2280      	movs	r2, #128	; 0x80
   176ea:	712a      	strb	r2, [r5, #4]
		if (channel) {
   176ec:	b121      	cbz	r1, 176f8 <setup+0xd4>
			int index = channel - KINETISK_PIT_CHANNELS;
   176ee:	4b1d      	ldr	r3, [pc, #116]	; (17764 <setup+0x140>)
   176f0:	440b      	add	r3, r1
   176f2:	111b      	asrs	r3, r3, #4
			NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
   176f4:	491c      	ldr	r1, [pc, #112]	; (17768 <setup+0x144>)
   176f6:	545a      	strb	r2, [r3, r1]
  UI_timer.begin(UI_timer_ISR, OC_UI_TIMER_RATE);
  UI_timer.priority(OC_UI_TIMER_PRIO);
#endif

  // Display splash screen and optional calibration
  bool reset_settings = false;
   176f8:	2300      	movs	r3, #0
  ui_mode = OC::ui.Splashscreen(reset_settings);
   176fa:	4818      	ldr	r0, [pc, #96]	; (1775c <setup+0x138>)
  bool reset_settings = false;
   176fc:	f88d 3007 	strb.w	r3, [sp, #7]
  ui_mode = OC::ui.Splashscreen(reset_settings);
   17700:	f10d 0107 	add.w	r1, sp, #7
   17704:	f7e9 fd04 	bl	1110 <OC::Ui::Splashscreen(bool&)>
   17708:	4d1a      	ldr	r5, [pc, #104]	; (17774 <setup+0x150>)

  if (ui_mode == OC::UI_MODE_CALIBRATE) {
   1770a:	2803      	cmp	r0, #3
  ui_mode = OC::ui.Splashscreen(reset_settings);
   1770c:	7028      	strb	r0, [r5, #0]
  if (ui_mode == OC::UI_MODE_CALIBRATE) {
   1770e:	d104      	bne.n	1771a <setup+0xf6>
    OC::ui.Calibrate();
   17710:	4812      	ldr	r0, [pc, #72]	; (1775c <setup+0x138>)
   17712:	f7ff fe41 	bl	17398 <OC::Ui::Calibrate()>
    ui_mode = OC::UI_MODE_MENU;
   17716:	2301      	movs	r3, #1
   17718:	702b      	strb	r3, [r5, #0]
  }
  OC::ui.set_screensaver_timeout(OC::calibration_data.screensaver_timeout);
   1771a:	f894 106c 	ldrb.w	r1, [r4, #108]	; 0x6c
   1771e:	480f      	ldr	r0, [pc, #60]	; (1775c <setup+0x138>)
   17720:	f7e9 fd64 	bl	11ec <OC::Ui::set_screensaver_timeout(unsigned long)>

  // initialize apps
  OC::apps::Init(reset_settings);
   17724:	f89d 0007 	ldrb.w	r0, [sp, #7]
   17728:	f7ff fb32 	bl	16d90 <OC::apps::Init(bool)>

#ifdef VOR
  VBiasManager *vbias_m = vbias_m->get();
   1772c:	f7ed fca6 	bl	507c <VBiasManager::get()>
   17730:	4605      	mov	r5, r0
        OC::DAC::set_Vbias(new_bias_value);
   17732:	f8b4 0070 	ldrh.w	r0, [r4, #112]	; 0x70
   17736:	f7e8 ff83 	bl	640 <OC::DAC::set_Vbias(unsigned long)>
        bias_state = new_bias_state;
   1773a:	2300      	movs	r3, #0
   1773c:	602b      	str	r3, [r5, #0]
  vbias_m->ChangeBiasToState(VBiasManager::BI);
#endif
}
   1773e:	b003      	add	sp, #12
   17740:	bd30      	pop	{r4, r5, pc}
   17742:	bf00      	nop
   17744:	e000e400 	.word	0xe000e400
   17748:	20005dc8 	.word	0x20005dc8
   1774c:	200042ec 	.word	0x200042ec
   17750:	20004294 	.word	0x20004294
   17754:	200065e0 	.word	0x200065e0
   17758:	1fffb870 	.word	0x1fffb870
   1775c:	1fffa7cc 	.word	0x1fffa7cc
   17760:	1fff8f05 	.word	0x1fff8f05
   17764:	bffc8f00 	.word	0xbffc8f00
   17768:	e000e444 	.word	0xe000e444
   1776c:	20002aa8 	.word	0x20002aa8
   17770:	1fff8fc9 	.word	0x1fff8fc9
   17774:	1fffa0b8 	.word	0x1fffa0b8

00017778 <Settings_handleButtonEvent(UI::Event const&)>:
    if (event.control == OC::CONTROL_BUTTON_L) {
   17778:	8843      	ldrh	r3, [r0, #2]
   1777a:	2b04      	cmp	r3, #4
void Settings_handleButtonEvent(const UI::Event &event) {
   1777c:	b510      	push	{r4, lr}
   1777e:	4604      	mov	r4, r0
    if (event.control == OC::CONTROL_BUTTON_L) {
   17780:	d105      	bne.n	1778e <Settings_handleButtonEvent(UI::Event const&)+0x16>
        if (event.type == UI::EVENT_BUTTON_LONG_PRESS) Settings_instance.OnLeftButtonLongPress();
   17782:	7803      	ldrb	r3, [r0, #0]
   17784:	2b02      	cmp	r3, #2
   17786:	d00c      	beq.n	177a2 <Settings_handleButtonEvent(UI::Event const&)+0x2a>
        OC::ui.Calibrate();
   17788:	4806      	ldr	r0, [pc, #24]	; (177a4 <Settings_handleButtonEvent(UI::Event const&)+0x2c>)
   1778a:	f7ff fe05 	bl	17398 <OC::Ui::Calibrate()>
    if (event.control == OC::CONTROL_BUTTON_R && event.type == UI::EVENT_BUTTON_PRESS) Settings_instance.OnRightButtonPress();
   1778e:	8863      	ldrh	r3, [r4, #2]
   17790:	2b08      	cmp	r3, #8
   17792:	d106      	bne.n	177a2 <Settings_handleButtonEvent(UI::Event const&)+0x2a>
   17794:	7820      	ldrb	r0, [r4, #0]
   17796:	2801      	cmp	r0, #1
   17798:	d103      	bne.n	177a2 <Settings_handleButtonEvent(UI::Event const&)+0x2a>
}
   1779a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        OC::apps::Init(1);
   1779e:	f7ff baf7 	b.w	16d90 <OC::apps::Init(bool)>
}
   177a2:	bd10      	pop	{r4, pc}
   177a4:	1fffa7cc 	.word	0x1fffa7cc

000177a8 <_GLOBAL__sub_I_LAST_REDRAW_TIME>:
  delay(OC_CORE_TIMER_RATE + 1);

  return
    OC::ADC::smoothed_raw_value(ADC_CHANNEL_1) + OC::ADC::smoothed_raw_value(ADC_CHANNEL_2) +
    OC::ADC::smoothed_raw_value(ADC_CHANNEL_3) + OC::ADC::smoothed_raw_value(ADC_CHANNEL_4);
}
   177a8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    EEPROMClass()                        { eeprom_initialize(); }
   177ac:	f002 fbb2 	bl	19f14 <eeprom_initialize>
		channel = NULL;
   177b0:	48b8      	ldr	r0, [pc, #736]	; (17a94 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2ec>)
IntervalTimer UI_timer;
   177b2:	4ab9      	ldr	r2, [pc, #740]	; (17a98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f0>)
   177b4:	49b9      	ldr	r1, [pc, #740]	; (17a9c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f4>)
   177b6:	2400      	movs	r4, #0
		nvic_priority = 128;
   177b8:	2580      	movs	r5, #128	; 0x80
		channel = NULL;
   177ba:	6004      	str	r4, [r0, #0]
		nvic_priority = 128;
   177bc:	7105      	strb	r5, [r0, #4]
   177be:	f004 ff7d 	bl	1c6bc <__aeabi_atexit>
		channel = NULL;
   177c2:	48b7      	ldr	r0, [pc, #732]	; (17aa0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f8>)
IntervalTimer CORE_timer;
   177c4:	49b5      	ldr	r1, [pc, #724]	; (17a9c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f4>)
   177c6:	4ab4      	ldr	r2, [pc, #720]	; (17a98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f0>)
   177c8:	6004      	str	r4, [r0, #0]
		nvic_priority = 128;
   177ca:	7105      	strb	r5, [r0, #4]
   177cc:	f004 ff76 	bl	1c6bc <__aeabi_atexit>
class Backup: public SystemExclusiveHandler {
   177d0:	4bb4      	ldr	r3, [pc, #720]	; (17aa4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2fc>)
   177d2:	4ab5      	ldr	r2, [pc, #724]	; (17aa8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x300>)
   177d4:	601a      	str	r2, [r3, #0]
   177d6:	715c      	strb	r4, [r3, #5]
   177d8:	80dc      	strh	r4, [r3, #6]
SETTINGS_DECLARE(EnigmaTMWS, ENIGMA_SETTING_LAST) {
   177da:	f7fe f981 	bl	15ae0 <settings::SettingsBase<EnigmaTMWS, 150u>::calc_storage_size()>
   177de:	4bb3      	ldr	r3, [pc, #716]	; (17aac <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x304>)
class EnigmaTMWS : public HSApplication, public SystemExclusiveHandler,
   177e0:	4ab3      	ldr	r2, [pc, #716]	; (17ab0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x308>)
SETTINGS_DECLARE(EnigmaTMWS, ENIGMA_SETTING_LAST) {
   177e2:	6018      	str	r0, [r3, #0]
class EnigmaTMWS : public HSApplication, public SystemExclusiveHandler,
   177e4:	4bb3      	ldr	r3, [pc, #716]	; (17ab4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x30c>)
   177e6:	601a      	str	r2, [r3, #0]
   177e8:	3220      	adds	r2, #32
   177ea:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
   177ee:	4ab2      	ldr	r2, [pc, #712]	; (17ab8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x310>)
   177f0:	f883 4312 	strb.w	r4, [r3, #786]	; 0x312
   177f4:	f8a3 43dc 	strh.w	r4, [r3, #988]	; 0x3dc
   177f8:	f883 43de 	strb.w	r4, [r3, #990]	; 0x3de
   177fc:	f8c3 23e0 	str.w	r2, [r3, #992]	; 0x3e0
   17800:	f883 43e4 	strb.w	r4, [r3, #996]	; 0x3e4
   17804:	f603 2264 	addw	r2, r3, #2660	; 0xa64
   17808:	2404      	movs	r4, #4
class EnigmaOutput {
   1780a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1780e:	3c01      	subs	r4, #1
   17810:	f8c2 113c 	str.w	r1, [r2, #316]	; 0x13c
   17814:	f8c2 1140 	str.w	r1, [r2, #320]	; 0x140
   17818:	f502 72a4 	add.w	r2, r2, #328	; 0x148
   1781c:	d1f7      	bne.n	1780e <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x66>
EnigmaTMWS EnigmaTMWS_instance;
   1781e:	4a9e      	ldr	r2, [pc, #632]	; (17a98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f0>)
   17820:	49a6      	ldr	r1, [pc, #664]	; (17abc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x314>)
class EnigmaTMWS : public HSApplication, public SystemExclusiveHandler,
   17822:	f8c3 4f88 	str.w	r4, [r3, #3976]	; 0xf88
   17826:	f8c3 4f8c 	str.w	r4, [r3, #3980]	; 0xf8c
   1782a:	f8a3 4f90 	strh.w	r4, [r3, #3984]	; 0xf90
   1782e:	f883 4f92 	strb.w	r4, [r3, #3986]	; 0xf92
EnigmaTMWS EnigmaTMWS_instance;
   17832:	48a0      	ldr	r0, [pc, #640]	; (17ab4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x30c>)
class HemisphereManager : public SystemExclusiveHandler,
   17834:	4da2      	ldr	r5, [pc, #648]	; (17ac0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x318>)
   17836:	f004 ff41 	bl	1c6bc <__aeabi_atexit>
SETTINGS_DECLARE(HemisphereManager, HEMISPHERE_SETTING_LAST) {
   1783a:	f7fe fa2b 	bl	15c94 <settings::SettingsBase<HemisphereManager, 6u>::calc_storage_size()>
   1783e:	4ba1      	ldr	r3, [pc, #644]	; (17ac4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x31c>)
   17840:	6018      	str	r0, [r3, #0]
class HemisphereManager : public SystemExclusiveHandler,
   17842:	4ba1      	ldr	r3, [pc, #644]	; (17ac8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x320>)
   17844:	602b      	str	r3, [r5, #0]
   17846:	f7f0 fb31 	bl	7eac <ClockManager::get()>
   1784a:	f8c5 0864 	str.w	r0, [r5, #2148]	; 0x864
SETTINGS_DECLARE(CaptainMIDI, MIDI_SETTING_LAST) {
   1784e:	f7fe fcb3 	bl	161b8 <settings::SettingsBase<CaptainMIDI, 161u>::calc_storage_size()>
   17852:	4b9e      	ldr	r3, [pc, #632]	; (17acc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x324>)
CaptainMIDI captain_midi_instance;
   17854:	4a90      	ldr	r2, [pc, #576]	; (17a98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f0>)
SETTINGS_DECLARE(CaptainMIDI, MIDI_SETTING_LAST) {
   17856:	6018      	str	r0, [r3, #0]
class CaptainMIDI : public SystemExclusiveHandler, public HSApplication,
   17858:	489d      	ldr	r0, [pc, #628]	; (17ad0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x328>)
   1785a:	4b9e      	ldr	r3, [pc, #632]	; (17ad4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x32c>)
   1785c:	6003      	str	r3, [r0, #0]
   1785e:	3320      	adds	r3, #32
   17860:	6083      	str	r3, [r0, #8]
CaptainMIDI captain_midi_instance;
   17862:	499d      	ldr	r1, [pc, #628]	; (17ad8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x330>)
   17864:	f004 ff2a 	bl	1c6bc <__aeabi_atexit>
SETTINGS_DECLARE(NeuralNetwork, NN_SETTING_LAST) {
   17868:	f7fe fd90 	bl	1638c <settings::SettingsBase<NeuralNetwork, 216u>::calc_storage_size()>
   1786c:	4b9b      	ldr	r3, [pc, #620]	; (17adc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x334>)
class NeuralNetwork : public HSApplication, public SystemExclusiveHandler,
   1786e:	4a9c      	ldr	r2, [pc, #624]	; (17ae0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x338>)
SETTINGS_DECLARE(NeuralNetwork, NN_SETTING_LAST) {
   17870:	6018      	str	r0, [r3, #0]
class NeuralNetwork : public HSApplication, public SystemExclusiveHandler,
   17872:	4b9c      	ldr	r3, [pc, #624]	; (17ae4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x33c>)
   17874:	601a      	str	r2, [r3, #0]
   17876:	3220      	adds	r2, #32
   17878:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
   1787c:	f883 43ea 	strb.w	r4, [r3, #1002]	; 0x3ea
   17880:	f8c3 43ec 	str.w	r4, [r3, #1004]	; 0x3ec
   17884:	f8c3 43f0 	str.w	r4, [r3, #1008]	; 0x3f0
   17888:	f8a3 43f4 	strh.w	r4, [r3, #1012]	; 0x3f4
   1788c:	f883 43f6 	strb.w	r4, [r3, #1014]	; 0x3f6
   17890:	2518      	movs	r5, #24
   17892:	461a      	mov	r2, r3
   17894:	3d01      	subs	r5, #1
class LogicGate {
   17896:	f883 43fd 	strb.w	r4, [r3, #1021]	; 0x3fd
   1789a:	f103 0324 	add.w	r3, r3, #36	; 0x24
   1789e:	d1f9      	bne.n	17894 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xec>
class ScaleEditor : public HSApplication, public SystemExclusiveHandler {
   178a0:	4891      	ldr	r0, [pc, #580]	; (17ae8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x340>)
   178a2:	4b92      	ldr	r3, [pc, #584]	; (17aec <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x344>)
   178a4:	6003      	str	r3, [r0, #0]
   178a6:	3320      	adds	r3, #32
ScaleEditor scale_editor_instance;
   178a8:	4991      	ldr	r1, [pc, #580]	; (17af0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x348>)
   178aa:	f8a2 57a4 	strh.w	r5, [r2, #1956]	; 0x7a4
class ScaleEditor : public HSApplication, public SystemExclusiveHandler {
   178ae:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
ScaleEditor scale_editor_instance;
   178b2:	4a79      	ldr	r2, [pc, #484]	; (17a98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f0>)
class WaveformEditor : public HSApplication, public SystemExclusiveHandler {
   178b4:	4c8f      	ldr	r4, [pc, #572]	; (17af4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x34c>)
   178b6:	f004 ff01 	bl	1c6bc <__aeabi_atexit>
class Settings : public HSApplication {
   178ba:	4b8f      	ldr	r3, [pc, #572]	; (17af8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x350>)
   178bc:	4a8f      	ldr	r2, [pc, #572]	; (17afc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x354>)
   178be:	601a      	str	r2, [r3, #0]
SETTINGS_DECLARE(TheDarkestTimeline, DT_SETTING_LAST) {
   178c0:	f7ff f8e0 	bl	16a84 <settings::SettingsBase<TheDarkestTimeline, 8u>::calc_storage_size()>
   178c4:	4b8e      	ldr	r3, [pc, #568]	; (17b00 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x358>)
};
   178c6:	4a8f      	ldr	r2, [pc, #572]	; (17b04 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x35c>)
SETTINGS_DECLARE(TheDarkestTimeline, DT_SETTING_LAST) {
   178c8:	6018      	str	r0, [r3, #0]
    {5, 0, OC::Scales::NUM_SCALES - 1, "Scale", NULL, settings::STORAGE_TYPE_U8},
   178ca:	4b8f      	ldr	r3, [pc, #572]	; (17b08 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x360>)
class TheDarkestTimeline : public HSApplication, public SystemExclusiveHandler,
   178cc:	488f      	ldr	r0, [pc, #572]	; (17b0c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x364>)
    {5, 0, OC::Scales::NUM_SCALES - 1, "Scale", NULL, settings::STORAGE_TYPE_U8},
   178ce:	681b      	ldr	r3, [r3, #0]
TheDarkestTimeline TheDarkestTimeline_instance;
   178d0:	498f      	ldr	r1, [pc, #572]	; (17b10 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x368>)
    {5, 0, OC::Scales::NUM_SCALES - 1, "Scale", NULL, settings::STORAGE_TYPE_U8},
   178d2:	3b01      	subs	r3, #1
};
   178d4:	6393      	str	r3, [r2, #56]	; 0x38
class TheDarkestTimeline : public HSApplication, public SystemExclusiveHandler,
   178d6:	4b8f      	ldr	r3, [pc, #572]	; (17b14 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x36c>)
   178d8:	6003      	str	r3, [r0, #0]
   178da:	3320      	adds	r3, #32
TheDarkestTimeline TheDarkestTimeline_instance;
   178dc:	4a6e      	ldr	r2, [pc, #440]	; (17a98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f0>)
class TheDarkestTimeline : public HSApplication, public SystemExclusiveHandler,
   178de:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
TheDarkestTimeline TheDarkestTimeline_instance;
   178e2:	f004 feeb 	bl	1c6bc <__aeabi_atexit>
   178e6:	4b8c      	ldr	r3, [pc, #560]	; (17b18 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x370>)
   178e8:	6023      	str	r3, [r4, #0]
   178ea:	3320      	adds	r3, #32
   178ec:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
   178f0:	2301      	movs	r3, #1
   178f2:	f884 5085 	strb.w	r5, [r4, #133]	; 0x85
   178f6:	f884 5086 	strb.w	r5, [r4, #134]	; 0x86
   178fa:	f884 5089 	strb.w	r5, [r4, #137]	; 0x89
   178fe:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
   17902:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
   17906:	f104 0090 	add.w	r0, r4, #144	; 0x90
   1790a:	f7f6 f8e7 	bl	dadc <VectorOscillator::VectorOscillator()>
   1790e:	f104 06d8 	add.w	r6, r4, #216	; 0xd8
   17912:	1970      	adds	r0, r6, r5
   17914:	3548      	adds	r5, #72	; 0x48
   17916:	f7f6 f8e1 	bl	dadc <VectorOscillator::VectorOscillator()>
   1791a:	f5b5 7f90 	cmp.w	r5, #288	; 0x120
   1791e:	d1f8      	bne.n	17912 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x16a>
   17920:	2300      	movs	r3, #0
   17922:	f884 31f8 	strb.w	r3, [r4, #504]	; 0x1f8
class ADEG : public HemisphereApplet {
   17926:	4b7d      	ldr	r3, [pc, #500]	; (17b1c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x374>)
   17928:	4a7d      	ldr	r2, [pc, #500]	; (17b20 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x378>)
   1792a:	601a      	str	r2, [r3, #0]
   1792c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
class ADSREG : public HemisphereApplet {
   17930:	4b7c      	ldr	r3, [pc, #496]	; (17b24 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x37c>)
   17932:	4a7d      	ldr	r2, [pc, #500]	; (17b28 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x380>)
   17934:	4d7d      	ldr	r5, [pc, #500]	; (17b2c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x384>)
class ASR : public HemisphereApplet {
   17936:	f8df 81f8 	ldr.w	r8, [pc, #504]	; 17b30 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x388>
        if (!instance) instance = new RingBufferManager;
   1793a:	4e7e      	ldr	r6, [pc, #504]	; (17b34 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x38c>)
   1793c:	601a      	str	r2, [r3, #0]
   1793e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
   17942:	2702      	movs	r7, #2
   17944:	6834      	ldr	r4, [r6, #0]
   17946:	f8c5 8000 	str.w	r8, [r5]
   1794a:	b9ac      	cbnz	r4, 17978 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x1d0>
   1794c:	f44f 6082 	mov.w	r0, #1040	; 0x410
   17950:	f002 fc80 	bl	1a254 <operator new(unsigned int)>
    RingBufferManager() {
   17954:	f8a0 4400 	strh.w	r4, [r0, #1024]	; 0x400
   17958:	f880 4402 	strb.w	r4, [r0, #1026]	; 0x402
   1795c:	f8c0 440c 	str.w	r4, [r0, #1036]	; 0x40c
        for (byte i = 0; i < 255; i++) buffer[i] = 0;
   17960:	1f03      	subs	r3, r0, #4
   17962:	f500 727e 	add.w	r2, r0, #1016	; 0x3f8
   17966:	f843 4f04 	str.w	r4, [r3, #4]!
   1796a:	429a      	cmp	r2, r3
   1796c:	d1fb      	bne.n	17966 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x1be>
        registered[LEFT_HEMISPHERE] = 0;
   1796e:	f8c0 4404 	str.w	r4, [r0, #1028]	; 0x404
        registered[RIGHT_HEMISPHERE] = 0;
   17972:	f8c0 4408 	str.w	r4, [r0, #1032]	; 0x408
        if (!instance) instance = new RingBufferManager;
   17976:	6030      	str	r0, [r6, #0]
   17978:	6833      	ldr	r3, [r6, #0]
   1797a:	672b      	str	r3, [r5, #112]	; 0x70
ASR ASR_instance[2];
   1797c:	2f01      	cmp	r7, #1
   1797e:	f505 75da 	add.w	r5, r5, #436	; 0x1b4
   17982:	f040 8430 	bne.w	181e6 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa3e>
   17986:	4a44      	ldr	r2, [pc, #272]	; (17a98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x2f0>)
   17988:	496b      	ldr	r1, [pc, #428]	; (17b38 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x390>)
class BootsNCat : public HemisphereApplet {
   1798a:	4d6c      	ldr	r5, [pc, #432]	; (17b3c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x394>)
   1798c:	4e6c      	ldr	r6, [pc, #432]	; (17b40 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x398>)
        if (!instance) instance = new LorenzGeneratorManager;
   1798e:	4f6d      	ldr	r7, [pc, #436]	; (17b44 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x39c>)

  inline void set_out_a(uint8_t out_a) {
    out_a_ = out_a;
   17990:	f8df a1b4 	ldr.w	sl, [pc, #436]	; 17b48 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3a0>
   17994:	2000      	movs	r0, #0
   17996:	f004 fe91 	bl	1c6bc <__aeabi_atexit>
class AnnularFusion : public HemisphereApplet {
   1799a:	4b6c      	ldr	r3, [pc, #432]	; (17b4c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3a4>)
   1799c:	4a6c      	ldr	r2, [pc, #432]	; (17b50 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3a8>)
   1799e:	601a      	str	r2, [r3, #0]
   179a0:	2400      	movs	r4, #0
   179a2:	671c      	str	r4, [r3, #112]	; 0x70
   179a4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
   179a8:	f8c3 4184 	str.w	r4, [r3, #388]	; 0x184
class AttenuateOffset : public HemisphereApplet {
   179ac:	4b69      	ldr	r3, [pc, #420]	; (17b54 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3ac>)
   179ae:	4a6a      	ldr	r2, [pc, #424]	; (17b58 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3b0>)
   179b0:	601a      	str	r2, [r3, #0]
   179b2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
class Binary : public HemisphereApplet {
   179b6:	4b69      	ldr	r3, [pc, #420]	; (17b5c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3b4>)
   179b8:	4869      	ldr	r0, [pc, #420]	; (17b60 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3b8>)
   179ba:	6018      	str	r0, [r3, #0]
   179bc:	f44f 61f0 	mov.w	r1, #1920	; 0x780
   179c0:	f44f 7200 	mov.w	r2, #512	; 0x200
   179c4:	6719      	str	r1, [r3, #112]	; 0x70
   179c6:	675a      	str	r2, [r3, #116]	; 0x74
   179c8:	f8c3 00e4 	str.w	r0, [r3, #228]	; 0xe4
   179cc:	f8c3 1154 	str.w	r1, [r3, #340]	; 0x154
   179d0:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
   179d4:	602e      	str	r6, [r5, #0]
   179d6:	66ec      	str	r4, [r5, #108]	; 0x6c
   179d8:	f105 0070 	add.w	r0, r5, #112	; 0x70
   179dc:	f7f6 f87e 	bl	dadc <VectorOscillator::VectorOscillator()>
   179e0:	f105 00b8 	add.w	r0, r5, #184	; 0xb8
   179e4:	f7f6 f87a 	bl	dadc <VectorOscillator::VectorOscillator()>
   179e8:	f505 7080 	add.w	r0, r5, #256	; 0x100
   179ec:	f7f6 f876 	bl	dadc <VectorOscillator::VectorOscillator()>
   179f0:	f8c5 616c 	str.w	r6, [r5, #364]	; 0x16c
   179f4:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   179f8:	f8c5 41d8 	str.w	r4, [r5, #472]	; 0x1d8
   179fc:	f505 70ee 	add.w	r0, r5, #476	; 0x1dc
   17a00:	f7f6 f86c 	bl	dadc <VectorOscillator::VectorOscillator()>
   17a04:	f505 7009 	add.w	r0, r5, #548	; 0x224
   17a08:	f7f6 f868 	bl	dadc <VectorOscillator::VectorOscillator()>
   17a0c:	f505 701b 	add.w	r0, r5, #620	; 0x26c
   17a10:	f7f6 f864 	bl	dadc <VectorOscillator::VectorOscillator()>
class Brancher : public HemisphereApplet {
   17a14:	4b53      	ldr	r3, [pc, #332]	; (17b64 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3bc>)
   17a16:	4a54      	ldr	r2, [pc, #336]	; (17b68 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3c0>)
   17a18:	601a      	str	r2, [r3, #0]
   17a1a:	675a      	str	r2, [r3, #116]	; 0x74
class Burst : public HemisphereApplet {
   17a1c:	4b53      	ldr	r3, [pc, #332]	; (17b6c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3c4>)
   17a1e:	4a54      	ldr	r2, [pc, #336]	; (17b70 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3c8>)
   17a20:	601a      	str	r2, [r3, #0]
   17a22:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
class CVRecV2 : public HemisphereApplet {
   17a26:	4b53      	ldr	r3, [pc, #332]	; (17b74 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3cc>)
   17a28:	4953      	ldr	r1, [pc, #332]	; (17b78 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3d0>)
   17a2a:	6019      	str	r1, [r3, #0]
   17a2c:	f44f 127c 	mov.w	r2, #4128768	; 0x3f0000
   17a30:	f8c3 26f4 	str.w	r2, [r3, #1780]	; 0x6f4
   17a34:	f8c3 16fc 	str.w	r1, [r3, #1788]	; 0x6fc
   17a38:	f8c3 2df0 	str.w	r2, [r3, #3568]	; 0xdf0
   17a3c:	f8c3 46f0 	str.w	r4, [r3, #1776]	; 0x6f0
   17a40:	f8c3 46f8 	str.w	r4, [r3, #1784]	; 0x6f8
   17a44:	f8c3 4dec 	str.w	r4, [r3, #3564]	; 0xdec
   17a48:	f8c3 4df4 	str.w	r4, [r3, #3572]	; 0xdf4
class Calculate : public HemisphereApplet {
   17a4c:	4b4b      	ldr	r3, [pc, #300]	; (17b7c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3d4>)
   17a4e:	4a4c      	ldr	r2, [pc, #304]	; (17b80 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3d8>)
   17a50:	601a      	str	r2, [r3, #0]
   17a52:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
class Carpeggio : public HemisphereApplet {
   17a56:	4b4b      	ldr	r3, [pc, #300]	; (17b84 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3dc>)
   17a58:	4a4b      	ldr	r2, [pc, #300]	; (17b88 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3e0>)
   17a5a:	601a      	str	r2, [r3, #0]
   17a5c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
class ClockDivider : public HemisphereApplet {
   17a60:	4b4a      	ldr	r3, [pc, #296]	; (17b8c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3e4>)
   17a62:	4a4b      	ldr	r2, [pc, #300]	; (17b90 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3e8>)
   17a64:	f8c5 42b4 	str.w	r4, [r5, #692]	; 0x2b4
class ClockSetup : public HemisphereApplet {
   17a68:	4d4a      	ldr	r5, [pc, #296]	; (17b94 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3ec>)
   17a6a:	601a      	str	r2, [r3, #0]
   17a6c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
   17a70:	4b49      	ldr	r3, [pc, #292]	; (17b98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3f0>)
   17a72:	602b      	str	r3, [r5, #0]
   17a74:	f7f0 fa1a 	bl	7eac <ClockManager::get()>
class ClockSkip : public HemisphereApplet {
   17a78:	4b48      	ldr	r3, [pc, #288]	; (17b9c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3f4>)
   17a7a:	4a49      	ldr	r2, [pc, #292]	; (17ba0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3f8>)
   17a7c:	601a      	str	r2, [r3, #0]
   17a7e:	67da      	str	r2, [r3, #124]	; 0x7c
class Compare : public HemisphereApplet {
   17a80:	4b48      	ldr	r3, [pc, #288]	; (17ba4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x3fc>)
   17a82:	4a49      	ldr	r2, [pc, #292]	; (17ba8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x400>)
   17a84:	601a      	str	r2, [r3, #0]
   17a86:	679a      	str	r2, [r3, #120]	; 0x78
class DrCrusher : public HemisphereApplet {
   17a88:	4b48      	ldr	r3, [pc, #288]	; (17bac <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x404>)
   17a8a:	6728      	str	r0, [r5, #112]	; 0x70
   17a8c:	210d      	movs	r1, #13
   17a8e:	4848      	ldr	r0, [pc, #288]	; (17bb0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x408>)
   17a90:	6018      	str	r0, [r3, #0]
   17a92:	e08f      	b.n	17bb4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x40c>
   17a94:	20002aa8 	.word	0x20002aa8
   17a98:	1fff9320 	.word	0x1fff9320
   17a9c:	00003b67 	.word	0x00003b67
   17aa0:	1fffb870 	.word	0x1fffb870
   17aa4:	1fffb1c0 	.word	0x1fffb1c0
   17aa8:	00021e64 	.word	0x00021e64
   17aac:	200046d4 	.word	0x200046d4
   17ab0:	00021e74 	.word	0x00021e74
   17ab4:	1fffd9ac 	.word	0x1fffd9ac
   17ab8:	ffff0000 	.word	0xffff0000
   17abc:	00003a91 	.word	0x00003a91
   17ac0:	200051b8 	.word	0x200051b8
   17ac4:	200046e0 	.word	0x200046e0
   17ac8:	00021ea4 	.word	0x00021ea4
   17acc:	200046d8 	.word	0x200046d8
   17ad0:	200046ec 	.word	0x200046ec
   17ad4:	00021eb4 	.word	0x00021eb4
   17ad8:	00003a93 	.word	0x00003a93
   17adc:	200046dc 	.word	0x200046dc
   17ae0:	00021eec 	.word	0x00021eec
   17ae4:	2000058c 	.word	0x2000058c
   17ae8:	20005a5c 	.word	0x20005a5c
   17aec:	00021f1c 	.word	0x00021f1c
   17af0:	00003a95 	.word	0x00003a95
   17af4:	20003450 	.word	0x20003450
   17af8:	200016c4 	.word	0x200016c4
   17afc:	00021f4c 	.word	0x00021f4c
   17b00:	200046e4 	.word	0x200046e4
   17b04:	1fff9d94 	.word	0x1fff9d94
   17b08:	0001e700 	.word	0x0001e700
   17b0c:	20002444 	.word	0x20002444
   17b10:	00003a97 	.word	0x00003a97
   17b14:	00021f64 	.word	0x00021f64
   17b18:	00021f94 	.word	0x00021f94
   17b1c:	1fffa8c8 	.word	0x1fffa8c8
   17b20:	00021fc4 	.word	0x00021fc4
   17b24:	1fffa9e8 	.word	0x1fffa9e8
   17b28:	00021fe0 	.word	0x00021fe0
   17b2c:	1fffab30 	.word	0x1fffab30
   17b30:	00021ffc 	.word	0x00021ffc
   17b34:	20003660 	.word	0x20003660
   17b38:	00004c33 	.word	0x00004c33
   17b3c:	1fffb390 	.word	0x1fffb390
   17b40:	0002206c 	.word	0x0002206c
   17b44:	20003664 	.word	0x20003664
   17b48:	04030100 	.word	0x04030100
   17b4c:	1fffae98 	.word	0x1fffae98
   17b50:	00022018 	.word	0x00022018
   17b54:	1fffb0c0 	.word	0x1fffb0c0
   17b58:	00022034 	.word	0x00022034
   17b5c:	1fffb1c8 	.word	0x1fffb1c8
   17b60:	00022050 	.word	0x00022050
   17b64:	1fffb668 	.word	0x1fffb668
   17b68:	00022088 	.word	0x00022088
   17b6c:	1fffb750 	.word	0x1fffb750
   17b70:	000220a4 	.word	0x000220a4
   17b74:	1fffb878 	.word	0x1fffb878
   17b78:	000220c0 	.word	0x000220c0
   17b7c:	1fffc670 	.word	0x1fffc670
   17b80:	000220dc 	.word	0x000220dc
   17b84:	1fffc7e8 	.word	0x1fffc7e8
   17b88:	000220f8 	.word	0x000220f8
   17b8c:	1fffc938 	.word	0x1fffc938
   17b90:	00022114 	.word	0x00022114
   17b94:	1fffca50 	.word	0x1fffca50
   17b98:	00022130 	.word	0x00022130
   17b9c:	1fffcac4 	.word	0x1fffcac4
   17ba0:	0002214c 	.word	0x0002214c
   17ba4:	1fffcbbc 	.word	0x1fffcbbc
   17ba8:	00022168 	.word	0x00022168
   17bac:	1fffccac 	.word	0x1fffccac
   17bb0:	00022184 	.word	0x00022184
   17bb4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   17bb8:	6759      	str	r1, [r3, #116]	; 0x74
   17bba:	f8a3 207a 	strh.w	r2, [r3, #122]	; 0x7a
   17bbe:	67d8      	str	r0, [r3, #124]	; 0x7c
   17bc0:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
   17bc4:	f8a3 20f6 	strh.w	r2, [r3, #246]	; 0xf6
   17bc8:	671c      	str	r4, [r3, #112]	; 0x70
   17bca:	f883 4078 	strb.w	r4, [r3, #120]	; 0x78
   17bce:	f8c3 40ec 	str.w	r4, [r3, #236]	; 0xec
   17bd2:	f883 40f4 	strb.w	r4, [r3, #244]	; 0xf4
class DualQuant : public HemisphereApplet {
   17bd6:	4bbf      	ldr	r3, [pc, #764]	; (17ed4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x72c>)
   17bd8:	4abf      	ldr	r2, [pc, #764]	; (17ed8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x730>)
   17bda:	601a      	str	r2, [r3, #0]
   17bdc:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
DualQuant DualQuant_instance[2];
   17be0:	49be      	ldr	r1, [pc, #760]	; (17edc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x734>)
   17be2:	4abf      	ldr	r2, [pc, #764]	; (17ee0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x738>)
LowerRenz LowerRenz_instance[2];
   17be4:	4ebf      	ldr	r6, [pc, #764]	; (17ee4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x73c>)
   17be6:	4620      	mov	r0, r4
   17be8:	f004 fd68 	bl	1c6bc <__aeabi_atexit>
class EnigmaJr : public HemisphereApplet {
   17bec:	4bbe      	ldr	r3, [pc, #760]	; (17ee8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x740>)
   17bee:	49bf      	ldr	r1, [pc, #764]	; (17eec <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x744>)
   17bf0:	6019      	str	r1, [r3, #0]
   17bf2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17bf6:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
   17bfa:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
   17bfe:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
   17c02:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
   17c06:	f8c3 130c 	str.w	r1, [r3, #780]	; 0x30c
   17c0a:	f8c3 24bc 	str.w	r2, [r3, #1212]	; 0x4bc
   17c0e:	f8c3 24c0 	str.w	r2, [r3, #1216]	; 0x4c0
   17c12:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
   17c16:	f8c3 2608 	str.w	r2, [r3, #1544]	; 0x608
EnigmaJr EnigmaJr_instance[2];
   17c1a:	49b5      	ldr	r1, [pc, #724]	; (17ef0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x748>)
   17c1c:	4ab0      	ldr	r2, [pc, #704]	; (17ee0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x738>)
class EnigmaJr : public HemisphereApplet {
   17c1e:	f883 4071 	strb.w	r4, [r3, #113]	; 0x71
   17c22:	f883 437d 	strb.w	r4, [r3, #893]	; 0x37d
EnigmaJr EnigmaJr_instance[2];
   17c26:	4620      	mov	r0, r4
   17c28:	f004 fd48 	bl	1c6bc <__aeabi_atexit>
class EnvFollow : public HemisphereApplet {
   17c2c:	4bb1      	ldr	r3, [pc, #708]	; (17ef4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x74c>)
   17c2e:	4ab2      	ldr	r2, [pc, #712]	; (17ef8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x750>)
   17c30:	601a      	str	r2, [r3, #0]
   17c32:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
class GateDelay : public HemisphereApplet {
   17c36:	4bb1      	ldr	r3, [pc, #708]	; (17efc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x754>)
   17c38:	4ab1      	ldr	r2, [pc, #708]	; (17f00 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x758>)
   17c3a:	601a      	str	r2, [r3, #0]
   17c3c:	f8c3 2284 	str.w	r2, [r3, #644]	; 0x284
class GatedVCA : public HemisphereApplet {
   17c40:	4bb0      	ldr	r3, [pc, #704]	; (17f04 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x75c>)
   17c42:	4ab1      	ldr	r2, [pc, #708]	; (17f08 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x760>)
   17c44:	601a      	str	r2, [r3, #0]
   17c46:	675a      	str	r2, [r3, #116]	; 0x74
class LoFiPCM : public HemisphereApplet {
   17c48:	4bb0      	ldr	r3, [pc, #704]	; (17f0c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x764>)
   17c4a:	48b1      	ldr	r0, [pc, #708]	; (17f10 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x768>)
   17c4c:	6018      	str	r0, [r3, #0]
   17c4e:	f44f 6200 	mov.w	r2, #2048	; 0x800
   17c52:	2108      	movs	r1, #8
   17c54:	f8c3 2878 	str.w	r2, [r3, #2168]	; 0x878
   17c58:	f8a3 486c 	strh.w	r4, [r3, #2156]	; 0x86c
   17c5c:	f883 486e 	strb.w	r4, [r3, #2158]	; 0x86e
   17c60:	f8c3 4870 	str.w	r4, [r3, #2160]	; 0x870
   17c64:	f8c3 1874 	str.w	r1, [r3, #2164]	; 0x874
   17c68:	f8c3 087c 	str.w	r0, [r3, #2172]	; 0x87c
   17c6c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
class Logic : public HemisphereApplet {
   17c70:	2502      	movs	r5, #2
   17c72:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
   17c76:	f8a3 40e8 	strh.w	r4, [r3, #232]	; 0xe8
   17c7a:	f883 40ea 	strb.w	r4, [r3, #234]	; 0xea
   17c7e:	f8c3 40ec 	str.w	r4, [r3, #236]	; 0xec
   17c82:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
   17c86:	4ba3      	ldr	r3, [pc, #652]	; (17f14 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x76c>)
   17c88:	4aa3      	ldr	r2, [pc, #652]	; (17f18 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x770>)
   17c8a:	601a      	str	r2, [r3, #0]
   17c8c:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
   17c90:	f8d7 8000 	ldr.w	r8, [r7]
class LowerRenz : public HemisphereApplet {
   17c94:	4ba1      	ldr	r3, [pc, #644]	; (17f1c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x774>)
   17c96:	6033      	str	r3, [r6, #0]
   17c98:	f1b8 0f00 	cmp.w	r8, #0
   17c9c:	d112      	bne.n	17cc4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x51c>
   17c9e:	2088      	movs	r0, #136	; 0x88
   17ca0:	f002 fad8 	bl	1a254 <operator new(unsigned int)>
        lorenz.Init(0);
   17ca4:	f100 0910 	add.w	r9, r0, #16
        if (!instance) instance = new LorenzGeneratorManager;
   17ca8:	4604      	mov	r4, r0
        lorenz.Init(0);
   17caa:	4641      	mov	r1, r8
   17cac:	4648      	mov	r0, r9
   17cae:	f000 fabb 	bl	18228 <streams::LorenzGenerator::Init(unsigned char)>
        lorenz.Init(1);
   17cb2:	2101      	movs	r1, #1
   17cb4:	4648      	mov	r0, r9
   17cb6:	f000 fab7 	bl	18228 <streams::LorenzGenerator::Init(unsigned char)>
   17cba:	f8c4 a040 	str.w	sl, [r4, #64]	; 0x40
        last_process_tick = 0;
   17cbe:	f8c4 800c 	str.w	r8, [r4, #12]
        if (!instance) instance = new LorenzGeneratorManager;
   17cc2:	603c      	str	r4, [r7, #0]
   17cc4:	683b      	ldr	r3, [r7, #0]
   17cc6:	66f3      	str	r3, [r6, #108]	; 0x6c
LowerRenz LowerRenz_instance[2];
   17cc8:	2d01      	cmp	r5, #1
   17cca:	f106 067c 	add.w	r6, r6, #124	; 0x7c
   17cce:	f040 828d 	bne.w	181ec <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa44>
class Metronome : public HemisphereApplet {
   17cd2:	4c93      	ldr	r4, [pc, #588]	; (17f20 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x778>)
   17cd4:	4e93      	ldr	r6, [pc, #588]	; (17f24 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x77c>)
   17cd6:	6026      	str	r6, [r4, #0]
   17cd8:	f7f0 f8e8 	bl	7eac <ClockManager::get()>
   17cdc:	6766      	str	r6, [r4, #116]	; 0x74
   17cde:	6720      	str	r0, [r4, #112]	; 0x70
   17ce0:	f7f0 f8e4 	bl	7eac <ClockManager::get()>
class MixerBal : public HemisphereApplet {
   17ce4:	4b90      	ldr	r3, [pc, #576]	; (17f28 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x780>)
   17ce6:	4a91      	ldr	r2, [pc, #580]	; (17f2c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x784>)
   17ce8:	601a      	str	r2, [r3, #0]
   17cea:	675a      	str	r2, [r3, #116]	; 0x74
class Palimpsest : public HemisphereApplet {
   17cec:	4b90      	ldr	r3, [pc, #576]	; (17f30 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x788>)
   17cee:	4a91      	ldr	r2, [pc, #580]	; (17f34 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x78c>)
   17cf0:	601a      	str	r2, [r3, #0]
   17cf2:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
class RunglBook : public HemisphereApplet {
   17cf6:	4b90      	ldr	r3, [pc, #576]	; (17f38 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x790>)
   17cf8:	4a90      	ldr	r2, [pc, #576]	; (17f3c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x794>)
   17cfa:	601a      	str	r2, [r3, #0]
   17cfc:	671a      	str	r2, [r3, #112]	; 0x70
class ScaleDuet : public HemisphereApplet {
   17cfe:	4b90      	ldr	r3, [pc, #576]	; (17f40 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x798>)
   17d00:	4a90      	ldr	r2, [pc, #576]	; (17f44 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x79c>)
   17d02:	f8c4 00e4 	str.w	r0, [r4, #228]	; 0xe4
   17d06:	601a      	str	r2, [r3, #0]
   17d08:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
ScaleDuet ScaleDuet_instance[2];
   17d0c:	498e      	ldr	r1, [pc, #568]	; (17f48 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7a0>)
   17d0e:	4a74      	ldr	r2, [pc, #464]	; (17ee0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x738>)
class TLNeuron : public HemisphereApplet {
   17d10:	4e8e      	ldr	r6, [pc, #568]	; (17f4c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7a4>)
   17d12:	f8df 823c 	ldr.w	r8, [pc, #572]	; 17f50 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7a8>
   17d16:	2000      	movs	r0, #0
   17d18:	f004 fcd0 	bl	1c6bc <__aeabi_atexit>
class Schmitt : public HemisphereApplet {
   17d1c:	4b8d      	ldr	r3, [pc, #564]	; (17f54 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7ac>)
   17d1e:	4a8e      	ldr	r2, [pc, #568]	; (17f58 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7b0>)
   17d20:	601a      	str	r2, [r3, #0]
   17d22:	67da      	str	r2, [r3, #124]	; 0x7c
class Scope : public HemisphereApplet {
   17d24:	4b8d      	ldr	r3, [pc, #564]	; (17f5c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7b4>)
   17d26:	4a8e      	ldr	r2, [pc, #568]	; (17f60 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7b8>)
   17d28:	601a      	str	r2, [r3, #0]
   17d2a:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
class Sequence5 : public HemisphereApplet {
   17d2e:	4b8d      	ldr	r3, [pc, #564]	; (17f64 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7bc>)
   17d30:	4a8d      	ldr	r2, [pc, #564]	; (17f68 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7c0>)
   17d32:	601a      	str	r2, [r3, #0]
   17d34:	2400      	movs	r4, #0
   17d36:	f883 4070 	strb.w	r4, [r3, #112]	; 0x70
   17d3a:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
   17d3e:	66dc      	str	r4, [r3, #108]	; 0x6c
   17d40:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
   17d44:	f8c3 40fc 	str.w	r4, [r3, #252]	; 0xfc
   17d48:	f883 4100 	strb.w	r4, [r3, #256]	; 0x100
   17d4c:	f8c3 4118 	str.w	r4, [r3, #280]	; 0x118
class ShiftGate : public HemisphereApplet {
   17d50:	4b86      	ldr	r3, [pc, #536]	; (17f6c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7c4>)
   17d52:	4a87      	ldr	r2, [pc, #540]	; (17f70 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7c8>)
   17d54:	601a      	str	r2, [r3, #0]
   17d56:	679a      	str	r2, [r3, #120]	; 0x78
class Shuffle : public HemisphereApplet {
   17d58:	4b86      	ldr	r3, [pc, #536]	; (17f74 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7cc>)
   17d5a:	4a87      	ldr	r2, [pc, #540]	; (17f78 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7d0>)
   17d5c:	601a      	str	r2, [r3, #0]
   17d5e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
class SkewedLFO : public HemisphereApplet {
   17d62:	4b86      	ldr	r3, [pc, #536]	; (17f7c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7d4>)
   17d64:	4a86      	ldr	r2, [pc, #536]	; (17f80 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7d8>)
   17d66:	601a      	str	r2, [r3, #0]
   17d68:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
class Slew : public HemisphereApplet {
   17d6c:	4b85      	ldr	r3, [pc, #532]	; (17f84 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7dc>)
   17d6e:	4a86      	ldr	r2, [pc, #536]	; (17f88 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7e0>)
   17d70:	601a      	str	r2, [r3, #0]
   17d72:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
class Squanch : public HemisphereApplet {
   17d76:	4b85      	ldr	r3, [pc, #532]	; (17f8c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7e4>)
   17d78:	4a85      	ldr	r2, [pc, #532]	; (17f90 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7e8>)
   17d7a:	601a      	str	r2, [r3, #0]
   17d7c:	f883 5070 	strb.w	r5, [r3, #112]	; 0x70
   17d80:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
   17d84:	f883 522c 	strb.w	r5, [r3, #556]	; 0x22c
Squanch Squanch_instance[2];
   17d88:	4a55      	ldr	r2, [pc, #340]	; (17ee0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x738>)
   17d8a:	4982      	ldr	r1, [pc, #520]	; (17f94 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7ec>)
   17d8c:	4620      	mov	r0, r4
   17d8e:	f004 fc95 	bl	1c6bc <__aeabi_atexit>
class Switch : public HemisphereApplet {
   17d92:	4b81      	ldr	r3, [pc, #516]	; (17f98 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7f0>)
   17d94:	4a81      	ldr	r2, [pc, #516]	; (17f9c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7f4>)
   17d96:	601a      	str	r2, [r3, #0]
   17d98:	66dc      	str	r4, [r3, #108]	; 0x6c
   17d9a:	679a      	str	r2, [r3, #120]	; 0x78
   17d9c:	f8c3 40e4 	str.w	r4, [r3, #228]	; 0xe4
   17da0:	4b7f      	ldr	r3, [pc, #508]	; (17fa0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7f8>)
   17da2:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   17da6:	461f      	mov	r7, r3
   17da8:	f04f 0e09 	mov.w	lr, #9
   17dac:	f847 8b70 	str.w	r8, [r7], #112
   17db0:	f04f 0c05 	mov.w	ip, #5
   17db4:	f8c3 e07c 	str.w	lr, [r3, #124]	; 0x7c
   17db8:	f8c3 c084 	str.w	ip, [r3, #132]	; 0x84
   17dbc:	f8c3 e108 	str.w	lr, [r3, #264]	; 0x108
   17dc0:	f8c3 c110 	str.w	ip, [r3, #272]	; 0x110
   17dc4:	e887 0007 	stmia.w	r7, {r0, r1, r2}
   17dc8:	f8c3 808c 	str.w	r8, [r3, #140]	; 0x8c
   17dcc:	f103 07fc 	add.w	r7, r3, #252	; 0xfc
class TM : public HemisphereApplet {
   17dd0:	4b74      	ldr	r3, [pc, #464]	; (17fa4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x7fc>)
class VectorEG : public HemisphereApplet {
   17dd2:	4e75      	ldr	r6, [pc, #468]	; (17fa8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x800>)
   17dd4:	e887 0007 	stmia.w	r7, {r0, r1, r2}
   17dd8:	4a74      	ldr	r2, [pc, #464]	; (17fac <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x804>)
   17dda:	601a      	str	r2, [r3, #0]
   17ddc:	f8c3 21b8 	str.w	r2, [r3, #440]	; 0x1b8
TM TM_instance[2];
   17de0:	4973      	ldr	r1, [pc, #460]	; (17fb0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x808>)
   17de2:	4a3f      	ldr	r2, [pc, #252]	; (17ee0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x738>)
   17de4:	4620      	mov	r0, r4
   17de6:	f004 fc69 	bl	1c6bc <__aeabi_atexit>
class Trending : public HemisphereApplet {
   17dea:	4b72      	ldr	r3, [pc, #456]	; (17fb4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x80c>)
   17dec:	4a72      	ldr	r2, [pc, #456]	; (17fb8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x810>)
   17dee:	601a      	str	r2, [r3, #0]
   17df0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
class TrigSeq : public HemisphereApplet {
   17df4:	4b71      	ldr	r3, [pc, #452]	; (17fbc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x814>)
   17df6:	4a72      	ldr	r2, [pc, #456]	; (17fc0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x818>)
   17df8:	601a      	str	r2, [r3, #0]
   17dfa:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
class TrigSeq16 : public HemisphereApplet {
   17dfe:	4b71      	ldr	r3, [pc, #452]	; (17fc4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x81c>)
   17e00:	4a71      	ldr	r2, [pc, #452]	; (17fc8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x820>)
   17e02:	601a      	str	r2, [r3, #0]
   17e04:	67da      	str	r2, [r3, #124]	; 0x7c
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
   17e06:	4a71      	ldr	r2, [pc, #452]	; (17fcc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x824>)
class Tuner : public HemisphereApplet {
   17e08:	4b71      	ldr	r3, [pc, #452]	; (17fd0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x828>)
   17e0a:	6810      	ldr	r0, [r2, #0]
   17e0c:	4c71      	ldr	r4, [pc, #452]	; (17fd4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x82c>)
   17e0e:	9001      	str	r0, [sp, #4]
	return ret;
   17e10:	9801      	ldr	r0, [sp, #4]
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
   17e12:	6812      	ldr	r2, [r2, #0]
	elapsedMillis(void) { ms = millis(); }
   17e14:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
   17e18:	9201      	str	r2, [sp, #4]
   17e1a:	4620      	mov	r0, r4
   17e1c:	496e      	ldr	r1, [pc, #440]	; (17fd8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x830>)
	return ret;
   17e1e:	9a01      	ldr	r2, [sp, #4]
   17e20:	6019      	str	r1, [r3, #0]
   17e22:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
   17e26:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   17e2a:	f840 6b70 	str.w	r6, [r0], #112
   17e2e:	f7f5 fe55 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e32:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
   17e36:	f7f5 fe51 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e3a:	f8c4 6114 	str.w	r6, [r4, #276]	; 0x114
   17e3e:	f504 70c2 	add.w	r0, r4, #388	; 0x184
   17e42:	f7f5 fe4b 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e46:	f504 70e6 	add.w	r0, r4, #460	; 0x1cc
class VectorLFO : public HemisphereApplet {
   17e4a:	4c64      	ldr	r4, [pc, #400]	; (17fdc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x834>)
   17e4c:	4e64      	ldr	r6, [pc, #400]	; (17fe0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x838>)
   17e4e:	f7f5 fe45 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e52:	4620      	mov	r0, r4
   17e54:	f840 6b70 	str.w	r6, [r0], #112
   17e58:	f7f5 fe40 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e5c:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
   17e60:	f7f5 fe3c 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e64:	f8c4 6110 	str.w	r6, [r4, #272]	; 0x110
   17e68:	f504 70c0 	add.w	r0, r4, #384	; 0x180
   17e6c:	f7f5 fe36 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e70:	f504 70e4 	add.w	r0, r4, #456	; 0x1c8
class VectorMod : public HemisphereApplet {
   17e74:	4c5b      	ldr	r4, [pc, #364]	; (17fe4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x83c>)
   17e76:	4e5c      	ldr	r6, [pc, #368]	; (17fe8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x840>)
   17e78:	f7f5 fe30 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e7c:	4620      	mov	r0, r4
   17e7e:	f840 6b70 	str.w	r6, [r0], #112
   17e82:	f7f5 fe2b 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e86:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
   17e8a:	f7f5 fe27 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e8e:	f8c4 6110 	str.w	r6, [r4, #272]	; 0x110
   17e92:	f504 70c0 	add.w	r0, r4, #384	; 0x180
   17e96:	f7f5 fe21 	bl	dadc <VectorOscillator::VectorOscillator()>
   17e9a:	f504 70e4 	add.w	r0, r4, #456	; 0x1c8
class VectorMorph : public HemisphereApplet {
   17e9e:	4c53      	ldr	r4, [pc, #332]	; (17fec <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x844>)
   17ea0:	4e53      	ldr	r6, [pc, #332]	; (17ff0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x848>)
   17ea2:	f7f5 fe1b 	bl	dadc <VectorOscillator::VectorOscillator()>
   17ea6:	4620      	mov	r0, r4
   17ea8:	f840 6b70 	str.w	r6, [r0], #112
   17eac:	f7f5 fe16 	bl	dadc <VectorOscillator::VectorOscillator()>
   17eb0:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
   17eb4:	f7f5 fe12 	bl	dadc <VectorOscillator::VectorOscillator()>
   17eb8:	f884 5118 	strb.w	r5, [r4, #280]	; 0x118
   17ebc:	f8c4 611c 	str.w	r6, [r4, #284]	; 0x11c
   17ec0:	f504 70c6 	add.w	r0, r4, #396	; 0x18c
   17ec4:	f7f5 fe0a 	bl	dadc <VectorOscillator::VectorOscillator()>
   17ec8:	f504 70ea 	add.w	r0, r4, #468	; 0x1d4
   17ecc:	f7f5 fe06 	bl	dadc <VectorOscillator::VectorOscillator()>
   17ed0:	e090      	b.n	17ff4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x84c>
   17ed2:	bf00      	nop
   17ed4:	1fffcda4 	.word	0x1fffcda4
   17ed8:	000221a0 	.word	0x000221a0
   17edc:	00004c35 	.word	0x00004c35
   17ee0:	1fff9320 	.word	0x1fff9320
   17ee4:	200002c4 	.word	0x200002c4
   17ee8:	1fffd394 	.word	0x1fffd394
   17eec:	000221bc 	.word	0x000221bc
   17ef0:	00004c37 	.word	0x00004c37
   17ef4:	1fffe940 	.word	0x1fffe940
   17ef8:	000221d8 	.word	0x000221d8
   17efc:	1fffea60 	.word	0x1fffea60
   17f00:	000221f4 	.word	0x000221f4
   17f04:	1fffef68 	.word	0x1fffef68
   17f08:	00022210 	.word	0x00022210
   17f0c:	1ffff054 	.word	0x1ffff054
   17f10:	0002222c 	.word	0x0002222c
   17f14:	2000014c 	.word	0x2000014c
   17f18:	00022248 	.word	0x00022248
   17f1c:	00022264 	.word	0x00022264
   17f20:	200003bc 	.word	0x200003bc
   17f24:	00022280 	.word	0x00022280
   17f28:	200004a4 	.word	0x200004a4
   17f2c:	0002229c 	.word	0x0002229c
   17f30:	20000d34 	.word	0x20000d34
   17f34:	000222b8 	.word	0x000222b8
   17f38:	20000ecc 	.word	0x20000ecc
   17f3c:	000222d4 	.word	0x000222d4
   17f40:	20000fac 	.word	0x20000fac
   17f44:	000222f0 	.word	0x000222f0
   17f48:	00004c39 	.word	0x00004c39
   17f4c:	00022f2c 	.word	0x00022f2c
   17f50:	00022408 	.word	0x00022408
   17f54:	2000130c 	.word	0x2000130c
   17f58:	0002230c 	.word	0x0002230c
   17f5c:	20001404 	.word	0x20001404
   17f60:	00022328 	.word	0x00022328
   17f64:	200015a4 	.word	0x200015a4
   17f68:	00022344 	.word	0x00022344
   17f6c:	20001744 	.word	0x20001744
   17f70:	00022360 	.word	0x00022360
   17f74:	20001834 	.word	0x20001834
   17f78:	0002237c 	.word	0x0002237c
   17f7c:	2000193c 	.word	0x2000193c
   17f80:	00022398 	.word	0x00022398
   17f84:	20001a44 	.word	0x20001a44
   17f88:	000223b4 	.word	0x000223b4
   17f8c:	20001b54 	.word	0x20001b54
   17f90:	000223d0 	.word	0x000223d0
   17f94:	00004c3b 	.word	0x00004c3b
   17f98:	20001ecc 	.word	0x20001ecc
   17f9c:	000223ec 	.word	0x000223ec
   17fa0:	20001fbc 	.word	0x20001fbc
   17fa4:	200020d4 	.word	0x200020d4
   17fa8:	000224b0 	.word	0x000224b0
   17fac:	00022424 	.word	0x00022424
   17fb0:	00003e2f 	.word	0x00003e2f
   17fb4:	20002654 	.word	0x20002654
   17fb8:	00022440 	.word	0x00022440
   17fbc:	2000288c 	.word	0x2000288c
   17fc0:	0002245c 	.word	0x0002245c
   17fc4:	20002794 	.word	0x20002794
   17fc8:	00022478 	.word	0x00022478
   17fcc:	20006600 	.word	0x20006600
   17fd0:	20002998 	.word	0x20002998
   17fd4:	20002ab0 	.word	0x20002ab0
   17fd8:	00022494 	.word	0x00022494
   17fdc:	20002cd8 	.word	0x20002cd8
   17fe0:	000224cc 	.word	0x000224cc
   17fe4:	20002ef8 	.word	0x20002ef8
   17fe8:	000224e8 	.word	0x000224e8
   17fec:	20003118 	.word	0x20003118
   17ff0:	00022504 	.word	0x00022504
class Voltage : public HemisphereApplet {
   17ff4:	4b7e      	ldr	r3, [pc, #504]	; (181f0 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa48>)
   17ff6:	4a7f      	ldr	r2, [pc, #508]	; (181f4 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa4c>)
   17ff8:	601a      	str	r2, [r3, #0]
   17ffa:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
class hMIDIIn : public HemisphereApplet {
   17ffe:	4b7e      	ldr	r3, [pc, #504]	; (181f8 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa50>)
   18000:	4a7e      	ldr	r2, [pc, #504]	; (181fc <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa54>)
   18002:	601a      	str	r2, [r3, #0]
   18004:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
class hMIDIOut : public HemisphereApplet {
   18008:	4b7d      	ldr	r3, [pc, #500]	; (18200 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa58>)
   1800a:	4a7e      	ldr	r2, [pc, #504]	; (18204 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa5c>)
   1800c:	601a      	str	r2, [r3, #0]
   1800e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
static const uint16_t DEFAULT_APP_ID = available_apps[DEFAULT_APP_INDEX].id;
   18012:	4b7d      	ldr	r3, [pc, #500]	; (18208 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa60>)
   18014:	f884 5234 	strb.w	r5, [r4, #564]	; 0x234
   18018:	881a      	ldrh	r2, [r3, #0]
   1801a:	4b7c      	ldr	r3, [pc, #496]	; (1820c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa64>)
   1801c:	801a      	strh	r2, [r3, #0]
};
   1801e:	4b7c      	ldr	r3, [pc, #496]	; (18210 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa68>)
   18020:	4a7c      	ldr	r2, [pc, #496]	; (18214 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa6c>)
   18022:	6818      	ldr	r0, [r3, #0]
   18024:	4b7c      	ldr	r3, [pc, #496]	; (18218 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa70>)
   18026:	6812      	ldr	r2, [r2, #0]
   18028:	611a      	str	r2, [r3, #16]
   1802a:	4a7c      	ldr	r2, [pc, #496]	; (1821c <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa74>)
   1802c:	60d8      	str	r0, [r3, #12]
   1802e:	6811      	ldr	r1, [r2, #0]
   18030:	4a7b      	ldr	r2, [pc, #492]	; (18220 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa78>)
   18032:	6359      	str	r1, [r3, #52]	; 0x34
   18034:	6812      	ldr	r2, [r2, #0]
   18036:	639a      	str	r2, [r3, #56]	; 0x38
   18038:	661a      	str	r2, [r3, #96]	; 0x60
   1803a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
   1803e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
   18042:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   18046:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   1804a:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
   1804e:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
   18052:	65d9      	str	r1, [r3, #92]	; 0x5c
   18054:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
   18058:	f8c3 10ac 	str.w	r1, [r3, #172]	; 0xac
   1805c:	f8c3 10d4 	str.w	r1, [r3, #212]	; 0xd4
   18060:	f8c3 10fc 	str.w	r1, [r3, #252]	; 0xfc
   18064:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
   18068:	f8c3 114c 	str.w	r1, [r3, #332]	; 0x14c
   1806c:	f8c3 1174 	str.w	r1, [r3, #372]	; 0x174
   18070:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
   18074:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
   18078:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
   1807c:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
   18080:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
   18084:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
   18088:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
   1808c:	f8c3 2290 	str.w	r2, [r3, #656]	; 0x290
   18090:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
   18094:	f8c3 22e0 	str.w	r2, [r3, #736]	; 0x2e0
   18098:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   1809c:	f8c3 2330 	str.w	r2, [r3, #816]	; 0x330
   180a0:	f8c3 2358 	str.w	r2, [r3, #856]	; 0x358
   180a4:	f8c3 2380 	str.w	r2, [r3, #896]	; 0x380
   180a8:	f8c3 23a8 	str.w	r2, [r3, #936]	; 0x3a8
   180ac:	f8c3 23d0 	str.w	r2, [r3, #976]	; 0x3d0
   180b0:	f8c3 23f8 	str.w	r2, [r3, #1016]	; 0x3f8
   180b4:	f8c3 119c 	str.w	r1, [r3, #412]	; 0x19c
   180b8:	f8c3 11c4 	str.w	r1, [r3, #452]	; 0x1c4
   180bc:	f8c3 11ec 	str.w	r1, [r3, #492]	; 0x1ec
   180c0:	f8c3 1214 	str.w	r1, [r3, #532]	; 0x214
   180c4:	f8c3 123c 	str.w	r1, [r3, #572]	; 0x23c
   180c8:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
   180cc:	f8c3 128c 	str.w	r1, [r3, #652]	; 0x28c
   180d0:	f8c3 12b4 	str.w	r1, [r3, #692]	; 0x2b4
   180d4:	f8c3 12dc 	str.w	r1, [r3, #732]	; 0x2dc
   180d8:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
   180dc:	f8c3 132c 	str.w	r1, [r3, #812]	; 0x32c
   180e0:	f8c3 1354 	str.w	r1, [r3, #852]	; 0x354
   180e4:	f8c3 137c 	str.w	r1, [r3, #892]	; 0x37c
   180e8:	f8c3 13a4 	str.w	r1, [r3, #932]	; 0x3a4
   180ec:	f8c3 13cc 	str.w	r1, [r3, #972]	; 0x3cc
   180f0:	f8c3 13f4 	str.w	r1, [r3, #1012]	; 0x3f4
   180f4:	f8c3 141c 	str.w	r1, [r3, #1052]	; 0x41c
   180f8:	f8c3 2420 	str.w	r2, [r3, #1056]	; 0x420
   180fc:	f8c3 2448 	str.w	r2, [r3, #1096]	; 0x448
   18100:	f8c3 2470 	str.w	r2, [r3, #1136]	; 0x470
   18104:	f8c3 2498 	str.w	r2, [r3, #1176]	; 0x498
   18108:	f8c3 24c0 	str.w	r2, [r3, #1216]	; 0x4c0
   1810c:	f8c3 24e8 	str.w	r2, [r3, #1256]	; 0x4e8
   18110:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
   18114:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
   18118:	f8c3 2560 	str.w	r2, [r3, #1376]	; 0x560
   1811c:	f8c3 2588 	str.w	r2, [r3, #1416]	; 0x588
   18120:	f8c3 25b0 	str.w	r2, [r3, #1456]	; 0x5b0
   18124:	f8c3 25d8 	str.w	r2, [r3, #1496]	; 0x5d8
   18128:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
   1812c:	f8c3 2628 	str.w	r2, [r3, #1576]	; 0x628
   18130:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
   18134:	f8c3 2678 	str.w	r2, [r3, #1656]	; 0x678
   18138:	f8c3 1444 	str.w	r1, [r3, #1092]	; 0x444
   1813c:	f8c3 146c 	str.w	r1, [r3, #1132]	; 0x46c
   18140:	f8c3 1494 	str.w	r1, [r3, #1172]	; 0x494
   18144:	f8c3 14bc 	str.w	r1, [r3, #1212]	; 0x4bc
   18148:	f8c3 14e4 	str.w	r1, [r3, #1252]	; 0x4e4
   1814c:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
   18150:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
   18154:	f8c3 155c 	str.w	r1, [r3, #1372]	; 0x55c
   18158:	f8c3 1584 	str.w	r1, [r3, #1412]	; 0x584
   1815c:	f8c3 15ac 	str.w	r1, [r3, #1452]	; 0x5ac
   18160:	f8c3 15d4 	str.w	r1, [r3, #1492]	; 0x5d4
   18164:	f8c3 15fc 	str.w	r1, [r3, #1532]	; 0x5fc
   18168:	f8c3 1624 	str.w	r1, [r3, #1572]	; 0x624
   1816c:	f8c3 164c 	str.w	r1, [r3, #1612]	; 0x64c
   18170:	f8c3 1674 	str.w	r1, [r3, #1652]	; 0x674
   18174:	f8c3 169c 	str.w	r1, [r3, #1692]	; 0x69c
   18178:	f8c3 26a0 	str.w	r2, [r3, #1696]	; 0x6a0
   1817c:	f8c3 26c8 	str.w	r2, [r3, #1736]	; 0x6c8
   18180:	f8c3 26f0 	str.w	r2, [r3, #1776]	; 0x6f0
   18184:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
   18188:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
   1818c:	f8c3 2768 	str.w	r2, [r3, #1896]	; 0x768
   18190:	f8c3 2790 	str.w	r2, [r3, #1936]	; 0x790
   18194:	f8c3 27b8 	str.w	r2, [r3, #1976]	; 0x7b8
   18198:	f8c3 27e0 	str.w	r2, [r3, #2016]	; 0x7e0
   1819c:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
   181a0:	f8c3 2830 	str.w	r2, [r3, #2096]	; 0x830
   181a4:	f8c3 2858 	str.w	r2, [r3, #2136]	; 0x858
   181a8:	f8c3 2880 	str.w	r2, [r3, #2176]	; 0x880
   181ac:	4a1d      	ldr	r2, [pc, #116]	; (18224 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0xa7c>)
   181ae:	f8c3 16c4 	str.w	r1, [r3, #1732]	; 0x6c4
   181b2:	6812      	ldr	r2, [r2, #0]
   181b4:	f8c3 16ec 	str.w	r1, [r3, #1772]	; 0x6ec
   181b8:	f8c3 1714 	str.w	r1, [r3, #1812]	; 0x714
   181bc:	f8c3 173c 	str.w	r1, [r3, #1852]	; 0x73c
   181c0:	f8c3 1764 	str.w	r1, [r3, #1892]	; 0x764
   181c4:	f8c3 178c 	str.w	r1, [r3, #1932]	; 0x78c
   181c8:	f8c3 17b4 	str.w	r1, [r3, #1972]	; 0x7b4
   181cc:	f8c3 17dc 	str.w	r1, [r3, #2012]	; 0x7dc
   181d0:	f8c3 1804 	str.w	r1, [r3, #2052]	; 0x804
   181d4:	f8c3 187c 	str.w	r1, [r3, #2172]	; 0x87c
   181d8:	f8c3 08a4 	str.w	r0, [r3, #2212]	; 0x8a4
   181dc:	f8c3 28a8 	str.w	r2, [r3, #2216]	; 0x8a8
}
   181e0:	b002      	add	sp, #8
   181e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   181e6:	2701      	movs	r7, #1
   181e8:	f7ff bbac 	b.w	17944 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x19c>
   181ec:	2501      	movs	r5, #1
   181ee:	e54f      	b.n	17c90 <_GLOBAL__sub_I_LAST_REDRAW_TIME+0x4e8>
   181f0:	20003350 	.word	0x20003350
   181f4:	00022520 	.word	0x00022520
   181f8:	20004db8 	.word	0x20004db8
   181fc:	0002253c 	.word	0x0002253c
   18200:	20004fb8 	.word	0x20004fb8
   18204:	00022558 	.word	0x00022558
   18208:	1fff9e54 	.word	0x1fff9e54
   1820c:	200046d0 	.word	0x200046d0
   18210:	1fffa0b0 	.word	0x1fffa0b0
   18214:	1fffa0b4 	.word	0x1fffa0b4
   18218:	1fff9328 	.word	0x1fff9328
   1821c:	1fffa060 	.word	0x1fffa060
   18220:	1fffa05c 	.word	0x1fffa05c
   18224:	1fffa064 	.word	0x1fffa064

00018228 <streams::LorenzGenerator::Init(unsigned char)>:
const int64_t a = 0.1 * (1 << 24);
const int64_t b = 0.1 * (1 << 24);
// const int64_t c = 13.0 * (1 << 24);

void LorenzGenerator::Init(uint8_t index) {
  if (index) {
   18228:	4b08      	ldr	r3, [pc, #32]	; (1824c <streams::LorenzGenerator::Init(unsigned char)+0x24>)
   1822a:	b139      	cbz	r1, 1823c <streams::LorenzGenerator::Init(unsigned char)+0x14>
    Lx2_ = 0.1 * (1 << 24);
    Ly2_ = 0;
   1822c:	2200      	movs	r2, #0
    Lz2_ = 0;
    Rx2_ = 0.1 * (1 << 24);
   1822e:	e9c0 2308 	strd	r2, r3, [r0, #32]
    Ry2_ = 0;
    Rz2_ = 0;
   18232:	e9c0 220a 	strd	r2, r2, [r0, #40]	; 0x28
    Lx2_ = 0.1 * (1 << 24);
   18236:	6183      	str	r3, [r0, #24]
    Ly2_ = 0;
   18238:	61c2      	str	r2, [r0, #28]
    Lz1_ = 0;
    Rx1_ = 0.1 * (1 << 24);
    Ry1_ = 0;
    Rz1_ = 0;
  }
}
   1823a:	4770      	bx	lr
    Ly1_ = 0;
   1823c:	e9c0 3100 	strd	r3, r1, [r0]
    Rx1_ = 0.1 * (1 << 24);
   18240:	e9c0 1302 	strd	r1, r3, [r0, #8]
    Rz1_ = 0;
   18244:	e9c0 1104 	strd	r1, r1, [r0, #16]
}
   18248:	4770      	bx	lr
   1824a:	bf00      	nop
   1824c:	00199999 	.word	0x00199999

00018250 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)>:
    int32_t freq1,
    int32_t freq2,
    bool reset1,
    bool reset2,
    uint8_t freq_range1,
    uint8_t freq_range2) {
   18250:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18254:	b08f      	sub	sp, #60	; 0x3c
   18256:	f3a2 2208 	usat	r2, #8, r2, asr #8
   1825a:	f89d 5060 	ldrb.w	r5, [sp, #96]	; 0x60
   1825e:	4cdc      	ldr	r4, [pc, #880]	; (185d0 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x380>)
   18260:	9202      	str	r2, [sp, #8]
   18262:	f3a1 2e08 	usat	lr, #8, r1, asr #8
  if (rate1 > 255) rate1 = 255;
  int32_t rate2 = (freq2 >> 8);
  if (rate2 < 0) rate2 = 0;
  if (rate2 > 255) rate2 = 255;

  if (reset1) Init(0) ;
   18266:	b133      	cbz	r3, 18276 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x26>
    Ly1_ = 0;
   18268:	2300      	movs	r3, #0
    Rx1_ = 0.1 * (1 << 24);
   1826a:	e9c0 3402 	strd	r3, r4, [r0, #8]
    Rz1_ = 0;
   1826e:	e9c0 3304 	strd	r3, r3, [r0, #16]
    Lx1_ = 0.1 * (1 << 24);
   18272:	6004      	str	r4, [r0, #0]
    Ly1_ = 0;
   18274:	6043      	str	r3, [r0, #4]
  if (reset2) Init(1) ; 
   18276:	b135      	cbz	r5, 18286 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x36>
    Ly2_ = 0;
   18278:	2300      	movs	r3, #0
    Rx2_ = 0.1 * (1 << 24);
   1827a:	e9c0 3408 	strd	r3, r4, [r0, #32]
    Rz2_ = 0;
   1827e:	e9c0 330a 	strd	r3, r3, [r0, #40]	; 0x28
    Lx2_ = 0.1 * (1 << 24);
   18282:	6184      	str	r4, [r0, #24]
    Ly2_ = 0;
   18284:	61c3      	str	r3, [r0, #28]

  // yes, yes, these should be functions...
  // Lorenz 1
  int64_t Ldt1 = static_cast<int64_t>(lut_lorenz_rate[rate1] >> (5 - freq_range1)); // was 5
   18286:	f8df 834c 	ldr.w	r8, [pc, #844]	; 185d4 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x384>
   1828a:	f89d 3064 	ldrb.w	r3, [sp, #100]	; 0x64
   1828e:	f858 202e 	ldr.w	r2, [r8, lr, lsl #2]
   18292:	f1c3 0305 	rsb	r3, r3, #5
   18296:	fa22 fc03 	lsr.w	ip, r2, r3
  int32_t Lx1 = Lx1_ + (Ldt1 * ((sigma * (Ly1_ - Lx1_)) >> 24) >> 24);
   1829a:	e9d0 9200 	ldrd	r9, r2, [r0]
   1829e:	f04f 6520 	mov.w	r5, #167772160	; 0xa000000
   182a2:	eba2 0309 	sub.w	r3, r2, r9
   182a6:	fb83 3105 	smull	r3, r1, r3, r5
   182aa:	0e1b      	lsrs	r3, r3, #24
   182ac:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   182b0:	fba3 360c 	umull	r3, r6, r3, ip
   182b4:	1609      	asrs	r1, r1, #24
   182b6:	fb0c 6101 	mla	r1, ip, r1, r6
   182ba:	0e1b      	lsrs	r3, r3, #24
  int32_t Ly1 = Ly1_ + (Ldt1 * ((Lx1_ * (rho1_ - Lz1_) >> 24) - Ly1_) >> 24);
   182bc:	e9d0 6710 	ldrd	r6, r7, [r0, #64]	; 0x40
  int32_t Lx1 = Lx1_ + (Ldt1 * ((sigma * (Ly1_ - Lx1_)) >> 24) >> 24);
   182c0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  int32_t Ly1 = Ly1_ + (Ldt1 * ((Lx1_ * (rho1_ - Lz1_) >> 24) - Ly1_) >> 24);
   182c4:	6881      	ldr	r1, [r0, #8]
   182c6:	ea4f 7ae9 	mov.w	sl, r9, asr #31
   182ca:	1a76      	subs	r6, r6, r1
   182cc:	eb67 77e1 	sbc.w	r7, r7, r1, asr #31
   182d0:	fb06 fa0a 	mul.w	sl, r6, sl
   182d4:	fb09 aa07 	mla	sl, r9, r7, sl
   182d8:	fba6 6709 	umull	r6, r7, r6, r9
   182dc:	44ba      	add	sl, r7
   182de:	0e36      	lsrs	r6, r6, #24
   182e0:	ea46 260a 	orr.w	r6, r6, sl, lsl #8
   182e4:	1ab6      	subs	r6, r6, r2
   182e6:	ea4f 6a2a 	mov.w	sl, sl, asr #24
   182ea:	eb6a 7ae2 	sbc.w	sl, sl, r2, asr #31
   182ee:	fba6 760c 	umull	r7, r6, r6, ip
   182f2:	fb0c 660a 	mla	r6, ip, sl, r6
   182f6:	0e3f      	lsrs	r7, r7, #24
   182f8:	ea47 2706 	orr.w	r7, r7, r6, lsl #8
  int32_t Lz1 = Lz1_ + (Ldt1 * ((Lx1_ * int64_t(Ly1_) >> 24) - (beta * Lz1_ >> 24)) >> 24); 
   182fc:	4eb6      	ldr	r6, [pc, #728]	; (185d8 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x388>)
  int32_t Lx1 = Lx1_ + (Ldt1 * ((sigma * (Ly1_ - Lx1_)) >> 24) >> 24);
   182fe:	444b      	add	r3, r9
  int32_t Lz1 = Lz1_ + (Ldt1 * ((Lx1_ * int64_t(Ly1_) >> 24) - (beta * Lz1_ >> 24)) >> 24); 
   18300:	fb81 6a06 	smull	r6, sl, r1, r6
  int32_t Ly1 = Ly1_ + (Ldt1 * ((Lx1_ * (rho1_ - Lz1_) >> 24) - Ly1_) >> 24);
   18304:	4417      	add	r7, r2
  int32_t Lz1 = Lz1_ + (Ldt1 * ((Lx1_ * int64_t(Ly1_) >> 24) - (beta * Lz1_ >> 24)) >> 24); 
   18306:	fb89 2902 	smull	r2, r9, r9, r2
   1830a:	0e12      	lsrs	r2, r2, #24
   1830c:	0e36      	lsrs	r6, r6, #24
   1830e:	ea42 2209 	orr.w	r2, r2, r9, lsl #8
   18312:	ea46 260a 	orr.w	r6, r6, sl, lsl #8
   18316:	1b96      	subs	r6, r2, r6
   18318:	ea4f 6929 	mov.w	r9, r9, asr #24
   1831c:	eb69 6a2a 	sbc.w	sl, r9, sl, asr #24
   18320:	fba6 260c 	umull	r2, r6, r6, ip
   18324:	fb0c 660a 	mla	r6, ip, sl, r6
   18328:	0e12      	lsrs	r2, r2, #24
   1832a:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  Lx1_ = Lx1;
  Ly1_ = Ly1;
   1832e:	e9c0 3700 	strd	r3, r7, [r0]
  int32_t Lz1 = Lz1_ + (Ldt1 * ((Lx1_ * int64_t(Ly1_) >> 24) - (beta * Lz1_ >> 24)) >> 24); 
   18332:	4411      	add	r1, r2
  Lz1_ = Lz1; 
   18334:	6081      	str	r1, [r0, #8]
  int32_t Lz1_scaled = ((Lz1 * 3) >> 16);
   18336:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   1833a:	140a      	asrs	r2, r1, #16
  int32_t Lx1_scaled = ((Lx1 * 3) >> 16) + 32769;
  int32_t Ly1_scaled = ((Ly1 * 3) >> 16) + 32769;
  // Rossler 1
  int64_t Rdt1 = static_cast<int64_t>(lut_lorenz_rate[rate1] >> 0);
   1833c:	f858 602e 	ldr.w	r6, [r8, lr, lsl #2]
  int32_t Lz1_scaled = ((Lz1 * 3) >> 16);
   18340:	9208      	str	r2, [sp, #32]
  int32_t Rx1 = Rx1_ + ((Rdt1 * (-Ry1_ - Rz1_ )) >> 24);
   18342:	e9d0 2e04 	ldrd	r2, lr, [r0, #16]
   18346:	4251      	negs	r1, r2
  int32_t Lx1_scaled = ((Lx1 * 3) >> 16) + 32769;
   18348:	f248 0c01 	movw	ip, #32769	; 0x8001
  int32_t Rx1 = Rx1_ + ((Rdt1 * (-Ry1_ - Rz1_ )) >> 24);
   1834c:	eba1 010e 	sub.w	r1, r1, lr
  int32_t Lx1_scaled = ((Lx1 * 3) >> 16) + 32769;
   18350:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  int32_t Ly1_scaled = ((Ly1 * 3) >> 16) + 32769;
   18354:	eb07 0747 	add.w	r7, r7, r7, lsl #1
  int32_t Lx1_scaled = ((Lx1 * 3) >> 16) + 32769;
   18358:	eb0c 4a23 	add.w	sl, ip, r3, asr #16
  int32_t Ly1_scaled = ((Ly1 * 3) >> 16) + 32769;
   1835c:	eb0c 4327 	add.w	r3, ip, r7, asr #16
  int32_t Rx1 = Rx1_ + ((Rdt1 * (-Ry1_ - Rz1_ )) >> 24);
   18360:	17cf      	asrs	r7, r1, #31
   18362:	fba1 1206 	umull	r1, r2, r1, r6
   18366:	fb06 2207 	mla	r2, r6, r7, r2
  int32_t Ry1 = Ry1_ + ((Rdt1 * (Rx1_ + ((a * Ry1_) >> 24))) >> 24);
   1836a:	6907      	ldr	r7, [r0, #16]
  int32_t Ly1_scaled = ((Ly1 * 3) >> 16) + 32769;
   1836c:	9303      	str	r3, [sp, #12]
  int32_t Rx1 = Rx1_ + ((Rdt1 * (-Ry1_ - Rz1_ )) >> 24);
   1836e:	0e09      	lsrs	r1, r1, #24
   18370:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
  int32_t Ry1 = Ry1_ + ((Rdt1 * (Rx1_ + ((a * Ry1_) >> 24))) >> 24);
   18374:	fb87 2704 	smull	r2, r7, r7, r4
  int32_t Rx1 = Rx1_ + ((Rdt1 * (-Ry1_ - Rz1_ )) >> 24);
   18378:	68c3      	ldr	r3, [r0, #12]
  int32_t Ry1 = Ry1_ + ((Rdt1 * (Rx1_ + ((a * Ry1_) >> 24))) >> 24);
   1837a:	0e12      	lsrs	r2, r2, #24
   1837c:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
   18380:	18d2      	adds	r2, r2, r3
   18382:	ea4f 6727 	mov.w	r7, r7, asr #24
   18386:	eb47 77e3 	adc.w	r7, r7, r3, asr #31
   1838a:	fba2 2b06 	umull	r2, fp, r2, r6
   1838e:	fb06 bb07 	mla	fp, r6, r7, fp
   18392:	0e12      	lsrs	r2, r2, #24
   18394:	6907      	ldr	r7, [r0, #16]
   18396:	ea42 220b 	orr.w	r2, r2, fp, lsl #8
   1839a:	443a      	add	r2, r7
  int32_t Rz1 = Rz1_ + ((Rdt1 * (b + ((Rz1_ * (Rx1_ - c1_)) >> 24)))  >> 24);
   1839c:	6d87      	ldr	r7, [r0, #88]	; 0x58
  int32_t Rx1 = Rx1_ + ((Rdt1 * (-Ry1_ - Rz1_ )) >> 24);
   1839e:	4419      	add	r1, r3
  int32_t Ry1 = Ry1_ + ((Rdt1 * (Rx1_ + ((a * Ry1_) >> 24))) >> 24);
   183a0:	ea4f 79e3 	mov.w	r9, r3, asr #31
  int32_t Rz1 = Rz1_ + ((Rdt1 * (b + ((Rz1_ * (Rx1_ - c1_)) >> 24)))  >> 24);
   183a4:	1bdb      	subs	r3, r3, r7
   183a6:	6dc7      	ldr	r7, [r0, #92]	; 0x5c
  Rx1_ = Rx1;
   183a8:	60c1      	str	r1, [r0, #12]
  int32_t Rz1 = Rz1_ + ((Rdt1 * (b + ((Rz1_ * (Rx1_ - c1_)) >> 24)))  >> 24);
   183aa:	eb69 0b07 	sbc.w	fp, r9, r7
   183ae:	ea4f 79ee 	mov.w	r9, lr, asr #31
   183b2:	fb03 f709 	mul.w	r7, r3, r9
   183b6:	fb0e 790b 	mla	r9, lr, fp, r7
   183ba:	fba3 730e 	umull	r7, r3, r3, lr
   183be:	444b      	add	r3, r9
   183c0:	0e3f      	lsrs	r7, r7, #24
   183c2:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
   183c6:	193f      	adds	r7, r7, r4
   183c8:	ea4f 6323 	mov.w	r3, r3, asr #24
   183cc:	f143 0300 	adc.w	r3, r3, #0
   183d0:	fba7 7906 	umull	r7, r9, r7, r6
   183d4:	fb06 9903 	mla	r9, r6, r3, r9
   183d8:	0e3f      	lsrs	r7, r7, #24
   183da:	ea47 2709 	orr.w	r7, r7, r9, lsl #8
   183de:	eb0e 0b07 	add.w	fp, lr, r7
  Ry1_ = Ry1;
  Rz1_ = Rz1; 
  int32_t Rz1_scaled = (Rz1 >> 14);
   183e2:	ea4f 33ab 	mov.w	r3, fp, asr #14
  int32_t Rx1_scaled = (Rx1 >> 14) + 32769;
  int32_t Ry1_scaled = (Ry1 >> 14) + 32769;

  // Lorenz 2
  int64_t Ldt2 = static_cast<int64_t>(lut_lorenz_rate[rate2] >> (5 - freq_range2)); // was 5
  int32_t Lx2 = Lx2_ + (Ldt2 * ((sigma * (Ly2_ - Lx2_)) >> 24) >> 24);
   183e6:	e9d0 6706 	ldrd	r6, r7, [r0, #24]
  int32_t Rz1_scaled = (Rz1 >> 14);
   183ea:	9309      	str	r3, [sp, #36]	; 0x24
  int32_t Rx1_scaled = (Rx1 >> 14) + 32769;
   183ec:	eb0c 33a1 	add.w	r3, ip, r1, asr #14
  Rz1_ = Rz1; 
   183f0:	e9c0 2b04 	strd	r2, fp, [r0, #16]
  int32_t Rx1_scaled = (Rx1 >> 14) + 32769;
   183f4:	9301      	str	r3, [sp, #4]
  int32_t Ry1_scaled = (Ry1 >> 14) + 32769;
   183f6:	eb0c 33a2 	add.w	r3, ip, r2, asr #14
   183fa:	930a      	str	r3, [sp, #40]	; 0x28
  int64_t Ldt2 = static_cast<int64_t>(lut_lorenz_rate[rate2] >> (5 - freq_range2)); // was 5
   183fc:	9b02      	ldr	r3, [sp, #8]
   183fe:	f89d 2068 	ldrb.w	r2, [sp, #104]	; 0x68
   18402:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
  int32_t Lx2 = Lx2_ + (Ldt2 * ((sigma * (Ly2_ - Lx2_)) >> 24) >> 24);
   18406:	1bb9      	subs	r1, r7, r6
   18408:	fb81 1505 	smull	r1, r5, r1, r5
  int64_t Ldt2 = static_cast<int64_t>(lut_lorenz_rate[rate2] >> (5 - freq_range2)); // was 5
   1840c:	f1c2 0205 	rsb	r2, r2, #5
  int32_t Lx2 = Lx2_ + (Ldt2 * ((sigma * (Ly2_ - Lx2_)) >> 24) >> 24);
   18410:	0e09      	lsrs	r1, r1, #24
  int64_t Ldt2 = static_cast<int64_t>(lut_lorenz_rate[rate2] >> (5 - freq_range2)); // was 5
   18412:	fa23 fe02 	lsr.w	lr, r3, r2
  int32_t Lx2 = Lx2_ + (Ldt2 * ((sigma * (Ly2_ - Lx2_)) >> 24) >> 24);
   18416:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
   1841a:	fba1 130e 	umull	r1, r3, r1, lr
   1841e:	162d      	asrs	r5, r5, #24
   18420:	fb0e 3305 	mla	r3, lr, r5, r3
   18424:	0e09      	lsrs	r1, r1, #24
  int32_t Ly2 = Ly2_ + (Ldt2 * ((Lx2_ * (rho2_ - Lz2_) >> 24) - Ly2_) >> 24);
   18426:	6a05      	ldr	r5, [r0, #32]
  int32_t Lx2 = Lx2_ + (Ldt2 * ((sigma * (Ly2_ - Lx2_)) >> 24) >> 24);
   18428:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
  int32_t Ly2 = Ly2_ + (Ldt2 * ((Lx2_ * (rho2_ - Lz2_) >> 24) - Ly2_) >> 24);
   1842c:	e9d0 3212 	ldrd	r3, r2, [r0, #72]	; 0x48
   18430:	ea4f 79e6 	mov.w	r9, r6, asr #31
   18434:	1b5b      	subs	r3, r3, r5
   18436:	eb62 72e5 	sbc.w	r2, r2, r5, asr #31
   1843a:	fb03 f909 	mul.w	r9, r3, r9
   1843e:	fb06 9902 	mla	r9, r6, r2, r9
   18442:	fba3 3206 	umull	r3, r2, r3, r6
   18446:	444a      	add	r2, r9
   18448:	0e1b      	lsrs	r3, r3, #24
   1844a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1844e:	1bdb      	subs	r3, r3, r7
   18450:	ea4f 6222 	mov.w	r2, r2, asr #24
   18454:	eb62 72e7 	sbc.w	r2, r2, r7, asr #31
   18458:	fba3 390e 	umull	r3, r9, r3, lr
   1845c:	fb0e 9902 	mla	r9, lr, r2, r9
   18460:	0e1b      	lsrs	r3, r3, #24
  int32_t Lz2 = Lz2_ + (Ldt2 * ((Lx2_ * int64_t(Ly2_) >> 24) - (beta * Lz2_ >> 24)) >> 24); 
   18462:	4a5d      	ldr	r2, [pc, #372]	; (185d8 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x388>)
  int32_t Ly2 = Ly2_ + (Ldt2 * ((Lx2_ * (rho2_ - Lz2_) >> 24) - Ly2_) >> 24);
   18464:	ea43 2309 	orr.w	r3, r3, r9, lsl #8
  int32_t Lx2 = Lx2_ + (Ldt2 * ((sigma * (Ly2_ - Lx2_)) >> 24) >> 24);
   18468:	4431      	add	r1, r6
  int32_t Lz2 = Lz2_ + (Ldt2 * ((Lx2_ * int64_t(Ly2_) >> 24) - (beta * Lz2_ >> 24)) >> 24); 
   1846a:	fb85 2902 	smull	r2, r9, r5, r2
  int32_t Ly2 = Ly2_ + (Ldt2 * ((Lx2_ * (rho2_ - Lz2_) >> 24) - Ly2_) >> 24);
   1846e:	443b      	add	r3, r7
  int32_t Lz2 = Lz2_ + (Ldt2 * ((Lx2_ * int64_t(Ly2_) >> 24) - (beta * Lz2_ >> 24)) >> 24); 
   18470:	fb86 6707 	smull	r6, r7, r6, r7
   18474:	0e36      	lsrs	r6, r6, #24
   18476:	0e12      	lsrs	r2, r2, #24
   18478:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
   1847c:	ea42 2209 	orr.w	r2, r2, r9, lsl #8
   18480:	1ab2      	subs	r2, r6, r2
   18482:	ea4f 6727 	mov.w	r7, r7, asr #24
   18486:	eb67 6929 	sbc.w	r9, r7, r9, asr #24
   1848a:	fba2 260e 	umull	r2, r6, r2, lr
   1848e:	fb0e 6609 	mla	r6, lr, r9, r6
  Lx2_ = Lx2;
  Ly2_ = Ly2;
   18492:	e9c0 1306 	strd	r1, r3, [r0, #24]
  int32_t Lz2 = Lz2_ + (Ldt2 * ((Lx2_ * int64_t(Ly2_) >> 24) - (beta * Lz2_ >> 24)) >> 24); 
   18496:	0e12      	lsrs	r2, r2, #24
  Lz2_ = Lz2; 
  int32_t Lz2_scaled = ((Lz2 * 3) >> 16);
  int32_t Lx2_scaled = ((Lx2 * 3) >> 16) + 32769;
  int32_t Ly2_scaled = ((Ly2 * 3) >> 16) + 32769;
   18498:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  int32_t Lz2 = Lz2_ + (Ldt2 * ((Lx2_ * int64_t(Ly2_) >> 24) - (beta * Lz2_ >> 24)) >> 24); 
   1849c:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  int32_t Ly2_scaled = ((Ly2 * 3) >> 16) + 32769;
   184a0:	eb0c 4323 	add.w	r3, ip, r3, asr #16
  int32_t Lz2 = Lz2_ + (Ldt2 * ((Lx2_ * int64_t(Ly2_) >> 24) - (beta * Lz2_ >> 24)) >> 24); 
   184a4:	4415      	add	r5, r2
  int32_t Ly2_scaled = ((Ly2 * 3) >> 16) + 32769;
   184a6:	9305      	str	r3, [sp, #20]
  // Rossler 2
  int64_t Rdt2 = static_cast<int64_t>(lut_lorenz_rate[rate2] >> 0);
   184a8:	9b02      	ldr	r3, [sp, #8]
  Lz2_ = Lz2; 
   184aa:	6205      	str	r5, [r0, #32]
  int64_t Rdt2 = static_cast<int64_t>(lut_lorenz_rate[rate2] >> 0);
   184ac:	f858 e023 	ldr.w	lr, [r8, r3, lsl #2]
  int32_t Rx2 = Rx2_ + ((Rdt2 * (-Ry2_ - Rz2_ )) >> 24);
   184b0:	f100 0324 	add.w	r3, r0, #36	; 0x24
   184b4:	e893 0188 	ldmia.w	r3, {r3, r7, r8}
  int32_t Lz2_scaled = ((Lz2 * 3) >> 16);
   184b8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   184bc:	142a      	asrs	r2, r5, #16
  int32_t Lx2_scaled = ((Lx2 * 3) >> 16) + 32769;
   184be:	eb01 0141 	add.w	r1, r1, r1, lsl #1
  int32_t Lz2_scaled = ((Lz2 * 3) >> 16);
   184c2:	920b      	str	r2, [sp, #44]	; 0x2c
  int32_t Lx2_scaled = ((Lx2 * 3) >> 16) + 32769;
   184c4:	eb0c 4221 	add.w	r2, ip, r1, asr #16
  int32_t Rx2 = Rx2_ + ((Rdt2 * (-Ry2_ - Rz2_ )) >> 24);
   184c8:	4279      	negs	r1, r7
   184ca:	eba1 0108 	sub.w	r1, r1, r8
   184ce:	17ce      	asrs	r6, r1, #31
  int32_t Lx2_scaled = ((Lx2 * 3) >> 16) + 32769;
   184d0:	9204      	str	r2, [sp, #16]
  int32_t Rx2 = Rx2_ + ((Rdt2 * (-Ry2_ - Rz2_ )) >> 24);
   184d2:	fba1 120e 	umull	r1, r2, r1, lr
   184d6:	fb0e 2206 	mla	r2, lr, r6, r2
   184da:	0e09      	lsrs	r1, r1, #24
   184dc:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
  int32_t Ry2 = Ry2_ + ((Rdt2 * (Rx2_ + ((a * Ry2_) >> 24))) >> 24);
   184e0:	fb87 2604 	smull	r2, r6, r7, r4
   184e4:	0e12      	lsrs	r2, r2, #24
   184e6:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
   184ea:	18d2      	adds	r2, r2, r3
   184ec:	ea4f 6626 	mov.w	r6, r6, asr #24
   184f0:	eb46 76e3 	adc.w	r6, r6, r3, asr #31
   184f4:	9602      	str	r6, [sp, #8]
   184f6:	fba2 260e 	umull	r2, r6, r2, lr
   184fa:	9206      	str	r2, [sp, #24]
   184fc:	9a02      	ldr	r2, [sp, #8]
   184fe:	fb0e 6602 	mla	r6, lr, r2, r6
   18502:	9a06      	ldr	r2, [sp, #24]
   18504:	0e12      	lsrs	r2, r2, #24
   18506:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
   1850a:	443a      	add	r2, r7
  int32_t Rz2 = Rz2_ + ((Rdt2 * (b + ((Rz2_ * (Rx2_ - c2_)) >> 24)))  >> 24);
   1850c:	e9d0 6718 	ldrd	r6, r7, [r0, #96]	; 0x60
  int32_t Rx2 = Rx2_ + ((Rdt2 * (-Ry2_ - Rz2_ )) >> 24);
   18510:	4419      	add	r1, r3
  int32_t Ry2 = Ry2_ + ((Rdt2 * (Rx2_ + ((a * Ry2_) >> 24))) >> 24);
   18512:	ea4f 79e3 	mov.w	r9, r3, asr #31
  int32_t Rz2 = Rz2_ + ((Rdt2 * (b + ((Rz2_ * (Rx2_ - c2_)) >> 24)))  >> 24);
   18516:	1b9b      	subs	r3, r3, r6
   18518:	eb69 0707 	sbc.w	r7, r9, r7
   1851c:	ea4f 79e8 	mov.w	r9, r8, asr #31
   18520:	fb03 f609 	mul.w	r6, r3, r9
   18524:	fb08 6907 	mla	r9, r8, r7, r6
   18528:	fba3 3608 	umull	r3, r6, r3, r8
   1852c:	444e      	add	r6, r9
   1852e:	0e1b      	lsrs	r3, r3, #24
   18530:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
   18534:	191b      	adds	r3, r3, r4
   18536:	ea4f 6626 	mov.w	r6, r6, asr #24
   1853a:	fba3 340e 	umull	r3, r4, r3, lr
   1853e:	f146 0600 	adc.w	r6, r6, #0
   18542:	fb0e 4406 	mla	r4, lr, r6, r4
   18546:	0e1b      	lsrs	r3, r3, #24
   18548:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
   1854c:	4443      	add	r3, r8
  Rx2_ = Rx2;
  Ry2_ = Ry2;
  Rz2_ = Rz2; 
  int32_t Rz2_scaled = (Rz2 >> 14);
   1854e:	139c      	asrs	r4, r3, #14
  Rz2_ = Rz2; 
   18550:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
        break;
      case LORENZ_OUTPUT_LX1_PLUS_RX2:
        dac_code_[i] = (Lx1_scaled + Rx2_scaled) >> 1;
        break;
      case LORENZ_OUTPUT_LX1_PLUS_RZ2:
        dac_code_[i] = (Lx1_scaled + Rz2_scaled) >> 1;
   18554:	eb0a 33a3 	add.w	r3, sl, r3, asr #14
   18558:	f3c3 034f 	ubfx	r3, r3, #1, #16
  Rx2_ = Rx2;
   1855c:	6241      	str	r1, [r0, #36]	; 0x24
  int32_t Rx2_scaled = (Rx2 >> 14) + 32769;
   1855e:	eb0c 31a1 	add.w	r1, ip, r1, asr #14
        dac_code_[i] = (Lx1_scaled + Lz2_scaled) >> 1;
   18562:	eb0a 4525 	add.w	r5, sl, r5, asr #16
        dac_code_[i] = (Lx1_scaled + Rz2_scaled) >> 1;
   18566:	9307      	str	r3, [sp, #28]
        dac_code_[i] = (Lx1_scaled + Rx2_scaled) >> 1;
   18568:	eb01 030a 	add.w	r3, r1, sl
  int32_t Rz2_scaled = (Rz2 >> 14);
   1856c:	940c      	str	r4, [sp, #48]	; 0x30
        dac_code_[i] = (Lx1_scaled + Rx2_scaled) >> 1;
   1856e:	f3c3 094f 	ubfx	r9, r3, #1, #16
        break;
      case LORENZ_OUTPUT_LX1_XOR_LX2:
        dac_code_[i] = Lx1_scaled ^ Lx2_scaled ;
        break;
      case LORENZ_OUTPUT_LX1_XOR_RX1:
        dac_code_[i] = Lx1_scaled ^ Rx1_scaled ;
   18572:	9c01      	ldr	r4, [sp, #4]
        dac_code_[i] = (Lx1_scaled + Lz2_scaled) >> 1;
   18574:	f3c5 034f 	ubfx	r3, r5, #1, #16
   18578:	9306      	str	r3, [sp, #24]
        dac_code_[i] = (Lx1_scaled + Ly2_scaled) >> 1;
   1857a:	9b05      	ldr	r3, [sp, #20]
        dac_code_[i] = Lx1_scaled ^ Rx1_scaled ;
   1857c:	ea8a 0404 	eor.w	r4, sl, r4
        dac_code_[i] = (Lx1_scaled + Ly2_scaled) >> 1;
   18580:	eb03 060a 	add.w	r6, r3, sl
        dac_code_[i] = Lx1_scaled ^ Rx1_scaled ;
   18584:	940d      	str	r4, [sp, #52]	; 0x34
        dac_code_[i] = (Lx1_scaled + Rx1_scaled) >> 1;
   18586:	9b01      	ldr	r3, [sp, #4]
        dac_code_[i] = Lx1_scaled ^ Lx2_scaled ;
   18588:	9c04      	ldr	r4, [sp, #16]
        dac_code_[i] = (Lx1_scaled + Rx1_scaled) >> 1;
   1858a:	eb03 050a 	add.w	r5, r3, sl
        dac_code_[i] = Lx1_scaled ^ Lx2_scaled ;
   1858e:	ea8a 0e04 	eor.w	lr, sl, r4
        dac_code_[i] = Lx1_scaled ^ Ly1_scaled ;
   18592:	9c03      	ldr	r4, [sp, #12]
        dac_code_[i] = (Lx1_scaled + Rx1_scaled) >> 1;
   18594:	f3c5 034f 	ubfx	r3, r5, #1, #16
        dac_code_[i] = (Lx1_scaled + Rz1_scaled) >> 1;
   18598:	eb0a 3bab 	add.w	fp, sl, fp, asr #14
  int32_t Ry2_scaled = (Ry2 >> 14) + 32769;
   1859c:	eb0c 3ca2 	add.w	ip, ip, r2, asr #14
        dac_code_[i] = (Lx1_scaled + Rx1_scaled) >> 1;
   185a0:	9302      	str	r3, [sp, #8]
        dac_code_[i] = (Lx1_scaled + Ly2_scaled) >> 1;
   185a2:	f3c6 064f 	ubfx	r6, r6, #1, #16
        dac_code_[i] = (Lx1_scaled + Rz1_scaled) >> 1;
   185a6:	f3cb 0b4f 	ubfx	fp, fp, #1, #16
   185aa:	f100 0368 	add.w	r3, r0, #104	; 0x68
        dac_code_[i] = (Lx1_scaled + Rx1_scaled) >> 1;
   185ae:	2200      	movs	r2, #0
        break;
      case LORENZ_OUTPUT_LX1_XOR_RX2:
        dac_code_[i] = Lx1_scaled ^ Rx2_scaled ;
   185b0:	ea8a 0701 	eor.w	r7, sl, r1
        dac_code_[i] = Lx1_scaled ^ Ly1_scaled ;
   185b4:	ea8a 0804 	eor.w	r8, sl, r4
    switch(i) {
   185b8:	2a02      	cmp	r2, #2
   185ba:	b2d4      	uxtb	r4, r2
   185bc:	d01d      	beq.n	185fa <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3aa>
   185be:	2c03      	cmp	r4, #3
   185c0:	d01e      	beq.n	18600 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3b0>
   185c2:	2c01      	cmp	r4, #1
        out_channel = out_a_ ;
   185c4:	bf14      	ite	ne
   185c6:	f890 4030 	ldrbne.w	r4, [r0, #48]	; 0x30
        out_channel = out_b_ ;
   185ca:	f890 4031 	ldrbeq.w	r4, [r0, #49]	; 0x31
   185ce:	e005      	b.n	185dc <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x38c>
   185d0:	00199999 	.word	0x00199999
   185d4:	00027468 	.word	0x00027468
   185d8:	02aaaaac 	.word	0x02aaaaac
    switch (out_channel) {
   185dc:	2c15      	cmp	r4, #21
   185de:	d814      	bhi.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
   185e0:	e8df f004 	tbb	[pc, r4]
   185e4:	201e1b11 	.word	0x201e1b11
   185e8:	28262422 	.word	0x28262422
   185ec:	312e2c2a 	.word	0x312e2c2a
   185f0:	3a383533 	.word	0x3a383533
   185f4:	44413f3c 	.word	0x44413f3c
   185f8:	4947      	.short	0x4947
        out_channel = out_c_ ;
   185fa:	f890 4032 	ldrb.w	r4, [r0, #50]	; 0x32
        break ;
   185fe:	e7ed      	b.n	185dc <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x38c>
        out_channel = out_d_ ;
   18600:	f890 4033 	ldrb.w	r4, [r0, #51]	; 0x33
        break ; 
   18604:	e7ea      	b.n	185dc <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x38c>
        dac_code_[i] = Lx1_scaled;
   18606:	f8a3 a000 	strh.w	sl, [r3]
  for (uint8_t i = 0; i < 4; ++i) {
   1860a:	3201      	adds	r2, #1
   1860c:	2a04      	cmp	r2, #4
   1860e:	f103 0302 	add.w	r3, r3, #2
   18612:	d1d1      	bne.n	185b8 <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x368>
       default:
        break;
    }
  }

}
   18614:	b00f      	add	sp, #60	; 0x3c
   18616:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        dac_code_[i] = Ly1_scaled;
   1861a:	9c03      	ldr	r4, [sp, #12]
        dac_code_[i] = Lz1_scaled;
   1861c:	801c      	strh	r4, [r3, #0]
        break;
   1861e:	e7f4      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
        dac_code_[i] = Lz1_scaled;
   18620:	9c08      	ldr	r4, [sp, #32]
   18622:	e7fb      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Lx2_scaled;
   18624:	9c04      	ldr	r4, [sp, #16]
   18626:	e7f9      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Ly2_scaled;
   18628:	9c05      	ldr	r4, [sp, #20]
   1862a:	e7f7      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Lz2_scaled;
   1862c:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   1862e:	e7f5      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Rx1_scaled;
   18630:	9c01      	ldr	r4, [sp, #4]
   18632:	e7f3      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Ry1_scaled;
   18634:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   18636:	e7f1      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Rz1_scaled;
   18638:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1863a:	e7ef      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Rx2_scaled;
   1863c:	8019      	strh	r1, [r3, #0]
        break;
   1863e:	e7e4      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
        dac_code_[i] = Ry2_scaled;
   18640:	f8a3 c000 	strh.w	ip, [r3]
        break;
   18644:	e7e1      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
        dac_code_[i] = Rz2_scaled;
   18646:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   18648:	e7e8      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = (Lx1_scaled + Rx1_scaled) >> 1;
   1864a:	9c02      	ldr	r4, [sp, #8]
   1864c:	e7e6      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = (Lx1_scaled + Rz1_scaled) >> 1;
   1864e:	f8a3 b000 	strh.w	fp, [r3]
        break;
   18652:	e7da      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
        dac_code_[i] = (Lx1_scaled + Ly2_scaled) >> 1;
   18654:	801e      	strh	r6, [r3, #0]
        break;
   18656:	e7d8      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
        dac_code_[i] = (Lx1_scaled + Lz2_scaled) >> 1;
   18658:	9c06      	ldr	r4, [sp, #24]
   1865a:	e7df      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = (Lx1_scaled + Rx2_scaled) >> 1;
   1865c:	f8a3 9000 	strh.w	r9, [r3]
        break;
   18660:	e7d3      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
        dac_code_[i] = (Lx1_scaled + Rz2_scaled) >> 1;
   18662:	9c07      	ldr	r4, [sp, #28]
   18664:	e7da      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Lx1_scaled ^ Ly1_scaled ;
   18666:	f8a3 8000 	strh.w	r8, [r3]
        break;
   1866a:	e7ce      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
        dac_code_[i] = Lx1_scaled ^ Lx2_scaled ;
   1866c:	f8a3 e000 	strh.w	lr, [r3]
        break;
   18670:	e7cb      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
        dac_code_[i] = Lx1_scaled ^ Rx1_scaled ;
   18672:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   18674:	e7d2      	b.n	1861c <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3cc>
        dac_code_[i] = Lx1_scaled ^ Rx2_scaled ;
   18676:	801f      	strh	r7, [r3, #0]
        break;
   18678:	e7c7      	b.n	1860a <streams::LorenzGenerator::Process(long, long, bool, bool, unsigned char, unsigned char)+0x3ba>
   1867a:	bf00      	nop

0001867c <ADC_Module::saveConfig(ADC_Module::ADC_Config*)>:
    //! Was the adc in use before a call?
    uint8_t adcWasInUse;

    //! Save config of the ADC to the ADC_Config struct
    void saveConfig(ADC_Config* config) {
        config->savedSC1A = *ADC_SC1A;
   1867c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1867e:	681b      	ldr	r3, [r3, #0]
   18680:	600b      	str	r3, [r1, #0]
        config->savedCFG1 = *ADC_CFG1;
   18682:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
   18684:	681b      	ldr	r3, [r3, #0]
   18686:	60cb      	str	r3, [r1, #12]
        config->savedCFG2 = *ADC_CFG2;
   18688:	6c03      	ldr	r3, [r0, #64]	; 0x40
   1868a:	681b      	ldr	r3, [r3, #0]
   1868c:	610b      	str	r3, [r1, #16]
        config->savedSC2 = *ADC_SC2;
   1868e:	6d43      	ldr	r3, [r0, #84]	; 0x54
   18690:	681b      	ldr	r3, [r3, #0]
   18692:	604b      	str	r3, [r1, #4]
        config->savedSC3 = *ADC_SC3;
   18694:	6d83      	ldr	r3, [r0, #88]	; 0x58
   18696:	681b      	ldr	r3, [r3, #0]
   18698:	608b      	str	r3, [r1, #8]
    }
   1869a:	4770      	bx	lr

0001869c <ADC_Module::calibrate()>:
    __disable_irq();
   1869c:	b672      	cpsid	i

    __attribute__((always_inline)) void setBit(volatile uint32_t* reg, uint8_t bit) {
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
    }
    __attribute__((always_inline)) void clearBit(volatile uint32_t* reg, uint8_t bit) {
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   1869e:	6d83      	ldr	r3, [r0, #88]	; 0x58
   186a0:	015b      	lsls	r3, r3, #5
    calibrating = 1;
   186a2:	2201      	movs	r2, #1
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   186a4:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   186a8:	7642      	strb	r2, [r0, #25]
   186aa:	e9c3 2206 	strd	r2, r2, [r3, #24]
    __enable_irq();
   186ae:	b662      	cpsie	i
}
   186b0:	4770      	bx	lr
   186b2:	Address 0x00000000000186b2 is out of bounds.


000186b4 <ADC_Module::setReference(unsigned char)>:
    if (analog_reference_internal==type) { // don't need to change anything
   186b4:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
   186b8:	428b      	cmp	r3, r1
   186ba:	d014      	beq.n	186e6 <ADC_Module::setReference(unsigned char)+0x32>
    if (type == ADC_REF_ALT) { // 1.2V ref for Teensy 3.x, 3.3 VDD for Teensy LC
   186bc:	2901      	cmp	r1, #1
   186be:	d10d      	bne.n	186dc <ADC_Module::setReference(unsigned char)+0x28>
    VREF_TRM = VREF_TRM_CHOPEN | 0x20; // enable module and set the trimmer to medium (max=0x3F=63)
   186c0:	4b09      	ldr	r3, [pc, #36]	; (186e8 <ADC_Module::setReference(unsigned char)+0x34>)
   186c2:	2260      	movs	r2, #96	; 0x60
   186c4:	701a      	strb	r2, [r3, #0]
    VREF_SC = VREF_SC_VREFEN | VREF_SC_REGEN | VREF_SC_ICOMPEN | VREF_SC_MODE_LV(1); // (=0xE1) enable 1.2 volt ref with all compensations
   186c6:	22e1      	movs	r2, #225	; 0xe1
   186c8:	705a      	strb	r2, [r3, #1]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   186ca:	6d43      	ldr	r3, [r0, #84]	; 0x54
        analog_reference_internal = ADC_REF_DEFAULT;
   186cc:	f880 1021 	strb.w	r1, [r0, #33]	; 0x21
   186d0:	015b      	lsls	r3, r3, #5
   186d2:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   186d6:	6019      	str	r1, [r3, #0]
    calibrate();
   186d8:	f7ff bfe0 	b.w	1869c <ADC_Module::calibrate()>
    } else if(type == ADC_REF_DEFAULT) { // ext ref for all Teensys, vcc also for Teensy 3.x
   186dc:	2900      	cmp	r1, #0
   186de:	d1fb      	bne.n	186d8 <ADC_Module::setReference(unsigned char)+0x24>
    VREF_SC = 0;
   186e0:	4b01      	ldr	r3, [pc, #4]	; (186e8 <ADC_Module::setReference(unsigned char)+0x34>)
   186e2:	7059      	strb	r1, [r3, #1]
   186e4:	e7f1      	b.n	186ca <ADC_Module::setReference(unsigned char)+0x16>
}
   186e6:	4770      	bx	lr
   186e8:	40074000 	.word	0x40074000

000186ec <ADC_Module::setAveraging(unsigned char)>:
void ADC_Module::setAveraging(uint8_t num) {
   186ec:	b538      	push	{r3, r4, r5, lr}
    if (calibrating) wait_for_cal();
   186ee:	7e43      	ldrb	r3, [r0, #25]
void ADC_Module::setAveraging(uint8_t num) {
   186f0:	4605      	mov	r5, r0
   186f2:	460c      	mov	r4, r1
    if (calibrating) wait_for_cal();
   186f4:	b10b      	cbz	r3, 186fa <ADC_Module::setAveraging(unsigned char)+0xe>
   186f6:	f000 f828 	bl	1874a <ADC_Module::wait_for_cal()>
   186fa:	6dab      	ldr	r3, [r5, #88]	; 0x58
    if (num <= 1) {
   186fc:	2c01      	cmp	r4, #1
   186fe:	ea4f 1343 	mov.w	r3, r3, lsl #5
   18702:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18706:	d805      	bhi.n	18714 <ADC_Module::setAveraging(unsigned char)+0x28>
   18708:	2200      	movs	r2, #0
   1870a:	609a      	str	r2, [r3, #8]
        num = 0;
   1870c:	4613      	mov	r3, r2
    analog_num_average = num;
   1870e:	f885 3020 	strb.w	r3, [r5, #32]
}
   18712:	bd38      	pop	{r3, r4, r5, pc}
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   18714:	2201      	movs	r2, #1
        if (num <= 4) {
   18716:	2c04      	cmp	r4, #4
   18718:	609a      	str	r2, [r3, #8]
   1871a:	d804      	bhi.n	18726 <ADC_Module::setAveraging(unsigned char)+0x3a>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   1871c:	2200      	movs	r2, #0
   1871e:	601a      	str	r2, [r3, #0]
   18720:	605a      	str	r2, [r3, #4]
            num = 4;
   18722:	2304      	movs	r3, #4
    }
   18724:	e7f3      	b.n	1870e <ADC_Module::setAveraging(unsigned char)+0x22>
        } else if (num <= 8) {
   18726:	2c08      	cmp	r4, #8
   18728:	d804      	bhi.n	18734 <ADC_Module::setAveraging(unsigned char)+0x48>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   1872a:	601a      	str	r2, [r3, #0]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   1872c:	2200      	movs	r2, #0
   1872e:	605a      	str	r2, [r3, #4]
            num = 8;
   18730:	2308      	movs	r3, #8
    }
   18732:	e7ec      	b.n	1870e <ADC_Module::setAveraging(unsigned char)+0x22>
        } else if (num <= 16) {
   18734:	2c10      	cmp	r4, #16
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   18736:	bf99      	ittee	ls
   18738:	2100      	movls	r1, #0
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   1873a:	e9c3 1200 	strdls	r1, r2, [r3]
   1873e:	601a      	strhi	r2, [r3, #0]
   18740:	605a      	strhi	r2, [r3, #4]
            num = 16;
   18742:	bf94      	ite	ls
   18744:	2310      	movls	r3, #16
            num = 32;
   18746:	2320      	movhi	r3, #32
    }
   18748:	e7e1      	b.n	1870e <ADC_Module::setAveraging(unsigned char)+0x22>

0001874a <ADC_Module::wait_for_cal()>:
void ADC_Module::wait_for_cal(void) {
   1874a:	b570      	push	{r4, r5, r6, lr}
   1874c:	4604      	mov	r4, r0
    __attribute__((always_inline)) void changeBit(volatile uint32_t* reg, uint8_t bit, bool state) {
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = state;
    }

    __attribute__((always_inline)) volatile bool getBit(volatile uint32_t* reg, uint8_t bit) {
        return (volatile bool)*(uint32_t*)(ADC_BITBAND_ADDR(reg, bit));
   1874e:	6da3      	ldr	r3, [r4, #88]	; 0x58
   18750:	015b      	lsls	r3, r3, #5
   18752:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18756:	69da      	ldr	r2, [r3, #28]
    while(getBit(ADC_SC3, ADC_SC3_CAL_BIT)) { // Bit ADC_SC3_CAL in register ADC0_SC3 cleared when calib. finishes.
   18758:	2a00      	cmp	r2, #0
   1875a:	d154      	bne.n	18806 <ADC_Module::wait_for_cal()+0xbc>
   1875c:	699b      	ldr	r3, [r3, #24]
    if(getBit(ADC_SC3, ADC_SC3_CALF_BIT)) { // calibration failed
   1875e:	b123      	cbz	r3, 1876a <ADC_Module::wait_for_cal()+0x20>
        fail_flag |= ADC_ERROR_CALIB; // the user should know and recalibrate manually
   18760:	8ae3      	ldrh	r3, [r4, #22]
   18762:	b29b      	uxth	r3, r3
   18764:	f043 0302 	orr.w	r3, r3, #2
   18768:	82e3      	strh	r3, [r4, #22]
    __disable_irq();
   1876a:	b672      	cpsid	i
    if (calibrating) {
   1876c:	7e63      	ldrb	r3, [r4, #25]
   1876e:	2b00      	cmp	r3, #0
   18770:	d037      	beq.n	187e2 <ADC_Module::wait_for_cal()+0x98>
        sum = *ADC_CLPS + *ADC_CLP4 + *ADC_CLP3 + *ADC_CLP2 + *ADC_CLP1 + *ADC_CLP0;
   18772:	6f62      	ldr	r2, [r4, #116]	; 0x74
   18774:	6f23      	ldr	r3, [r4, #112]	; 0x70
   18776:	681b      	ldr	r3, [r3, #0]
   18778:	6816      	ldr	r6, [r2, #0]
   1877a:	6fa2      	ldr	r2, [r4, #120]	; 0x78
   1877c:	6815      	ldr	r5, [r2, #0]
   1877e:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
   18780:	6810      	ldr	r0, [r2, #0]
   18782:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   18786:	4433      	add	r3, r6
   18788:	6811      	ldr	r1, [r2, #0]
   1878a:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
   1878e:	442b      	add	r3, r5
   18790:	6812      	ldr	r2, [r2, #0]
   18792:	4403      	add	r3, r0
   18794:	440b      	add	r3, r1
   18796:	4413      	add	r3, r2
        sum = (sum / 2) | 0x8000;
   18798:	f3c3 034e 	ubfx	r3, r3, #1, #15
        *ADC_PG = sum;
   1879c:	6e62      	ldr	r2, [r4, #100]	; 0x64
   1879e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   187a2:	6013      	str	r3, [r2, #0]
        sum = *ADC_CLMS + *ADC_CLM4 + *ADC_CLM3 + *ADC_CLM2 + *ADC_CLM1 + *ADC_CLM0;
   187a4:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
   187a8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   187ac:	681b      	ldr	r3, [r3, #0]
   187ae:	6816      	ldr	r6, [r2, #0]
   187b0:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   187b4:	6815      	ldr	r5, [r2, #0]
   187b6:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
   187ba:	6810      	ldr	r0, [r2, #0]
   187bc:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
   187c0:	4433      	add	r3, r6
   187c2:	6811      	ldr	r1, [r2, #0]
   187c4:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
   187c8:	442b      	add	r3, r5
   187ca:	6812      	ldr	r2, [r2, #0]
   187cc:	4403      	add	r3, r0
   187ce:	440b      	add	r3, r1
   187d0:	4413      	add	r3, r2
        sum = (sum / 2) | 0x8000;
   187d2:	f3c3 034e 	ubfx	r3, r3, #1, #15
        *ADC_MG = sum;
   187d6:	6ea2      	ldr	r2, [r4, #104]	; 0x68
   187d8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   187dc:	6013      	str	r3, [r2, #0]
        calibrating = 0;
   187de:	2300      	movs	r3, #0
   187e0:	7663      	strb	r3, [r4, #25]
    __enable_irq();
   187e2:	b662      	cpsie	i
    if(init_calib) {
   187e4:	7ea3      	ldrb	r3, [r4, #26]
   187e6:	b16b      	cbz	r3, 18804 <ADC_Module::wait_for_cal()+0xba>
        setConversionSpeed(ADC_MED_SPEED);
   187e8:	2102      	movs	r1, #2
   187ea:	4620      	mov	r0, r4
   187ec:	f000 f84e 	bl	1888c <ADC_Module::setConversionSpeed(unsigned char)>
        setSamplingSpeed(ADC_MED_SPEED);
   187f0:	2102      	movs	r1, #2
   187f2:	4620      	mov	r0, r4
   187f4:	f000 f8be 	bl	18974 <ADC_Module::setSamplingSpeed(unsigned char)>
        setAveraging(4);
   187f8:	2104      	movs	r1, #4
   187fa:	4620      	mov	r0, r4
   187fc:	f7ff ff76 	bl	186ec <ADC_Module::setAveraging(unsigned char)>
        init_calib = 0; // clear
   18800:	2300      	movs	r3, #0
   18802:	76a3      	strb	r3, [r4, #26]
}
   18804:	bd70      	pop	{r4, r5, r6, pc}
        yield();
   18806:	f002 fda9 	bl	1b35c <yield>
   1880a:	e7a0      	b.n	1874e <ADC_Module::wait_for_cal()+0x4>

0001880c <ADC_Module::setResolution(unsigned char)>:
void ADC_Module::setResolution(uint8_t bits) {
   1880c:	b538      	push	{r3, r4, r5, lr}
    if(analog_res_bits==bits) {
   1880e:	7ec3      	ldrb	r3, [r0, #27]
   18810:	428b      	cmp	r3, r1
void ADC_Module::setResolution(uint8_t bits) {
   18812:	4605      	mov	r5, r0
   18814:	460c      	mov	r4, r1
    if(analog_res_bits==bits) {
   18816:	d017      	beq.n	18848 <ADC_Module::setResolution(unsigned char)+0x3c>
    if (calibrating) wait_for_cal();
   18818:	7e43      	ldrb	r3, [r0, #25]
   1881a:	b10b      	cbz	r3, 18820 <ADC_Module::setResolution(unsigned char)+0x14>
   1881c:	f7ff ff95 	bl	1874a <ADC_Module::wait_for_cal()>
    if (bits <8) {
   18820:	2c07      	cmp	r4, #7
   18822:	d912      	bls.n	1884a <ADC_Module::setResolution(unsigned char)+0x3e>
        config = 16;
   18824:	2c0e      	cmp	r4, #14
   18826:	bf28      	it	cs
   18828:	2410      	movcs	r4, #16
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   1882a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    if ( (config == 8) || (config == 9) )  {
   1882c:	f1a4 0208 	sub.w	r2, r4, #8
   18830:	b2d2      	uxtb	r2, r2
   18832:	015b      	lsls	r3, r3, #5
   18834:	2a01      	cmp	r2, #1
   18836:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   1883a:	d808      	bhi.n	1884e <ADC_Module::setResolution(unsigned char)+0x42>
   1883c:	2200      	movs	r2, #0
   1883e:	60da      	str	r2, [r3, #12]
   18840:	609a      	str	r2, [r3, #8]
        analog_max_val = 255; // diff mode 9 bits has 1 bit for sign, so max value is the same as single 8 bits
   18842:	23ff      	movs	r3, #255	; 0xff
        analog_max_val = 65535;
   18844:	61eb      	str	r3, [r5, #28]
    analog_res_bits = config;
   18846:	76ec      	strb	r4, [r5, #27]
}
   18848:	bd38      	pop	{r3, r4, r5, pc}
        config = 8;
   1884a:	2408      	movs	r4, #8
   1884c:	e7ed      	b.n	1882a <ADC_Module::setResolution(unsigned char)+0x1e>
    } else if ( (config == 10 )|| (config == 11) ) {
   1884e:	f1a4 020a 	sub.w	r2, r4, #10
   18852:	b2d2      	uxtb	r2, r2
   18854:	2a01      	cmp	r2, #1
   18856:	d806      	bhi.n	18866 <ADC_Module::setResolution(unsigned char)+0x5a>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   18858:	2201      	movs	r2, #1
   1885a:	60da      	str	r2, [r3, #12]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   1885c:	2200      	movs	r2, #0
   1885e:	609a      	str	r2, [r3, #8]
        analog_max_val = 1023;
   18860:	f240 33ff 	movw	r3, #1023	; 0x3ff
   18864:	e7ee      	b.n	18844 <ADC_Module::setResolution(unsigned char)+0x38>
    } else if ( (config == 12 )|| (config == 13) ) {
   18866:	f1a4 020c 	sub.w	r2, r4, #12
   1886a:	b2d2      	uxtb	r2, r2
   1886c:	2a01      	cmp	r2, #1
   1886e:	bf98      	it	ls
   18870:	2100      	movls	r1, #0
   18872:	f04f 0201 	mov.w	r2, #1
   18876:	bf99      	ittee	ls
   18878:	60d9      	strls	r1, [r3, #12]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   1887a:	609a      	strls	r2, [r3, #8]
   1887c:	60da      	strhi	r2, [r3, #12]
   1887e:	609a      	strhi	r2, [r3, #8]
        analog_max_val = 4095;
   18880:	bf94      	ite	ls
   18882:	f640 73ff 	movwls	r3, #4095	; 0xfff
        analog_max_val = 65535;
   18886:	f64f 73ff 	movwhi	r3, #65535	; 0xffff
   1888a:	e7db      	b.n	18844 <ADC_Module::setResolution(unsigned char)+0x38>

0001888c <ADC_Module::setConversionSpeed(unsigned char)>:
void ADC_Module::setConversionSpeed(uint8_t speed) {
   1888c:	b538      	push	{r3, r4, r5, lr}
    if(speed==conversion_speed) { // no change
   1888e:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   18892:	428b      	cmp	r3, r1
void ADC_Module::setConversionSpeed(uint8_t speed) {
   18894:	4604      	mov	r4, r0
   18896:	460d      	mov	r5, r1
    if(speed==conversion_speed) { // no change
   18898:	d06b      	beq.n	18972 <ADC_Module::setConversionSpeed(unsigned char)+0xe6>
    if (calibrating) wait_for_cal();
   1889a:	7e43      	ldrb	r3, [r0, #25]
   1889c:	b10b      	cbz	r3, 188a2 <ADC_Module::setConversionSpeed(unsigned char)+0x16>
   1889e:	f7ff ff54 	bl	1874a <ADC_Module::wait_for_cal()>
   188a2:	6c23      	ldr	r3, [r4, #64]	; 0x40
    if(speed >= ADC_ADACK_2_4) {
   188a4:	2d0f      	cmp	r5, #15
   188a6:	ea4f 1343 	mov.w	r3, r3, lsl #5
   188aa:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   188ae:	d91e      	bls.n	188ee <ADC_Module::setConversionSpeed(unsigned char)+0x62>
   188b0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   188b2:	0152      	lsls	r2, r2, #5
   188b4:	f102 4284 	add.w	r2, r2, #1107296256	; 0x42000000
   188b8:	2101      	movs	r1, #1
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   188ba:	2000      	movs	r0, #0
        if(speed == ADC_ADACK_2_4) {
   188bc:	2d10      	cmp	r5, #16
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   188be:	60d9      	str	r1, [r3, #12]
   188c0:	e9c2 1100 	strd	r1, r1, [r2]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   188c4:	6150      	str	r0, [r2, #20]
   188c6:	6190      	str	r0, [r2, #24]
   188c8:	d104      	bne.n	188d4 <ADC_Module::setConversionSpeed(unsigned char)+0x48>
   188ca:	6098      	str	r0, [r3, #8]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   188cc:	61d1      	str	r1, [r2, #28]
    conversion_speed = speed;
   188ce:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
   188d2:	e04e      	b.n	18972 <ADC_Module::setConversionSpeed(unsigned char)+0xe6>
        } else if(speed == ADC_ADACK_4_0) {
   188d4:	2d11      	cmp	r5, #17
   188d6:	d101      	bne.n	188dc <ADC_Module::setConversionSpeed(unsigned char)+0x50>
   188d8:	6099      	str	r1, [r3, #8]
   188da:	e7f7      	b.n	188cc <ADC_Module::setConversionSpeed(unsigned char)+0x40>
        } else if(speed == ADC_ADACK_5_2) {
   188dc:	2d12      	cmp	r5, #18
   188de:	d102      	bne.n	188e6 <ADC_Module::setConversionSpeed(unsigned char)+0x5a>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   188e0:	6098      	str	r0, [r3, #8]
   188e2:	61d0      	str	r0, [r2, #28]
    }
   188e4:	e7f3      	b.n	188ce <ADC_Module::setConversionSpeed(unsigned char)+0x42>
        } else if(speed == ADC_ADACK_6_2) {
   188e6:	2d13      	cmp	r5, #19
   188e8:	d1f1      	bne.n	188ce <ADC_Module::setConversionSpeed(unsigned char)+0x42>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   188ea:	6099      	str	r1, [r3, #8]
   188ec:	e7f9      	b.n	188e2 <ADC_Module::setConversionSpeed(unsigned char)+0x56>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   188ee:	2200      	movs	r2, #0
   188f0:	60da      	str	r2, [r3, #12]
    if(speed == ADC_VERY_LOW_SPEED) {
   188f2:	b9ad      	cbnz	r5, 18920 <ADC_Module::setConversionSpeed(unsigned char)+0x94>
   188f4:	609d      	str	r5, [r3, #8]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   188f6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   188f8:	015b      	lsls	r3, r3, #5
   188fa:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   188fe:	2201      	movs	r2, #1
   18900:	61da      	str	r2, [r3, #28]
        ADC_CFG1_speed = ADC_CFG1_LOW_SPEED;
   18902:	2361      	movs	r3, #97	; 0x61
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = state;
   18904:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   18906:	0152      	lsls	r2, r2, #5
   18908:	f102 4284 	add.w	r2, r2, #1107296256	; 0x42000000
   1890c:	2101      	movs	r1, #1
   1890e:	2000      	movs	r0, #0
   18910:	e9c2 1000 	strd	r1, r0, [r2]
    changeBit(ADC_CFG1, ADC_CFG1_ADIV1_BIT, !!(ADC_CFG1_speed & ADC_CFG1_ADIV_MASK_1));
   18914:	0999      	lsrs	r1, r3, #6
    changeBit(ADC_CFG1, ADC_CFG1_ADIV0_BIT, !!(ADC_CFG1_speed & ADC_CFG1_ADIV_MASK_0));
   18916:	f3c3 1340 	ubfx	r3, r3, #5, #1
   1891a:	6191      	str	r1, [r2, #24]
   1891c:	6153      	str	r3, [r2, #20]
   1891e:	e7d6      	b.n	188ce <ADC_Module::setConversionSpeed(unsigned char)+0x42>
    } else if(speed == ADC_LOW_SPEED) {
   18920:	1e69      	subs	r1, r5, #1
   18922:	2904      	cmp	r1, #4
   18924:	d820      	bhi.n	18968 <ADC_Module::setConversionSpeed(unsigned char)+0xdc>
   18926:	e8df f001 	tbb	[pc, r1]
   1892a:	0503      	.short	0x0503
   1892c:	150d      	.short	0x150d
   1892e:	15          	.byte	0x15
   1892f:	00          	.byte	0x00
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   18930:	609a      	str	r2, [r3, #8]
   18932:	e7e0      	b.n	188f6 <ADC_Module::setConversionSpeed(unsigned char)+0x6a>
   18934:	609a      	str	r2, [r3, #8]
   18936:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   18938:	015b      	lsls	r3, r3, #5
   1893a:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   1893e:	61da      	str	r2, [r3, #28]
        ADC_CFG1_speed = ADC_CFG1_HI_SPEED_16_BITS;
   18940:	2341      	movs	r3, #65	; 0x41
   18942:	e7df      	b.n	18904 <ADC_Module::setConversionSpeed(unsigned char)+0x78>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   18944:	2201      	movs	r2, #1
   18946:	609a      	str	r2, [r3, #8]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   18948:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1894a:	015b      	lsls	r3, r3, #5
   1894c:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18950:	2200      	movs	r2, #0
   18952:	e7f4      	b.n	1893e <ADC_Module::setConversionSpeed(unsigned char)+0xb2>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   18954:	2201      	movs	r2, #1
   18956:	609a      	str	r2, [r3, #8]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   18958:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1895a:	015b      	lsls	r3, r3, #5
   1895c:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18960:	2200      	movs	r2, #0
   18962:	61da      	str	r2, [r3, #28]
        ADC_CFG1_speed = ADC_CFG1_VERY_HIGH_SPEED;
   18964:	2321      	movs	r3, #33	; 0x21
   18966:	e7cd      	b.n	18904 <ADC_Module::setConversionSpeed(unsigned char)+0x78>
        fail_flag |= ADC_ERROR_OTHER;
   18968:	8ae3      	ldrh	r3, [r4, #22]
   1896a:	b29b      	uxth	r3, r3
   1896c:	f043 0301 	orr.w	r3, r3, #1
   18970:	82e3      	strh	r3, [r4, #22]
}
   18972:	bd38      	pop	{r3, r4, r5, pc}

00018974 <ADC_Module::setSamplingSpeed(unsigned char)>:
void ADC_Module::setSamplingSpeed(uint8_t speed) {
   18974:	b538      	push	{r3, r4, r5, lr}
    if(speed==sampling_speed) { // no change
   18976:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
   1897a:	428b      	cmp	r3, r1
void ADC_Module::setSamplingSpeed(uint8_t speed) {
   1897c:	4604      	mov	r4, r0
   1897e:	460d      	mov	r5, r1
    if(speed==sampling_speed) { // no change
   18980:	d012      	beq.n	189a8 <ADC_Module::setSamplingSpeed(unsigned char)+0x34>
    if (calibrating) wait_for_cal();
   18982:	7e43      	ldrb	r3, [r0, #25]
   18984:	b10b      	cbz	r3, 1898a <ADC_Module::setSamplingSpeed(unsigned char)+0x16>
   18986:	f7ff fee0 	bl	1874a <ADC_Module::wait_for_cal()>
    if(speed == ADC_VERY_LOW_SPEED) {
   1898a:	b975      	cbnz	r5, 189aa <ADC_Module::setSamplingSpeed(unsigned char)+0x36>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   1898c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1898e:	015b      	lsls	r3, r3, #5
   18990:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18994:	2201      	movs	r2, #1
   18996:	611a      	str	r2, [r3, #16]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   18998:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1899a:	015b      	lsls	r3, r3, #5
   1899c:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   189a0:	e9c3 5500 	strd	r5, r5, [r3]
    sampling_speed =  speed;
   189a4:	f884 5025 	strb.w	r5, [r4, #37]	; 0x25
}
   189a8:	bd38      	pop	{r3, r4, r5, pc}
    } else if(speed == ADC_LOW_SPEED) {
   189aa:	1e6b      	subs	r3, r5, #1
   189ac:	2b04      	cmp	r3, #4
   189ae:	d8fb      	bhi.n	189a8 <ADC_Module::setSamplingSpeed(unsigned char)+0x34>
   189b0:	e8df f003 	tbb	[pc, r3]
   189b4:	1e1e1103 	.word	0x1e1e1103
   189b8:	2a          	.byte	0x2a
   189b9:	00          	.byte	0x00
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   189ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   189bc:	015b      	lsls	r3, r3, #5
   189be:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   189c2:	2201      	movs	r2, #1
   189c4:	611a      	str	r2, [r3, #16]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   189c6:	6c23      	ldr	r3, [r4, #64]	; 0x40
   189c8:	015b      	lsls	r3, r3, #5
   189ca:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   189ce:	2100      	movs	r1, #0
   189d0:	6059      	str	r1, [r3, #4]
   189d2:	601a      	str	r2, [r3, #0]
    }
   189d4:	e7e6      	b.n	189a4 <ADC_Module::setSamplingSpeed(unsigned char)+0x30>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   189d6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   189d8:	015b      	lsls	r3, r3, #5
   189da:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   189de:	2201      	movs	r2, #1
   189e0:	611a      	str	r2, [r3, #16]
   189e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
   189e4:	015b      	lsls	r3, r3, #5
   189e6:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   189ea:	605a      	str	r2, [r3, #4]
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   189ec:	2200      	movs	r2, #0
   189ee:	e7f0      	b.n	189d2 <ADC_Module::setSamplingSpeed(unsigned char)+0x5e>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   189f0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   189f2:	015b      	lsls	r3, r3, #5
   189f4:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   189f8:	2201      	movs	r2, #1
   189fa:	611a      	str	r2, [r3, #16]
   189fc:	6c23      	ldr	r3, [r4, #64]	; 0x40
   189fe:	015b      	lsls	r3, r3, #5
   18a00:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18a04:	605a      	str	r2, [r3, #4]
   18a06:	e7e4      	b.n	189d2 <ADC_Module::setSamplingSpeed(unsigned char)+0x5e>
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   18a08:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   18a0a:	015b      	lsls	r3, r3, #5
   18a0c:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18a10:	2200      	movs	r2, #0
   18a12:	611a      	str	r2, [r3, #16]
    }
   18a14:	e7c6      	b.n	189a4 <ADC_Module::setSamplingSpeed(unsigned char)+0x30>

00018a16 <ADC_Module::analog_init()>:
void ADC_Module::analog_init() {
   18a16:	b538      	push	{r3, r4, r5, lr}
    analog_res_bits = 0;
   18a18:	2100      	movs	r1, #0
    analog_reference_internal = 2;
   18a1a:	2302      	movs	r3, #2
    analog_res_bits = 0;
   18a1c:	76c1      	strb	r1, [r0, #27]
    analog_max_val = 0;
   18a1e:	61c1      	str	r1, [r0, #28]
    analog_num_average = 0;
   18a20:	f880 1020 	strb.w	r1, [r0, #32]
    analog_reference_internal = 2;
   18a24:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 1;
   18a28:	6c03      	ldr	r3, [r0, #64]	; 0x40
    var_enableInterrupts = 0;
   18a2a:	f880 1022 	strb.w	r1, [r0, #34]	; 0x22
   18a2e:	015b      	lsls	r3, r3, #5
   18a30:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
    pga_value = 1;
   18a34:	2501      	movs	r5, #1
   18a36:	f880 5023 	strb.w	r5, [r0, #35]	; 0x23
void ADC_Module::analog_init() {
   18a3a:	4604      	mov	r4, r0
    conversion_speed = 0;
   18a3c:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
    num_measurements = 0;
   18a40:	7541      	strb	r1, [r0, #21]
    sampling_speed =  0;
   18a42:	f880 1025 	strb.w	r1, [r0, #37]	; 0x25
    calibrating = 0;
   18a46:	7641      	strb	r1, [r0, #25]
    fail_flag = ADC_ERROR_CLEAR; // clear all errors
   18a48:	82c1      	strh	r1, [r0, #22]
   18a4a:	611d      	str	r5, [r3, #16]
    setReference(ADC_REF_3V3);
   18a4c:	f7ff fe32 	bl	186b4 <ADC_Module::setReference(unsigned char)>
    setResolution(10);
   18a50:	210a      	movs	r1, #10
   18a52:	f7ff fedb 	bl	1880c <ADC_Module::setResolution(unsigned char)>
    setAveraging(32);
   18a56:	4620      	mov	r0, r4
    init_calib = 1;
   18a58:	76a5      	strb	r5, [r4, #26]
    setAveraging(32);
   18a5a:	2120      	movs	r1, #32
   18a5c:	f7ff fe46 	bl	186ec <ADC_Module::setAveraging(unsigned char)>
    setConversionSpeed(ADC_LOW_SPEED);
   18a60:	4629      	mov	r1, r5
   18a62:	4620      	mov	r0, r4
   18a64:	f7ff ff12 	bl	1888c <ADC_Module::setConversionSpeed(unsigned char)>
    setSamplingSpeed(ADC_LOW_SPEED);
   18a68:	4620      	mov	r0, r4
   18a6a:	4629      	mov	r1, r5
   18a6c:	f7ff ff82 	bl	18974 <ADC_Module::setSamplingSpeed(unsigned char)>
    calibrate();
   18a70:	4620      	mov	r0, r4
}
   18a72:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    calibrate();
   18a76:	f7ff be11 	b.w	1869c <ADC_Module::calibrate()>
   18a7a:	Address 0x0000000000018a7a is out of bounds.


00018a7c <ADC_Module::ADC_Module(unsigned char, unsigned char const*, ADC_Module::ADC_NLIST const*)>:
ADC_Module::ADC_Module(uint8_t ADC_number, const uint8_t* const a_channel2sc1a, const ADC_NLIST* const a_diff_table) :
   18a7c:	b510      	push	{r4, lr}
        , diff_table(a_diff_table)
   18a7e:	62c3      	str	r3, [r0, #44]	; 0x2c
        , adc_offset((uint32_t)0x20000)
   18a80:	f44f 3300 	mov.w	r3, #131072	; 0x20000
   18a84:	6303      	str	r3, [r0, #48]	; 0x30
        , ADC_SC1A(&ADC0_SC1A + adc_offset*ADC_num)
   18a86:	04cb      	lsls	r3, r1, #19
   18a88:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   18a8c:	f503 336c 	add.w	r3, r3, #241664	; 0x3b000
        , channel2sc1a(a_channel2sc1a)
   18a90:	6282      	str	r2, [r0, #40]	; 0x28
        , ADC_SC1B(&ADC0_SC1B + adc_offset*ADC_num)
   18a92:	1d1a      	adds	r2, r3, #4
   18a94:	6382      	str	r2, [r0, #56]	; 0x38
        , ADC_CFG1(&ADC0_CFG1 + adc_offset*ADC_num)
   18a96:	f103 0208 	add.w	r2, r3, #8
   18a9a:	63c2      	str	r2, [r0, #60]	; 0x3c
        , ADC_CFG2(&ADC0_CFG2 + adc_offset*ADC_num)
   18a9c:	f103 020c 	add.w	r2, r3, #12
   18aa0:	6402      	str	r2, [r0, #64]	; 0x40
        , ADC_RA(&ADC0_RA + adc_offset*ADC_num)
   18aa2:	f103 0210 	add.w	r2, r3, #16
   18aa6:	6442      	str	r2, [r0, #68]	; 0x44
        , ADC_RB(&ADC0_RB + adc_offset*ADC_num)
   18aa8:	f103 0214 	add.w	r2, r3, #20
   18aac:	6482      	str	r2, [r0, #72]	; 0x48
        , ADC_CV1(&ADC0_CV1 + adc_offset*ADC_num)
   18aae:	f103 0218 	add.w	r2, r3, #24
   18ab2:	64c2      	str	r2, [r0, #76]	; 0x4c
        , ADC_CV2(&ADC0_CV2 + adc_offset*ADC_num)
   18ab4:	f103 021c 	add.w	r2, r3, #28
   18ab8:	6502      	str	r2, [r0, #80]	; 0x50
        , ADC_SC2(&ADC0_SC2 + adc_offset*ADC_num)
   18aba:	f103 0220 	add.w	r2, r3, #32
   18abe:	6542      	str	r2, [r0, #84]	; 0x54
        , ADC_SC3(&ADC0_SC3 + adc_offset*ADC_num)
   18ac0:	f103 0224 	add.w	r2, r3, #36	; 0x24
   18ac4:	6582      	str	r2, [r0, #88]	; 0x58
        , ADC_PGA(&ADC0_PGA + adc_offset*ADC_num)
   18ac6:	f103 0250 	add.w	r2, r3, #80	; 0x50
   18aca:	65c2      	str	r2, [r0, #92]	; 0x5c
        , ADC_OFS(&ADC0_OFS + adc_offset*ADC_num)
   18acc:	f103 0228 	add.w	r2, r3, #40	; 0x28
   18ad0:	6602      	str	r2, [r0, #96]	; 0x60
        , ADC_PG(&ADC0_PG + adc_offset*ADC_num)
   18ad2:	f103 022c 	add.w	r2, r3, #44	; 0x2c
   18ad6:	6642      	str	r2, [r0, #100]	; 0x64
        , ADC_MG(&ADC0_MG + adc_offset*ADC_num)
   18ad8:	f103 0230 	add.w	r2, r3, #48	; 0x30
   18adc:	6682      	str	r2, [r0, #104]	; 0x68
        , ADC_CLPD(&ADC0_CLPD + adc_offset*ADC_num)
   18ade:	f103 0234 	add.w	r2, r3, #52	; 0x34
   18ae2:	66c2      	str	r2, [r0, #108]	; 0x6c
        , ADC_CLPS(&ADC0_CLPS + adc_offset*ADC_num)
   18ae4:	f103 0238 	add.w	r2, r3, #56	; 0x38
   18ae8:	6702      	str	r2, [r0, #112]	; 0x70
        , ADC_CLP4(&ADC0_CLP4 + adc_offset*ADC_num)
   18aea:	f103 023c 	add.w	r2, r3, #60	; 0x3c
   18aee:	6742      	str	r2, [r0, #116]	; 0x74
        , ADC_CLP3(&ADC0_CLP3 + adc_offset*ADC_num)
   18af0:	f103 0240 	add.w	r2, r3, #64	; 0x40
   18af4:	6782      	str	r2, [r0, #120]	; 0x78
        , ADC_CLP2(&ADC0_CLP2 + adc_offset*ADC_num)
   18af6:	f103 0244 	add.w	r2, r3, #68	; 0x44
   18afa:	67c2      	str	r2, [r0, #124]	; 0x7c
        , ADC_CLP1(&ADC0_CLP1 + adc_offset*ADC_num)
   18afc:	f103 0248 	add.w	r2, r3, #72	; 0x48
   18b00:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
        , ADC_CLP0(&ADC0_CLP0 + adc_offset*ADC_num)
   18b04:	f103 024c 	add.w	r2, r3, #76	; 0x4c
   18b08:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
        , ADC_CLMD(&ADC0_CLMD + adc_offset*ADC_num)
   18b0c:	f103 0254 	add.w	r2, r3, #84	; 0x54
   18b10:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
        , ADC_CLMS(&ADC0_CLMS + adc_offset*ADC_num)
   18b14:	f103 0258 	add.w	r2, r3, #88	; 0x58
   18b18:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
        , ADC_CLM4(&ADC0_CLM4 + adc_offset*ADC_num)
   18b1c:	f103 025c 	add.w	r2, r3, #92	; 0x5c
   18b20:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
        , ADC_CLM3(&ADC0_CLM3 + adc_offset*ADC_num)
   18b24:	f103 0260 	add.w	r2, r3, #96	; 0x60
   18b28:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
        , ADC_CLM2(&ADC0_CLM2 + adc_offset*ADC_num)
   18b2c:	f103 0264 	add.w	r2, r3, #100	; 0x64
   18b30:	f8c0 2098 	str.w	r2, [r0, #152]	; 0x98
        , ADC_CLM1(&ADC0_CLM1 + adc_offset*ADC_num)
   18b34:	f103 0268 	add.w	r2, r3, #104	; 0x68
        , ADC_SC1A(&ADC0_SC1A + adc_offset*ADC_num)
   18b38:	6343      	str	r3, [r0, #52]	; 0x34
        , ADC_CLM1(&ADC0_CLM1 + adc_offset*ADC_num)
   18b3a:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
        , ADC_CLM0(&ADC0_CLM0 + adc_offset*ADC_num)
   18b3e:	336c      	adds	r3, #108	; 0x6c
        , PDB0_CHnC1(&PDB0_CH0C1 + ADC_num*0xA)
   18b40:	4a08      	ldr	r2, [pc, #32]	; (18b64 <ADC_Module::ADC_Module(unsigned char, unsigned char const*, ADC_Module::ADC_NLIST const*)+0xe8>)
        ADC_num(ADC_number)
   18b42:	7601      	strb	r1, [r0, #24]
        , ADC_CLM0(&ADC0_CLM0 + adc_offset*ADC_num)
   18b44:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
        , PDB0_CHnC1(&PDB0_CH0C1 + ADC_num*0xA)
   18b48:	2328      	movs	r3, #40	; 0x28
   18b4a:	fb13 2301 	smlabb	r3, r3, r1, r2
        , IRQ_ADC(IRQ_ADC0 + ADC_num*1)
   18b4e:	3139      	adds	r1, #57	; 0x39
ADC_Module::ADC_Module(uint8_t ADC_number, const uint8_t* const a_channel2sc1a, const ADC_NLIST* const a_diff_table) :
   18b50:	4604      	mov	r4, r0
        , PDB0_CHnC1(&PDB0_CH0C1 + ADC_num*0xA)
   18b52:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
        , IRQ_ADC(IRQ_ADC0 + ADC_num*1)
   18b56:	f880 10a8 	strb.w	r1, [r0, #168]	; 0xa8
    analog_init();
   18b5a:	f7ff ff5c 	bl	18a16 <ADC_Module::analog_init()>
}
   18b5e:	4620      	mov	r0, r4
   18b60:	bd10      	pop	{r4, pc}
   18b62:	bf00      	nop
   18b64:	40036010 	.word	0x40036010

00018b68 <ADC_Module::disableInterrupts()>:
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   18b68:	6b43      	ldr	r3, [r0, #52]	; 0x34
   18b6a:	015b      	lsls	r3, r3, #5
   18b6c:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
    var_enableInterrupts = 0;
   18b70:	2200      	movs	r2, #0
   18b72:	f880 2022 	strb.w	r2, [r0, #34]	; 0x22
   18b76:	619a      	str	r2, [r3, #24]
    NVIC_DISABLE_IRQ(IRQ_ADC);
   18b78:	f890 20a8 	ldrb.w	r2, [r0, #168]	; 0xa8
   18b7c:	0953      	lsrs	r3, r2, #5
   18b7e:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
   18b82:	3360      	adds	r3, #96	; 0x60
   18b84:	009b      	lsls	r3, r3, #2
   18b86:	f002 021f 	and.w	r2, r2, #31
   18b8a:	2101      	movs	r1, #1
   18b8c:	fa01 f202 	lsl.w	r2, r1, r2
   18b90:	601a      	str	r2, [r3, #0]
}
   18b92:	4770      	bx	lr

00018b94 <ADC_Module::disableDMA()>:
   18b94:	6d43      	ldr	r3, [r0, #84]	; 0x54
   18b96:	015b      	lsls	r3, r3, #5
   18b98:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18b9c:	2200      	movs	r2, #0
   18b9e:	609a      	str	r2, [r3, #8]
}
   18ba0:	4770      	bx	lr

00018ba2 <ADC_Module::disableCompare()>:
   18ba2:	6d43      	ldr	r3, [r0, #84]	; 0x54
   18ba4:	015b      	lsls	r3, r3, #5
   18ba6:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18baa:	2200      	movs	r2, #0
   18bac:	615a      	str	r2, [r3, #20]
}
   18bae:	4770      	bx	lr

00018bb0 <ADC_Module::checkPin(unsigned char)>:
    if(pin>ADC_MAX_PIN) {
   18bb0:	2928      	cmp	r1, #40	; 0x28
   18bb2:	d807      	bhi.n	18bc4 <ADC_Module::checkPin(unsigned char)+0x14>
    const uint8_t sc1a_pin = channel2sc1a[pin];
   18bb4:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if( (sc1a_pin&ADC_SC1A_CHANNELS) == ADC_SC1A_PIN_INVALID ) {
   18bb6:	5c58      	ldrb	r0, [r3, r1]
   18bb8:	f000 001f 	and.w	r0, r0, #31
   18bbc:	381f      	subs	r0, #31
   18bbe:	bf18      	it	ne
   18bc0:	2001      	movne	r0, #1
   18bc2:	4770      	bx	lr
        return false;   // all others are invalid
   18bc4:	2000      	movs	r0, #0
}
   18bc6:	4770      	bx	lr

00018bc8 <ADC_Module::startReadFast(unsigned char)>:
void ADC_Module::startReadFast(uint8_t pin) {
   18bc8:	b510      	push	{r4, lr}
    const uint8_t sc1a_pin = channel2sc1a[pin];
   18bca:	6a84      	ldr	r4, [r0, #40]	; 0x28
   18bcc:	6c02      	ldr	r2, [r0, #64]	; 0x40
   18bce:	5c63      	ldrb	r3, [r4, r1]
    if(sc1a_pin&ADC_SC1A_PIN_MUX) { // mux a
   18bd0:	5661      	ldrsb	r1, [r4, r1]
   18bd2:	0152      	lsls	r2, r2, #5
   18bd4:	f102 4284 	add.w	r2, r2, #1107296256	; 0x42000000
   18bd8:	43c9      	mvns	r1, r1
   18bda:	0fc9      	lsrs	r1, r1, #31
   18bdc:	6111      	str	r1, [r2, #16]
    __disable_irq();
   18bde:	b672      	cpsid	i
    *ADC_SC1A = (sc1a_pin&ADC_SC1A_CHANNELS) + var_enableInterrupts*ADC_SC1_AIEN;
   18be0:	f890 1022 	ldrb.w	r1, [r0, #34]	; 0x22
   18be4:	6b42      	ldr	r2, [r0, #52]	; 0x34
   18be6:	f003 031f 	and.w	r3, r3, #31
   18bea:	eb03 1381 	add.w	r3, r3, r1, lsl #6
   18bee:	6013      	str	r3, [r2, #0]
    __enable_irq();
   18bf0:	b662      	cpsie	i
}
   18bf2:	bd10      	pop	{r4, pc}

00018bf4 <ADC_Module::startSingleRead(unsigned char)>:
bool ADC_Module::startSingleRead(uint8_t pin) {
   18bf4:	b570      	push	{r4, r5, r6, lr}
   18bf6:	4604      	mov	r4, r0
    if(!checkPin(pin)) {
   18bf8:	f7ff ffda 	bl	18bb0 <ADC_Module::checkPin(unsigned char)>
bool ADC_Module::startSingleRead(uint8_t pin) {
   18bfc:	460e      	mov	r6, r1
    if(!checkPin(pin)) {
   18bfe:	4605      	mov	r5, r0
   18c00:	b930      	cbnz	r0, 18c10 <ADC_Module::startSingleRead(unsigned char)+0x1c>
        fail_flag |= ADC_ERROR_WRONG_PIN;
   18c02:	8ae3      	ldrh	r3, [r4, #22]
   18c04:	b29b      	uxth	r3, r3
   18c06:	f043 0304 	orr.w	r3, r3, #4
   18c0a:	82e3      	strh	r3, [r4, #22]
}
   18c0c:	4628      	mov	r0, r5
   18c0e:	bd70      	pop	{r4, r5, r6, pc}
    if (calibrating) wait_for_cal();
   18c10:	7e63      	ldrb	r3, [r4, #25]
   18c12:	b113      	cbz	r3, 18c1a <ADC_Module::startSingleRead(unsigned char)+0x26>
   18c14:	4620      	mov	r0, r4
   18c16:	f7ff fd98 	bl	1874a <ADC_Module::wait_for_cal()>
        return (volatile bool)*(uint32_t*)(ADC_BITBAND_ADDR(reg, bit));
   18c1a:	6d63      	ldr	r3, [r4, #84]	; 0x54
   18c1c:	015b      	lsls	r3, r3, #5
   18c1e:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18c22:	69db      	ldr	r3, [r3, #28]
   18c24:	3b00      	subs	r3, #0
   18c26:	bf18      	it	ne
   18c28:	2301      	movne	r3, #1
    adcWasInUse = isConverting(); // is the ADC running now?
   18c2a:	7523      	strb	r3, [r4, #20]
    if(adcWasInUse) { // this means we're interrupting a conversion
   18c2c:	b12b      	cbz	r3, 18c3a <ADC_Module::startSingleRead(unsigned char)+0x46>
        __disable_irq();
   18c2e:	b672      	cpsid	i
        saveConfig(&adc_config);
   18c30:	4621      	mov	r1, r4
   18c32:	4620      	mov	r0, r4
   18c34:	f7ff fd22 	bl	1867c <ADC_Module::saveConfig(ADC_Module::ADC_Config*)>
        __enable_irq();
   18c38:	b662      	cpsie	i
        (*(uint32_t *)ADC_BITBAND_ADDR((reg), (bit))) = 0;
   18c3a:	6da3      	ldr	r3, [r4, #88]	; 0x58
   18c3c:	015b      	lsls	r3, r3, #5
   18c3e:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
   18c42:	2200      	movs	r2, #0
   18c44:	60da      	str	r2, [r3, #12]
    startReadFast(pin);
   18c46:	4631      	mov	r1, r6
   18c48:	4620      	mov	r0, r4
   18c4a:	f7ff ffbd 	bl	18bc8 <ADC_Module::startReadFast(unsigned char)>
    return true;
   18c4e:	e7dd      	b.n	18c0c <ADC_Module::startSingleRead(unsigned char)+0x18>

00018c50 <ADC::ADC()>:
ADC::ADC() : // awkward initialization  so there are no -Wreorder warnings
   18c50:	b538      	push	{r3, r4, r5, lr}
   18c52:	4604      	mov	r4, r0
    , adc1_obj(1, channel2sc1aADC1, diff_table_ADC1)
   18c54:	f104 05ac 	add.w	r5, r4, #172	; 0xac
    adc0_obj(0, channel2sc1aADC0, diff_table_ADC0)
   18c58:	4b0e      	ldr	r3, [pc, #56]	; (18c94 <ADC::ADC()+0x44>)
   18c5a:	4a0f      	ldr	r2, [pc, #60]	; (18c98 <ADC::ADC()+0x48>)
   18c5c:	2100      	movs	r1, #0
   18c5e:	f7ff ff0d 	bl	18a7c <ADC_Module::ADC_Module(unsigned char, unsigned char const*, ADC_Module::ADC_NLIST const*)>
    , adc1_obj(1, channel2sc1aADC1, diff_table_ADC1)
   18c62:	4b0e      	ldr	r3, [pc, #56]	; (18c9c <ADC::ADC()+0x4c>)
   18c64:	4a0e      	ldr	r2, [pc, #56]	; (18ca0 <ADC::ADC()+0x50>)
   18c66:	2101      	movs	r1, #1
   18c68:	4628      	mov	r0, r5
   18c6a:	f7ff ff07 	bl	18a7c <ADC_Module::ADC_Module(unsigned char, unsigned char const*, ADC_Module::ADC_NLIST const*)>
    , adc1(&adc1_obj)
   18c6e:	2302      	movs	r3, #2
   18c70:	f884 3158 	strb.w	r3, [r4, #344]	; 0x158
    SIM_SCGC6 |= SIM_SCGC6_ADC0;
   18c74:	4b0b      	ldr	r3, [pc, #44]	; (18ca4 <ADC::ADC()+0x54>)
    , adc0(&adc0_obj)
   18c76:	f8c4 415c 	str.w	r4, [r4, #348]	; 0x15c
    SIM_SCGC6 |= SIM_SCGC6_ADC0;
   18c7a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    , adc1(&adc1_obj)
   18c7c:	f8c4 5160 	str.w	r5, [r4, #352]	; 0x160
    SIM_SCGC6 |= SIM_SCGC6_ADC0;
   18c80:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
   18c84:	63da      	str	r2, [r3, #60]	; 0x3c
    SIM_SCGC3 |= SIM_SCGC3_ADC1;
   18c86:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   18c88:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
   18c8c:	631a      	str	r2, [r3, #48]	; 0x30
}
   18c8e:	4620      	mov	r0, r4
   18c90:	bd38      	pop	{r3, r4, r5, pc}
   18c92:	bf00      	nop
   18c94:	0002786c 	.word	0x0002786c
   18c98:	00027874 	.word	0x00027874
   18c9c:	00027870 	.word	0x00027870
   18ca0:	000278a0 	.word	0x000278a0
   18ca4:	40048000 	.word	0x40048000

00018ca8 <ADC::setReference(unsigned char, signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18ca8:	2a01      	cmp	r2, #1
        adc1->setReference(type);
   18caa:	bf0c      	ite	eq
   18cac:	f8d0 0160 	ldreq.w	r0, [r0, #352]	; 0x160
    adc0->setReference(type); // adc_num isn't changed or has selected ADC0
   18cb0:	f8d0 015c 	ldrne.w	r0, [r0, #348]	; 0x15c
   18cb4:	f7ff bcfe 	b.w	186b4 <ADC_Module::setReference(unsigned char)>

00018cb8 <ADC::setResolution(unsigned char, signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18cb8:	2a01      	cmp	r2, #1
        adc1->setResolution(bits);
   18cba:	bf0c      	ite	eq
   18cbc:	f8d0 0160 	ldreq.w	r0, [r0, #352]	; 0x160
    adc0->setResolution(bits); // adc_num isn't changed or has selected ADC0
   18cc0:	f8d0 015c 	ldrne.w	r0, [r0, #348]	; 0x15c
   18cc4:	f7ff bda2 	b.w	1880c <ADC_Module::setResolution(unsigned char)>

00018cc8 <ADC::setConversionSpeed(unsigned char, signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18cc8:	2a01      	cmp	r2, #1
        adc1->setConversionSpeed(speed);
   18cca:	bf0c      	ite	eq
   18ccc:	f8d0 0160 	ldreq.w	r0, [r0, #352]	; 0x160
    adc0->setConversionSpeed(speed); // adc_num isn't changed or has selected ADC0
   18cd0:	f8d0 015c 	ldrne.w	r0, [r0, #348]	; 0x15c
   18cd4:	f7ff bdda 	b.w	1888c <ADC_Module::setConversionSpeed(unsigned char)>

00018cd8 <ADC::setSamplingSpeed(unsigned char, signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18cd8:	2a01      	cmp	r2, #1
        adc1->setSamplingSpeed(speed);
   18cda:	bf0c      	ite	eq
   18cdc:	f8d0 0160 	ldreq.w	r0, [r0, #352]	; 0x160
    adc0->setSamplingSpeed(speed); // adc_num isn't changed or has selected ADC0
   18ce0:	f8d0 015c 	ldrne.w	r0, [r0, #348]	; 0x15c
   18ce4:	f7ff be46 	b.w	18974 <ADC_Module::setSamplingSpeed(unsigned char)>

00018ce8 <ADC::setAveraging(unsigned char, signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18ce8:	2a01      	cmp	r2, #1
        adc1->setAveraging(num);
   18cea:	bf0c      	ite	eq
   18cec:	f8d0 0160 	ldreq.w	r0, [r0, #352]	; 0x160
    adc0->setAveraging(num); // adc_num isn't changed or has selected ADC0
   18cf0:	f8d0 015c 	ldrne.w	r0, [r0, #348]	; 0x15c
   18cf4:	f7ff bcfa 	b.w	186ec <ADC_Module::setAveraging(unsigned char)>

00018cf8 <ADC::disableInterrupts(signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18cf8:	2901      	cmp	r1, #1
        adc1->disableInterrupts();
   18cfa:	bf0c      	ite	eq
   18cfc:	f8d0 0160 	ldreq.w	r0, [r0, #352]	; 0x160
    adc0->disableInterrupts();
   18d00:	f8d0 015c 	ldrne.w	r0, [r0, #348]	; 0x15c
   18d04:	f7ff bf30 	b.w	18b68 <ADC_Module::disableInterrupts()>

00018d08 <ADC::disableDMA(signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18d08:	2901      	cmp	r1, #1
        adc1->disableDMA();
   18d0a:	bf0c      	ite	eq
   18d0c:	f8d0 0160 	ldreq.w	r0, [r0, #352]	; 0x160
    adc0->disableDMA();
   18d10:	f8d0 015c 	ldrne.w	r0, [r0, #348]	; 0x15c
   18d14:	f7ff bf3e 	b.w	18b94 <ADC_Module::disableDMA()>

00018d18 <ADC::disableCompare(signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18d18:	2901      	cmp	r1, #1
        adc1->disableCompare();
   18d1a:	bf0c      	ite	eq
   18d1c:	f8d0 0160 	ldreq.w	r0, [r0, #352]	; 0x160
    adc0->disableCompare();
   18d20:	f8d0 015c 	ldrne.w	r0, [r0, #348]	; 0x15c
   18d24:	f7ff bf3d 	b.w	18ba2 <ADC_Module::disableCompare()>

00018d28 <ADC::startSingleRead(unsigned char, signed char)>:
    if( adc_num==-1 ) { // use no ADC in particular
   18d28:	1c53      	adds	r3, r2, #1
bool ADC::startSingleRead(uint8_t pin, int8_t adc_num) {
   18d2a:	b570      	push	{r4, r5, r6, lr}
   18d2c:	4604      	mov	r4, r0
   18d2e:	460d      	mov	r5, r1
    if( adc_num==-1 ) { // use no ADC in particular
   18d30:	d12d      	bne.n	18d8e <ADC::startSingleRead(unsigned char, signed char)+0x66>
        bool adc0Pin = adc0->checkPin(pin);
   18d32:	f8d0 015c 	ldr.w	r0, [r0, #348]	; 0x15c
   18d36:	f7ff ff3b 	bl	18bb0 <ADC_Module::checkPin(unsigned char)>
        bool adc1Pin = adc1->checkPin(pin);
   18d3a:	4629      	mov	r1, r5
        bool adc0Pin = adc0->checkPin(pin);
   18d3c:	4606      	mov	r6, r0
        bool adc1Pin = adc1->checkPin(pin);
   18d3e:	f8d4 0160 	ldr.w	r0, [r4, #352]	; 0x160
   18d42:	f7ff ff35 	bl	18bb0 <ADC_Module::checkPin(unsigned char)>
   18d46:	4603      	mov	r3, r0
        if(adc0Pin && adc1Pin)  { // Both ADCs
   18d48:	b176      	cbz	r6, 18d68 <ADC::startSingleRead(unsigned char, signed char)+0x40>
            if( (adc0->num_measurements) > (adc1->num_measurements)) { // use the ADC with less workload
   18d4a:	f8d4 015c 	ldr.w	r0, [r4, #348]	; 0x15c
        if(adc0Pin && adc1Pin)  { // Both ADCs
   18d4e:	b173      	cbz	r3, 18d6e <ADC::startSingleRead(unsigned char, signed char)+0x46>
            if( (adc0->num_measurements) > (adc1->num_measurements)) { // use the ADC with less workload
   18d50:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
   18d54:	7d41      	ldrb	r1, [r0, #21]
   18d56:	7d5a      	ldrb	r2, [r3, #21]
   18d58:	4291      	cmp	r1, r2
                return adc1->startSingleRead(pin);
   18d5a:	4629      	mov	r1, r5
            if( (adc0->num_measurements) > (adc1->num_measurements)) { // use the ADC with less workload
   18d5c:	d900      	bls.n	18d60 <ADC::startSingleRead(unsigned char, signed char)+0x38>
                return adc1->startSingleRead(pin);
   18d5e:	4618      	mov	r0, r3
}
   18d60:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return adc1->startSingleRead(pin);
   18d64:	f7ff bf46 	b.w	18bf4 <ADC_Module::startSingleRead(unsigned char)>
            if( (adc0->num_measurements) > (adc1->num_measurements)) { // use the ADC with less workload
   18d68:	f8d4 0160 	ldr.w	r0, [r4, #352]	; 0x160
        } else if(adc1Pin) { // ADC1
   18d6c:	b10b      	cbz	r3, 18d72 <ADC::startSingleRead(unsigned char, signed char)+0x4a>
            return adc1->startSingleRead(pin);
   18d6e:	4629      	mov	r1, r5
   18d70:	e7f6      	b.n	18d60 <ADC::startSingleRead(unsigned char, signed char)+0x38>
            adc0->fail_flag |= ADC_ERROR_WRONG_PIN;
   18d72:	f8d4 215c 	ldr.w	r2, [r4, #348]	; 0x15c
   18d76:	8ad3      	ldrh	r3, [r2, #22]
   18d78:	b29b      	uxth	r3, r3
   18d7a:	f043 0304 	orr.w	r3, r3, #4
   18d7e:	82d3      	strh	r3, [r2, #22]
            adc1->fail_flag |= ADC_ERROR_WRONG_PIN;
   18d80:	8ac3      	ldrh	r3, [r0, #22]
   18d82:	b29b      	uxth	r3, r3
   18d84:	f043 0304 	orr.w	r3, r3, #4
   18d88:	82c3      	strh	r3, [r0, #22]
}
   18d8a:	2000      	movs	r0, #0
   18d8c:	bd70      	pop	{r4, r5, r6, pc}
    else if( adc_num==0 ) { // user wants ADC0
   18d8e:	b912      	cbnz	r2, 18d96 <ADC::startSingleRead(unsigned char, signed char)+0x6e>
        return adc0->startSingleRead(pin);
   18d90:	f8d0 015c 	ldr.w	r0, [r0, #348]	; 0x15c
   18d94:	e7e4      	b.n	18d60 <ADC::startSingleRead(unsigned char, signed char)+0x38>
    else if( adc_num==1 ){ // user wants ADC 1
   18d96:	2a01      	cmp	r2, #1
   18d98:	d102      	bne.n	18da0 <ADC::startSingleRead(unsigned char, signed char)+0x78>
        return adc1->startSingleRead(pin);
   18d9a:	f8d0 0160 	ldr.w	r0, [r0, #352]	; 0x160
   18d9e:	e7df      	b.n	18d60 <ADC::startSingleRead(unsigned char, signed char)+0x38>
    adc0->fail_flag |= ADC_ERROR_OTHER;
   18da0:	f8d0 215c 	ldr.w	r2, [r0, #348]	; 0x15c
   18da4:	8ad3      	ldrh	r3, [r2, #22]
   18da6:	b29b      	uxth	r3, r3
   18da8:	f043 0301 	orr.w	r3, r3, #1
   18dac:	82d3      	strh	r3, [r2, #22]
    return false;
   18dae:	e7ec      	b.n	18d8a <ADC::startSingleRead(unsigned char, signed char)+0x62>

00018db0 <ADC::readSingle(signed char)>:
    if(adc_num==1){ // user wants ADC 1, do nothing if it's a Teensy 3.0
   18db0:	2901      	cmp	r1, #1
        return (int16_t)(int32_t)*ADC_RA;
   18db2:	bf0c      	ite	eq
   18db4:	f8d0 3160 	ldreq.w	r3, [r0, #352]	; 0x160
   18db8:	f8d0 315c 	ldrne.w	r3, [r0, #348]	; 0x15c
   18dbc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   18dbe:	6818      	ldr	r0, [r3, #0]
   18dc0:	b200      	sxth	r0, r0
}
   18dc2:	4770      	bx	lr

00018dc4 <FreqMeasureClass::begin()>:
#define FTM_SC_VALUE (FTM_SC_TOIE | FTM_SC_CLKS(1) | FTM_SC_PS(0))
#define FTM_ISR_NAME ftm1_isr

static inline void capture_init(void)
{
	if (FTM1_MOD != 0xFFFF || (FTM1_SC & 0x7F) != FTM_SC_VALUE) {
   18dc4:	4b17      	ldr	r3, [pc, #92]	; (18e24 <FreqMeasureClass::begin()+0x60>)
   18dc6:	6899      	ldr	r1, [r3, #8]
   18dc8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   18dcc:	4291      	cmp	r1, r2
   18dce:	d104      	bne.n	18dda <FreqMeasureClass::begin()+0x16>
   18dd0:	681a      	ldr	r2, [r3, #0]
   18dd2:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   18dd6:	2a48      	cmp	r2, #72	; 0x48
   18dd8:	d008      	beq.n	18dec <FreqMeasureClass::begin()+0x28>
		FTM1_SC = 0;
   18dda:	2200      	movs	r2, #0
		FTM1_CNT = 0;
		FTM1_MOD = 0xFFFF;
   18ddc:	f64f 71ff 	movw	r1, #65535	; 0xffff
		FTM1_SC = 0;
   18de0:	601a      	str	r2, [r3, #0]
		FTM1_CNT = 0;
   18de2:	605a      	str	r2, [r3, #4]
		FTM1_MOD = 0xFFFF;
   18de4:	6099      	str	r1, [r3, #8]
		FTM1_SC = FTM_SC_VALUE;
   18de6:	2148      	movs	r1, #72	; 0x48
   18de8:	6019      	str	r1, [r3, #0]
		#ifdef KINETISK
		FTM1_MODE = 0;
   18dea:	655a      	str	r2, [r3, #84]	; 0x54
		#endif
	}
	NVIC_SET_PRIORITY(IRQ_FTM1, 48);
   18dec:	4b0e      	ldr	r3, [pc, #56]	; (18e28 <FreqMeasureClass::begin()+0x64>)
   18dee:	2230      	movs	r2, #48	; 0x30
   18df0:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
static uint32_t capture_previous;

void FreqMeasureClass::begin(void)
{
	capture_init();
	capture_msw = 0;
   18df4:	4a0d      	ldr	r2, [pc, #52]	; (18e2c <FreqMeasureClass::begin()+0x68>)
   18df6:	2300      	movs	r3, #0
   18df8:	8013      	strh	r3, [r2, #0]
	capture_previous = 0;
   18dfa:	4a0d      	ldr	r2, [pc, #52]	; (18e30 <FreqMeasureClass::begin()+0x6c>)
   18dfc:	6013      	str	r3, [r2, #0]
	buffer_head = 0;
   18dfe:	4a0d      	ldr	r2, [pc, #52]	; (18e34 <FreqMeasureClass::begin()+0x70>)
   18e00:	7013      	strb	r3, [r2, #0]
	buffer_tail = 0;
   18e02:	4a0d      	ldr	r2, [pc, #52]	; (18e38 <FreqMeasureClass::begin()+0x74>)
   18e04:	7013      	strb	r3, [r2, #0]
{
	#if defined(KINETISL)
	FTM1_C0SC = 0;
	delayMicroseconds(1);
	#endif
	FTM1_C0SC = 0b01000100;
   18e06:	4b07      	ldr	r3, [pc, #28]	; (18e24 <FreqMeasureClass::begin()+0x60>)
   18e08:	2244      	movs	r2, #68	; 0x44
   18e0a:	60da      	str	r2, [r3, #12]
	// config pin for capture + enable internal pull up
	*portConfigRegister(CAPTURE_USE_FTM1_CH0) = PORT_PCR_MUX(3) | PORT_PCR_PE | PORT_PCR_PS;
   18e0c:	4b0b      	ldr	r3, [pc, #44]	; (18e3c <FreqMeasureClass::begin()+0x78>)
   18e0e:	69db      	ldr	r3, [r3, #28]
   18e10:	f240 3203 	movw	r2, #771	; 0x303
   18e14:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_FTM1);
   18e16:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
   18e1a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   18e1e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	capture_start();
}
   18e22:	4770      	bx	lr
   18e24:	40039000 	.word	0x40039000
   18e28:	e000e400 	.word	0xe000e400
   18e2c:	20005d0a 	.word	0x20005d0a
   18e30:	20005d3c 	.word	0x20005d3c
   18e34:	20005d08 	.word	0x20005d08
   18e38:	20005d09 	.word	0x20005d09
   18e3c:	00027b0c 	.word	0x00027b0c

00018e40 <FreqMeasureClass::available()>:

uint8_t FreqMeasureClass::available(void)
{
	uint8_t head, tail;

	head = buffer_head;
   18e40:	4b05      	ldr	r3, [pc, #20]	; (18e58 <FreqMeasureClass::available()+0x18>)
   18e42:	7819      	ldrb	r1, [r3, #0]
	tail = buffer_tail;
   18e44:	4b05      	ldr	r3, [pc, #20]	; (18e5c <FreqMeasureClass::available()+0x1c>)
   18e46:	781a      	ldrb	r2, [r3, #0]
	head = buffer_head;
   18e48:	b2c8      	uxtb	r0, r1

	if (head >= tail) 
   18e4a:	4291      	cmp	r1, r2
	tail = buffer_tail;
   18e4c:	b2d3      	uxtb	r3, r2
		return (head - tail);

	return FREQMEASURE_BUFFER_LEN + head - tail;
   18e4e:	bf38      	it	cc
   18e50:	300c      	addcc	r0, #12
   18e52:	1ac0      	subs	r0, r0, r3
   18e54:	b2c0      	uxtb	r0, r0
}
   18e56:	4770      	bx	lr
   18e58:	20005d08 	.word	0x20005d08
   18e5c:	20005d09 	.word	0x20005d09

00018e60 <FreqMeasureClass::read()>:
uint32_t FreqMeasureClass::read(void)
{
	uint8_t head, tail;
	uint32_t value;

	head = buffer_head;
   18e60:	4b09      	ldr	r3, [pc, #36]	; (18e88 <FreqMeasureClass::read()+0x28>)
	tail = buffer_tail;
   18e62:	4a0a      	ldr	r2, [pc, #40]	; (18e8c <FreqMeasureClass::read()+0x2c>)
	head = buffer_head;
   18e64:	7818      	ldrb	r0, [r3, #0]
	tail = buffer_tail;
   18e66:	7811      	ldrb	r1, [r2, #0]
	if (head == tail) return 0xFFFFFFFF;
   18e68:	4288      	cmp	r0, r1
	tail = buffer_tail;
   18e6a:	b2cb      	uxtb	r3, r1
	if (head == tail) return 0xFFFFFFFF;
   18e6c:	d009      	beq.n	18e82 <FreqMeasureClass::read()+0x22>
	tail = tail + 1;
   18e6e:	3301      	adds	r3, #1
   18e70:	b2db      	uxtb	r3, r3
	if (tail >= FREQMEASURE_BUFFER_LEN) tail = 0;
   18e72:	2b0c      	cmp	r3, #12
   18e74:	bf28      	it	cs
   18e76:	2300      	movcs	r3, #0
	value = buffer_value[tail];
   18e78:	4905      	ldr	r1, [pc, #20]	; (18e90 <FreqMeasureClass::read()+0x30>)
   18e7a:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	buffer_tail = tail;
   18e7e:	7013      	strb	r3, [r2, #0]
	return value;
   18e80:	4770      	bx	lr
	if (head == tail) return 0xFFFFFFFF;
   18e82:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   18e86:	4770      	bx	lr
   18e88:	20005d08 	.word	0x20005d08
   18e8c:	20005d09 	.word	0x20005d09
   18e90:	20005d0c 	.word	0x20005d0c

00018e94 <FreqMeasureClass::countToFrequency(unsigned long)>:

float FreqMeasureClass::countToFrequency(uint32_t count)
{
   18e94:	b508      	push	{r3, lr}
#if defined(__AVR__)
	return (float)F_CPU / (float)count;
#elif defined(__arm__) && defined(TEENSYDUINO) && defined(KINETISK)
	return (float)F_BUS / (float)count;
   18e96:	f004 f90b 	bl	1d0b0 <__aeabi_ui2f>
   18e9a:	4601      	mov	r1, r0
   18e9c:	4801      	ldr	r0, [pc, #4]	; (18ea4 <FreqMeasureClass::countToFrequency(unsigned long)+0x10>)
   18e9e:	f004 fa13 	bl	1d2c8 <__aeabi_fdiv>
#elif defined(__arm__) && defined(TEENSYDUINO) && defined(KINETISL)
	return (float)(F_PLL/2) / (float)count;
#endif
}
   18ea2:	bd08      	pop	{r3, pc}
   18ea4:	4c64e1c0 	.word	0x4c64e1c0

00018ea8 <FreqMeasureClass::end()>:
	FTM1_SC = FTM_SC_VALUE | FTM_SC_TOF;
	#endif
}
static inline void capture_shutdown(void)
{
	FTM1_C0SC = 0;
   18ea8:	4a06      	ldr	r2, [pc, #24]	; (18ec4 <FreqMeasureClass::end()+0x1c>)
   18eaa:	2300      	movs	r3, #0
   18eac:	60d3      	str	r3, [r2, #12]
	*portConfigRegister(CAPTURE_USE_FTM1_CH0) = 0;
   18eae:	4a06      	ldr	r2, [pc, #24]	; (18ec8 <FreqMeasureClass::end()+0x20>)
   18eb0:	69d2      	ldr	r2, [r2, #28]
   18eb2:	6013      	str	r3, [r2, #0]
	NVIC_DISABLE_IRQ(IRQ_FTM1);
   18eb4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
   18eb8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   18ebc:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184

void FreqMeasureClass::end(void)
{
	capture_shutdown();
}
   18ec0:	4770      	bx	lr
   18ec2:	bf00      	nop
   18ec4:	40039000 	.word	0x40039000
   18ec8:	00027b0c 	.word	0x00027b0c

00018ecc <ftm1_isr>:
	return (FTM1_SC & FTM_SC_TOF) ? 1 : 0;
   18ecc:	4918      	ldr	r1, [pc, #96]	; (18f30 <ftm1_isr+0x64>)
   18ece:	680b      	ldr	r3, [r1, #0]
   18ed0:	f013 0380 	ands.w	r3, r3, #128	; 0x80

void FTM_ISR_NAME (void)
{
   18ed4:	b510      	push	{r4, lr}
   18ed6:	d006      	beq.n	18ee6 <ftm1_isr+0x1a>
	uint32_t capture, period, i;
	bool inc = false;

	if (capture_overflow()) {
		capture_overflow_reset();
		capture_msw++;
   18ed8:	4a16      	ldr	r2, [pc, #88]	; (18f34 <ftm1_isr+0x68>)
	FTM1_SC = FTM_SC_VALUE;
   18eda:	2348      	movs	r3, #72	; 0x48
   18edc:	600b      	str	r3, [r1, #0]
   18ede:	8813      	ldrh	r3, [r2, #0]
   18ee0:	3301      	adds	r3, #1
   18ee2:	8013      	strh	r3, [r2, #0]
		inc = true;
   18ee4:	2301      	movs	r3, #1
	return (FTM1_C0SC & 0x80) ? 1 : 0;
   18ee6:	68ca      	ldr	r2, [r1, #12]
   18ee8:	0612      	lsls	r2, r2, #24
   18eea:	d51d      	bpl.n	18f28 <ftm1_isr+0x5c>
	uint32_t val = FTM1_C0V;
   18eec:	690a      	ldr	r2, [r1, #16]
	FTM1_C0SC = 0b01000100;
   18eee:	2044      	movs	r0, #68	; 0x44
   18ef0:	60c8      	str	r0, [r1, #12]

		capture = capture_read();
		if (capture <= 0xE000 || !inc) {
			capture |= (capture_msw << 16);
		} else {
			capture |= ((capture_msw - 1) << 16);
   18ef2:	4910      	ldr	r1, [pc, #64]	; (18f34 <ftm1_isr+0x68>)
		if (capture <= 0xE000 || !inc) {
   18ef4:	f5b2 4f60 	cmp.w	r2, #57344	; 0xe000
			capture |= ((capture_msw - 1) << 16);
   18ef8:	8809      	ldrh	r1, [r1, #0]
		if (capture <= 0xE000 || !inc) {
   18efa:	d900      	bls.n	18efe <ftm1_isr+0x32>
   18efc:	b9ab      	cbnz	r3, 18f2a <ftm1_isr+0x5e>
		}
		// compute the waveform period
		period = capture - capture_previous;
   18efe:	4b0e      	ldr	r3, [pc, #56]	; (18f38 <ftm1_isr+0x6c>)
		capture_previous = capture;
		// store it into the buffer
		i = buffer_head + 1;
		if (i >= FREQMEASURE_BUFFER_LEN) i = 0;
		if (i != buffer_tail) {
   18f00:	4c0e      	ldr	r4, [pc, #56]	; (18f3c <ftm1_isr+0x70>)
		period = capture - capture_previous;
   18f02:	6818      	ldr	r0, [r3, #0]
			capture |= ((capture_msw - 1) << 16);
   18f04:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
		i = buffer_head + 1;
   18f08:	490d      	ldr	r1, [pc, #52]	; (18f40 <ftm1_isr+0x74>)
		capture_previous = capture;
   18f0a:	601a      	str	r2, [r3, #0]
		i = buffer_head + 1;
   18f0c:	780b      	ldrb	r3, [r1, #0]
		if (i != buffer_tail) {
   18f0e:	7824      	ldrb	r4, [r4, #0]
		i = buffer_head + 1;
   18f10:	3301      	adds	r3, #1
		if (i >= FREQMEASURE_BUFFER_LEN) i = 0;
   18f12:	2b0c      	cmp	r3, #12
   18f14:	bfa8      	it	ge
   18f16:	2300      	movge	r3, #0
		if (i != buffer_tail) {
   18f18:	429c      	cmp	r4, r3
   18f1a:	d005      	beq.n	18f28 <ftm1_isr+0x5c>
		period = capture - capture_previous;
   18f1c:	1a12      	subs	r2, r2, r0
			buffer_value[i] = period;
   18f1e:	4809      	ldr	r0, [pc, #36]	; (18f44 <ftm1_isr+0x78>)
   18f20:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
			buffer_head = i;
   18f24:	b2db      	uxtb	r3, r3
   18f26:	700b      	strb	r3, [r1, #0]
		}
	}
}
   18f28:	bd10      	pop	{r4, pc}
			capture |= ((capture_msw - 1) << 16);
   18f2a:	3901      	subs	r1, #1
   18f2c:	e7e7      	b.n	18efe <ftm1_isr+0x32>
   18f2e:	bf00      	nop
   18f30:	40039000 	.word	0x40039000
   18f34:	20005d0a 	.word	0x20005d0a
   18f38:	20005d3c 	.word	0x20005d3c
   18f3c:	20005d09 	.word	0x20005d09
   18f40:	20005d08 	.word	0x20005d08
   18f44:	20005d0c 	.word	0x20005d0c

00018f48 <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
   18f48:	b510      	push	{r4, lr}
   18f4a:	4604      	mov	r4, r0
		release();
   18f4c:	f000 feee 	bl	19d2c <DMAChannel::release()>
	}
   18f50:	4620      	mov	r0, r4
   18f52:	bd10      	pop	{r4, pc}

00018f54 <SH1106_128x64_Driver::Flush()>:
				CORE_PIN8_PORTSET = CORE_PIN8_BITMASK;
   18f54:	4b09      	ldr	r3, [pc, #36]	; (18f7c <SH1106_128x64_Driver::Flush()+0x28>)
   18f56:	2208      	movs	r2, #8
   18f58:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
   18f5c:	4a08      	ldr	r2, [pc, #32]	; (18f80 <SH1106_128x64_Driver::Flush()+0x2c>)
   18f5e:	f5a3 2377 	sub.w	r3, r3, #1011712	; 0xf7000
   18f62:	7911      	ldrb	r1, [r2, #4]
   18f64:	7719      	strb	r1, [r3, #28]
		DMA_CERQ = channel;
   18f66:	7912      	ldrb	r2, [r2, #4]
   18f68:	769a      	strb	r2, [r3, #26]
  // Assume DMA transfer has completed, else we're doomed
  digitalWriteFast(OLED_CS, OLED_CS_INACTIVE); // U8G_ESC_CS(0)
  page_dma.clearComplete();
  page_dma.disable();
  // DmaSpi.h::post_finishCurrentTransfer_impl
  SPI0_RSER = 0;
   18f6a:	f503 3310 	add.w	r3, r3, #147456	; 0x24000
   18f6e:	2200      	movs	r2, #0
   18f70:	631a      	str	r2, [r3, #48]	; 0x30
  SPI0_SR = 0xFF0F0000;
   18f72:	f5a2 0271 	sub.w	r2, r2, #15794176	; 0xf10000
   18f76:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
}
   18f78:	4770      	bx	lr
   18f7a:	bf00      	nop
   18f7c:	400ff000 	.word	0x400ff000
   18f80:	20005dc0 	.word	0x20005dc0

00018f84 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)>:
  // adapted from https://github.com/xxxajk/spi4teensy3
  int i;
  int nf;
  uint8_t *buf = (uint8_t *)bufr;

  if (n & 1) {
   18f84:	f011 0f01 	tst.w	r1, #1
void SH1106_128x64_Driver::SPI_send(void *bufr, size_t n) {
   18f88:	b570      	push	{r4, r5, r6, lr}
   18f8a:	4c23      	ldr	r4, [pc, #140]	; (19018 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x94>)
  if (n & 1) {
   18f8c:	d00c      	beq.n	18fa8 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x24>
    uint8_t b = *buf++;
   18f8e:	f810 2b01 	ldrb.w	r2, [r0], #1
    // clear any data in RX/TX FIFOs, and be certain we are in master mode.
    SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_CLR_TXF | SPI_MCR_PCSIS(0x1F);
   18f92:	4b22      	ldr	r3, [pc, #136]	; (1901c <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x98>)
    SPI0_SR = SPI_SR_TCF;
   18f94:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
    SPI0_PUSHR = SPI_PUSHR_CONT | b;
   18f98:	432a      	orrs	r2, r5
    SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_CLR_TXF | SPI_MCR_PCSIS(0x1F);
   18f9a:	601c      	str	r4, [r3, #0]
    SPI0_SR = SPI_SR_TCF;
   18f9c:	62dd      	str	r5, [r3, #44]	; 0x2c
    SPI0_PUSHR = SPI_PUSHR_CONT | b;
   18f9e:	635a      	str	r2, [r3, #52]	; 0x34
    while (!(SPI0_SR & SPI_SR_TCF));
   18fa0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   18fa2:	2a00      	cmp	r2, #0
   18fa4:	dafc      	bge.n	18fa0 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x1c>
    n--;
   18fa6:	3901      	subs	r1, #1
  }
  // clear any data in RX/TX FIFOs, and be certain we are in master mode.
  SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_CLR_TXF | SPI_MCR_PCSIS(0x1F);
  // initial number of words to push into TX FIFO
  nf = n / 2 < 3 ? n / 2 : 3;
   18fa8:	2905      	cmp	r1, #5
  SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_CLR_TXF | SPI_MCR_PCSIS(0x1F);
   18faa:	4b1c      	ldr	r3, [pc, #112]	; (1901c <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x98>)
  // limit for pushing data into TX FIFO
  uint8_t* limit = buf + n;
  for (i = 0; i < nf; i++) {
    uint16_t w = (*buf++) << 8;
    w |= *buf++;
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | w;
   18fac:	4e1b      	ldr	r6, [pc, #108]	; (1901c <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x98>)
  SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_CLR_TXF | SPI_MCR_PCSIS(0x1F);
   18fae:	601c      	str	r4, [r3, #0]
  nf = n / 2 < 3 ? n / 2 : 3;
   18fb0:	bf94      	ite	ls
   18fb2:	084a      	lsrls	r2, r1, #1
   18fb4:	2203      	movhi	r2, #3
  uint8_t* limit = buf + n;
   18fb6:	4401      	add	r1, r0
  for (i = 0; i < nf; i++) {
   18fb8:	eb00 0442 	add.w	r4, r0, r2, lsl #1
   18fbc:	42a0      	cmp	r0, r4
   18fbe:	d105      	bne.n	18fcc <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x48>
  }
  // write data to TX FIFO
  while (buf < limit) {
          uint16_t w = *buf++ << 8;
          w |= *buf++;
          while (!(SPI0_SR & SPI_SR_RXCTR));
   18fc0:	4816      	ldr	r0, [pc, #88]	; (1901c <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x98>)
  while (buf < limit) {
   18fc2:	428c      	cmp	r4, r1
   18fc4:	d30f      	bcc.n	18fe6 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x62>
          SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | w;
          SPI0_POPR;
  }
  // wait for data to be sent
  while (nf) {
          while (!(SPI0_SR & SPI_SR_RXCTR));
   18fc6:	4b15      	ldr	r3, [pc, #84]	; (1901c <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x98>)
  while (nf) {
   18fc8:	b9fa      	cbnz	r2, 1900a <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x86>
          SPI0_POPR;
          nf--;
  }
}
   18fca:	bd70      	pop	{r4, r5, r6, pc}
    w |= *buf++;
   18fcc:	4605      	mov	r5, r0
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | w;
   18fce:	7840      	ldrb	r0, [r0, #1]
   18fd0:	f815 3b02 	ldrb.w	r3, [r5], #2
   18fd4:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   18fd8:	ba5b      	rev16	r3, r3
   18fda:	b29b      	uxth	r3, r3
   18fdc:	f043 4310 	orr.w	r3, r3, #2415919104	; 0x90000000
   18fe0:	6373      	str	r3, [r6, #52]	; 0x34
    w |= *buf++;
   18fe2:	4628      	mov	r0, r5
   18fe4:	e7ea      	b.n	18fbc <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x38>
          w |= *buf++;
   18fe6:	4625      	mov	r5, r4
   18fe8:	7864      	ldrb	r4, [r4, #1]
   18fea:	f815 3b02 	ldrb.w	r3, [r5], #2
   18fee:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
   18ff2:	ba5b      	rev16	r3, r3
   18ff4:	b29b      	uxth	r3, r3
          while (!(SPI0_SR & SPI_SR_RXCTR));
   18ff6:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
   18ff8:	f014 0ff0 	tst.w	r4, #240	; 0xf0
   18ffc:	d0fb      	beq.n	18ff6 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x72>
          SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | w;
   18ffe:	f043 4310 	orr.w	r3, r3, #2415919104	; 0x90000000
   19002:	6343      	str	r3, [r0, #52]	; 0x34
          SPI0_POPR;
   19004:	6b83      	ldr	r3, [r0, #56]	; 0x38
          w |= *buf++;
   19006:	462c      	mov	r4, r5
   19008:	e7db      	b.n	18fc2 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x3e>
          while (!(SPI0_SR & SPI_SR_RXCTR));
   1900a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   1900c:	f011 0ff0 	tst.w	r1, #240	; 0xf0
   19010:	d0fb      	beq.n	1900a <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x86>
          SPI0_POPR;
   19012:	6b99      	ldr	r1, [r3, #56]	; 0x38
          nf--;
   19014:	3a01      	subs	r2, #1
   19016:	e7d7      	b.n	18fc8 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)+0x44>
   19018:	801f0c00 	.word	0x801f0c00
   1901c:	4002c000 	.word	0x4002c000

00019020 <SH1106_128x64_Driver::Clear()>:
void SH1106_128x64_Driver::Clear() {
   19020:	b570      	push	{r4, r5, r6, lr}
  memset(empty_page, 0, sizeof(kPageSize));
   19022:	2204      	movs	r2, #4
   19024:	2100      	movs	r1, #0
   19026:	4814      	ldr	r0, [pc, #80]	; (19078 <SH1106_128x64_Driver::Clear()+0x58>)
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
   19028:	4c14      	ldr	r4, [pc, #80]	; (1907c <SH1106_128x64_Driver::Clear()+0x5c>)
   1902a:	f001 f8b5 	bl	1a198 <memset>
  SH1106_data_start_seq[2] = 0xb0 | 0;
   1902e:	4814      	ldr	r0, [pc, #80]	; (19080 <SH1106_128x64_Driver::Clear()+0x60>)
   19030:	2610      	movs	r6, #16
   19032:	23b0      	movs	r3, #176	; 0xb0
				CORE_PIN8_PORTCLEAR = CORE_PIN8_BITMASK;
   19034:	2508      	movs	r5, #8
   19036:	7083      	strb	r3, [r0, #2]
  SPI_send(SH1106_data_start_seq, sizeof(SH1106_data_start_seq));
   19038:	2103      	movs	r1, #3
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
   1903a:	f8c4 60c8 	str.w	r6, [r4, #200]	; 0xc8
				CORE_PIN8_PORTCLEAR = CORE_PIN8_BITMASK;
   1903e:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
   19042:	f7ff ff9f 	bl	18f84 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)>
				CORE_PIN6_PORTSET = CORE_PIN6_BITMASK;
   19046:	f8c4 60c4 	str.w	r6, [r4, #196]	; 0xc4
    SPI_send(empty_page, kPageSize);
   1904a:	4e0b      	ldr	r6, [pc, #44]	; (19078 <SH1106_128x64_Driver::Clear()+0x58>)
   1904c:	2180      	movs	r1, #128	; 0x80
   1904e:	4630      	mov	r0, r6
   19050:	f7ff ff98 	bl	18f84 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)>
  for (size_t p = 0; p < kNumPages; ++p)
   19054:	3d01      	subs	r5, #1
   19056:	d1f9      	bne.n	1904c <SH1106_128x64_Driver::Clear()+0x2c>
				CORE_PIN8_PORTSET = CORE_PIN8_BITMASK;
   19058:	2308      	movs	r3, #8
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
   1905a:	2510      	movs	r5, #16
				CORE_PIN8_PORTSET = CORE_PIN8_BITMASK;
   1905c:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
  SPI_send(SH1106_display_on_seq, sizeof(SH1106_display_on_seq));
   19060:	4808      	ldr	r0, [pc, #32]	; (19084 <SH1106_128x64_Driver::Clear()+0x64>)
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
   19062:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
   19066:	2101      	movs	r1, #1
				CORE_PIN8_PORTCLEAR = CORE_PIN8_BITMASK;
   19068:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
   1906c:	f7ff ff8a 	bl	18f84 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)>
				CORE_PIN6_PORTSET = CORE_PIN6_BITMASK;
   19070:	f8c4 50c4 	str.w	r5, [r4, #196]	; 0xc4
}
   19074:	bd70      	pop	{r4, r5, r6, pc}
   19076:	bf00      	nop
   19078:	20005d40 	.word	0x20005d40
   1907c:	400ff000 	.word	0x400ff000
   19080:	1fffa0d2 	.word	0x1fffa0d2
   19084:	1fffa0d5 	.word	0x1fffa0d5

00019088 <SH1106_128x64_Driver::Init()>:
void SH1106_128x64_Driver::Init() {
   19088:	b570      	push	{r4, r5, r6, lr}
  pinMode(OLED_CS, OUTPUT);
   1908a:	2101      	movs	r1, #1
   1908c:	2008      	movs	r0, #8
				CORE_PIN7_PORTSET = CORE_PIN7_BITMASK;
   1908e:	4c35      	ldr	r4, [pc, #212]	; (19164 <SH1106_128x64_Driver::Init()+0xdc>)
   19090:	f001 f96a 	bl	1a368 <pinMode>
  pinMode(OLED_RST, OUTPUT);
   19094:	2101      	movs	r1, #1
   19096:	2007      	movs	r0, #7
   19098:	f001 f966 	bl	1a368 <pinMode>
   1909c:	2504      	movs	r5, #4
  pinMode(OLED_DC, OUTPUT);
   1909e:	2101      	movs	r1, #1
   190a0:	2006      	movs	r0, #6
   190a2:	f001 f961 	bl	1a368 <pinMode>
  delay(1);
   190a6:	2001      	movs	r0, #1
   190a8:	f8c4 50c4 	str.w	r5, [r4, #196]	; 0xc4
   190ac:	f001 f9ec 	bl	1a488 <delay>
  delay(10);
   190b0:	200a      	movs	r0, #10
				CORE_PIN7_PORTCLEAR = CORE_PIN7_BITMASK;
   190b2:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
   190b6:	f001 f9e7 	bl	1a488 <delay>
				CORE_PIN8_PORTSET = CORE_PIN8_BITMASK;
   190ba:	2608      	movs	r6, #8
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
   190bc:	2310      	movs	r3, #16
				CORE_PIN7_PORTSET = CORE_PIN7_BITMASK;
   190be:	f8c4 50c4 	str.w	r5, [r4, #196]	; 0xc4
  delay(20);
   190c2:	2014      	movs	r0, #20
				CORE_PIN8_PORTSET = CORE_PIN8_BITMASK;
   190c4:	f8c4 60c4 	str.w	r6, [r4, #196]	; 0xc4
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
   190c8:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
				CORE_PIN7_PORTCLEAR = CORE_PIN7_BITMASK;
   190cc:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
   190d0:	f001 f9da 	bl	1a488 <delay>
  delay(20);
   190d4:	2014      	movs	r0, #20
				CORE_PIN7_PORTSET = CORE_PIN7_BITMASK;
   190d6:	f8c4 50c4 	str.w	r5, [r4, #196]	; 0xc4
   190da:	f001 f9d5 	bl	1a488 <delay>
  SPI_send(SH1106_init_seq, sizeof(SH1106_init_seq));
   190de:	4822      	ldr	r0, [pc, #136]	; (19168 <SH1106_128x64_Driver::Init()+0xe0>)
				CORE_PIN8_PORTCLEAR = CORE_PIN8_BITMASK;
   190e0:	f8c4 60c8 	str.w	r6, [r4, #200]	; 0xc8
   190e4:	2119      	movs	r1, #25
   190e6:	f7ff ff4d 	bl	18f84 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)>
				CORE_PIN8_PORTSET = CORE_PIN8_BITMASK;
   190ea:	4920      	ldr	r1, [pc, #128]	; (1916c <SH1106_128x64_Driver::Init()+0xe4>)
		TCD->DADDR = &p;
   190ec:	4a20      	ldr	r2, [pc, #128]	; (19170 <SH1106_128x64_Driver::Init()+0xe8>)
   190ee:	680b      	ldr	r3, [r1, #0]
   190f0:	f8c4 60c4 	str.w	r6, [r4, #196]	; 0xc4
			if (TCD->SOFF != 0) TCD->SOFF = 1;
   190f4:	f9b3 0004 	ldrsh.w	r0, [r3, #4]
		TCD->DADDR = &p;
   190f8:	611a      	str	r2, [r3, #16]
		TCD->DOFF = 0;
   190fa:	2200      	movs	r2, #0
   190fc:	829a      	strh	r2, [r3, #20]
		TCD->ATTR_DST = 0;
   190fe:	719a      	strb	r2, [r3, #6]
		TCD->DLASTSGA = 0;
   19100:	619a      	str	r2, [r3, #24]
			TCD->NBYTES = 1;
   19102:	2201      	movs	r2, #1
   19104:	609a      	str	r2, [r3, #8]
			if (TCD->SOFF != 0) TCD->SOFF = 1;
   19106:	b100      	cbz	r0, 1910a <SH1106_128x64_Driver::Init()+0x82>
   19108:	809a      	strh	r2, [r3, #4]
			TCD->ATTR = TCD->ATTR & 0xF8F8;
   1910a:	88da      	ldrh	r2, [r3, #6]
   1910c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
   19110:	f022 0207 	bic.w	r2, r2, #7
   19114:	80da      	strh	r2, [r3, #6]
		if (!(TCD->BITER & DMA_TCD_BITER_ELINK)) {
   19116:	8bda      	ldrh	r2, [r3, #30]
   19118:	0412      	lsls	r2, r2, #16
   1911a:	d417      	bmi.n	1914c <SH1106_128x64_Driver::Init()+0xc4>
			TCD->BITER = len;
   1911c:	2280      	movs	r2, #128	; 0x80
   1911e:	83da      	strh	r2, [r3, #30]
			TCD->CITER = (TCD->CITER & 0xFE00) | len;
   19120:	82da      	strh	r2, [r3, #22]
		TCD->CSR |= DMA_TCD_CSR_DREQ;
   19122:	8b9a      	ldrh	r2, [r3, #28]
   19124:	b292      	uxth	r2, r2
   19126:	f042 0208 	orr.w	r2, r2, #8
   1912a:	839a      	strh	r2, [r3, #28]
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
   1912c:	790b      	ldrb	r3, [r1, #4]
   1912e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   19132:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
   19136:	2200      	movs	r2, #0
   19138:	701a      	strb	r2, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
   1913a:	2291      	movs	r2, #145	; 0x91
   1913c:	701a      	strb	r2, [r3, #0]
		DMA_CERQ = channel;
   1913e:	4b0d      	ldr	r3, [pc, #52]	; (19174 <SH1106_128x64_Driver::Init()+0xec>)
   19140:	790a      	ldrb	r2, [r1, #4]
   19142:	769a      	strb	r2, [r3, #26]
}
   19144:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  Clear();
   19148:	f7ff bf6a 	b.w	19020 <SH1106_128x64_Driver::Clear()>
			TCD->BITER = (TCD->BITER & 0xFE00) | len;
   1914c:	8bda      	ldrh	r2, [r3, #30]
   1914e:	f402 427e 	and.w	r2, r2, #65024	; 0xfe00
   19152:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   19156:	83da      	strh	r2, [r3, #30]
			TCD->CITER = (TCD->CITER & 0xFE00) | len;
   19158:	8ada      	ldrh	r2, [r3, #22]
   1915a:	f402 427e 	and.w	r2, r2, #65024	; 0xfe00
   1915e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   19162:	e7dd      	b.n	19120 <SH1106_128x64_Driver::Init()+0x98>
   19164:	400ff000 	.word	0x400ff000
   19168:	1fffa0b9 	.word	0x1fffa0b9
   1916c:	20005dc0 	.word	0x20005dc0
   19170:	4002c034 	.word	0x4002c034
   19174:	40008000 	.word	0x40008000

00019178 <SH1106_128x64_Driver::SendPage(unsigned int, unsigned char const*)>:
void SH1106_128x64_Driver::SendPage(uint_fast8_t index, const uint8_t *data) {
   19178:	4603      	mov	r3, r0
  SH1106_data_start_seq[2] = 0xb0 | index;
   1917a:	4815      	ldr	r0, [pc, #84]	; (191d0 <SH1106_128x64_Driver::SendPage(unsigned int, unsigned char const*)+0x58>)
void SH1106_128x64_Driver::SendPage(uint_fast8_t index, const uint8_t *data) {
   1917c:	b570      	push	{r4, r5, r6, lr}
  SH1106_data_start_seq[2] = 0xb0 | index;
   1917e:	f063 034f 	orn	r3, r3, #79	; 0x4f
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
   19182:	4d14      	ldr	r5, [pc, #80]	; (191d4 <SH1106_128x64_Driver::SendPage(unsigned int, unsigned char const*)+0x5c>)
   19184:	7083      	strb	r3, [r0, #2]
   19186:	2610      	movs	r6, #16
				CORE_PIN8_PORTCLEAR = CORE_PIN8_BITMASK;
   19188:	2308      	movs	r3, #8
void SH1106_128x64_Driver::SendPage(uint_fast8_t index, const uint8_t *data) {
   1918a:	460c      	mov	r4, r1
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
   1918c:	f8c5 60c8 	str.w	r6, [r5, #200]	; 0xc8
  SPI_send(SH1106_data_start_seq, sizeof(SH1106_data_start_seq)); // u8g_WriteEscSeqP(u8g, dev, u8g_dev_ssd1306_128x64_data_start);
   19190:	2103      	movs	r1, #3
				CORE_PIN8_PORTCLEAR = CORE_PIN8_BITMASK;
   19192:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
   19196:	f7ff fef5 	bl	18f84 <SH1106_128x64_Driver::SPI_send(void*, unsigned int)>
  SPI0_SR = 0xFF0F0000;
   1919a:	4b0f      	ldr	r3, [pc, #60]	; (191d8 <SH1106_128x64_Driver::SendPage(unsigned int, unsigned char const*)+0x60>)
   1919c:	4a0f      	ldr	r2, [pc, #60]	; (191dc <SH1106_128x64_Driver::SendPage(unsigned int, unsigned char const*)+0x64>)
				CORE_PIN6_PORTSET = CORE_PIN6_BITMASK;
   1919e:	f8c5 60c4 	str.w	r6, [r5, #196]	; 0xc4
   191a2:	62da      	str	r2, [r3, #44]	; 0x2c
  SPI0_RSER = SPI_RSER_RFDF_RE | SPI_RSER_RFDF_DIRS | SPI_RSER_TFFF_RE | SPI_RSER_TFFF_DIRS;
   191a4:	f102 727d 	add.w	r2, r2, #66322432	; 0x3f40000
   191a8:	631a      	str	r2, [r3, #48]	; 0x30
  page_dma.sourceBuffer(data, kPageSize);
   191aa:	4a0d      	ldr	r2, [pc, #52]	; (191e0 <SH1106_128x64_Driver::SendPage(unsigned int, unsigned char const*)+0x68>)
   191ac:	6813      	ldr	r3, [r2, #0]
		TCD->SOFF = 1;
   191ae:	2101      	movs	r1, #1
   191b0:	8099      	strh	r1, [r3, #4]
		TCD->NBYTES = 1;
   191b2:	6099      	str	r1, [r3, #8]
		TCD->SLAST = -len;
   191b4:	f06f 017f 	mvn.w	r1, #127	; 0x7f
   191b8:	60d9      	str	r1, [r3, #12]
		TCD->ATTR_SRC = 0;
   191ba:	2000      	movs	r0, #0
		TCD->BITER = len;
   191bc:	2180      	movs	r1, #128	; 0x80
		TCD->SADDR = p;
   191be:	601c      	str	r4, [r3, #0]
		TCD->ATTR_SRC = 0;
   191c0:	71d8      	strb	r0, [r3, #7]
		TCD->BITER = len;
   191c2:	83d9      	strh	r1, [r3, #30]
		TCD->CITER = len;
   191c4:	82d9      	strh	r1, [r3, #22]
		DMA_SERQ = channel;
   191c6:	4b07      	ldr	r3, [pc, #28]	; (191e4 <SH1106_128x64_Driver::SendPage(unsigned int, unsigned char const*)+0x6c>)
   191c8:	7912      	ldrb	r2, [r2, #4]
   191ca:	76da      	strb	r2, [r3, #27]
}
   191cc:	bd70      	pop	{r4, r5, r6, pc}
   191ce:	bf00      	nop
   191d0:	1fffa0d2 	.word	0x1fffa0d2
   191d4:	400ff000 	.word	0x400ff000
   191d8:	4002c000 	.word	0x4002c000
   191dc:	ff0f0000 	.word	0xff0f0000
   191e0:	20005dc0 	.word	0x20005dc0
   191e4:	40008000 	.word	0x40008000

000191e8 <SH1106_128x64_Driver::AdjustOffset(unsigned char)>:

/*static*/
void SH1106_128x64_Driver::AdjustOffset(uint8_t offset) {
  SH1106_data_start_seq[1] = offset; // lower 4 bits of col adr
   191e8:	4b01      	ldr	r3, [pc, #4]	; (191f0 <SH1106_128x64_Driver::AdjustOffset(unsigned char)+0x8>)
   191ea:	7058      	strb	r0, [r3, #1]
}
   191ec:	4770      	bx	lr
   191ee:	bf00      	nop
   191f0:	1fffa0d2 	.word	0x1fffa0d2

000191f4 <_GLOBAL__sub_I__ZN20SH1106_128x64_Driver4InitEv>:
   191f4:	b510      	push	{r4, lr}
		begin();
   191f6:	4c06      	ldr	r4, [pc, #24]	; (19210 <_GLOBAL__sub_I__ZN20SH1106_128x64_Driver4InitEv+0x1c>)
   191f8:	2100      	movs	r1, #0
   191fa:	4620      	mov	r0, r4
   191fc:	f000 fd46 	bl	19c8c <DMAChannel::begin(bool)>
static DMAChannel page_dma;
   19200:	4620      	mov	r0, r4
   19202:	4a04      	ldr	r2, [pc, #16]	; (19214 <_GLOBAL__sub_I__ZN20SH1106_128x64_Driver4InitEv+0x20>)
   19204:	4904      	ldr	r1, [pc, #16]	; (19218 <_GLOBAL__sub_I__ZN20SH1106_128x64_Driver4InitEv+0x24>)
}
   19206:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static DMAChannel page_dma;
   1920a:	f003 ba57 	b.w	1c6bc <__aeabi_atexit>
   1920e:	bf00      	nop
   19210:	20005dc0 	.word	0x20005dc0
   19214:	1fff9320 	.word	0x1fff9320
   19218:	00018f49 	.word	0x00018f49

0001921c <display::Init()>:
    memset(frame_memory_, 0, sizeof(frame_memory_));
   1921c:	4b0e      	ldr	r3, [pc, #56]	; (19258 <display::Init()+0x3c>)
namespace display {

FrameBuffer<SH1106_128x64_Driver::kFrameSize, 2> frame_buffer;
PagedDisplayDriver<SH1106_128x64_Driver> driver;

void Init() {
   1921e:	b510      	push	{r4, lr}
   19220:	4618      	mov	r0, r3
   19222:	f44f 6200 	mov.w	r2, #2048	; 0x800
   19226:	2100      	movs	r1, #0
   19228:	f000 ffb6 	bl	1a198 <memset>
      frame_buffers_[f] = frame_memory_ + kFrameSize * f;
   1922c:	f500 6280 	add.w	r2, r0, #1024	; 0x400
    write_ptr_ = read_ptr_ = 0;
   19230:	2400      	movs	r4, #0
      frame_buffers_[f] = frame_memory_ + kFrameSize * f;
   19232:	f8c0 0800 	str.w	r0, [r0, #2048]	; 0x800
   19236:	f8c0 2804 	str.w	r2, [r0, #2052]	; 0x804
    write_ptr_ = read_ptr_ = 0;
   1923a:	f8c0 480c 	str.w	r4, [r0, #2060]	; 0x80c
   1923e:	f8c0 4808 	str.w	r4, [r0, #2056]	; 0x808

  PagedDisplayDriver() { }

  void Init() {

    display_driver::Init();
   19242:	f7ff ff21 	bl	19088 <SH1106_128x64_Driver::Init()>

    current_page_index_ = 0;
   19246:	4b05      	ldr	r3, [pc, #20]	; (1925c <display::Init()+0x40>)
  frame_buffer.Init();
  driver.Init();
  graphics.Init();
   19248:	4805      	ldr	r0, [pc, #20]	; (19260 <display::Init()+0x44>)
   1924a:	601c      	str	r4, [r3, #0]
    current_page_data_ = NULL;
   1924c:	605c      	str	r4, [r3, #4]
}
   1924e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  graphics.Init();
   19252:	f000 b809 	b.w	19268 <weegfx::Graphics::Init()>
   19256:	bf00      	nop
   19258:	20005dc8 	.word	0x20005dc8
   1925c:	200065d8 	.word	0x200065d8
   19260:	200065e0 	.word	0x200065e0

00019264 <display::AdjustOffset(unsigned char)>:

void AdjustOffset(uint8_t offset) {
	SH1106_128x64_Driver::AdjustOffset(offset);
   19264:	f7ff bfc0 	b.w	191e8 <SH1106_128x64_Driver::AdjustOffset(unsigned char)>

00019268 <weegfx::Graphics::Init()>:

template <weegfx::DRAW_MODE draw_mode>
inline void draw_rect(uint8_t *buf, weegfx::coord_t y, weegfx::coord_t w, weegfx::coord_t h) __attribute__((always_inline)); 

void Graphics::Init() {
  frame_ = NULL;
   19268:	2300      	movs	r3, #0
   1926a:	6003      	str	r3, [r0, #0]
  text_x_ = x;
   1926c:	6043      	str	r3, [r0, #4]
  text_y_ = y;
   1926e:	6083      	str	r3, [r0, #8]
  setPrintPos(0, 0);
}
   19270:	4770      	bx	lr

00019272 <weegfx::Graphics::Begin(unsigned char*, bool)>:

void Graphics::Begin(uint8_t *frame, bool clear_frame) {
   19272:	b510      	push	{r4, lr}
   19274:	4604      	mov	r4, r0
   19276:	4608      	mov	r0, r1

  frame_ = frame;
   19278:	6021      	str	r1, [r4, #0]
  if (clear_frame)
   1927a:	b122      	cbz	r2, 19286 <weegfx::Graphics::Begin(unsigned char*, bool)+0x14>
    memset(frame_, 0, kFrameSize);
   1927c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   19280:	2100      	movs	r1, #0
   19282:	f000 ff89 	bl	1a198 <memset>
  text_x_ = x;
   19286:	2300      	movs	r3, #0
   19288:	6063      	str	r3, [r4, #4]
  text_y_ = y;
   1928a:	60a3      	str	r3, [r4, #8]

  setPrintPos(0, 0);
}
   1928c:	bd10      	pop	{r4, pc}

0001928e <weegfx::Graphics::End()>:

void Graphics::End() {
  frame_ = NULL;
   1928e:	2300      	movs	r3, #0
   19290:	6003      	str	r3, [r0, #0]
}
   19292:	4770      	bx	lr

00019294 <weegfx::Graphics::drawRect(int, int, int, int)>:
  if (remainder) {
    draw_pixel_row<draw_mode>(buf, w, ~(0xff << remainder));
  }
}

void Graphics::drawRect(coord_t x, coord_t y, coord_t w, coord_t h) {
   19294:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19298:	461f      	mov	r7, r3
  CLIPX(x, w);
   1929a:	18cb      	adds	r3, r1, r3
   1929c:	2b80      	cmp	r3, #128	; 0x80
   1929e:	bfc8      	it	gt
   192a0:	f1c1 0780 	rsbgt	r7, r1, #128	; 0x80
   192a4:	2900      	cmp	r1, #0
   192a6:	bfbc      	itt	lt
   192a8:	187f      	addlt	r7, r7, r1
   192aa:	2100      	movlt	r1, #0
   192ac:	2f00      	cmp	r7, #0
void Graphics::drawRect(coord_t x, coord_t y, coord_t w, coord_t h) {
   192ae:	9d06      	ldr	r5, [sp, #24]
   192b0:	4614      	mov	r4, r2
  CLIPX(x, w);
   192b2:	dd49      	ble.n	19348 <weegfx::Graphics::drawRect(int, int, int, int)+0xb4>
  CLIPY(y, h);
   192b4:	1953      	adds	r3, r2, r5
   192b6:	2b40      	cmp	r3, #64	; 0x40
   192b8:	bfc8      	it	gt
   192ba:	f1c2 0540 	rsbgt	r5, r2, #64	; 0x40
   192be:	2a00      	cmp	r2, #0
   192c0:	bfbc      	itt	lt
   192c2:	18ad      	addlt	r5, r5, r2
   192c4:	2400      	movlt	r4, #0
   192c6:	2d00      	cmp	r5, #0
   192c8:	dd3e      	ble.n	19348 <weegfx::Graphics::drawRect(int, int, int, int)+0xb4>
  return frame_ + ((y >>3) << 7) + x;
   192ca:	10e3      	asrs	r3, r4, #3
   192cc:	6806      	ldr	r6, [r0, #0]
   192ce:	eb01 11c3 	add.w	r1, r1, r3, lsl #7
  if (remainder) {
   192d2:	f014 0407 	ands.w	r4, r4, #7
   192d6:	440e      	add	r6, r1
   192d8:	d014      	beq.n	19304 <weegfx::Graphics::drawRect(int, int, int, int)+0x70>
    remainder = 8 - remainder;
   192da:	f1c4 0408 	rsb	r4, r4, #8
    uint8_t mask = ~(0xff >> remainder);
   192de:	22ff      	movs	r2, #255	; 0xff
    if (h < remainder) {
   192e0:	42a5      	cmp	r5, r4
    uint8_t mask = ~(0xff >> remainder);
   192e2:	fa42 f304 	asr.w	r3, r2, r4
   192e6:	ea6f 0303 	mvn.w	r3, r3
      mask &= (0xff >> (remainder - h));
   192ea:	bfbc      	itt	lt
   192ec:	1b64      	sublt	r4, r4, r5
   192ee:	4122      	asrlt	r2, r4
    uint8_t mask = ~(0xff >> remainder);
   192f0:	b2db      	uxtb	r3, r3
      mask &= (0xff >> (remainder - h));
   192f2:	bfba      	itte	lt
   192f4:	4013      	andlt	r3, r2
      h = 0;
   192f6:	2500      	movlt	r5, #0
      h -= remainder;
   192f8:	1b2d      	subge	r5, r5, r4
inline void draw_pixel_row(uint8_t *dst, weegfx::coord_t count, uint8_t mask) {
   192fa:	19f0      	adds	r0, r6, r7
  while (count-- > 0x0) {
   192fc:	4632      	mov	r2, r6
   192fe:	4282      	cmp	r2, r0
   19300:	d10f      	bne.n	19322 <weegfx::Graphics::drawRect(int, int, int, int)+0x8e>
    buf += Graphics::kWidth;
   19302:	3680      	adds	r6, #128	; 0x80
  remainder = h & 0x7;
   19304:	f005 0807 	and.w	r8, r5, #7
  h >>= 3;
   19308:	10ed      	asrs	r5, r5, #3
   1930a:	462c      	mov	r4, r5
  while (h--) {
   1930c:	4633      	mov	r3, r6
   1930e:	3c01      	subs	r4, #1
   19310:	d30d      	bcc.n	1932e <weegfx::Graphics::drawRect(int, int, int, int)+0x9a>
      case weegfx::DRAW_NORMAL: *dst++ |= mask; break;
   19312:	4618      	mov	r0, r3
   19314:	463a      	mov	r2, r7
   19316:	21ff      	movs	r1, #255	; 0xff
   19318:	f000 ff3e 	bl	1a198 <memset>
   1931c:	4603      	mov	r3, r0
    buf += Graphics::kWidth;
   1931e:	3380      	adds	r3, #128	; 0x80
   19320:	e7f5      	b.n	1930e <weegfx::Graphics::drawRect(int, int, int, int)+0x7a>
      case weegfx::DRAW_NORMAL: *dst++ |= mask; break;
   19322:	f812 1b01 	ldrb.w	r1, [r2], #1
   19326:	4319      	orrs	r1, r3
   19328:	f802 1c01 	strb.w	r1, [r2, #-1]
   1932c:	e7e7      	b.n	192fe <weegfx::Graphics::drawRect(int, int, int, int)+0x6a>
   1932e:	eb06 16c5 	add.w	r6, r6, r5, lsl #7
  if (remainder) {
   19332:	f1b8 0f00 	cmp.w	r8, #0
   19336:	d007      	beq.n	19348 <weegfx::Graphics::drawRect(int, int, int, int)+0xb4>
    draw_pixel_row<draw_mode>(buf, w, ~(0xff << remainder));
   19338:	23ff      	movs	r3, #255	; 0xff
   1933a:	fa03 f308 	lsl.w	r3, r3, r8
   1933e:	43db      	mvns	r3, r3
   19340:	b2db      	uxtb	r3, r3
inline void draw_pixel_row(uint8_t *dst, weegfx::coord_t count, uint8_t mask) {
   19342:	4437      	add	r7, r6
  while (count-- > 0x0) {
   19344:	42b7      	cmp	r7, r6
   19346:	d101      	bne.n	1934c <weegfx::Graphics::drawRect(int, int, int, int)+0xb8>
  draw_rect<DRAW_NORMAL>(get_frame_ptr(x, y), y, w, h);
}
   19348:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      case weegfx::DRAW_NORMAL: *dst++ |= mask; break;
   1934c:	f816 2b01 	ldrb.w	r2, [r6], #1
   19350:	431a      	orrs	r2, r3
   19352:	f806 2c01 	strb.w	r2, [r6, #-1]
   19356:	e7f5      	b.n	19344 <weegfx::Graphics::drawRect(int, int, int, int)+0xb0>

00019358 <weegfx::Graphics::clearRect(int, int, int, int)>:

void Graphics::clearRect(coord_t x, coord_t y, coord_t w, coord_t h) {
   19358:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1935c:	461f      	mov	r7, r3
  CLIPX(x, w);
   1935e:	18cb      	adds	r3, r1, r3
   19360:	2b80      	cmp	r3, #128	; 0x80
   19362:	bfc8      	it	gt
   19364:	f1c1 0780 	rsbgt	r7, r1, #128	; 0x80
   19368:	2900      	cmp	r1, #0
   1936a:	bfbc      	itt	lt
   1936c:	187f      	addlt	r7, r7, r1
   1936e:	2100      	movlt	r1, #0
   19370:	2f00      	cmp	r7, #0
void Graphics::clearRect(coord_t x, coord_t y, coord_t w, coord_t h) {
   19372:	9d06      	ldr	r5, [sp, #24]
   19374:	4614      	mov	r4, r2
  CLIPX(x, w);
   19376:	dd4a      	ble.n	1940e <weegfx::Graphics::clearRect(int, int, int, int)+0xb6>
  CLIPY(y, h);
   19378:	1953      	adds	r3, r2, r5
   1937a:	2b40      	cmp	r3, #64	; 0x40
   1937c:	bfc8      	it	gt
   1937e:	f1c2 0540 	rsbgt	r5, r2, #64	; 0x40
   19382:	2a00      	cmp	r2, #0
   19384:	bfbc      	itt	lt
   19386:	18ad      	addlt	r5, r5, r2
   19388:	2400      	movlt	r4, #0
   1938a:	2d00      	cmp	r5, #0
   1938c:	dd3f      	ble.n	1940e <weegfx::Graphics::clearRect(int, int, int, int)+0xb6>
   1938e:	10e3      	asrs	r3, r4, #3
   19390:	6806      	ldr	r6, [r0, #0]
   19392:	eb01 11c3 	add.w	r1, r1, r3, lsl #7
  if (remainder) {
   19396:	f014 0407 	ands.w	r4, r4, #7
   1939a:	440e      	add	r6, r1
   1939c:	d015      	beq.n	193ca <weegfx::Graphics::clearRect(int, int, int, int)+0x72>
    remainder = 8 - remainder;
   1939e:	f1c4 0408 	rsb	r4, r4, #8
    uint8_t mask = ~(0xff >> remainder);
   193a2:	22ff      	movs	r2, #255	; 0xff
    if (h < remainder) {
   193a4:	42a5      	cmp	r5, r4
    uint8_t mask = ~(0xff >> remainder);
   193a6:	fa42 f304 	asr.w	r3, r2, r4
   193aa:	ea6f 0303 	mvn.w	r3, r3
      mask &= (0xff >> (remainder - h));
   193ae:	bfb8      	it	lt
   193b0:	1b64      	sublt	r4, r4, r5
    uint8_t mask = ~(0xff >> remainder);
   193b2:	b2db      	uxtb	r3, r3
      mask &= (0xff >> (remainder - h));
   193b4:	bfbd      	ittte	lt
   193b6:	4122      	asrlt	r2, r4
   193b8:	4013      	andlt	r3, r2
      h = 0;
   193ba:	2500      	movlt	r5, #0
      h -= remainder;
   193bc:	1b2d      	subge	r5, r5, r4
inline void draw_pixel_row(uint8_t *dst, weegfx::coord_t count, uint8_t mask) {
   193be:	19f0      	adds	r0, r6, r7
  while (count-- > 0x0) {
   193c0:	4632      	mov	r2, r6
      case weegfx::DRAW_CLEAR: *dst++ &= ~mask; break;
   193c2:	43db      	mvns	r3, r3
  while (count-- > 0x0) {
   193c4:	4282      	cmp	r2, r0
   193c6:	d10f      	bne.n	193e8 <weegfx::Graphics::clearRect(int, int, int, int)+0x90>
    buf += Graphics::kWidth;
   193c8:	3680      	adds	r6, #128	; 0x80
  remainder = h & 0x7;
   193ca:	f005 0807 	and.w	r8, r5, #7
  h >>= 3;
   193ce:	10ed      	asrs	r5, r5, #3
   193d0:	462c      	mov	r4, r5
  while (h--) {
   193d2:	4633      	mov	r3, r6
   193d4:	3c01      	subs	r4, #1
   193d6:	d30d      	bcc.n	193f4 <weegfx::Graphics::clearRect(int, int, int, int)+0x9c>
      case weegfx::DRAW_CLEAR: *dst++ &= ~mask; break;
   193d8:	4618      	mov	r0, r3
   193da:	463a      	mov	r2, r7
   193dc:	2100      	movs	r1, #0
   193de:	f000 fedb 	bl	1a198 <memset>
   193e2:	4603      	mov	r3, r0
    buf += Graphics::kWidth;
   193e4:	3380      	adds	r3, #128	; 0x80
   193e6:	e7f5      	b.n	193d4 <weegfx::Graphics::clearRect(int, int, int, int)+0x7c>
      case weegfx::DRAW_CLEAR: *dst++ &= ~mask; break;
   193e8:	f812 1b01 	ldrb.w	r1, [r2], #1
   193ec:	4019      	ands	r1, r3
   193ee:	f802 1c01 	strb.w	r1, [r2, #-1]
   193f2:	e7e7      	b.n	193c4 <weegfx::Graphics::clearRect(int, int, int, int)+0x6c>
   193f4:	eb06 16c5 	add.w	r6, r6, r5, lsl #7
  if (remainder) {
   193f8:	f1b8 0f00 	cmp.w	r8, #0
   193fc:	d007      	beq.n	1940e <weegfx::Graphics::clearRect(int, int, int, int)+0xb6>
    draw_pixel_row<draw_mode>(buf, w, ~(0xff << remainder));
   193fe:	23ff      	movs	r3, #255	; 0xff
   19400:	fa03 f308 	lsl.w	r3, r3, r8
inline void draw_pixel_row(uint8_t *dst, weegfx::coord_t count, uint8_t mask) {
   19404:	4437      	add	r7, r6
      case weegfx::DRAW_CLEAR: *dst++ &= ~mask; break;
   19406:	f063 03ff 	orn	r3, r3, #255	; 0xff
  while (count-- > 0x0) {
   1940a:	42b7      	cmp	r7, r6
   1940c:	d101      	bne.n	19412 <weegfx::Graphics::clearRect(int, int, int, int)+0xba>
  draw_rect<DRAW_CLEAR>(get_frame_ptr(x, y), y, w, h);
}
   1940e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      case weegfx::DRAW_CLEAR: *dst++ &= ~mask; break;
   19412:	f816 2b01 	ldrb.w	r2, [r6], #1
   19416:	401a      	ands	r2, r3
   19418:	f806 2c01 	strb.w	r2, [r6, #-1]
   1941c:	e7f5      	b.n	1940a <weegfx::Graphics::clearRect(int, int, int, int)+0xb2>

0001941e <weegfx::Graphics::invertRect(int, int, int, int)>:

void Graphics::invertRect(coord_t x, coord_t y, coord_t w, coord_t h) {
   1941e:	b5f0      	push	{r4, r5, r6, r7, lr}
  CLIPX(x, w);
   19420:	18cd      	adds	r5, r1, r3
   19422:	2d80      	cmp	r5, #128	; 0x80
   19424:	bfc8      	it	gt
   19426:	f1c1 0380 	rsbgt	r3, r1, #128	; 0x80
   1942a:	2900      	cmp	r1, #0
   1942c:	bfbc      	itt	lt
   1942e:	185b      	addlt	r3, r3, r1
   19430:	2100      	movlt	r1, #0
   19432:	2b00      	cmp	r3, #0
void Graphics::invertRect(coord_t x, coord_t y, coord_t w, coord_t h) {
   19434:	9c05      	ldr	r4, [sp, #20]
  CLIPX(x, w);
   19436:	dd4a      	ble.n	194ce <weegfx::Graphics::invertRect(int, int, int, int)+0xb0>
  CLIPY(y, h);
   19438:	1915      	adds	r5, r2, r4
   1943a:	2d40      	cmp	r5, #64	; 0x40
   1943c:	bfc8      	it	gt
   1943e:	f1c2 0440 	rsbgt	r4, r2, #64	; 0x40
   19442:	2a00      	cmp	r2, #0
   19444:	bfbc      	itt	lt
   19446:	18a4      	addlt	r4, r4, r2
   19448:	2200      	movlt	r2, #0
   1944a:	2c00      	cmp	r4, #0
   1944c:	dd3f      	ble.n	194ce <weegfx::Graphics::invertRect(int, int, int, int)+0xb0>
   1944e:	10d5      	asrs	r5, r2, #3
   19450:	6800      	ldr	r0, [r0, #0]
   19452:	eb01 11c5 	add.w	r1, r1, r5, lsl #7
  if (remainder) {
   19456:	f012 0207 	ands.w	r2, r2, #7
   1945a:	4401      	add	r1, r0
   1945c:	d014      	beq.n	19488 <weegfx::Graphics::invertRect(int, int, int, int)+0x6a>
    remainder = 8 - remainder;
   1945e:	f1c2 0208 	rsb	r2, r2, #8
    uint8_t mask = ~(0xff >> remainder);
   19462:	25ff      	movs	r5, #255	; 0xff
    if (h < remainder) {
   19464:	4294      	cmp	r4, r2
    uint8_t mask = ~(0xff >> remainder);
   19466:	fa45 f002 	asr.w	r0, r5, r2
   1946a:	ea6f 0000 	mvn.w	r0, r0
      mask &= (0xff >> (remainder - h));
   1946e:	bfbc      	itt	lt
   19470:	1b12      	sublt	r2, r2, r4
   19472:	4115      	asrlt	r5, r2
    uint8_t mask = ~(0xff >> remainder);
   19474:	b2c0      	uxtb	r0, r0
      h -= remainder;
   19476:	bfae      	itee	ge
   19478:	1aa4      	subge	r4, r4, r2
      mask &= (0xff >> (remainder - h));
   1947a:	4028      	andlt	r0, r5
      h = 0;
   1947c:	2400      	movlt	r4, #0
inline void draw_pixel_row(uint8_t *dst, weegfx::coord_t count, uint8_t mask) {
   1947e:	18ce      	adds	r6, r1, r3
  while (count-- > 0x0) {
   19480:	460a      	mov	r2, r1
   19482:	42b2      	cmp	r2, r6
   19484:	d10b      	bne.n	1949e <weegfx::Graphics::invertRect(int, int, int, int)+0x80>
    buf += Graphics::kWidth;
   19486:	3180      	adds	r1, #128	; 0x80
  remainder = h & 0x7;
   19488:	f004 0707 	and.w	r7, r4, #7
  h >>= 3;
   1948c:	10e4      	asrs	r4, r4, #3
   1948e:	4625      	mov	r5, r4
  while (h--) {
   19490:	460a      	mov	r2, r1
   19492:	3d01      	subs	r5, #1
   19494:	d312      	bcc.n	194bc <weegfx::Graphics::invertRect(int, int, int, int)+0x9e>
   19496:	4610      	mov	r0, r2
  while (count-- > 0x0) {
   19498:	eb02 0c03 	add.w	ip, r2, r3
   1949c:	e00a      	b.n	194b4 <weegfx::Graphics::invertRect(int, int, int, int)+0x96>
      case weegfx::DRAW_INVERSE: *dst++ ^= mask; break;
   1949e:	f812 5b01 	ldrb.w	r5, [r2], #1
   194a2:	4045      	eors	r5, r0
   194a4:	f802 5c01 	strb.w	r5, [r2, #-1]
   194a8:	e7eb      	b.n	19482 <weegfx::Graphics::invertRect(int, int, int, int)+0x64>
   194aa:	f810 6b01 	ldrb.w	r6, [r0], #1
   194ae:	43f6      	mvns	r6, r6
   194b0:	f800 6c01 	strb.w	r6, [r0, #-1]
  while (count-- > 0x0) {
   194b4:	4560      	cmp	r0, ip
   194b6:	d1f8      	bne.n	194aa <weegfx::Graphics::invertRect(int, int, int, int)+0x8c>
    buf += Graphics::kWidth;
   194b8:	3280      	adds	r2, #128	; 0x80
   194ba:	e7ea      	b.n	19492 <weegfx::Graphics::invertRect(int, int, int, int)+0x74>
   194bc:	eb01 11c4 	add.w	r1, r1, r4, lsl #7
  if (remainder) {
   194c0:	b12f      	cbz	r7, 194ce <weegfx::Graphics::invertRect(int, int, int, int)+0xb0>
    draw_pixel_row<draw_mode>(buf, w, ~(0xff << remainder));
   194c2:	22ff      	movs	r2, #255	; 0xff
   194c4:	40ba      	lsls	r2, r7
   194c6:	b2d2      	uxtb	r2, r2
inline void draw_pixel_row(uint8_t *dst, weegfx::coord_t count, uint8_t mask) {
   194c8:	440b      	add	r3, r1
  while (count-- > 0x0) {
   194ca:	4299      	cmp	r1, r3
   194cc:	d100      	bne.n	194d0 <weegfx::Graphics::invertRect(int, int, int, int)+0xb2>
  draw_rect<DRAW_INVERSE>(get_frame_ptr(x, y), y, w, h);
}
   194ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
      case weegfx::DRAW_INVERSE: *dst++ ^= mask; break;
   194d0:	f811 0b01 	ldrb.w	r0, [r1], #1
   194d4:	4050      	eors	r0, r2
   194d6:	43c0      	mvns	r0, r0
   194d8:	f801 0c01 	strb.w	r0, [r1, #-1]
   194dc:	e7f5      	b.n	194ca <weegfx::Graphics::invertRect(int, int, int, int)+0xac>

000194de <weegfx::Graphics::drawHLine(int, int, int)>:
  drawVLine(x, y + 1, h - 1);
  drawVLine(x + w - 1, y + 1, h - 1);
  drawHLine(x, y + h - 1, w);
}

void Graphics::drawHLine(coord_t x, coord_t y, coord_t w) {
   194de:	b510      	push	{r4, lr}

  coord_t h = 1;
  CLIPX(x, w);
   194e0:	18cc      	adds	r4, r1, r3
   194e2:	2c80      	cmp	r4, #128	; 0x80
   194e4:	bfc8      	it	gt
   194e6:	f1c1 0380 	rsbgt	r3, r1, #128	; 0x80
   194ea:	2900      	cmp	r1, #0
   194ec:	bfbc      	itt	lt
   194ee:	185b      	addlt	r3, r3, r1
   194f0:	2100      	movlt	r1, #0
   194f2:	2b00      	cmp	r3, #0
   194f4:	dd0f      	ble.n	19516 <weegfx::Graphics::drawHLine(int, int, int)+0x38>
  CLIPY(y, h);
   194f6:	2a3f      	cmp	r2, #63	; 0x3f
   194f8:	d80d      	bhi.n	19516 <weegfx::Graphics::drawHLine(int, int, int)+0x38>
   194fa:	6800      	ldr	r0, [r0, #0]
   194fc:	10d4      	asrs	r4, r2, #3
   194fe:	eb01 11c4 	add.w	r1, r1, r4, lsl #7
   19502:	4401      	add	r1, r0
  uint8_t *start = get_frame_ptr(x, y);

  draw_pixel_row<DRAW_NORMAL>(start, w, 0x1 << (y & 0x7));
   19504:	f002 0207 	and.w	r2, r2, #7
   19508:	2001      	movs	r0, #1
   1950a:	fa00 f202 	lsl.w	r2, r0, r2
   1950e:	b2d2      	uxtb	r2, r2
inline void draw_pixel_row(uint8_t *dst, weegfx::coord_t count, uint8_t mask) {
   19510:	440b      	add	r3, r1
  while (count-- > 0x0) {
   19512:	428b      	cmp	r3, r1
   19514:	d100      	bne.n	19518 <weegfx::Graphics::drawHLine(int, int, int)+0x3a>
}
   19516:	bd10      	pop	{r4, pc}
      case weegfx::DRAW_NORMAL: *dst++ |= mask; break;
   19518:	f811 0b01 	ldrb.w	r0, [r1], #1
   1951c:	4310      	orrs	r0, r2
   1951e:	f801 0c01 	strb.w	r0, [r1, #-1]
   19522:	e7f6      	b.n	19512 <weegfx::Graphics::drawHLine(int, int, int)+0x34>

00019524 <weegfx::Graphics::drawHLineDots(int, int, int)>:

void Graphics::drawHLineDots(coord_t x, coord_t y, coord_t w) {
   19524:	b530      	push	{r4, r5, lr}

  coord_t h = 1;
  CLIPX(x, w);
   19526:	18cc      	adds	r4, r1, r3
   19528:	2c80      	cmp	r4, #128	; 0x80
   1952a:	bfc8      	it	gt
   1952c:	f1c1 0380 	rsbgt	r3, r1, #128	; 0x80
   19530:	2900      	cmp	r1, #0
   19532:	bfbc      	itt	lt
   19534:	185b      	addlt	r3, r3, r1
   19536:	2100      	movlt	r1, #0
   19538:	2b00      	cmp	r3, #0
   1953a:	dd1b      	ble.n	19574 <weegfx::Graphics::drawHLineDots(int, int, int)+0x50>
  CLIPY(y, h);
   1953c:	2a3f      	cmp	r2, #63	; 0x3f
   1953e:	d819      	bhi.n	19574 <weegfx::Graphics::drawHLineDots(int, int, int)+0x50>
  uint8_t *start = get_frame_ptr(x, y);

  draw_pixel_row<DRAW_DOT>(start, w, 0x1 << (y & 0x7));
   19540:	f002 0507 	and.w	r5, r2, #7
   19544:	10d2      	asrs	r2, r2, #3
   19546:	eb01 11c2 	add.w	r1, r1, r2, lsl #7
   1954a:	2401      	movs	r4, #1
   1954c:	6802      	ldr	r2, [r0, #0]
   1954e:	40ac      	lsls	r4, r5
   19550:	3104      	adds	r1, #4
   19552:	b2e4      	uxtb	r4, r4
  while (count-- > 0x0) {
   19554:	440a      	add	r2, r1
      case weegfx::DRAW_DOT: { *dst++|= mask; *dst++|= mask; *dst++ |= 0x0; *dst++ |= 0x0; count -= 0x3; } break;
   19556:	f812 1c04 	ldrb.w	r1, [r2, #-4]
   1955a:	4321      	orrs	r1, r4
   1955c:	f802 1c04 	strb.w	r1, [r2, #-4]
   19560:	f812 1c03 	ldrb.w	r1, [r2, #-3]
   19564:	3b04      	subs	r3, #4
   19566:	4321      	orrs	r1, r4
  while (count-- > 0x0) {
   19568:	2b00      	cmp	r3, #0
      case weegfx::DRAW_DOT: { *dst++|= mask; *dst++|= mask; *dst++ |= 0x0; *dst++ |= 0x0; count -= 0x3; } break;
   1956a:	f802 1c03 	strb.w	r1, [r2, #-3]
  while (count-- > 0x0) {
   1956e:	f102 0204 	add.w	r2, r2, #4
   19572:	dcf0      	bgt.n	19556 <weegfx::Graphics::drawHLineDots(int, int, int)+0x32>
}
   19574:	bd30      	pop	{r4, r5, pc}

00019576 <weegfx::Graphics::drawVLine(int, int, int)>:

void Graphics::drawVLine(coord_t x, coord_t y, coord_t h) {

  coord_t w = 1;
  CLIPX(x, w);
   19576:	297f      	cmp	r1, #127	; 0x7f
void Graphics::drawVLine(coord_t x, coord_t y, coord_t h) {
   19578:	b570      	push	{r4, r5, r6, lr}
  CLIPX(x, w);
   1957a:	d839      	bhi.n	195f0 <weegfx::Graphics::drawVLine(int, int, int)+0x7a>
  CLIPY(y, h);
   1957c:	18d4      	adds	r4, r2, r3
   1957e:	2c40      	cmp	r4, #64	; 0x40
   19580:	bfc8      	it	gt
   19582:	f1c2 0340 	rsbgt	r3, r2, #64	; 0x40
   19586:	2a00      	cmp	r2, #0
   19588:	bfbc      	itt	lt
   1958a:	189b      	addlt	r3, r3, r2
   1958c:	2200      	movlt	r2, #0
   1958e:	2b00      	cmp	r3, #0
   19590:	dd2e      	ble.n	195f0 <weegfx::Graphics::drawVLine(int, int, int)+0x7a>
   19592:	10d4      	asrs	r4, r2, #3
   19594:	6806      	ldr	r6, [r0, #0]
   19596:	eb01 11c4 	add.w	r1, r1, r4, lsl #7
  uint8_t *buf = get_frame_ptr(x, y);

  // unaligned start
  coord_t remainder = y & 0x7;
  if (remainder) {
   1959a:	f012 0207 	ands.w	r2, r2, #7
   1959e:	eb06 0401 	add.w	r4, r6, r1
   195a2:	d016      	beq.n	195d2 <weegfx::Graphics::drawVLine(int, int, int)+0x5c>
    remainder = 8 - remainder;
   195a4:	f1c2 0208 	rsb	r2, r2, #8
    uint8_t mask = ~(0xff >> remainder);
   195a8:	25ff      	movs	r5, #255	; 0xff
    if (h < remainder) {
   195aa:	4293      	cmp	r3, r2
    uint8_t mask = ~(0xff >> remainder);
   195ac:	fa45 f002 	asr.w	r0, r5, r2
   195b0:	ea6f 0000 	mvn.w	r0, r0
      mask &= (0xff >> (remainder - h));
   195b4:	bfb8      	it	lt
   195b6:	1ad2      	sublt	r2, r2, r3
    uint8_t mask = ~(0xff >> remainder);
   195b8:	b2c0      	uxtb	r0, r0
      mask &= (0xff >> (remainder - h));
   195ba:	bfb4      	ite	lt
   195bc:	4115      	asrlt	r5, r2
      h = 0;
    } else {
      h -= remainder;
   195be:	1a9b      	subge	r3, r3, r2
    }

    *buf |= mask;
   195c0:	5c72      	ldrb	r2, [r6, r1]
      mask &= (0xff >> (remainder - h));
   195c2:	bfb8      	it	lt
   195c4:	4028      	andlt	r0, r5
    *buf |= mask;
   195c6:	ea40 0002 	orr.w	r0, r0, r2
   195ca:	5470      	strb	r0, [r6, r1]
      h = 0;
   195cc:	bfb8      	it	lt
   195ce:	2300      	movlt	r3, #0
    buf += kWidth;
   195d0:	3480      	adds	r4, #128	; 0x80
  }

  // aligned loop
  remainder = h & 0x7;
   195d2:	f003 0007 	and.w	r0, r3, #7
  h >>= 3;
  while (h--) {
   195d6:	2200      	movs	r2, #0
  h >>= 3;
   195d8:	10db      	asrs	r3, r3, #3
    *buf = 0xff;
   195da:	21ff      	movs	r1, #255	; 0xff
  while (h--) {
   195dc:	4293      	cmp	r3, r2
   195de:	d108      	bne.n	195f2 <weegfx::Graphics::drawVLine(int, int, int)+0x7c>
   195e0:	01db      	lsls	r3, r3, #7
    buf += kWidth;
  }

  // unaligned remainder
  if (remainder) {
   195e2:	b128      	cbz	r0, 195f0 <weegfx::Graphics::drawVLine(int, int, int)+0x7a>
    *buf |= ~(0xff << remainder);
   195e4:	5ce2      	ldrb	r2, [r4, r3]
   195e6:	21ff      	movs	r1, #255	; 0xff
   195e8:	4081      	lsls	r1, r0
   195ea:	ea62 0201 	orn	r2, r2, r1
   195ee:	54e2      	strb	r2, [r4, r3]
  }
}
   195f0:	bd70      	pop	{r4, r5, r6, pc}
    *buf = 0xff;
   195f2:	01d5      	lsls	r5, r2, #7
   195f4:	3201      	adds	r2, #1
   195f6:	5561      	strb	r1, [r4, r5]
    buf += kWidth;
   195f8:	e7f0      	b.n	195dc <weegfx::Graphics::drawVLine(int, int, int)+0x66>

000195fa <weegfx::Graphics::drawFrame(int, int, int, int)>:
void Graphics::drawFrame(coord_t x, coord_t y, coord_t w, coord_t h) {
   195fa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   195fe:	f8dd 8020 	ldr.w	r8, [sp, #32]
   19602:	4614      	mov	r4, r2
   19604:	4605      	mov	r5, r0
   19606:	460e      	mov	r6, r1
  drawVLine(x, y + 1, h - 1);
   19608:	f104 0901 	add.w	r9, r4, #1
   1960c:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
void Graphics::drawFrame(coord_t x, coord_t y, coord_t w, coord_t h) {
   19610:	461f      	mov	r7, r3
  drawHLine(x, y, w);
   19612:	f7ff ff64 	bl	194de <weegfx::Graphics::drawHLine(int, int, int)>
  drawVLine(x, y + 1, h - 1);
   19616:	4653      	mov	r3, sl
   19618:	464a      	mov	r2, r9
   1961a:	4631      	mov	r1, r6
   1961c:	4628      	mov	r0, r5
   1961e:	f7ff ffaa 	bl	19576 <weegfx::Graphics::drawVLine(int, int, int)>
  drawVLine(x + w - 1, y + 1, h - 1);
   19622:	19f1      	adds	r1, r6, r7
   19624:	4653      	mov	r3, sl
   19626:	464a      	mov	r2, r9
   19628:	4628      	mov	r0, r5
   1962a:	3901      	subs	r1, #1
   1962c:	f7ff ffa3 	bl	19576 <weegfx::Graphics::drawVLine(int, int, int)>
  drawHLine(x, y + h - 1, w);
   19630:	eb04 0208 	add.w	r2, r4, r8
   19634:	463b      	mov	r3, r7
   19636:	4631      	mov	r1, r6
   19638:	4628      	mov	r0, r5
   1963a:	3a01      	subs	r2, #1
}
   1963c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  drawHLine(x, y + h - 1, w);
   19640:	f7ff bf4d 	b.w	194de <weegfx::Graphics::drawHLine(int, int, int)>

00019644 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)>:
    *buf |= ~(pattern << remainder);
  }
}


void Graphics::drawBitmap8(coord_t x, coord_t y, coord_t w, const uint8_t *data) {
   19644:	b5f0      	push	{r4, r5, r6, r7, lr}

  if (x + w > kWidth) w = kWidth - x;
   19646:	18cd      	adds	r5, r1, r3
   19648:	2d80      	cmp	r5, #128	; 0x80
   1964a:	bfc8      	it	gt
   1964c:	f1c1 0380 	rsbgt	r3, r1, #128	; 0x80
void Graphics::drawBitmap8(coord_t x, coord_t y, coord_t w, const uint8_t *data) {
   19650:	9c05      	ldr	r4, [sp, #20]
  if (x < 0) {
   19652:	2900      	cmp	r1, #0
    data += x;
    w += x;
   19654:	bfbc      	itt	lt
   19656:	185b      	addlt	r3, r3, r1
    data += x;
   19658:	1864      	addlt	r4, r4, r1
  }
  if (w <= 0)
   1965a:	2b00      	cmp	r3, #0
   1965c:	dd05      	ble.n	1966a <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x26>
    return;

  coord_t h = 8;
  CLIPY(y, h);
   1965e:	2a38      	cmp	r2, #56	; 0x38
   19660:	dd04      	ble.n	1966c <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x28>
   19662:	f1c2 0540 	rsb	r5, r2, #64	; 0x40
   19666:	2d00      	cmp	r5, #0
   19668:	dc07      	bgt.n	1967a <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x36>
      buf += kWidth;
      src = data;
      SETPIXELS_H(buf, w, (*src++) >> (8 - remainder));
    }
  }
}
   1966a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  CLIPY(y, h);
   1966c:	2a00      	cmp	r2, #0
   1966e:	da03      	bge.n	19678 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x34>
   19670:	f102 0508 	add.w	r5, r2, #8
   19674:	2200      	movs	r2, #0
   19676:	e7f6      	b.n	19666 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x22>
  coord_t h = 8;
   19678:	2508      	movs	r5, #8
   1967a:	10d6      	asrs	r6, r2, #3
   1967c:	6800      	ldr	r0, [r0, #0]
   1967e:	eb01 11c6 	add.w	r1, r1, r6, lsl #7
  if (!remainder) {
   19682:	f012 0207 	ands.w	r2, r2, #7
   19686:	4401      	add	r1, r0
   19688:	4423      	add	r3, r4
   1968a:	d01a      	beq.n	196c2 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x7e>
    SETPIXELS_H(buf, w, (*src++) << remainder);
   1968c:	460f      	mov	r7, r1
    const uint8_t *src = data;
   1968e:	4626      	mov	r6, r4
    SETPIXELS_H(buf, w, (*src++) << remainder);
   19690:	429e      	cmp	r6, r3
   19692:	d119      	bne.n	196c8 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x84>
    if (h >= 8) {
   19694:	2d08      	cmp	r5, #8
   19696:	d1e8      	bne.n	1966a <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x26>
      buf += kWidth;
   19698:	3180      	adds	r1, #128	; 0x80
      SETPIXELS_H(buf, w, (*src++) >> (8 - remainder));
   1969a:	f1c2 0208 	rsb	r2, r2, #8
   1969e:	429c      	cmp	r4, r3
   196a0:	d0e3      	beq.n	1966a <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x26>
   196a2:	f814 0b01 	ldrb.w	r0, [r4], #1
   196a6:	f811 5b01 	ldrb.w	r5, [r1], #1
   196aa:	4110      	asrs	r0, r2
   196ac:	4328      	orrs	r0, r5
   196ae:	f801 0c01 	strb.w	r0, [r1, #-1]
   196b2:	e7f4      	b.n	1969e <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x5a>
    SETPIXELS_H(buf, w, *data++);
   196b4:	f811 2b01 	ldrb.w	r2, [r1], #1
   196b8:	f814 0b01 	ldrb.w	r0, [r4], #1
   196bc:	4302      	orrs	r2, r0
   196be:	f801 2c01 	strb.w	r2, [r1, #-1]
   196c2:	429c      	cmp	r4, r3
   196c4:	d1f6      	bne.n	196b4 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x70>
   196c6:	e7d0      	b.n	1966a <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x26>
    SETPIXELS_H(buf, w, (*src++) << remainder);
   196c8:	f816 0b01 	ldrb.w	r0, [r6], #1
   196cc:	f817 cb01 	ldrb.w	ip, [r7], #1
   196d0:	4090      	lsls	r0, r2
   196d2:	ea40 000c 	orr.w	r0, r0, ip
   196d6:	f807 0c01 	strb.w	r0, [r7, #-1]
   196da:	e7d9      	b.n	19690 <weegfx::Graphics::drawBitmap8(int, int, int, unsigned char const*)+0x4c>

000196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>:
void Graphics::drawLine(coord_t x0, coord_t y0, coord_t x1, coord_t y1) {
    drawLine(x0, y0, x1, y1, 1);
}

// p = period. Draw a dotted line with a pixel every p
void Graphics::drawLine(coord_t x0, coord_t y0, coord_t x1, coord_t y1, uint8_t p) {
   196dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   196e0:	9c09      	ldr	r4, [sp, #36]	; 0x24
   196e2:	f89d e028 	ldrb.w	lr, [sp, #40]	; 0x28
  uint8_t c = 0;
  coord_t dx, dy;
  if (x0 > x1 ) dx = x0-x1; else dx = x1-x0;
   196e6:	4299      	cmp	r1, r3
   196e8:	bfcc      	ite	gt
   196ea:	1acd      	subgt	r5, r1, r3
   196ec:	1a5d      	suble	r5, r3, r1
  if (y0 > y1 ) dy = y0-y1; else dy = y1-y0;
   196ee:	42a2      	cmp	r2, r4
   196f0:	dd10      	ble.n	19714 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x38>
   196f2:	1b17      	subs	r7, r2, r4

  bool steep = false;
  if (dy > dx) {
   196f4:	42bd      	cmp	r5, r7
   196f6:	db17      	blt.n	19728 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x4c>
    steep = true;
    SWAP(dx, dy);
    SWAP(x0, y0);
    SWAP(x1, y1);
  }
  if (x0 > x1) {
   196f8:	463e      	mov	r6, r7
   196fa:	4299      	cmp	r1, r3
   196fc:	462f      	mov	r7, r5
   196fe:	4635      	mov	r5, r6
   19700:	dd05      	ble.n	1970e <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x32>
   19702:	4616      	mov	r6, r2
   19704:	4622      	mov	r2, r4
   19706:	4634      	mov	r4, r6
   19708:	460e      	mov	r6, r1
   1970a:	4619      	mov	r1, r3
   1970c:	4633      	mov	r3, r6
  bool steep = false;
   1970e:	f04f 0c00 	mov.w	ip, #0
   19712:	e011      	b.n	19738 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x5c>
  if (y0 > y1 ) dy = y0-y1; else dy = y1-y0;
   19714:	1aa7      	subs	r7, r4, r2
  if (dy > dx) {
   19716:	42bd      	cmp	r5, r7
   19718:	daee      	bge.n	196f8 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x1c>
   1971a:	461e      	mov	r6, r3
   1971c:	4623      	mov	r3, r4
   1971e:	4634      	mov	r4, r6
   19720:	460e      	mov	r6, r1
   19722:	4611      	mov	r1, r2
   19724:	4632      	mov	r2, r6
   19726:	e005      	b.n	19734 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x58>
   19728:	4616      	mov	r6, r2
   1972a:	461a      	mov	r2, r3
   1972c:	4633      	mov	r3, r6
   1972e:	460e      	mov	r6, r1
   19730:	4621      	mov	r1, r4
   19732:	4634      	mov	r4, r6
    steep = true;
   19734:	f04f 0c01 	mov.w	ip, #1
    SWAP(x0, x1);
    SWAP(y0, y1);
  }
  coord_t err = dx >> 1;
   19738:	107e      	asrs	r6, r7, #1
  coord_t ystep = (y1 > y0) ? 1 : -1;
   1973a:	42a2      	cmp	r2, r4
   1973c:	bfb4      	ite	lt
   1973e:	2401      	movlt	r4, #1
   19740:	f04f 34ff 	movge.w	r4, #4294967295	; 0xffffffff
  // OPTIMIZE Generate mask/buffer offset before loop and update on-the-fly instead of setPixeling
  // OPTIMIZE Generate spans of pixels to draw

  if (steep) {
    for(coord_t x = x0; x <= x1; x++ ) {
      if (++c % p == 0) setPixel(y, x);
   19744:	f1c1 0901 	rsb	r9, r1, #1
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19748:	f04f 0a01 	mov.w	sl, #1
  if (steep) {
   1974c:	f1bc 0f00 	cmp.w	ip, #0
   19750:	d14a      	bne.n	197e8 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x10c>
        y += ystep;
        err += dx;
      }
    }
  } else {
    for(coord_t x = x0; x <= x1; x++ ) {
   19752:	428b      	cmp	r3, r1
   19754:	db4a      	blt.n	197ec <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x110>
      if (++c % p == 0) setPixel(x, y);
   19756:	eb09 0c01 	add.w	ip, r9, r1
   1975a:	fa5f fc8c 	uxtb.w	ip, ip
   1975e:	fbbc f8fe 	udiv	r8, ip, lr
   19762:	fb0e cc18 	mls	ip, lr, r8, ip
   19766:	fa5f fc8c 	uxtb.w	ip, ip
   1976a:	f1bc 0f00 	cmp.w	ip, #0
   1976e:	d111      	bne.n	19794 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0xb8>
  return frame_ + ((y >>3) << 7) + x;
   19770:	ea4f 08e2 	mov.w	r8, r2, asr #3
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19774:	f8d0 b000 	ldr.w	fp, [r0]
  return frame_ + ((y >>3) << 7) + x;
   19778:	eb01 18c8 	add.w	r8, r1, r8, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   1977c:	f002 0c07 	and.w	ip, r2, #7
   19780:	f81b b008 	ldrb.w	fp, [fp, r8]
   19784:	fa0a fc0c 	lsl.w	ip, sl, ip
   19788:	ea4c 0c0b 	orr.w	ip, ip, fp
   1978c:	f8d0 b000 	ldr.w	fp, [r0]
   19790:	f80b c008 	strb.w	ip, [fp, r8]
      err -= dy;
      if (err < 0) {
   19794:	1b76      	subs	r6, r6, r5
        y += ystep;
   19796:	bf44      	itt	mi
   19798:	1912      	addmi	r2, r2, r4
        err += dx;
   1979a:	19f6      	addmi	r6, r6, r7
    for(coord_t x = x0; x <= x1; x++ ) {
   1979c:	3101      	adds	r1, #1
   1979e:	e7d8      	b.n	19752 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x76>
      if (++c % p == 0) setPixel(y, x);
   197a0:	eb09 0c01 	add.w	ip, r9, r1
   197a4:	fa5f fc8c 	uxtb.w	ip, ip
   197a8:	fbbc f8fe 	udiv	r8, ip, lr
   197ac:	fb0e cc18 	mls	ip, lr, r8, ip
   197b0:	fa5f fc8c 	uxtb.w	ip, ip
   197b4:	f1bc 0f00 	cmp.w	ip, #0
   197b8:	d111      	bne.n	197de <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0x102>
  return frame_ + ((y >>3) << 7) + x;
   197ba:	ea4f 08e1 	mov.w	r8, r1, asr #3
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   197be:	f8d0 b000 	ldr.w	fp, [r0]
  return frame_ + ((y >>3) << 7) + x;
   197c2:	eb02 18c8 	add.w	r8, r2, r8, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   197c6:	f001 0c07 	and.w	ip, r1, #7
   197ca:	f81b b008 	ldrb.w	fp, [fp, r8]
   197ce:	fa0a fc0c 	lsl.w	ip, sl, ip
   197d2:	ea4c 0c0b 	orr.w	ip, ip, fp
   197d6:	f8d0 b000 	ldr.w	fp, [r0]
   197da:	f80b c008 	strb.w	ip, [fp, r8]
      if (err < 0) {
   197de:	1b76      	subs	r6, r6, r5
        y += ystep;
   197e0:	bf44      	itt	mi
   197e2:	1912      	addmi	r2, r2, r4
        err += dx;
   197e4:	19f6      	addmi	r6, r6, r7
    for(coord_t x = x0; x <= x1; x++ ) {
   197e6:	3101      	adds	r1, #1
   197e8:	428b      	cmp	r3, r1
   197ea:	dad9      	bge.n	197a0 <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)+0xc4>
      }
    }
  }
}
   197ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000197f0 <weegfx::Graphics::drawLine(int, int, int, int)>:
void Graphics::drawLine(coord_t x0, coord_t y0, coord_t x1, coord_t y1) {
   197f0:	b513      	push	{r0, r1, r4, lr}
    drawLine(x0, y0, x1, y1, 1);
   197f2:	2401      	movs	r4, #1
   197f4:	9401      	str	r4, [sp, #4]
   197f6:	9c04      	ldr	r4, [sp, #16]
   197f8:	9400      	str	r4, [sp, #0]
   197fa:	f7ff ff6f 	bl	196dc <weegfx::Graphics::drawLine(int, int, int, int, unsigned char)>
}
   197fe:	b002      	add	sp, #8
   19800:	bd10      	pop	{r4, pc}

00019802 <weegfx::Graphics::drawCircle(int, int, int)>:

void Graphics::drawCircle(coord_t center_x, coord_t center_y, coord_t r) {
   19802:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  coord_t ddF_x = 1;
  coord_t ddF_y = -2 * r;
  coord_t x = 0;
  coord_t y = r;

  setPixel(center_x  , center_y+r);
   19806:	189c      	adds	r4, r3, r2
  return frame_ + ((y >>3) << 7) + x;
   19808:	ea4f 0ce4 	mov.w	ip, r4, asr #3
   1980c:	f8d0 e000 	ldr.w	lr, [r0]
   19810:	eb01 1ccc 	add.w	ip, r1, ip, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19814:	2601      	movs	r6, #1
   19816:	f81e 800c 	ldrb.w	r8, [lr, ip]
   1981a:	f004 0407 	and.w	r4, r4, #7
   1981e:	fa06 f404 	lsl.w	r4, r6, r4
   19822:	ea44 0408 	orr.w	r4, r4, r8
   19826:	f80e 400c 	strb.w	r4, [lr, ip]
  setPixel(center_x  , center_y-r);
   1982a:	1ad4      	subs	r4, r2, r3
  return frame_ + ((y >>3) << 7) + x;
   1982c:	ea4f 0ce4 	mov.w	ip, r4, asr #3
   19830:	f8d0 e000 	ldr.w	lr, [r0]
   19834:	eb01 1ccc 	add.w	ip, r1, ip, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19838:	f004 0407 	and.w	r4, r4, #7
   1983c:	f81e 800c 	ldrb.w	r8, [lr, ip]
   19840:	fa06 f404 	lsl.w	r4, r6, r4
   19844:	ea44 0408 	orr.w	r4, r4, r8
   19848:	f80e 400c 	strb.w	r4, [lr, ip]
  return frame_ + ((y >>3) << 7) + x;
   1984c:	ea4f 08e2 	mov.w	r8, r2, asr #3
  setPixel(center_x+r, center_y  );
   19850:	eb03 0c01 	add.w	ip, r3, r1
   19854:	eb0c 1cc8 	add.w	ip, ip, r8, lsl #7
   19858:	f8d0 9000 	ldr.w	r9, [r0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   1985c:	f002 0407 	and.w	r4, r2, #7
   19860:	f819 e00c 	ldrb.w	lr, [r9, ip]
   19864:	fa06 f404 	lsl.w	r4, r6, r4
   19868:	b2e4      	uxtb	r4, r4
   1986a:	ea44 0e0e 	orr.w	lr, r4, lr
   1986e:	f809 e00c 	strb.w	lr, [r9, ip]
  setPixel(center_x-r, center_y  );
   19872:	eba1 0c03 	sub.w	ip, r1, r3
  return frame_ + ((y >>3) << 7) + x;
   19876:	eb0c 1cc8 	add.w	ip, ip, r8, lsl #7
   1987a:	f8d0 e000 	ldr.w	lr, [r0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   1987e:	f81e 800c 	ldrb.w	r8, [lr, ip]
  coord_t ddF_y = -2 * r;
   19882:	f06f 0701 	mvn.w	r7, #1
   19886:	ea44 0408 	orr.w	r4, r4, r8
   1988a:	f80e 400c 	strb.w	r4, [lr, ip]
  coord_t f = 1 - r;
   1988e:	f1c3 0501 	rsb	r5, r3, #1
  coord_t ddF_y = -2 * r;
   19892:	435f      	muls	r7, r3
  coord_t x = 0;
   19894:	f04f 0c00 	mov.w	ip, #0

  while (x < y) {
   19898:	459c      	cmp	ip, r3
   1989a:	db01      	blt.n	198a0 <weegfx::Graphics::drawCircle(int, int, int)+0x9e>
    setPixel(center_x + y, center_y + x);
    setPixel(center_x - y, center_y + x);
    setPixel(center_x + y, center_y - x);
    setPixel(center_x - y, center_y - x);
  }
}
   1989c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (f >= 0) {
   198a0:	2d00      	cmp	r5, #0
      y--;
   198a2:	bfa8      	it	ge
   198a4:	f103 33ff 	addge.w	r3, r3, #4294967295	; 0xffffffff
    x++;
   198a8:	f10c 0c01 	add.w	ip, ip, #1
    setPixel(center_x + x, center_y + y);
   198ac:	eb03 0402 	add.w	r4, r3, r2
  return frame_ + ((y >>3) << 7) + x;
   198b0:	ea4f 09e4 	mov.w	r9, r4, asr #3
   198b4:	eb01 080c 	add.w	r8, r1, ip
   198b8:	f8d0 a000 	ldr.w	sl, [r0]
   198bc:	eb08 1ec9 	add.w	lr, r8, r9, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   198c0:	f004 0407 	and.w	r4, r4, #7
   198c4:	f81a b00e 	ldrb.w	fp, [sl, lr]
   198c8:	fa06 f404 	lsl.w	r4, r6, r4
   198cc:	b2e4      	uxtb	r4, r4
   198ce:	ea44 0b0b 	orr.w	fp, r4, fp
   198d2:	f80a b00e 	strb.w	fp, [sl, lr]
   198d6:	eba1 0e0c 	sub.w	lr, r1, ip
  return frame_ + ((y >>3) << 7) + x;
   198da:	f8d0 a000 	ldr.w	sl, [r0]
   198de:	eb0e 19c9 	add.w	r9, lr, r9, lsl #7
      ddF_y += 2;
   198e2:	bfa8      	it	ge
   198e4:	3702      	addge	r7, #2
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   198e6:	f81a b009 	ldrb.w	fp, [sl, r9]
   198ea:	ea44 040b 	orr.w	r4, r4, fp
   198ee:	f80a 4009 	strb.w	r4, [sl, r9]
    setPixel(center_x + x, center_y - y);
   198f2:	eba2 0403 	sub.w	r4, r2, r3
  return frame_ + ((y >>3) << 7) + x;
   198f6:	ea4f 09e4 	mov.w	r9, r4, asr #3
   198fa:	f8d0 a000 	ldr.w	sl, [r0]
   198fe:	eb08 18c9 	add.w	r8, r8, r9, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19902:	f004 0407 	and.w	r4, r4, #7
   19906:	f81a b008 	ldrb.w	fp, [sl, r8]
   1990a:	fa06 f404 	lsl.w	r4, r6, r4
   1990e:	b2e4      	uxtb	r4, r4
   19910:	ea44 0b0b 	orr.w	fp, r4, fp
   19914:	f80a b008 	strb.w	fp, [sl, r8]
  return frame_ + ((y >>3) << 7) + x;
   19918:	eb0e 1ec9 	add.w	lr, lr, r9, lsl #7
   1991c:	f8d0 8000 	ldr.w	r8, [r0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19920:	f818 900e 	ldrb.w	r9, [r8, lr]
   19924:	ea44 0409 	orr.w	r4, r4, r9
   19928:	f808 400e 	strb.w	r4, [r8, lr]
   1992c:	eb02 040c 	add.w	r4, r2, ip
  return frame_ + ((y >>3) << 7) + x;
   19930:	ea4f 09e4 	mov.w	r9, r4, asr #3
    setPixel(center_x + y, center_y + x);
   19934:	eb03 0801 	add.w	r8, r3, r1
   19938:	f8d0 a000 	ldr.w	sl, [r0]
   1993c:	eb08 1ec9 	add.w	lr, r8, r9, lsl #7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19940:	f004 0407 	and.w	r4, r4, #7
   19944:	f81a b00e 	ldrb.w	fp, [sl, lr]
   19948:	fa06 f404 	lsl.w	r4, r6, r4
   1994c:	b2e4      	uxtb	r4, r4
   1994e:	ea44 0b0b 	orr.w	fp, r4, fp
   19952:	f80a b00e 	strb.w	fp, [sl, lr]
    setPixel(center_x - y, center_y + x);
   19956:	eba1 0e03 	sub.w	lr, r1, r3
  return frame_ + ((y >>3) << 7) + x;
   1995a:	f8d0 a000 	ldr.w	sl, [r0]
   1995e:	eb0e 19c9 	add.w	r9, lr, r9, lsl #7
      f += ddF_y;
   19962:	bfa8      	it	ge
   19964:	19ed      	addge	r5, r5, r7
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19966:	f81a b009 	ldrb.w	fp, [sl, r9]
   1996a:	ea44 040b 	orr.w	r4, r4, fp
   1996e:	f80a 4009 	strb.w	r4, [sl, r9]
   19972:	eba2 040c 	sub.w	r4, r2, ip
  return frame_ + ((y >>3) << 7) + x;
   19976:	ea4f 09e4 	mov.w	r9, r4, asr #3
   1997a:	eb08 18c9 	add.w	r8, r8, r9, lsl #7
   1997e:	f8d0 a000 	ldr.w	sl, [r0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   19982:	f004 0407 	and.w	r4, r4, #7
   19986:	f81a b008 	ldrb.w	fp, [sl, r8]
   1998a:	fa06 f404 	lsl.w	r4, r6, r4
   1998e:	b2e4      	uxtb	r4, r4
   19990:	ea44 0b0b 	orr.w	fp, r4, fp
   19994:	f80a b008 	strb.w	fp, [sl, r8]
  return frame_ + ((y >>3) << 7) + x;
   19998:	eb0e 1ec9 	add.w	lr, lr, r9, lsl #7
   1999c:	f8d0 8000 	ldr.w	r8, [r0]
  *(get_frame_ptr(x, y)) |= (0x1 << (y & 0x7));
   199a0:	f818 900e 	ldrb.w	r9, [r8, lr]
    f += ddF_x;
   199a4:	eb05 054c 	add.w	r5, r5, ip, lsl #1
   199a8:	ea44 0409 	orr.w	r4, r4, r9
   199ac:	f808 400e 	strb.w	r4, [r8, lr]
   199b0:	3501      	adds	r5, #1
}
   199b2:	e771      	b.n	19898 <weegfx::Graphics::drawCircle(int, int, int)+0x96>

000199b4 <weegfx::Graphics::draw_char(char, int, int)>:
}

// OPTIMIZE When printing strings, all chars will have the same y/remainder
// This will probably only save a few cycles, if any. Also the clipping can
// be made optional (template?)
void Graphics::draw_char(char c, coord_t x, coord_t y) {
   199b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (!c) c = '0';
   199b6:	460c      	mov	r4, r1
   199b8:	b1c9      	cbz	r1, 199ee <weegfx::Graphics::draw_char(char, int, int)+0x3a>
  if (c <= 32 || c > 127)
   199ba:	3921      	subs	r1, #33	; 0x21
   199bc:	295e      	cmp	r1, #94	; 0x5e
   199be:	d815      	bhi.n	199ec <weegfx::Graphics::draw_char(char, int, int)+0x38>
  return ssd1306xled_font6x8 + Graphics::kFixedFontW * (c - 32);
   199c0:	4d29      	ldr	r5, [pc, #164]	; (19a68 <weegfx::Graphics::draw_char(char, int, int)+0xb4>)
   199c2:	f1a4 0620 	sub.w	r6, r4, #32
   199c6:	2106      	movs	r1, #6
    return;

  coord_t w = Graphics::kFixedFontW;
  coord_t h = Graphics::kFixedFontH;
  font_glyph data = get_char_glyph(c);
  if (c + w > kWidth) w = kWidth - x;
   199c8:	2c7a      	cmp	r4, #122	; 0x7a
  return ssd1306xled_font6x8 + Graphics::kFixedFontW * (c - 32);
   199ca:	fb01 5506 	mla	r5, r1, r6, r5
  if (c + w > kWidth) w = kWidth - x;
   199ce:	d948      	bls.n	19a62 <weegfx::Graphics::draw_char(char, int, int)+0xae>
  if (x < 0) {
   199d0:	2a00      	cmp	r2, #0
  if (c + w > kWidth) w = kWidth - x;
   199d2:	f1c2 0180 	rsb	r1, r2, #128	; 0x80
  if (x < 0) {
   199d6:	da01      	bge.n	199dc <weegfx::Graphics::draw_char(char, int, int)+0x28>
    w += x;
   199d8:	4411      	add	r1, r2
    data += x;
   199da:	4415      	add	r5, r2
  }
  if (w <= 0) return;
   199dc:	2900      	cmp	r1, #0
   199de:	dd05      	ble.n	199ec <weegfx::Graphics::draw_char(char, int, int)+0x38>
  CLIPY(y, h);
   199e0:	2b38      	cmp	r3, #56	; 0x38
   199e2:	dd06      	ble.n	199f2 <weegfx::Graphics::draw_char(char, int, int)+0x3e>
   199e4:	f1c3 0440 	rsb	r4, r3, #64	; 0x40
   199e8:	2c00      	cmp	r4, #0
   199ea:	dc09      	bgt.n	19a00 <weegfx::Graphics::draw_char(char, int, int)+0x4c>
      dest += kWidth;
      src = data;
      SETPIXELS_H(dest, w, (*src++) >> (8 - remainder));
    }
  }
}
   199ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (!c) c = '0';
   199ee:	2430      	movs	r4, #48	; 0x30
   199f0:	e7e6      	b.n	199c0 <weegfx::Graphics::draw_char(char, int, int)+0xc>
  CLIPY(y, h);
   199f2:	2b00      	cmp	r3, #0
   199f4:	da03      	bge.n	199fe <weegfx::Graphics::draw_char(char, int, int)+0x4a>
   199f6:	f103 0408 	add.w	r4, r3, #8
   199fa:	2300      	movs	r3, #0
   199fc:	e7f4      	b.n	199e8 <weegfx::Graphics::draw_char(char, int, int)+0x34>
  coord_t h = Graphics::kFixedFontH;
   199fe:	2408      	movs	r4, #8
  return frame_ + ((y >>3) << 7) + x;
   19a00:	10de      	asrs	r6, r3, #3
   19a02:	eb02 16c6 	add.w	r6, r2, r6, lsl #7
   19a06:	6802      	ldr	r2, [r0, #0]
  if (!remainder) {
   19a08:	f013 0307 	ands.w	r3, r3, #7
   19a0c:	4432      	add	r2, r6
   19a0e:	4429      	add	r1, r5
   19a10:	d01a      	beq.n	19a48 <weegfx::Graphics::draw_char(char, int, int)+0x94>
    SETPIXELS_H(dest, w, (*src++) << remainder);
   19a12:	4617      	mov	r7, r2
  if (!remainder) {
   19a14:	462e      	mov	r6, r5
    SETPIXELS_H(dest, w, (*src++) << remainder);
   19a16:	428e      	cmp	r6, r1
   19a18:	d119      	bne.n	19a4e <weegfx::Graphics::draw_char(char, int, int)+0x9a>
    if (h >= 8) {
   19a1a:	2c08      	cmp	r4, #8
   19a1c:	d1e6      	bne.n	199ec <weegfx::Graphics::draw_char(char, int, int)+0x38>
      dest += kWidth;
   19a1e:	3280      	adds	r2, #128	; 0x80
      SETPIXELS_H(dest, w, (*src++) >> (8 - remainder));
   19a20:	f1c3 0308 	rsb	r3, r3, #8
   19a24:	428d      	cmp	r5, r1
   19a26:	d0e1      	beq.n	199ec <weegfx::Graphics::draw_char(char, int, int)+0x38>
   19a28:	f815 0b01 	ldrb.w	r0, [r5], #1
   19a2c:	f812 4b01 	ldrb.w	r4, [r2], #1
   19a30:	4118      	asrs	r0, r3
   19a32:	4320      	orrs	r0, r4
   19a34:	f802 0c01 	strb.w	r0, [r2, #-1]
   19a38:	e7f4      	b.n	19a24 <weegfx::Graphics::draw_char(char, int, int)+0x70>
    SETPIXELS_H(dest, w, *data++);
   19a3a:	f812 3b01 	ldrb.w	r3, [r2], #1
   19a3e:	f815 0b01 	ldrb.w	r0, [r5], #1
   19a42:	4303      	orrs	r3, r0
   19a44:	f802 3c01 	strb.w	r3, [r2, #-1]
   19a48:	428d      	cmp	r5, r1
   19a4a:	d1f6      	bne.n	19a3a <weegfx::Graphics::draw_char(char, int, int)+0x86>
   19a4c:	e7ce      	b.n	199ec <weegfx::Graphics::draw_char(char, int, int)+0x38>
    SETPIXELS_H(dest, w, (*src++) << remainder);
   19a4e:	f816 0b01 	ldrb.w	r0, [r6], #1
   19a52:	f817 cb01 	ldrb.w	ip, [r7], #1
   19a56:	4098      	lsls	r0, r3
   19a58:	ea40 000c 	orr.w	r0, r0, ip
   19a5c:	f807 0c01 	strb.w	r0, [r7, #-1]
   19a60:	e7d9      	b.n	19a16 <weegfx::Graphics::draw_char(char, int, int)+0x62>
  if (x < 0) {
   19a62:	2a00      	cmp	r2, #0
   19a64:	dabc      	bge.n	199e0 <weegfx::Graphics::draw_char(char, int, int)+0x2c>
   19a66:	e7b7      	b.n	199d8 <weegfx::Graphics::draw_char(char, int, int)+0x24>
   19a68:	000278cc 	.word	0x000278cc

00019a6c <weegfx::Graphics::print(char)>:

void Graphics::print(char c) {
   19a6c:	b510      	push	{r4, lr}
   19a6e:	4604      	mov	r4, r0
  draw_char(c, text_x_, text_y_);
   19a70:	6883      	ldr	r3, [r0, #8]
   19a72:	6842      	ldr	r2, [r0, #4]
   19a74:	f7ff ff9e 	bl	199b4 <weegfx::Graphics::draw_char(char, int, int)>
  text_x_ += kFixedFontW;
   19a78:	6863      	ldr	r3, [r4, #4]
   19a7a:	3306      	adds	r3, #6
   19a7c:	6063      	str	r3, [r4, #4]
}
   19a7e:	bd10      	pop	{r4, pc}

00019a80 <weegfx::Graphics::pretty_print_right(int)>:
         (unsigned)(str - buf) >= sizeof(buf) - width)
    *--str = ' ';
  print(str);
}

void Graphics::pretty_print_right(int value) {
   19a80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  coord_t x = text_x_ - kFixedFontW;
   19a84:	6844      	ldr	r4, [r0, #4]
  coord_t y = text_y_;
   19a86:	6886      	ldr	r6, [r0, #8]

  if (!value) {
   19a88:	2900      	cmp	r1, #0
void Graphics::pretty_print_right(int value) {
   19a8a:	4605      	mov	r5, r0
  coord_t x = text_x_ - kFixedFontW;
   19a8c:	f1a4 0406 	sub.w	r4, r4, #6
  if (!value) {
   19a90:	d106      	bne.n	19aa0 <weegfx::Graphics::pretty_print_right(int)+0x20>
    draw_char('0', x, y);
   19a92:	4633      	mov	r3, r6
   19a94:	4622      	mov	r2, r4
   19a96:	2130      	movs	r1, #48	; 0x30
      value /= 10;
    }
    if (sign)
      draw_char(sign, x, y);
  }
}
   19a98:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      draw_char(sign, x, y);
   19a9c:	f7ff bf8a 	b.w	199b4 <weegfx::Graphics::draw_char(char, int, int)>
    if (value < 0) {
   19aa0:	da17      	bge.n	19ad2 <weegfx::Graphics::pretty_print_right(int)+0x52>
      value = -value;
   19aa2:	4249      	negs	r1, r1
      sign = '-';
   19aa4:	272d      	movs	r7, #45	; 0x2d
      draw_char('0' + value % 10, x, y);
   19aa6:	f04f 080a 	mov.w	r8, #10
   19aaa:	fbb1 f9f8 	udiv	r9, r1, r8
   19aae:	fb08 1119 	mls	r1, r8, r9, r1
   19ab2:	3130      	adds	r1, #48	; 0x30
   19ab4:	4622      	mov	r2, r4
   19ab6:	b2c9      	uxtb	r1, r1
   19ab8:	4633      	mov	r3, r6
   19aba:	4628      	mov	r0, r5
   19abc:	f7ff ff7a 	bl	199b4 <weegfx::Graphics::draw_char(char, int, int)>
    while (value) {
   19ac0:	4649      	mov	r1, r9
      x -= kFixedFontW;
   19ac2:	3c06      	subs	r4, #6
    while (value) {
   19ac4:	2900      	cmp	r1, #0
   19ac6:	d1f0      	bne.n	19aaa <weegfx::Graphics::pretty_print_right(int)+0x2a>
      draw_char(sign, x, y);
   19ac8:	4633      	mov	r3, r6
   19aca:	4622      	mov	r2, r4
   19acc:	4639      	mov	r1, r7
   19ace:	4628      	mov	r0, r5
   19ad0:	e7e2      	b.n	19a98 <weegfx::Graphics::pretty_print_right(int)+0x18>
      sign = '+';
   19ad2:	272b      	movs	r7, #43	; 0x2b
   19ad4:	e7e7      	b.n	19aa6 <weegfx::Graphics::pretty_print_right(int)+0x26>

00019ad6 <weegfx::Graphics::print(char const*)>:

void Graphics::print(const char *s) {
   19ad6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  coord_t x = text_x_;
   19ad8:	6845      	ldr	r5, [r0, #4]
  coord_t y = text_y_;
   19ada:	6887      	ldr	r7, [r0, #8]
void Graphics::print(const char *s) {
   19adc:	4604      	mov	r4, r0
   19ade:	1e4e      	subs	r6, r1, #1

  // TODO Track position, only clip when necessary or early-out?
  while (*s) {
   19ae0:	f816 1f01 	ldrb.w	r1, [r6, #1]!
   19ae4:	b909      	cbnz	r1, 19aea <weegfx::Graphics::print(char const*)+0x14>
    draw_char(*s++, x, y);
    x += kFixedFontW;
  }

  text_x_ = x;
   19ae6:	6065      	str	r5, [r4, #4]
}
   19ae8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    draw_char(*s++, x, y);
   19aea:	462a      	mov	r2, r5
   19aec:	463b      	mov	r3, r7
   19aee:	4620      	mov	r0, r4
   19af0:	f7ff ff60 	bl	199b4 <weegfx::Graphics::draw_char(char, int, int)>
    x += kFixedFontW;
   19af4:	3506      	adds	r5, #6
   19af6:	e7f3      	b.n	19ae0 <weegfx::Graphics::print(char const*)+0xa>

00019af8 <weegfx::Graphics::print_right(char const*)>:

void Graphics::print_right(const char *s) {
   19af8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  weegfx::coord_t x = text_x_;
   19afc:	6847      	ldr	r7, [r0, #4]
  weegfx::coord_t y = text_y_;
   19afe:	f8d0 8008 	ldr.w	r8, [r0, #8]
void Graphics::print_right(const char *s) {
   19b02:	4604      	mov	r4, r0
   19b04:	460d      	mov	r5, r1
   19b06:	460a      	mov	r2, r1
   19b08:	4616      	mov	r6, r2
  const char *c = s;
  while (*c) ++c; // find end
   19b0a:	3201      	adds	r2, #1
   19b0c:	7833      	ldrb	r3, [r6, #0]
   19b0e:	2b00      	cmp	r3, #0
   19b10:	d1fa      	bne.n	19b08 <weegfx::Graphics::print_right(char const*)+0x10>

  while (c > s) {
   19b12:	42ae      	cmp	r6, r5
   19b14:	d801      	bhi.n	19b1a <weegfx::Graphics::print_right(char const*)+0x22>
    x -= kFixedFontW;
    draw_char(*--c, x, y);
  }
}
   19b16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    x -= kFixedFontW;
   19b1a:	3f06      	subs	r7, #6
    draw_char(*--c, x, y);
   19b1c:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
   19b20:	4643      	mov	r3, r8
   19b22:	463a      	mov	r2, r7
   19b24:	4620      	mov	r0, r4
   19b26:	f7ff ff45 	bl	199b4 <weegfx::Graphics::draw_char(char, int, int)>
   19b2a:	e7f2      	b.n	19b12 <weegfx::Graphics::print_right(char const*)+0x1a>

00019b2c <weegfx::Graphics::printf(char const*, ...)>:

void Graphics::printf(const char *fmt, ...) {
   19b2c:	b40e      	push	{r1, r2, r3}
   19b2e:	b510      	push	{r4, lr}
   19b30:	b0a3      	sub	sp, #140	; 0x8c
   19b32:	ab25      	add	r3, sp, #148	; 0x94
   19b34:	4604      	mov	r4, r0
   19b36:	f853 2b04 	ldr.w	r2, [r3], #4
  char buf[128];
  va_list args;
  va_start(args, fmt );
   19b3a:	9301      	str	r3, [sp, #4]
  vsnprintf(buf, sizeof(buf), fmt, args);
   19b3c:	2180      	movs	r1, #128	; 0x80
   19b3e:	a802      	add	r0, sp, #8
   19b40:	f003 fe1a 	bl	1d778 <vsniprintf>
  va_end(args);
  print(buf);
   19b44:	a902      	add	r1, sp, #8
   19b46:	4620      	mov	r0, r4
   19b48:	f7ff ffc5 	bl	19ad6 <weegfx::Graphics::print(char const*)>
}
   19b4c:	b023      	add	sp, #140	; 0x8c
   19b4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   19b52:	b003      	add	sp, #12
   19b54:	4770      	bx	lr

00019b56 <weegfx::Graphics::drawStr(int, int, char const*)>:

void Graphics::drawStr(coord_t x, coord_t y, const char *s) {
   19b56:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19b58:	4606      	mov	r6, r0
   19b5a:	460c      	mov	r4, r1
   19b5c:	4617      	mov	r7, r2
   19b5e:	1e5d      	subs	r5, r3, #1
  while (*s) {
   19b60:	f815 1f01 	ldrb.w	r1, [r5, #1]!
   19b64:	b901      	cbnz	r1, 19b68 <weegfx::Graphics::drawStr(int, int, char const*)+0x12>
    draw_char(*s++, x, y);
    x += kFixedFontW;
  }
}
   19b66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    draw_char(*s++, x, y);
   19b68:	4622      	mov	r2, r4
   19b6a:	463b      	mov	r3, r7
   19b6c:	4630      	mov	r0, r6
   19b6e:	f7ff ff21 	bl	199b4 <weegfx::Graphics::draw_char(char, int, int)>
    x += kFixedFontW;
   19b72:	3406      	adds	r4, #6
   19b74:	e7f4      	b.n	19b60 <weegfx::Graphics::drawStr(int, int, char const*)+0xa>

00019b76 <char* itos<int, false>(int, char*, unsigned int)>:
  char *pos = buf + buflen;
   19b76:	4411      	add	r1, r2
  if (!value) {
   19b78:	1e03      	subs	r3, r0, #0
  *--pos = '\0';
   19b7a:	f04f 0200 	mov.w	r2, #0
char *itos(type value, char *buf, size_t buflen) {
   19b7e:	b530      	push	{r4, r5, lr}
  *--pos = '\0';
   19b80:	f801 2c01 	strb.w	r2, [r1, #-1]
  if (!value) {
   19b84:	d104      	bne.n	19b90 <char* itos<int, false>(int, char*, unsigned int)+0x1a>
    *--pos = '0';
   19b86:	2330      	movs	r3, #48	; 0x30
   19b88:	1e88      	subs	r0, r1, #2
   19b8a:	f801 3c02 	strb.w	r3, [r1, #-2]
}
   19b8e:	bd30      	pop	{r4, r5, pc}
    if (value < 0)  {
   19b90:	da01      	bge.n	19b96 <char* itos<int, false>(int, char*, unsigned int)+0x20>
      value = -value;
   19b92:	425b      	negs	r3, r3
      sign = '-';
   19b94:	222d      	movs	r2, #45	; 0x2d
  *--pos = '\0';
   19b96:	1e48      	subs	r0, r1, #1
      *--pos = '0' + value % 10;
   19b98:	210a      	movs	r1, #10
   19b9a:	fbb3 f4f1 	udiv	r4, r3, r1
   19b9e:	fb01 3314 	mls	r3, r1, r4, r3
   19ba2:	3330      	adds	r3, #48	; 0x30
   19ba4:	4605      	mov	r5, r0
   19ba6:	f800 3d01 	strb.w	r3, [r0, #-1]!
    while (value) {
   19baa:	4623      	mov	r3, r4
   19bac:	2c00      	cmp	r4, #0
   19bae:	d1f4      	bne.n	19b9a <char* itos<int, false>(int, char*, unsigned int)+0x24>
    if (sign)
   19bb0:	2a00      	cmp	r2, #0
   19bb2:	d0ec      	beq.n	19b8e <char* itos<int, false>(int, char*, unsigned int)+0x18>
      *--pos = sign;
   19bb4:	232d      	movs	r3, #45	; 0x2d
   19bb6:	f800 3c01 	strb.w	r3, [r0, #-1]
   19bba:	1ea8      	subs	r0, r5, #2
  return pos;
   19bbc:	e7e7      	b.n	19b8e <char* itos<int, false>(int, char*, unsigned int)+0x18>

00019bbe <weegfx::Graphics::print(int)>:
void Graphics::print(int value) {
   19bbe:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   19bc0:	4604      	mov	r4, r0
  print(itos<int, false>(value, buf, sizeof(buf)));
   19bc2:	220c      	movs	r2, #12
void Graphics::print(int value) {
   19bc4:	4608      	mov	r0, r1
  print(itos<int, false>(value, buf, sizeof(buf)));
   19bc6:	a901      	add	r1, sp, #4
   19bc8:	f7ff ffd5 	bl	19b76 <char* itos<int, false>(int, char*, unsigned int)>
   19bcc:	4601      	mov	r1, r0
   19bce:	4620      	mov	r0, r4
   19bd0:	f7ff ff81 	bl	19ad6 <weegfx::Graphics::print(char const*)>
}
   19bd4:	b004      	add	sp, #16
   19bd6:	bd10      	pop	{r4, pc}

00019bd8 <weegfx::Graphics::print(int, unsigned int)>:
void Graphics::print(int value, unsigned width) {
   19bd8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  char *str = itos<int, false>(value, buf, sizeof(buf));
   19bda:	466e      	mov	r6, sp
void Graphics::print(int value, unsigned width) {
   19bdc:	4614      	mov	r4, r2
   19bde:	4605      	mov	r5, r0
  char *str = itos<int, false>(value, buf, sizeof(buf));
   19be0:	220f      	movs	r2, #15
void Graphics::print(int value, unsigned width) {
   19be2:	4608      	mov	r0, r1
  char *str = itos<int, false>(value, buf, sizeof(buf));
   19be4:	4631      	mov	r1, r6
   19be6:	f7ff ffc6 	bl	19b76 <char* itos<int, false>(int, char*, unsigned int)>
         (unsigned)(str - buf) >= sizeof(buf) - width)
   19bea:	f1c4 040f 	rsb	r4, r4, #15
  char *str = itos<int, false>(value, buf, sizeof(buf));
   19bee:	4601      	mov	r1, r0
    *--str = ' ';
   19bf0:	2220      	movs	r2, #32
  while (str > buf &&
   19bf2:	42b1      	cmp	r1, r6
   19bf4:	d804      	bhi.n	19c00 <weegfx::Graphics::print(int, unsigned int)+0x28>
  print(str);
   19bf6:	4628      	mov	r0, r5
   19bf8:	f7ff ff6d 	bl	19ad6 <weegfx::Graphics::print(char const*)>
}
   19bfc:	b004      	add	sp, #16
   19bfe:	bd70      	pop	{r4, r5, r6, pc}
         (unsigned)(str - buf) >= sizeof(buf) - width)
   19c00:	1b8b      	subs	r3, r1, r6
  while (str > buf &&
   19c02:	42a3      	cmp	r3, r4
   19c04:	d3f7      	bcc.n	19bf6 <weegfx::Graphics::print(int, unsigned int)+0x1e>
    *--str = ' ';
   19c06:	f801 2d01 	strb.w	r2, [r1, #-1]!
   19c0a:	e7f2      	b.n	19bf2 <weegfx::Graphics::print(int, unsigned int)+0x1a>

00019c0c <char* itos<int, true>(int, char*, unsigned int)>:
  char *pos = buf + buflen;
   19c0c:	4411      	add	r1, r2
  *--pos = '\0';
   19c0e:	2300      	movs	r3, #0
char *itos(type value, char *buf, size_t buflen) {
   19c10:	b530      	push	{r4, r5, lr}
  *--pos = '\0';
   19c12:	f801 3c01 	strb.w	r3, [r1, #-1]
  if (!value) {
   19c16:	1e03      	subs	r3, r0, #0
   19c18:	d107      	bne.n	19c2a <char* itos<int, true>(int, char*, unsigned int)+0x1e>
    *--pos = '0';
   19c1a:	2330      	movs	r3, #48	; 0x30
   19c1c:	f801 3c02 	strb.w	r3, [r1, #-2]
      *--pos = ' ';
   19c20:	2320      	movs	r3, #32
   19c22:	1ec8      	subs	r0, r1, #3
   19c24:	f801 3c03 	strb.w	r3, [r1, #-3]
}
   19c28:	bd30      	pop	{r4, r5, pc}
    if (value < 0)  {
   19c2a:	da12      	bge.n	19c52 <char* itos<int, true>(int, char*, unsigned int)+0x46>
      value = -value;
   19c2c:	425b      	negs	r3, r3
      sign = '-';
   19c2e:	222d      	movs	r2, #45	; 0x2d
  *--pos = '\0';
   19c30:	3901      	subs	r1, #1
      *--pos = '0' + value % 10;
   19c32:	240a      	movs	r4, #10
   19c34:	fbb3 f5f4 	udiv	r5, r3, r4
   19c38:	fb04 3315 	mls	r3, r4, r5, r3
   19c3c:	3330      	adds	r3, #48	; 0x30
   19c3e:	4608      	mov	r0, r1
   19c40:	f801 3d01 	strb.w	r3, [r1, #-1]!
    while (value) {
   19c44:	462b      	mov	r3, r5
   19c46:	2d00      	cmp	r5, #0
   19c48:	d1f4      	bne.n	19c34 <char* itos<int, true>(int, char*, unsigned int)+0x28>
      *--pos = sign;
   19c4a:	3802      	subs	r0, #2
   19c4c:	f801 2c01 	strb.w	r2, [r1, #-1]
  return pos;
   19c50:	e7ea      	b.n	19c28 <char* itos<int, true>(int, char*, unsigned int)+0x1c>
      sign = '+';
   19c52:	222b      	movs	r2, #43	; 0x2b
   19c54:	e7ec      	b.n	19c30 <char* itos<int, true>(int, char*, unsigned int)+0x24>

00019c56 <weegfx::Graphics::pretty_print(int, unsigned int)>:
void Graphics::pretty_print(int value, unsigned width) {
   19c56:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  char *str = itos<int, true>(value, buf, sizeof(buf));
   19c58:	ae01      	add	r6, sp, #4
void Graphics::pretty_print(int value, unsigned width) {
   19c5a:	4614      	mov	r4, r2
   19c5c:	4605      	mov	r5, r0
  char *str = itos<int, true>(value, buf, sizeof(buf));
   19c5e:	220c      	movs	r2, #12
void Graphics::pretty_print(int value, unsigned width) {
   19c60:	4608      	mov	r0, r1
  char *str = itos<int, true>(value, buf, sizeof(buf));
   19c62:	4631      	mov	r1, r6
   19c64:	f7ff ffd2 	bl	19c0c <char* itos<int, true>(int, char*, unsigned int)>
         (unsigned)(str - buf) >= sizeof(buf) - width)
   19c68:	f1c4 040c 	rsb	r4, r4, #12
  char *str = itos<int, true>(value, buf, sizeof(buf));
   19c6c:	4601      	mov	r1, r0
    *--str = ' ';
   19c6e:	2220      	movs	r2, #32
  while (str > buf &&
   19c70:	42b1      	cmp	r1, r6
   19c72:	d804      	bhi.n	19c7e <weegfx::Graphics::pretty_print(int, unsigned int)+0x28>
  print(str);
   19c74:	4628      	mov	r0, r5
   19c76:	f7ff ff2e 	bl	19ad6 <weegfx::Graphics::print(char const*)>
}
   19c7a:	b004      	add	sp, #16
   19c7c:	bd70      	pop	{r4, r5, r6, pc}
         (unsigned)(str - buf) >= sizeof(buf) - width)
   19c7e:	1b8b      	subs	r3, r1, r6
  while (str > buf &&
   19c80:	42a3      	cmp	r3, r4
   19c82:	d3f7      	bcc.n	19c74 <weegfx::Graphics::pretty_print(int, unsigned int)+0x1e>
    *--str = ' ';
   19c84:	f801 2d01 	strb.w	r2, [r1, #-1]!
   19c88:	e7f2      	b.n	19c70 <weegfx::Graphics::pretty_print(int, unsigned int)+0x1a>
   19c8a:	Address 0x0000000000019c8a is out of bounds.


00019c8c <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
   19c8c:	b530      	push	{r4, r5, lr}
	uint32_t ch = 0;

	__disable_irq();
   19c8e:	b672      	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
   19c90:	4c24      	ldr	r4, [pc, #144]	; (19d24 <DMAChannel::begin(bool)+0x98>)
   19c92:	b989      	cbnz	r1, 19cb8 <DMAChannel::begin(bool)+0x2c>
   19c94:	6801      	ldr	r1, [r0, #0]
   19c96:	b179      	cbz	r1, 19cb8 <DMAChannel::begin(bool)+0x2c>
   19c98:	7903      	ldrb	r3, [r0, #4]
   19c9a:	2b0f      	cmp	r3, #15
   19c9c:	d80c      	bhi.n	19cb8 <DMAChannel::begin(bool)+0x2c>
	  && (dma_channel_allocated_mask & (1 << channel))
   19c9e:	8822      	ldrh	r2, [r4, #0]
   19ca0:	411a      	asrs	r2, r3
   19ca2:	07d2      	lsls	r2, r2, #31
   19ca4:	d508      	bpl.n	19cb8 <DMAChannel::begin(bool)+0x2c>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
   19ca6:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
   19caa:	f503 6390 	add.w	r3, r3, #1152	; 0x480
   19cae:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
   19cb2:	d101      	bne.n	19cb8 <DMAChannel::begin(bool)+0x2c>
		// DMA channel already allocated
		__enable_irq();
   19cb4:	b662      	cpsie	i
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
}
   19cb6:	bd30      	pop	{r4, r5, pc}
		if (!(dma_channel_allocated_mask & (1 << ch))) {
   19cb8:	8821      	ldrh	r1, [r4, #0]
   19cba:	2300      	movs	r3, #0
   19cbc:	fa41 f203 	asr.w	r2, r1, r3
   19cc0:	f012 0201 	ands.w	r2, r2, #1
   19cc4:	d126      	bne.n	19d14 <DMAChannel::begin(bool)+0x88>
			dma_channel_allocated_mask |= (1 << ch);
   19cc6:	2501      	movs	r5, #1
   19cc8:	409d      	lsls	r5, r3
   19cca:	4329      	orrs	r1, r5
   19ccc:	8021      	strh	r1, [r4, #0]
			__enable_irq();
   19cce:	b662      	cpsie	i
	SIM_SCGC7 |= SIM_SCGC7_DMA;
   19cd0:	4915      	ldr	r1, [pc, #84]	; (19d28 <DMAChannel::begin(bool)+0x9c>)
	channel = ch;
   19cd2:	b2dc      	uxtb	r4, r3
   19cd4:	7104      	strb	r4, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
   19cd6:	6c0d      	ldr	r5, [r1, #64]	; 0x40
   19cd8:	f045 0502 	orr.w	r5, r5, #2
   19cdc:	640d      	str	r5, [r1, #64]	; 0x40
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
   19cde:	6bcd      	ldr	r5, [r1, #60]	; 0x3c
	TCD = (TCD_t *)(0x40009000 + ch * 32);
   19ce0:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
   19ce4:	f045 0502 	orr.w	r5, r5, #2
   19ce8:	63cd      	str	r5, [r1, #60]	; 0x3c
	TCD = (TCD_t *)(0x40009000 + ch * 32);
   19cea:	f503 6390 	add.w	r3, r3, #1152	; 0x480
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
   19cee:	f5a1 2180 	sub.w	r1, r1, #262144	; 0x40000
	TCD = (TCD_t *)(0x40009000 + ch * 32);
   19cf2:	015b      	lsls	r3, r3, #5
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
   19cf4:	2582      	movs	r5, #130	; 0x82
   19cf6:	600d      	str	r5, [r1, #0]
	DMA_CERQ = ch;
   19cf8:	768c      	strb	r4, [r1, #26]
	DMA_CERR = ch;
   19cfa:	778c      	strb	r4, [r1, #30]
	DMA_CEEI = ch;
   19cfc:	760c      	strb	r4, [r1, #24]
	DMA_CINT = ch;
   19cfe:	77cc      	strb	r4, [r1, #31]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
   19d00:	6003      	str	r3, [r0, #0]
	*p++ = 0;
   19d02:	e9c3 2200 	strd	r2, r2, [r3]
	*p++ = 0;
   19d06:	e9c3 2202 	strd	r2, r2, [r3, #8]
	*p++ = 0;
   19d0a:	e9c3 2204 	strd	r2, r2, [r3, #16]
	*p++ = 0;
   19d0e:	e9c3 2206 	strd	r2, r2, [r3, #24]
   19d12:	e7d0      	b.n	19cb6 <DMAChannel::begin(bool)+0x2a>
		if (++ch >= DMA_MAX_CHANNELS) {
   19d14:	3301      	adds	r3, #1
   19d16:	2b10      	cmp	r3, #16
   19d18:	d1d0      	bne.n	19cbc <DMAChannel::begin(bool)+0x30>
			__enable_irq();
   19d1a:	b662      	cpsie	i
			TCD = (TCD_t *)0;
   19d1c:	2200      	movs	r2, #0
   19d1e:	6002      	str	r2, [r0, #0]
			channel = DMA_MAX_CHANNELS;
   19d20:	7103      	strb	r3, [r0, #4]
			return; // no more channels available
   19d22:	e7c8      	b.n	19cb6 <DMAChannel::begin(bool)+0x2a>
   19d24:	200065ec 	.word	0x200065ec
   19d28:	40048000 	.word	0x40048000

00019d2c <DMAChannel::release()>:

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
   19d2c:	7903      	ldrb	r3, [r0, #4]
   19d2e:	2b0f      	cmp	r3, #15
   19d30:	d80f      	bhi.n	19d52 <DMAChannel::release()+0x26>
	DMA_CERQ = channel;
   19d32:	4a08      	ldr	r2, [pc, #32]	; (19d54 <DMAChannel::release()+0x28>)
   19d34:	7693      	strb	r3, [r2, #26]
	__disable_irq();
   19d36:	b672      	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
   19d38:	4907      	ldr	r1, [pc, #28]	; (19d58 <DMAChannel::release()+0x2c>)
   19d3a:	7903      	ldrb	r3, [r0, #4]
   19d3c:	2201      	movs	r2, #1
   19d3e:	409a      	lsls	r2, r3
   19d40:	880b      	ldrh	r3, [r1, #0]
   19d42:	ea23 0302 	bic.w	r3, r3, r2
   19d46:	800b      	strh	r3, [r1, #0]
	__enable_irq();
   19d48:	b662      	cpsie	i
	channel = DMA_MAX_CHANNELS;
   19d4a:	2310      	movs	r3, #16
   19d4c:	7103      	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
   19d4e:	2300      	movs	r3, #0
   19d50:	6003      	str	r3, [r0, #0]
}
   19d52:	4770      	bx	lr
   19d54:	40008000 	.word	0x40008000
   19d58:	200065ec 	.word	0x200065ec

00019d5c <dummy_funct()>:
}
#endif

static void dummy_funct(void)
{
}
   19d5c:	4770      	bx	lr
   19d5e:	Address 0x0000000000019d5e is out of bounds.


00019d60 <IntervalTimer::beginCycles(void (*)(), unsigned long)>:
	if (channel) {
   19d60:	6803      	ldr	r3, [r0, #0]
{
   19d62:	b530      	push	{r4, r5, lr}
   19d64:	4604      	mov	r4, r0
	if (channel) {
   19d66:	b1eb      	cbz	r3, 19da4 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x44>
		channel->TCTRL = 0;
   19d68:	2000      	movs	r0, #0
   19d6a:	6098      	str	r0, [r3, #8]
		channel->TFLG = 1;
   19d6c:	2001      	movs	r0, #1
   19d6e:	60d8      	str	r0, [r3, #12]
	int index = channel - KINETISK_PIT_CHANNELS;
   19d70:	6820      	ldr	r0, [r4, #0]
   19d72:	4b18      	ldr	r3, [pc, #96]	; (19dd4 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x74>)
	channel->LDVAL = cycles;
   19d74:	6002      	str	r2, [r0, #0]
	int index = channel - KINETISK_PIT_CHANNELS;
   19d76:	4403      	add	r3, r0
   19d78:	111b      	asrs	r3, r3, #4
	channel->TCTRL = 3;
   19d7a:	2203      	movs	r2, #3
	funct_table[index] = funct;
   19d7c:	4d16      	ldr	r5, [pc, #88]	; (19dd8 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x78>)
	channel->TCTRL = 3;
   19d7e:	6082      	str	r2, [r0, #8]
	NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
   19d80:	4a16      	ldr	r2, [pc, #88]	; (19ddc <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x7c>)
	funct_table[index] = funct;
   19d82:	f845 1023 	str.w	r1, [r5, r3, lsl #2]
	NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
   19d86:	7921      	ldrb	r1, [r4, #4]
   19d88:	5499      	strb	r1, [r3, r2]
	NVIC_ENABLE_IRQ(IRQ_PIT_CH0 + index);
   19d8a:	3344      	adds	r3, #68	; 0x44
   19d8c:	115a      	asrs	r2, r3, #5
   19d8e:	f102 2238 	add.w	r2, r2, #939538432	; 0x38003800
   19d92:	3240      	adds	r2, #64	; 0x40
   19d94:	0092      	lsls	r2, r2, #2
   19d96:	f003 031f 	and.w	r3, r3, #31
   19d9a:	2001      	movs	r0, #1
   19d9c:	fa00 f303 	lsl.w	r3, r0, r3
   19da0:	6013      	str	r3, [r2, #0]
	return true;
   19da2:	e016      	b.n	19dd2 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x72>
		SIM_SCGC6 |= SIM_SCGC6_PIT;
   19da4:	480e      	ldr	r0, [pc, #56]	; (19de0 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x80>)
   19da6:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
   19da8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   19dac:	63c3      	str	r3, [r0, #60]	; 0x3c
		__asm__ volatile("nop"); // solves timing problem on Teensy 3.5
   19dae:	bf00      	nop
		PIT_MCR = 1;
   19db0:	4b0c      	ldr	r3, [pc, #48]	; (19de4 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x84>)
   19db2:	2001      	movs	r0, #1
   19db4:	6018      	str	r0, [r3, #0]
		channel = KINETISK_PIT_CHANNELS;
   19db6:	f503 7380 	add.w	r3, r3, #256	; 0x100
			if (++channel >= KINETISK_PIT_CHANNELS + NUM_CHANNELS) {
   19dba:	480b      	ldr	r0, [pc, #44]	; (19de8 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x88>)
		channel = KINETISK_PIT_CHANNELS;
   19dbc:	6023      	str	r3, [r4, #0]
			if (channel->TCTRL == 0) break;
   19dbe:	6823      	ldr	r3, [r4, #0]
   19dc0:	689d      	ldr	r5, [r3, #8]
   19dc2:	2d00      	cmp	r5, #0
   19dc4:	d0d4      	beq.n	19d70 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x10>
			if (++channel >= KINETISK_PIT_CHANNELS + NUM_CHANNELS) {
   19dc6:	3310      	adds	r3, #16
   19dc8:	4283      	cmp	r3, r0
   19dca:	6023      	str	r3, [r4, #0]
   19dcc:	d9f7      	bls.n	19dbe <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x5e>
				channel = NULL;
   19dce:	2000      	movs	r0, #0
   19dd0:	6020      	str	r0, [r4, #0]
}
   19dd2:	bd30      	pop	{r4, r5, pc}
   19dd4:	bffc8f00 	.word	0xbffc8f00
   19dd8:	1fffa0d8 	.word	0x1fffa0d8
   19ddc:	e000e444 	.word	0xe000e444
   19de0:	40048000 	.word	0x40048000
   19de4:	40037000 	.word	0x40037000
   19de8:	4003713f 	.word	0x4003713f

00019dec <IntervalTimer::end()>:
void IntervalTimer::end() {
   19dec:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (channel) {
   19dee:	6804      	ldr	r4, [r0, #0]
   19df0:	b1cc      	cbz	r4, 19e26 <IntervalTimer::end()+0x3a>
		int index = channel - KINETISK_PIT_CHANNELS;
   19df2:	490d      	ldr	r1, [pc, #52]	; (19e28 <IntervalTimer::end()+0x3c>)
		funct_table[index] = dummy_funct;
   19df4:	4e0d      	ldr	r6, [pc, #52]	; (19e2c <IntervalTimer::end()+0x40>)
   19df6:	4f0e      	ldr	r7, [pc, #56]	; (19e30 <IntervalTimer::end()+0x44>)
		int index = channel - KINETISK_PIT_CHANNELS;
   19df8:	4421      	add	r1, r4
   19dfa:	1109      	asrs	r1, r1, #4
		NVIC_DISABLE_IRQ(IRQ_PIT_CH0 + index);
   19dfc:	f101 0244 	add.w	r2, r1, #68	; 0x44
   19e00:	1153      	asrs	r3, r2, #5
   19e02:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
   19e06:	3360      	adds	r3, #96	; 0x60
   19e08:	009b      	lsls	r3, r3, #2
   19e0a:	2501      	movs	r5, #1
   19e0c:	f002 021f 	and.w	r2, r2, #31
   19e10:	fa05 f202 	lsl.w	r2, r5, r2
		funct_table[index] = dummy_funct;
   19e14:	f846 7021 	str.w	r7, [r6, r1, lsl #2]
		channel->TCTRL = 0;
   19e18:	2100      	movs	r1, #0
		NVIC_DISABLE_IRQ(IRQ_PIT_CH0 + index);
   19e1a:	601a      	str	r2, [r3, #0]
		channel->TCTRL = 0;
   19e1c:	60a1      	str	r1, [r4, #8]
		channel->TFLG = 1;
   19e1e:	60e5      	str	r5, [r4, #12]
		NVIC_CLEAR_PENDING(IRQ_PIT_CH0 + index);
   19e20:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
		channel = 0;
   19e24:	6001      	str	r1, [r0, #0]
}
   19e26:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19e28:	bffc8f00 	.word	0xbffc8f00
   19e2c:	1fffa0d8 	.word	0x1fffa0d8
   19e30:	00019d5d 	.word	0x00019d5d

00019e34 <pit0_isr>:
	PIT_TFLG0 = 1;
   19e34:	4b03      	ldr	r3, [pc, #12]	; (19e44 <pit0_isr+0x10>)
   19e36:	2201      	movs	r2, #1
   19e38:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	funct_table[0]();
   19e3c:	4b02      	ldr	r3, [pc, #8]	; (19e48 <pit0_isr+0x14>)
   19e3e:	681b      	ldr	r3, [r3, #0]
   19e40:	4718      	bx	r3
   19e42:	bf00      	nop
   19e44:	40037000 	.word	0x40037000
   19e48:	1fffa0d8 	.word	0x1fffa0d8

00019e4c <pit1_isr>:
	PIT_TFLG1 = 1;
   19e4c:	4b03      	ldr	r3, [pc, #12]	; (19e5c <pit1_isr+0x10>)
   19e4e:	2201      	movs	r2, #1
   19e50:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
	funct_table[1]();
   19e54:	4b02      	ldr	r3, [pc, #8]	; (19e60 <pit1_isr+0x14>)
   19e56:	685b      	ldr	r3, [r3, #4]
   19e58:	4718      	bx	r3
   19e5a:	bf00      	nop
   19e5c:	40037000 	.word	0x40037000
   19e60:	1fffa0d8 	.word	0x1fffa0d8

00019e64 <pit2_isr>:
	PIT_TFLG2 = 1;
   19e64:	4b03      	ldr	r3, [pc, #12]	; (19e74 <pit2_isr+0x10>)
   19e66:	2201      	movs	r2, #1
   19e68:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
	funct_table[2]();
   19e6c:	4b02      	ldr	r3, [pc, #8]	; (19e78 <pit2_isr+0x14>)
   19e6e:	689b      	ldr	r3, [r3, #8]
   19e70:	4718      	bx	r3
   19e72:	bf00      	nop
   19e74:	40037000 	.word	0x40037000
   19e78:	1fffa0d8 	.word	0x1fffa0d8

00019e7c <pit3_isr>:
	PIT_TFLG3 = 1;
   19e7c:	4b03      	ldr	r3, [pc, #12]	; (19e8c <pit3_isr+0x10>)
   19e7e:	2201      	movs	r2, #1
   19e80:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
	funct_table[3]();
   19e84:	4b02      	ldr	r3, [pc, #8]	; (19e90 <pit3_isr+0x14>)
   19e86:	68db      	ldr	r3, [r3, #12]
   19e88:	4718      	bx	r3
   19e8a:	bf00      	nop
   19e8c:	40037000 	.word	0x40037000
   19e90:	1fffa0d8 	.word	0x1fffa0d8

00019e94 <random()>:
int32_t random(void)
{
	int32_t hi, lo, x;

	// the algorithm used in avr-libc 1.6.4
	x = seed;
   19e94:	4a0c      	ldr	r2, [pc, #48]	; (19ec8 <random()+0x34>)
	if (x == 0) x = 123459876;
   19e96:	490d      	ldr	r1, [pc, #52]	; (19ecc <random()+0x38>)
	x = seed;
   19e98:	6813      	ldr	r3, [r2, #0]
	if (x == 0) x = 123459876;
   19e9a:	2b00      	cmp	r3, #0
   19e9c:	bf08      	it	eq
   19e9e:	460b      	moveq	r3, r1
	hi = x / 127773;
	lo = x % 127773;
   19ea0:	490b      	ldr	r1, [pc, #44]	; (19ed0 <random()+0x3c>)
   19ea2:	fb93 f0f1 	sdiv	r0, r3, r1
   19ea6:	fb01 3310 	mls	r3, r1, r0, r3
	x = 16807 * lo - 2836 * hi;
   19eaa:	490a      	ldr	r1, [pc, #40]	; (19ed4 <random()+0x40>)
   19eac:	4348      	muls	r0, r1
   19eae:	f244 11a7 	movw	r1, #16807	; 0x41a7
   19eb2:	fb01 0003 	mla	r0, r1, r3, r0
	if (x < 0) x += 0x7FFFFFFF;
   19eb6:	2800      	cmp	r0, #0
   19eb8:	bfbc      	itt	lt
   19eba:	f100 4000 	addlt.w	r0, r0, #2147483648	; 0x80000000
   19ebe:	f100 30ff 	addlt.w	r0, r0, #4294967295	; 0xffffffff
	seed = x;
   19ec2:	6010      	str	r0, [r2, #0]
	return x;
}
   19ec4:	4770      	bx	lr
   19ec6:	bf00      	nop
   19ec8:	200065f0 	.word	0x200065f0
   19ecc:	075bd924 	.word	0x075bd924
   19ed0:	0001f31d 	.word	0x0001f31d
   19ed4:	fffff4ec 	.word	0xfffff4ec

00019ed8 <random(unsigned long)>:

uint32_t random(uint32_t howbig)
{
   19ed8:	b510      	push	{r4, lr}
	if (howbig == 0) return 0;
   19eda:	4604      	mov	r4, r0
   19edc:	b128      	cbz	r0, 19eea <random(unsigned long)+0x12>
	return random() % howbig;
   19ede:	f7ff ffd9 	bl	19e94 <random()>
   19ee2:	fbb0 f3f4 	udiv	r3, r0, r4
   19ee6:	fb03 0414 	mls	r4, r3, r4, r0
}
   19eea:	4620      	mov	r0, r4
   19eec:	bd10      	pop	{r4, pc}

00019eee <random(long, long)>:

int32_t random(int32_t howsmall, int32_t howbig)
{
	if (howsmall >= howbig) return howsmall;
   19eee:	4288      	cmp	r0, r1
{
   19ef0:	b510      	push	{r4, lr}
   19ef2:	4604      	mov	r4, r0
	if (howsmall >= howbig) return howsmall;
   19ef4:	da03      	bge.n	19efe <random(long, long)+0x10>
	int32_t diff = howbig - howsmall;
	return random(diff) + howsmall;
   19ef6:	1a08      	subs	r0, r1, r0
   19ef8:	f7ff ffee 	bl	19ed8 <random(unsigned long)>
   19efc:	4404      	add	r4, r0
}
   19efe:	4620      	mov	r0, r4
   19f00:	bd10      	pop	{r4, pc}
   19f02:	Address 0x0000000000019f02 is out of bounds.


00019f04 <flexram_wait>:
	return (FTFL_FCNFG & FTFL_FCNFG_EEERDY) ? 1 : 0;
}

static void flexram_wait(void)
{
	while (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) {
   19f04:	4a02      	ldr	r2, [pc, #8]	; (19f10 <flexram_wait+0xc>)
   19f06:	7853      	ldrb	r3, [r2, #1]
   19f08:	07db      	lsls	r3, r3, #31
   19f0a:	d5fc      	bpl.n	19f06 <flexram_wait+0x2>
		// TODO: timeout
	}
}
   19f0c:	4770      	bx	lr
   19f0e:	bf00      	nop
   19f10:	40020000 	.word	0x40020000

00019f14 <eeprom_initialize>:
{
   19f14:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	if (FTFL_FCNFG & FTFL_FCNFG_RAMRDY) {
   19f16:	4c16      	ldr	r4, [pc, #88]	; (19f70 <eeprom_initialize+0x5c>)
	uint16_t do_flash_cmd[] = {
   19f18:	4916      	ldr	r1, [pc, #88]	; (19f74 <eeprom_initialize+0x60>)
   19f1a:	466b      	mov	r3, sp
   19f1c:	2210      	movs	r2, #16
   19f1e:	4618      	mov	r0, r3
   19f20:	f000 f866 	bl	19ff0 <memcpy>
	if (FTFL_FCNFG & FTFL_FCNFG_RAMRDY) {
   19f24:	7862      	ldrb	r2, [r4, #1]
   19f26:	0791      	lsls	r1, r2, #30
   19f28:	d407      	bmi.n	19f3a <eeprom_initialize+0x26>
{
   19f2a:	4b13      	ldr	r3, [pc, #76]	; (19f78 <eeprom_initialize+0x64>)
	while (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) {
   19f2c:	4910      	ldr	r1, [pc, #64]	; (19f70 <eeprom_initialize+0x5c>)
   19f2e:	784a      	ldrb	r2, [r1, #1]
   19f30:	07d2      	lsls	r2, r2, #31
   19f32:	d41a      	bmi.n	19f6a <eeprom_initialize+0x56>
		if (++count > 200000) break;
   19f34:	3b01      	subs	r3, #1
   19f36:	d1fa      	bne.n	19f2e <eeprom_initialize+0x1a>
   19f38:	e017      	b.n	19f6a <eeprom_initialize+0x56>
		uint8_t stat = FTFL_FSTAT & 0x70;
   19f3a:	7822      	ldrb	r2, [r4, #0]
		if (stat) FTFL_FSTAT = stat;
   19f3c:	f012 0270 	ands.w	r2, r2, #112	; 0x70
   19f40:	bf18      	it	ne
   19f42:	7022      	strbne	r2, [r4, #0]
		FTFL_FCCOB0 = 0x80; // PGMPART = Program Partition Command
   19f44:	2280      	movs	r2, #128	; 0x80
   19f46:	71e2      	strb	r2, [r4, #7]
		FTFL_FCCOB3 = 0;
   19f48:	2200      	movs	r2, #0
   19f4a:	7122      	strb	r2, [r4, #4]
		FTFL_FCCOB4 = EEESPLIT | EEESIZE;
   19f4c:	2233      	movs	r2, #51	; 0x33
   19f4e:	72e2      	strb	r2, [r4, #11]
		FTFL_FCCOB5 = EEPARTITION;
   19f50:	2203      	movs	r2, #3
   19f52:	72a2      	strb	r2, [r4, #10]
		__disable_irq();
   19f54:	b672      	cpsid	i
		(*((void (*)(volatile uint8_t *))((uint32_t)do_flash_cmd | 1)))(&FTFL_FSTAT);
   19f56:	f040 0301 	orr.w	r3, r0, #1
   19f5a:	4805      	ldr	r0, [pc, #20]	; (19f70 <eeprom_initialize+0x5c>)
   19f5c:	4798      	blx	r3
		__enable_irq();
   19f5e:	b662      	cpsie	i
		status = FTFL_FSTAT;
   19f60:	7823      	ldrb	r3, [r4, #0]
		if (status & 0x70) {
   19f62:	f013 0370 	ands.w	r3, r3, #112	; 0x70
   19f66:	d0e0      	beq.n	19f2a <eeprom_initialize+0x16>
			FTFL_FSTAT = (status & 0x70);
   19f68:	7023      	strb	r3, [r4, #0]
}
   19f6a:	b004      	add	sp, #16
   19f6c:	bd10      	pop	{r4, pc}
   19f6e:	bf00      	nop
   19f70:	40020000 	.word	0x40020000
   19f74:	00027af4 	.word	0x00027af4
   19f78:	00030d41 	.word	0x00030d41

00019f7c <eeprom_read_byte>:
	if (offset >= EEPROM_SIZE) return 0;
   19f7c:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
{
   19f80:	b510      	push	{r4, lr}
   19f82:	4604      	mov	r4, r0
	if (offset >= EEPROM_SIZE) return 0;
   19f84:	d20a      	bcs.n	19f9c <eeprom_read_byte+0x20>
	if (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) eeprom_initialize();
   19f86:	4b06      	ldr	r3, [pc, #24]	; (19fa0 <eeprom_read_byte+0x24>)
   19f88:	785b      	ldrb	r3, [r3, #1]
   19f8a:	07db      	lsls	r3, r3, #31
   19f8c:	d401      	bmi.n	19f92 <eeprom_read_byte+0x16>
   19f8e:	f7ff ffc1 	bl	19f14 <eeprom_initialize>
	return FlexRAM[offset];
   19f92:	f104 54a0 	add.w	r4, r4, #335544320	; 0x14000000
   19f96:	7820      	ldrb	r0, [r4, #0]
   19f98:	b2c0      	uxtb	r0, r0
}
   19f9a:	bd10      	pop	{r4, pc}
	if (offset >= EEPROM_SIZE) return 0;
   19f9c:	2000      	movs	r0, #0
   19f9e:	e7fc      	b.n	19f9a <eeprom_read_byte+0x1e>
   19fa0:	40020000 	.word	0x40020000

00019fa4 <eeprom_write_byte>:

void eeprom_write_byte(uint8_t *addr, uint8_t value)
{
	uint32_t offset = (uint32_t)addr;

	if (offset >= EEPROM_SIZE) return;
   19fa4:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
{
   19fa8:	b570      	push	{r4, r5, r6, lr}
   19faa:	4604      	mov	r4, r0
   19fac:	460d      	mov	r5, r1
	if (offset >= EEPROM_SIZE) return;
   19fae:	d214      	bcs.n	19fda <eeprom_write_byte+0x36>
	if (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) eeprom_initialize();
   19fb0:	4e0a      	ldr	r6, [pc, #40]	; (19fdc <eeprom_write_byte+0x38>)
   19fb2:	7873      	ldrb	r3, [r6, #1]
   19fb4:	07db      	lsls	r3, r3, #31
   19fb6:	d401      	bmi.n	19fbc <eeprom_write_byte+0x18>
   19fb8:	f7ff ffac 	bl	19f14 <eeprom_initialize>
	if (FlexRAM[offset] != value) {
   19fbc:	f104 54a0 	add.w	r4, r4, #335544320	; 0x14000000
   19fc0:	7823      	ldrb	r3, [r4, #0]
   19fc2:	42ab      	cmp	r3, r5
   19fc4:	d009      	beq.n	19fda <eeprom_write_byte+0x36>
		kinetis_hsrun_disable();
		uint8_t stat = FTFL_FSTAT & 0x70;
   19fc6:	7833      	ldrb	r3, [r6, #0]
		if (stat) FTFL_FSTAT = stat;
   19fc8:	f013 0370 	ands.w	r3, r3, #112	; 0x70
   19fcc:	bf18      	it	ne
   19fce:	7033      	strbne	r3, [r6, #0]
		FlexRAM[offset] = value;
   19fd0:	7025      	strb	r5, [r4, #0]
		flexram_wait();
		kinetis_hsrun_enable();
	}
}
   19fd2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		flexram_wait();
   19fd6:	f7ff bf95 	b.w	19f04 <flexram_wait>
}
   19fda:	bd70      	pop	{r4, r5, r6, pc}
   19fdc:	40020000 	.word	0x40020000

00019fe0 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
   19fe0:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
   19fe2:	f7fd fb1f 	bl	17624 <setup>
	while (1) {
		loop();
   19fe6:	f00e f85b 	bl	280a0 <__loop_veneer>
		yield();
   19fea:	f001 f9b7 	bl	1b35c <yield>
	while (1) {
   19fee:	e7fa      	b.n	19fe6 <main+0x6>

00019ff0 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
   19ff0:	b401      	push	{r0}
#endif
	orr	r3, r1, r0
   19ff2:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
   19ff6:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
   19ffa:	d16f      	bne.n	1a0dc <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
   19ffc:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
   19ffe:	d341      	bcc.n	1a084 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
   1a000:	f851 3b04 	ldr.w	r3, [r1], #4
   1a004:	f840 3b04 	str.w	r3, [r0], #4
   1a008:	f851 3b04 	ldr.w	r3, [r1], #4
   1a00c:	f840 3b04 	str.w	r3, [r0], #4
   1a010:	f851 3b04 	ldr.w	r3, [r1], #4
   1a014:	f840 3b04 	str.w	r3, [r0], #4
   1a018:	f851 3b04 	ldr.w	r3, [r1], #4
   1a01c:	f840 3b04 	str.w	r3, [r0], #4
   1a020:	f851 3b04 	ldr.w	r3, [r1], #4
   1a024:	f840 3b04 	str.w	r3, [r0], #4
   1a028:	f851 3b04 	ldr.w	r3, [r1], #4
   1a02c:	f840 3b04 	str.w	r3, [r0], #4
   1a030:	f851 3b04 	ldr.w	r3, [r1], #4
   1a034:	f840 3b04 	str.w	r3, [r0], #4
   1a038:	f851 3b04 	ldr.w	r3, [r1], #4
   1a03c:	f840 3b04 	str.w	r3, [r0], #4
   1a040:	f851 3b04 	ldr.w	r3, [r1], #4
   1a044:	f840 3b04 	str.w	r3, [r0], #4
   1a048:	f851 3b04 	ldr.w	r3, [r1], #4
   1a04c:	f840 3b04 	str.w	r3, [r0], #4
   1a050:	f851 3b04 	ldr.w	r3, [r1], #4
   1a054:	f840 3b04 	str.w	r3, [r0], #4
   1a058:	f851 3b04 	ldr.w	r3, [r1], #4
   1a05c:	f840 3b04 	str.w	r3, [r0], #4
   1a060:	f851 3b04 	ldr.w	r3, [r1], #4
   1a064:	f840 3b04 	str.w	r3, [r0], #4
   1a068:	f851 3b04 	ldr.w	r3, [r1], #4
   1a06c:	f840 3b04 	str.w	r3, [r0], #4
   1a070:	f851 3b04 	ldr.w	r3, [r1], #4
   1a074:	f840 3b04 	str.w	r3, [r0], #4
   1a078:	f851 3b04 	ldr.w	r3, [r1], #4
   1a07c:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
   1a080:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
   1a082:	d2bd      	bcs.n	1a000 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
   1a084:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
   1a086:	d311      	bcc.n	1a0ac <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
   1a088:	f851 3b04 	ldr.w	r3, [r1], #4
   1a08c:	f840 3b04 	str.w	r3, [r0], #4
   1a090:	f851 3b04 	ldr.w	r3, [r1], #4
   1a094:	f840 3b04 	str.w	r3, [r0], #4
   1a098:	f851 3b04 	ldr.w	r3, [r1], #4
   1a09c:	f840 3b04 	str.w	r3, [r0], #4
   1a0a0:	f851 3b04 	ldr.w	r3, [r1], #4
   1a0a4:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
   1a0a8:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
   1a0aa:	d2ed      	bcs.n	1a088 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
   1a0ac:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
   1a0ae:	d305      	bcc.n	1a0bc <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
   1a0b0:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
   1a0b4:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
   1a0b8:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
   1a0ba:	d2f9      	bcs.n	1a0b0 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
   1a0bc:	3204      	adds	r2, #4
	beq	.Ldone
   1a0be:	d00a      	beq.n	1a0d6 <memcpy+0xe6>

	lsls	r2, r2, #31
   1a0c0:	07d2      	lsls	r2, r2, #31
	itt ne
   1a0c2:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
   1a0c4:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
   1a0c8:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
   1a0cc:	d303      	bcc.n	1a0d6 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
   1a0ce:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
   1a0d0:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
   1a0d2:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
   1a0d4:	7043      	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
   1a0d6:	bc01      	pop	{r0}
#endif
	bx	lr
   1a0d8:	4770      	bx	lr
   1a0da:	bf00      	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
   1a0dc:	2a0c      	cmp	r2, #12
	blo	.Lbyte_copy
   1a0de:	d34a      	bcc.n	1a176 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
   1a0e0:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
   1a0e4:	d011      	beq.n	1a10a <memcpy+0x11a>

	rsb	r3, #4
   1a0e6:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
   1a0ea:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
   1a0ec:	07db      	lsls	r3, r3, #31
	itt ne
   1a0ee:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
   1a0f0:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
   1a0f4:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
   1a0f8:	d307      	bcc.n	1a10a <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
   1a0fa:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
   1a0fe:	f800 3b01 	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
   1a102:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
   1a106:	f800 3b01 	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
   1a10a:	f011 0303 	ands.w	r3, r1, #3
	beq	.Lbig_block
   1a10e:	f43f af75 	beq.w	19ffc <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
   1a112:	b430      	push	{r4, r5}
	subs	r2, #4
   1a114:	3a04      	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
   1a116:	1ac9      	subs	r1, r1, r3
	rsb	ip, r3, #4
   1a118:	f1c3 0c04 	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
   1a11c:	f851 4b04 	ldr.w	r4, [r1], #4

	cmp	r3, #2
   1a120:	2b02      	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
   1a122:	d019      	beq.n	1a158 <memcpy+0x168>
	cmp	r3, #3
   1a124:	2b03      	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
   1a126:	d00b      	beq.n	1a140 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
   1a128:	0a24      	lsrs	r4, r4, #8
   1a12a:	f851 3b04 	ldr.w	r3, [r1], #4
   1a12e:	061d      	lsls	r5, r3, #24
   1a130:	ea44 0405 	orr.w	r4, r4, r5
   1a134:	f840 4b04 	str.w	r4, [r0], #4
   1a138:	461c      	mov	r4, r3
   1a13a:	3a04      	subs	r2, #4
   1a13c:	d2f4      	bcs.n	1a128 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
   1a13e:	e016      	b.n	1a16e <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
   1a140:	0e24      	lsrs	r4, r4, #24
   1a142:	f851 3b04 	ldr.w	r3, [r1], #4
   1a146:	021d      	lsls	r5, r3, #8
   1a148:	ea44 0405 	orr.w	r4, r4, r5
   1a14c:	f840 4b04 	str.w	r4, [r0], #4
   1a150:	461c      	mov	r4, r3
   1a152:	3a04      	subs	r2, #4
   1a154:	d2f4      	bcs.n	1a140 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
   1a156:	e00a      	b.n	1a16e <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
   1a158:	0c24      	lsrs	r4, r4, #16
   1a15a:	f851 3b04 	ldr.w	r3, [r1], #4
   1a15e:	041d      	lsls	r5, r3, #16
   1a160:	ea44 0405 	orr.w	r4, r4, r5
   1a164:	f840 4b04 	str.w	r4, [r0], #4
   1a168:	461c      	mov	r4, r3
   1a16a:	3a04      	subs	r2, #4
   1a16c:	d2f4      	bcs.n	1a158 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
   1a16e:	3204      	adds	r2, #4
	subs	r1, ip
   1a170:	ebb1 010c 	subs.w	r1, r1, ip
	pop	{r4, r5}
   1a174:	bc30      	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
   1a176:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
   1a178:	d3a0      	bcc.n	1a0bc <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
   1a17a:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
   1a17c:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
   1a180:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
   1a184:	d2f9      	bcs.n	1a17a <memcpy+0x18a>

	ldrb	r3, [r1]
   1a186:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
   1a188:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
   1a18a:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
   1a18c:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
   1a18e:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
   1a190:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
   1a192:	bc01      	pop	{r0}
#endif
	bx	lr
   1a194:	4770      	bx	lr
   1a196:	bf00      	nop

0001a198 <memset>:
	.type	memset, %function
	.thumb_func
	memset:
//FUNCTION(memset)
    // save the original pointer
    push    { r0, lr }
   1a198:	b501      	push	{r0, lr}

    // check for zero length
    cbz     r2, .L_done
   1a19a:	b1ea      	cbz	r2, 1a1d8 <memset+0x40>

    // short memsets aren't worth optimizing and make sure we have
    // enough headroom to try to do dwordwise move optimization
    cmp     r2, #16
   1a19c:	2a10      	cmp	r2, #16
    blt     .L_bytewise
   1a19e:	db17      	blt.n	1a1d0 <memset+0x38>

    // see how many bytes we need to move to align to dword boundaries
    and     r3, r0, #7
   1a1a0:	f000 0307 	and.w	r3, r0, #7
    cbz     r3, .L_prepare_dwordwise
   1a1a4:	b133      	cbz	r3, 1a1b4 <memset+0x1c>
    rsb     r3, #8
   1a1a6:	f1c3 0308 	rsb	r3, r3, #8
    subs    r2, r3
   1a1aa:	1ad2      	subs	r2, r2, r3

.L_bytewise_align:
    // bytewise to align memset
    subs    r3, r3, #1
   1a1ac:	3b01      	subs	r3, #1
    strb    r1, [r0], #1
   1a1ae:	f800 1b01 	strb.w	r1, [r0], #1
    bgt     .L_bytewise_align
   1a1b2:	dcfb      	bgt.n	1a1ac <memset+0x14>

.L_prepare_dwordwise:
    // fill a pair of 32 bit registers with the 8 bit value
    uxtb    r1, r1
   1a1b4:	b2c9      	uxtb	r1, r1
    orr     r1, r1, r1, lsl #8
   1a1b6:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
   1a1ba:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    mov     r12, r1
   1a1be:	468c      	mov	ip, r1

    // load the number of dwords left
    lsrs    r3, r2, #3
   1a1c0:	08d3      	lsrs	r3, r2, #3

.L_dwordwise:
    // dwordwise memset
		
    subs    r3, r3, #1
   1a1c2:	3b01      	subs	r3, #1
    strd    r1, r12, [r0], #8
   1a1c4:	e8e0 1c02 	strd	r1, ip, [r0], #8
    bgt     .L_dwordwise
   1a1c8:	dcfb      	bgt.n	1a1c2 <memset+0x2a>

    // remaining bytes
    ands     r2, #7
   1a1ca:	f012 0207 	ands.w	r2, r2, #7
    beq     .L_done
   1a1ce:	d003      	beq.n	1a1d8 <memset+0x40>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
   1a1d0:	3a01      	subs	r2, #1
    strb    r1, [r0], #1
   1a1d2:	f800 1b01 	strb.w	r1, [r0], #1
    bgt     .L_bytewise
   1a1d6:	dcfb      	bgt.n	1a1d0 <memset+0x38>

.L_done:
    // restore the base pointer as return value
    pop     { r0, pc }
   1a1d8:	bd01      	pop	{r0, pc}
   1a1da:	bf00      	nop

0001a1dc <fault_isr>:
{
   1a1dc:	b508      	push	{r3, lr}
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
   1a1de:	4c0b      	ldr	r4, [pc, #44]	; (1a20c <fault_isr+0x30>)
   1a1e0:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1a1e2:	0358      	lsls	r0, r3, #13
   1a1e4:	d501      	bpl.n	1a1ea <fault_isr+0xe>
   1a1e6:	f000 fa2f 	bl	1a648 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
   1a1ea:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1a1ec:	0559      	lsls	r1, r3, #21
   1a1ee:	d501      	bpl.n	1a1f4 <fault_isr+0x18>
   1a1f0:	f000 f80e 	bl	1a210 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
   1a1f4:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1a1f6:	051a      	lsls	r2, r3, #20
   1a1f8:	d501      	bpl.n	1a1fe <fault_isr+0x22>
   1a1fa:	f000 f809 	bl	1a210 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
   1a1fe:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1a200:	04db      	lsls	r3, r3, #19
   1a202:	d5ed      	bpl.n	1a1e0 <fault_isr+0x4>
   1a204:	f000 f804 	bl	1a210 <unused_isr>
   1a208:	e7ea      	b.n	1a1e0 <fault_isr+0x4>
   1a20a:	bf00      	nop
   1a20c:	40048000 	.word	0x40048000

0001a210 <unused_isr>:
{
   1a210:	b508      	push	{r3, lr}
	fault_isr();
   1a212:	f7ff ffe3 	bl	1a1dc <fault_isr>
   1a216:	Address 0x000000000001a216 is out of bounds.


0001a218 <startup_early_hook>:
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
   1a218:	4b01      	ldr	r3, [pc, #4]	; (1a220 <startup_early_hook+0x8>)
   1a21a:	2210      	movs	r2, #16
   1a21c:	801a      	strh	r2, [r3, #0]
}
   1a21e:	4770      	bx	lr
   1a220:	40052000 	.word	0x40052000

0001a224 <startup_late_hook>:
static void startup_default_late_hook(void) {}
   1a224:	4770      	bx	lr
   1a226:	Address 0x000000000001a226 is out of bounds.


0001a228 <_sbrk>:
__attribute__((weak))
void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
   1a228:	4909      	ldr	r1, [pc, #36]	; (1a250 <_sbrk+0x28>)
{
   1a22a:	b508      	push	{r3, lr}
   1a22c:	4603      	mov	r3, r0
	prev = __brkval;
   1a22e:	6808      	ldr	r0, [r1, #0]
	if (incr != 0) {
   1a230:	b15b      	cbz	r3, 1a24a <_sbrk+0x22>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
   1a232:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
   1a234:	4403      	add	r3, r0
   1a236:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
   1a23a:	4293      	cmp	r3, r2
   1a23c:	d306      	bcc.n	1a24c <_sbrk+0x24>
			errno = ENOMEM;
   1a23e:	f003 fad3 	bl	1d7e8 <__errno>
   1a242:	230c      	movs	r3, #12
   1a244:	6003      	str	r3, [r0, #0]
			return (void *)-1;
   1a246:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		}
		__brkval = prev + incr;
	}
	return prev;
}
   1a24a:	bd08      	pop	{r3, pc}
		__brkval = prev + incr;
   1a24c:	600b      	str	r3, [r1, #0]
   1a24e:	e7fc      	b.n	1a24a <_sbrk+0x22>
   1a250:	1fffa0e8 	.word	0x1fffa0e8

0001a254 <operator new(unsigned int)>:

#include "new.h"

void * operator new(size_t size)
{
  return malloc(size);
   1a254:	f003 b9ba 	b.w	1d5cc <malloc>

0001a258 <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
   1a258:	4770      	bx	lr
   1a25a:	Address 0x000000000001a25a is out of bounds.


0001a25c <getIsrTable>:

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
   1a25c:	f100 4040 	add.w	r0, r0, #3221225472	; 0xc0000000
   1a260:	f5a0 2392 	sub.w	r3, r0, #299008	; 0x49000
   1a264:	2b7c      	cmp	r3, #124	; 0x7c
   1a266:	d912      	bls.n	1a28e <getIsrTable+0x32>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
   1a268:	f5a0 2394 	sub.w	r3, r0, #303104	; 0x4a000
   1a26c:	2b7c      	cmp	r3, #124	; 0x7c
   1a26e:	d910      	bls.n	1a292 <getIsrTable+0x36>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
   1a270:	f5a0 2396 	sub.w	r3, r0, #307200	; 0x4b000
   1a274:	2b7c      	cmp	r3, #124	; 0x7c
   1a276:	d90e      	bls.n	1a296 <getIsrTable+0x3a>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
   1a278:	f5a0 2398 	sub.w	r3, r0, #311296	; 0x4c000
   1a27c:	2b7c      	cmp	r3, #124	; 0x7c
   1a27e:	d90c      	bls.n	1a29a <getIsrTable+0x3e>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
   1a280:	f5a0 209a 	sub.w	r0, r0, #315392	; 0x4d000
   1a284:	287c      	cmp	r0, #124	; 0x7c
   1a286:	4806      	ldr	r0, [pc, #24]	; (1a2a0 <getIsrTable+0x44>)
   1a288:	bf88      	it	hi
   1a28a:	2000      	movhi	r0, #0
   1a28c:	4770      	bx	lr
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
   1a28e:	4805      	ldr	r0, [pc, #20]	; (1a2a4 <getIsrTable+0x48>)
   1a290:	4770      	bx	lr
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
   1a292:	4805      	ldr	r0, [pc, #20]	; (1a2a8 <getIsrTable+0x4c>)
   1a294:	4770      	bx	lr
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
   1a296:	4805      	ldr	r0, [pc, #20]	; (1a2ac <getIsrTable+0x50>)
   1a298:	4770      	bx	lr
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
   1a29a:	4805      	ldr	r0, [pc, #20]	; (1a2b0 <getIsrTable+0x54>)
	return isr_table;
}
   1a29c:	4770      	bx	lr
   1a29e:	bf00      	nop
   1a2a0:	1fffa1c4 	.word	0x1fffa1c4
   1a2a4:	1fffa0ec 	.word	0x1fffa0ec
   1a2a8:	1fffa124 	.word	0x1fffa124
   1a2ac:	1fffa174 	.word	0x1fffa174
   1a2b0:	1fffa1a4 	.word	0x1fffa1a4

0001a2b4 <rtc_set>:
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
   1a2b4:	4b03      	ldr	r3, [pc, #12]	; (1a2c4 <rtc_set+0x10>)
   1a2b6:	2200      	movs	r2, #0
   1a2b8:	615a      	str	r2, [r3, #20]
	RTC_TPR = 0;
   1a2ba:	605a      	str	r2, [r3, #4]
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
   1a2bc:	2210      	movs	r2, #16
	RTC_TSR = t;
   1a2be:	6018      	str	r0, [r3, #0]
	RTC_SR = RTC_SR_TCE;
   1a2c0:	615a      	str	r2, [r3, #20]
}
   1a2c2:	4770      	bx	lr
   1a2c4:	4003d000 	.word	0x4003d000

0001a2c8 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
   1a2c8:	4770      	bx	lr
   1a2ca:	Address 0x000000000001a2ca is out of bounds.


0001a2cc <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
   1a2cc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
   1a2d0:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
{
   1a2d4:	b513      	push	{r0, r1, r4, lr}
	NVIC_ENABLE_IRQ(IRQ_PORTA);
   1a2d6:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTB);
   1a2da:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1a2de:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTC);
   1a2e2:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   1a2e6:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTD);
   1a2ea:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   1a2ee:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTE);
   1a2f2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
   1a2f6:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
   1a2fa:	4a19      	ldr	r2, [pc, #100]	; (1a360 <_init_Teensyduino_internal_+0x94>)
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
   1a2fc:	2328      	movs	r3, #40	; 0x28
	FTM0_MOD = DEFAULT_FTM_MOD;
   1a2fe:	f64e 70ff 	movw	r0, #61439	; 0xefff
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
   1a302:	2109      	movs	r1, #9
	FTM0_CNT = 0;
   1a304:	2400      	movs	r4, #0
   1a306:	6054      	str	r4, [r2, #4]
	FTM0_MOD = DEFAULT_FTM_MOD;
   1a308:	6090      	str	r0, [r2, #8]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
   1a30a:	60d3      	str	r3, [r2, #12]
	FTM0_C1SC = 0x28;
   1a30c:	6153      	str	r3, [r2, #20]
	FTM0_C2SC = 0x28;
   1a30e:	61d3      	str	r3, [r2, #28]
	FTM0_C3SC = 0x28;
   1a310:	6253      	str	r3, [r2, #36]	; 0x24
	FTM0_C4SC = 0x28;
   1a312:	62d3      	str	r3, [r2, #44]	; 0x2c
	FTM0_C5SC = 0x28;
   1a314:	6353      	str	r3, [r2, #52]	; 0x34
	FTM0_C6SC = 0x28;
   1a316:	63d3      	str	r3, [r2, #60]	; 0x3c
	FTM0_C7SC = 0x28;
   1a318:	6453      	str	r3, [r2, #68]	; 0x44
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
   1a31a:	6011      	str	r1, [r2, #0]
	FTM1_CNT = 0;
   1a31c:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
   1a320:	6054      	str	r4, [r2, #4]
	FTM1_MOD = DEFAULT_FTM_MOD;
   1a322:	6090      	str	r0, [r2, #8]
	FTM1_C0SC = 0x28;
   1a324:	60d3      	str	r3, [r2, #12]
	FTM1_C1SC = 0x28;
   1a326:	6153      	str	r3, [r2, #20]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
   1a328:	6011      	str	r1, [r2, #0]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
   1a32a:	f502 22fe 	add.w	r2, r2, #520192	; 0x7f000
   1a32e:	6054      	str	r4, [r2, #4]
	FTM2_MOD = DEFAULT_FTM_MOD;
   1a330:	6090      	str	r0, [r2, #8]
	FTM2_C0SC = 0x28;
   1a332:	60d3      	str	r3, [r2, #12]
	FTM2_C1SC = 0x28;
   1a334:	6153      	str	r3, [r2, #20]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
   1a336:	6011      	str	r1, [r2, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
   1a338:	f001 f87a 	bl	1b430 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
   1a33c:	f7ff ffc4 	bl	1a2c8 <startup_middle_hook>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
   1a340:	4c08      	ldr	r4, [pc, #32]	; (1a364 <_init_Teensyduino_internal_+0x98>)
   1a342:	6823      	ldr	r3, [r4, #0]
   1a344:	9300      	str	r3, [sp, #0]
	return ret;
   1a346:	9b00      	ldr	r3, [sp, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
   1a348:	2b13      	cmp	r3, #19
   1a34a:	d9fa      	bls.n	1a342 <_init_Teensyduino_internal_+0x76>
	usb_init();
   1a34c:	f000 fc8a 	bl	1ac64 <usb_init>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
   1a350:	6823      	ldr	r3, [r4, #0]
   1a352:	9301      	str	r3, [sp, #4]
	return ret;
   1a354:	9b01      	ldr	r3, [sp, #4]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
   1a356:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   1a35a:	d3f9      	bcc.n	1a350 <_init_Teensyduino_internal_+0x84>
}
   1a35c:	b002      	add	sp, #8
   1a35e:	bd10      	pop	{r4, pc}
   1a360:	40038000 	.word	0x40038000
   1a364:	20006600 	.word	0x20006600

0001a368 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
   1a368:	2821      	cmp	r0, #33	; 0x21
   1a36a:	d817      	bhi.n	1a39c <pinMode+0x34>
	config = portConfigRegister(pin);
   1a36c:	4a14      	ldr	r2, [pc, #80]	; (1a3c0 <pinMode+0x58>)
   1a36e:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
   1a372:	2901      	cmp	r1, #1
	config = portConfigRegister(pin);
   1a374:	685b      	ldr	r3, [r3, #4]
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
   1a376:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
   1a37a:	d001      	beq.n	1a380 <pinMode+0x18>
   1a37c:	2904      	cmp	r1, #4
   1a37e:	d10e      	bne.n	1a39e <pinMode+0x36>
		*portModeRegister(pin) = 1;
   1a380:	2201      	movs	r2, #1
   1a382:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
   1a386:	f44f 72a2 	mov.w	r2, #324	; 0x144
   1a38a:	601a      	str	r2, [r3, #0]
		    *config |= PORT_PCR_ODE;
   1a38c:	681a      	ldr	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
   1a38e:	2904      	cmp	r1, #4
		    *config |= PORT_PCR_ODE;
   1a390:	bf0c      	ite	eq
   1a392:	f042 0220 	orreq.w	r2, r2, #32
		    *config &= ~PORT_PCR_ODE;
   1a396:	f022 0220 	bicne.w	r2, r2, #32
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
		} else { // INPUT_DISABLE
			*config = 0;
   1a39a:	601a      	str	r2, [r3, #0]
		}
	}
}
   1a39c:	4770      	bx	lr
		*portModeRegister(pin) = 0;
   1a39e:	2200      	movs	r2, #0
   1a3a0:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
		if (mode == INPUT) {
   1a3a4:	b911      	cbnz	r1, 1a3ac <pinMode+0x44>
			*config = PORT_PCR_MUX(1);
   1a3a6:	f44f 7280 	mov.w	r2, #256	; 0x100
   1a3aa:	e7f6      	b.n	1a39a <pinMode+0x32>
		} else if (mode == INPUT_PULLUP) {
   1a3ac:	2902      	cmp	r1, #2
   1a3ae:	d102      	bne.n	1a3b6 <pinMode+0x4e>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
   1a3b0:	f240 1203 	movw	r2, #259	; 0x103
   1a3b4:	e7f1      	b.n	1a39a <pinMode+0x32>
		} else if (mode == INPUT_PULLDOWN) {
   1a3b6:	2903      	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
   1a3b8:	bf08      	it	eq
   1a3ba:	f44f 7281 	moveq.w	r2, #258	; 0x102
   1a3be:	e7ec      	b.n	1a39a <pinMode+0x32>
   1a3c0:	00027b0c 	.word	0x00027b0c

0001a3c4 <attachInterrupt>:
	if (pin >= CORE_NUM_DIGITAL) return;
   1a3c4:	2821      	cmp	r0, #33	; 0x21
{
   1a3c6:	b570      	push	{r4, r5, r6, lr}
   1a3c8:	460e      	mov	r6, r1
	if (pin >= CORE_NUM_DIGITAL) return;
   1a3ca:	d830      	bhi.n	1a42e <attachInterrupt+0x6a>
	switch (mode) {
   1a3cc:	2a04      	cmp	r2, #4
   1a3ce:	d82e      	bhi.n	1a42e <attachInterrupt+0x6a>
	mask = (mask << 16) | 0x01000000;
   1a3d0:	4917      	ldr	r1, [pc, #92]	; (1a430 <attachInterrupt+0x6c>)
   1a3d2:	5c8c      	ldrb	r4, [r1, r2]
	config = portConfigRegister(pin);
   1a3d4:	4a17      	ldr	r2, [pc, #92]	; (1a434 <attachInterrupt+0x70>)
   1a3d6:	eb02 03c0 	add.w	r3, r2, r0, lsl #3
	mask = (mask << 16) | 0x01000000;
   1a3da:	0424      	lsls	r4, r4, #16
	config = portConfigRegister(pin);
   1a3dc:	685d      	ldr	r5, [r3, #4]
	if ((*config & 0x00000700) == 0) {
   1a3de:	6829      	ldr	r1, [r5, #0]
   1a3e0:	f411 61e0 	ands.w	r1, r1, #1792	; 0x700
   1a3e4:	d101      	bne.n	1a3ea <attachInterrupt+0x26>
		pinMode(pin, INPUT);
   1a3e6:	f7ff ffbf 	bl	1a368 <pinMode>
	_VectorsRam[irq + 16] = function;
   1a3ea:	4b13      	ldr	r3, [pc, #76]	; (1a438 <attachInterrupt+0x74>)
   1a3ec:	4a13      	ldr	r2, [pc, #76]	; (1a43c <attachInterrupt+0x78>)
   1a3ee:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
   1a3f2:	4a13      	ldr	r2, [pc, #76]	; (1a440 <attachInterrupt+0x7c>)
   1a3f4:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
   1a3f8:	4a12      	ldr	r2, [pc, #72]	; (1a444 <attachInterrupt+0x80>)
   1a3fa:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
   1a3fe:	4a12      	ldr	r2, [pc, #72]	; (1a448 <attachInterrupt+0x84>)
   1a400:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
   1a404:	4a11      	ldr	r2, [pc, #68]	; (1a44c <attachInterrupt+0x88>)
   1a406:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
	voidFuncPtr* isr_table = getIsrTable(config);
   1a40a:	4628      	mov	r0, r5
   1a40c:	f7ff ff26 	bl	1a25c <getIsrTable>
	if(!isr_table) return;
   1a410:	b168      	cbz	r0, 1a42e <attachInterrupt+0x6a>
	__disable_irq();
   1a412:	b672      	cpsid	i
	cfg = *config;
   1a414:	682b      	ldr	r3, [r5, #0]
	cfg &= ~0x000F0000;		// disable any previous interrupt
   1a416:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
	*config = cfg;
   1a41a:	602b      	str	r3, [r5, #0]
   1a41c:	431c      	orrs	r4, r3
	return (v % 128) / 4;
   1a41e:	f3c5 0384 	ubfx	r3, r5, #2, #5
	cfg |= mask;
   1a422:	f044 7480 	orr.w	r4, r4, #16777216	; 0x1000000
	isr_table[pin_index] = function;	// set the function pointer
   1a426:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
	*config = cfg;			// enable the new interrupt
   1a42a:	602c      	str	r4, [r5, #0]
	__enable_irq();
   1a42c:	b662      	cpsie	i
}
   1a42e:	bd70      	pop	{r4, r5, r6, pc}
   1a430:	00027b04 	.word	0x00027b04
   1a434:	00027b0c 	.word	0x00027b0c
   1a438:	1fff8200 	.word	0x1fff8200
   1a43c:	1fff9261 	.word	0x1fff9261
   1a440:	1fff9231 	.word	0x1fff9231
   1a444:	1fff9201 	.word	0x1fff9201
   1a448:	1fff91d1 	.word	0x1fff91d1
   1a44c:	1fff91a1 	.word	0x1fff91a1

0001a450 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
   1a450:	b672      	cpsid	i
	current = SYST_CVR;
   1a452:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
	count = systick_millis_count;
   1a456:	4a0b      	ldr	r2, [pc, #44]	; (1a484 <micros+0x34>)
	current = SYST_CVR;
   1a458:	698b      	ldr	r3, [r1, #24]
	count = systick_millis_count;
   1a45a:	6812      	ldr	r2, [r2, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
   1a45c:	f8d1 1d04 	ldr.w	r1, [r1, #3332]	; 0xd04
	__enable_irq();
   1a460:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
   1a462:	0149      	lsls	r1, r1, #5
   1a464:	d502      	bpl.n	1a46c <micros+0x1c>
   1a466:	2b32      	cmp	r3, #50	; 0x32
   1a468:	bf88      	it	hi
   1a46a:	3201      	addhi	r2, #1
	current = ((F_CPU / 1000) - 1) - current;
   1a46c:	f5c3 33ea 	rsb	r3, r3, #119808	; 0x1d400
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
}
   1a470:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	return count * 1000 + current / (F_CPU / 1000000);
   1a474:	2178      	movs	r1, #120	; 0x78
	current = ((F_CPU / 1000) - 1) - current;
   1a476:	33bf      	adds	r3, #191	; 0xbf
	return count * 1000 + current / (F_CPU / 1000000);
   1a478:	fbb3 f3f1 	udiv	r3, r3, r1
}
   1a47c:	fb00 3002 	mla	r0, r0, r2, r3
   1a480:	4770      	bx	lr
   1a482:	bf00      	nop
   1a484:	20006600 	.word	0x20006600

0001a488 <delay>:

void delay(uint32_t ms)
{
   1a488:	b538      	push	{r3, r4, r5, lr}
   1a48a:	4604      	mov	r4, r0
	uint32_t start = micros();
   1a48c:	f7ff ffe0 	bl	1a450 <micros>
   1a490:	4605      	mov	r5, r0

	if (ms > 0) {
   1a492:	b16c      	cbz	r4, 1a4b0 <delay+0x28>
		while (1) {
			while ((micros() - start) >= 1000) {
   1a494:	f7ff ffdc 	bl	1a450 <micros>
   1a498:	1b40      	subs	r0, r0, r5
   1a49a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
   1a49e:	d202      	bcs.n	1a4a6 <delay+0x1e>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
   1a4a0:	f000 ff5c 	bl	1b35c <yield>
			while ((micros() - start) >= 1000) {
   1a4a4:	e7f6      	b.n	1a494 <delay+0xc>
				if (ms == 0) return;
   1a4a6:	3c01      	subs	r4, #1
   1a4a8:	d002      	beq.n	1a4b0 <delay+0x28>
				start += 1000;
   1a4aa:	f505 757a 	add.w	r5, r5, #1000	; 0x3e8
   1a4ae:	e7f1      	b.n	1a494 <delay+0xc>
		}
	}
}
   1a4b0:	bd38      	pop	{r3, r4, r5, pc}
   1a4b2:	Address 0x000000000001a4b2 is out of bounds.


0001a4b4 <endpoint0_transmit>:
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
   1a4b4:	b5f0      	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
   1a4b6:	4c0c      	ldr	r4, [pc, #48]	; (1a4e8 <endpoint0_transmit+0x34>)
   1a4b8:	4e0c      	ldr	r6, [pc, #48]	; (1a4ec <endpoint0_transmit+0x38>)
   1a4ba:	7823      	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
   1a4bc:	4d0c      	ldr	r5, [pc, #48]	; (1a4f0 <endpoint0_transmit+0x3c>)
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
   1a4be:	f043 0702 	orr.w	r7, r3, #2
   1a4c2:	eb06 02c7 	add.w	r2, r6, r7, lsl #3
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
   1a4c6:	f083 0301 	eor.w	r3, r3, #1
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
   1a4ca:	6050      	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
   1a4cc:	782a      	ldrb	r2, [r5, #0]
	ep0_tx_bdt_bank ^= 1;
   1a4ce:	7023      	strb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
   1a4d0:	2a00      	cmp	r2, #0
   1a4d2:	bf14      	ite	ne
   1a4d4:	20c8      	movne	r0, #200	; 0xc8
   1a4d6:	2088      	moveq	r0, #136	; 0x88
   1a4d8:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
   1a4dc:	f082 0201 	eor.w	r2, r2, #1
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
   1a4e0:	f846 0037 	str.w	r0, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
   1a4e4:	702a      	strb	r2, [r5, #0]
}
   1a4e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a4e8:	20006684 	.word	0x20006684
   1a4ec:	1fff8000 	.word	0x1fff8000
   1a4f0:	20006685 	.word	0x20006685

0001a4f4 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
   1a4f4:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
   1a4f6:	2b04      	cmp	r3, #4
{
   1a4f8:	b510      	push	{r4, lr}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
   1a4fa:	d810      	bhi.n	1a51e <usb_rx+0x2a>
	__disable_irq();
   1a4fc:	b672      	cpsid	i
	ret = rx_first[endpoint];
   1a4fe:	4a09      	ldr	r2, [pc, #36]	; (1a524 <usb_rx+0x30>)
   1a500:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
   1a504:	b148      	cbz	r0, 1a51a <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
   1a506:	6841      	ldr	r1, [r0, #4]
   1a508:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
   1a50c:	4906      	ldr	r1, [pc, #24]	; (1a528 <usb_rx+0x34>)
   1a50e:	8804      	ldrh	r4, [r0, #0]
   1a510:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
   1a514:	1b12      	subs	r2, r2, r4
   1a516:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
   1a51a:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
   1a51c:	bd10      	pop	{r4, pc}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
   1a51e:	2000      	movs	r0, #0
   1a520:	e7fc      	b.n	1a51c <usb_rx+0x28>
   1a522:	bf00      	nop
   1a524:	20006694 	.word	0x20006694
   1a528:	200066f4 	.word	0x200066f4

0001a52c <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
   1a52c:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
   1a52e:	2804      	cmp	r0, #4
   1a530:	d80a      	bhi.n	1a548 <usb_tx_packet_count+0x1c>
	__disable_irq();
   1a532:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
   1a534:	4b05      	ldr	r3, [pc, #20]	; (1a54c <usb_tx_packet_count+0x20>)
   1a536:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
	uint32_t count=0;
   1a53a:	2000      	movs	r0, #0
	for (p = tx_first[endpoint]; p; p = p->next) count++;
   1a53c:	b90b      	cbnz	r3, 1a542 <usb_tx_packet_count+0x16>
	__enable_irq();
   1a53e:	b662      	cpsie	i
	return count;
   1a540:	4770      	bx	lr
	for (p = tx_first[endpoint]; p; p = p->next) count++;
   1a542:	685b      	ldr	r3, [r3, #4]
   1a544:	3001      	adds	r0, #1
   1a546:	e7f9      	b.n	1a53c <usb_tx_packet_count+0x10>
	if (endpoint >= NUM_ENDPOINTS) return 0;
   1a548:	2000      	movs	r0, #0
}
   1a54a:	4770      	bx	lr
   1a54c:	200066c4 	.word	0x200066c4

0001a550 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
   1a550:	b430      	push	{r4, r5}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
   1a552:	b672      	cpsid	i
	cfg = usb_endpoint_config_table;
   1a554:	4c17      	ldr	r4, [pc, #92]	; (1a5b4 <usb_rx_memory+0x64>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
   1a556:	4a18      	ldr	r2, [pc, #96]	; (1a5b8 <usb_rx_memory+0x68>)
	__disable_irq();
   1a558:	2304      	movs	r3, #4
		if (*cfg++ & USB_ENDPT_EPRXEN) {
   1a55a:	f814 1b01 	ldrb.w	r1, [r4], #1
   1a55e:	0709      	lsls	r1, r1, #28
   1a560:	d51d      	bpl.n	1a59e <usb_rx_memory+0x4e>
			if (table[index(i, RX, EVEN)].desc == 0) {
   1a562:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
   1a566:	b969      	cbnz	r1, 1a584 <usb_rx_memory+0x34>
				table[index(i, RX, EVEN)].addr = packet->buf;
   1a568:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
   1a56c:	3008      	adds	r0, #8
   1a56e:	6048      	str	r0, [r1, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
   1a570:	4912      	ldr	r1, [pc, #72]	; (1a5bc <usb_rx_memory+0x6c>)
   1a572:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
   1a576:	4a12      	ldr	r2, [pc, #72]	; (1a5c0 <usb_rx_memory+0x70>)
   1a578:	7813      	ldrb	r3, [r2, #0]
   1a57a:	3b01      	subs	r3, #1
   1a57c:	7013      	strb	r3, [r2, #0]
				__enable_irq();
   1a57e:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
   1a580:	bc30      	pop	{r4, r5}
   1a582:	4770      	bx	lr
			if (table[index(i, RX, ODD)].desc == 0) {
   1a584:	f043 0101 	orr.w	r1, r3, #1
   1a588:	f852 5031 	ldr.w	r5, [r2, r1, lsl #3]
   1a58c:	b93d      	cbnz	r5, 1a59e <usb_rx_memory+0x4e>
				table[index(i, RX, ODD)].addr = packet->buf;
   1a58e:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
   1a592:	3008      	adds	r0, #8
   1a594:	6058      	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
   1a596:	4b0b      	ldr	r3, [pc, #44]	; (1a5c4 <usb_rx_memory+0x74>)
   1a598:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
   1a59c:	e7eb      	b.n	1a576 <usb_rx_memory+0x26>
	for (i=1; i <= NUM_ENDPOINTS; i++) {
   1a59e:	3304      	adds	r3, #4
   1a5a0:	2b18      	cmp	r3, #24
   1a5a2:	d1da      	bne.n	1a55a <usb_rx_memory+0xa>
	__enable_irq();
   1a5a4:	b662      	cpsie	i
	usb_rx_memory_needed = 0;
   1a5a6:	4b06      	ldr	r3, [pc, #24]	; (1a5c0 <usb_rx_memory+0x70>)
   1a5a8:	2200      	movs	r2, #0
   1a5aa:	701a      	strb	r2, [r3, #0]
}
   1a5ac:	bc30      	pop	{r4, r5}
	usb_free(packet);
   1a5ae:	f000 bbbb 	b.w	1ad28 <usb_free>
   1a5b2:	bf00      	nop
   1a5b4:	00027c80 	.word	0x00027c80
   1a5b8:	1fff8000 	.word	0x1fff8000
   1a5bc:	00400088 	.word	0x00400088
   1a5c0:	200066fe 	.word	0x200066fe
   1a5c4:	004000c8 	.word	0x004000c8

0001a5c8 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
   1a5c8:	1e42      	subs	r2, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
   1a5ca:	2a04      	cmp	r2, #4
{
   1a5cc:	b530      	push	{r4, r5, lr}
	if (endpoint >= NUM_ENDPOINTS) return;
   1a5ce:	d82c      	bhi.n	1a62a <usb_tx+0x62>
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
   1a5d0:	4b19      	ldr	r3, [pc, #100]	; (1a638 <usb_tx+0x70>)
   1a5d2:	0140      	lsls	r0, r0, #5
   1a5d4:	f040 0010 	orr.w	r0, r0, #16
   1a5d8:	4403      	add	r3, r0
	__disable_irq();
   1a5da:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
   1a5dc:	4c17      	ldr	r4, [pc, #92]	; (1a63c <usb_tx+0x74>)
   1a5de:	5ca0      	ldrb	r0, [r4, r2]
   1a5e0:	2803      	cmp	r0, #3
   1a5e2:	d818      	bhi.n	1a616 <usb_tx+0x4e>
   1a5e4:	e8df f000 	tbb	[pc, r0]
   1a5e8:	14021126 	.word	0x14021126
   1a5ec:	2005      	movs	r0, #5
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
   1a5ee:	f013 0f08 	tst.w	r3, #8
	tx_state[endpoint] = next;
   1a5f2:	54a0      	strb	r0, [r4, r2]
	b->addr = packet->buf;
   1a5f4:	f101 0208 	add.w	r2, r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
   1a5f8:	8809      	ldrh	r1, [r1, #0]
	b->addr = packet->buf;
   1a5fa:	605a      	str	r2, [r3, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
   1a5fc:	bf14      	ite	ne
   1a5fe:	22c8      	movne	r2, #200	; 0xc8
   1a600:	2288      	moveq	r2, #136	; 0x88
   1a602:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
   1a606:	601a      	str	r2, [r3, #0]
   1a608:	e00e      	b.n	1a628 <usb_tx+0x60>
		b++;
   1a60a:	3308      	adds	r3, #8
		next = TX_STATE_EVEN_FREE;
   1a60c:	2002      	movs	r0, #2
		break;
   1a60e:	e7ee      	b.n	1a5ee <usb_tx+0x26>
		b++;
   1a610:	3308      	adds	r3, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
   1a612:	2004      	movs	r0, #4
		break;
   1a614:	e7eb      	b.n	1a5ee <usb_tx+0x26>
		if (tx_first[endpoint] == NULL) {
   1a616:	480a      	ldr	r0, [pc, #40]	; (1a640 <usb_tx+0x78>)
   1a618:	4b0a      	ldr	r3, [pc, #40]	; (1a644 <usb_tx+0x7c>)
   1a61a:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
   1a61e:	b92c      	cbnz	r4, 1a62c <usb_tx+0x64>
			tx_first[endpoint] = packet;
   1a620:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
		tx_last[endpoint] = packet;
   1a624:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	__enable_irq();
   1a628:	b662      	cpsie	i
}
   1a62a:	bd30      	pop	{r4, r5, pc}
			tx_last[endpoint]->next = packet;
   1a62c:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   1a630:	6041      	str	r1, [r0, #4]
   1a632:	e7f7      	b.n	1a624 <usb_tx+0x5c>
		next = TX_STATE_ODD_FREE;
   1a634:	2003      	movs	r0, #3
   1a636:	e7da      	b.n	1a5ee <usb_tx+0x26>
   1a638:	1fff8000 	.word	0x1fff8000
   1a63c:	200066ec 	.word	0x200066ec
   1a640:	200066c4 	.word	0x200066c4
   1a644:	200066d8 	.word	0x200066d8

0001a648 <usb_isr>:
}



void usb_isr(void)
{
   1a648:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		data = ep0_tx_ptr;
   1a64c:	4ea9      	ldr	r6, [pc, #676]	; (1a8f4 <usb_isr+0x2ac>)
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
   1a64e:	4baa      	ldr	r3, [pc, #680]	; (1a8f8 <usb_isr+0x2b0>)
   1a650:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
   1a654:	0759      	lsls	r1, r3, #29
	status = USB0_ISTAT;
   1a656:	b2dc      	uxtb	r4, r3
	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
   1a658:	d51d      	bpl.n	1a696 <usb_isr+0x4e>
		if (usb_configuration) {
   1a65a:	4ba8      	ldr	r3, [pc, #672]	; (1a8fc <usb_isr+0x2b4>)
   1a65c:	781b      	ldrb	r3, [r3, #0]
   1a65e:	b1b3      	cbz	r3, 1a68e <usb_isr+0x46>
			t = usb_reboot_timer;
   1a660:	4aa7      	ldr	r2, [pc, #668]	; (1a900 <usb_isr+0x2b8>)
   1a662:	7811      	ldrb	r1, [r2, #0]
			if (t) {
   1a664:	f001 03ff 	and.w	r3, r1, #255	; 0xff
   1a668:	b121      	cbz	r1, 1a674 <usb_isr+0x2c>
				usb_reboot_timer = --t;
   1a66a:	3b01      	subs	r3, #1
   1a66c:	b2db      	uxtb	r3, r3
   1a66e:	7013      	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
   1a670:	b903      	cbnz	r3, 1a674 <usb_isr+0x2c>
	__asm__ volatile("bkpt");
   1a672:	be00      	bkpt	0x0000
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
   1a674:	4aa3      	ldr	r2, [pc, #652]	; (1a904 <usb_isr+0x2bc>)
   1a676:	7811      	ldrb	r1, [r2, #0]
			if (t) {
   1a678:	f001 03ff 	and.w	r3, r1, #255	; 0xff
   1a67c:	b129      	cbz	r1, 1a68a <usb_isr+0x42>
				usb_cdc_transmit_flush_timer = --t;
   1a67e:	3b01      	subs	r3, #1
   1a680:	b2db      	uxtb	r3, r3
   1a682:	7013      	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
   1a684:	b90b      	cbnz	r3, 1a68a <usb_isr+0x42>
   1a686:	f000 fe1b 	bl	1b2c0 <usb_serial_flush_callback>
				usb_seremu_transmit_flush_timer = --t;
				if (t == 0) usb_seremu_flush_callback();
			}
#endif
#ifdef MIDI_INTERFACE
                        usb_midi_flush_output();
   1a68a:	f000 fc2b 	bl	1aee4 <usb_midi_flush_output>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
   1a68e:	4b9a      	ldr	r3, [pc, #616]	; (1a8f8 <usb_isr+0x2b0>)
   1a690:	2204      	movs	r2, #4
   1a692:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
   1a696:	f014 0108 	ands.w	r1, r4, #8
   1a69a:	f000 826f 	beq.w	1ab7c <usb_isr+0x534>
		uint8_t endpoint;
		stat = USB0_STAT;
   1a69e:	4b96      	ldr	r3, [pc, #600]	; (1a8f8 <usb_isr+0x2b0>)
   1a6a0:	4c99      	ldr	r4, [pc, #612]	; (1a908 <usb_isr+0x2c0>)
   1a6a2:	f893 7090 	ldrb.w	r7, [r3, #144]	; 0x90
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
   1a6a6:	093d      	lsrs	r5, r7, #4
		stat = USB0_STAT;
   1a6a8:	b2fb      	uxtb	r3, r7
		if (endpoint == 0) {
   1a6aa:	ea4f 0897 	mov.w	r8, r7, lsr #2
   1a6ae:	f040 81ec 	bne.w	1aa8a <usb_isr+0x442>
	pid = BDT_PID(b->desc);
   1a6b2:	f854 3038 	ldr.w	r3, [r4, r8, lsl #3]
	b = stat2bufferdescriptor(stat);
   1a6b6:	eb04 02c8 	add.w	r2, r4, r8, lsl #3
	pid = BDT_PID(b->desc);
   1a6ba:	f3c3 0383 	ubfx	r3, r3, #2, #4
	switch (pid) {
   1a6be:	2b09      	cmp	r3, #9
	buf = b->addr;
   1a6c0:	6852      	ldr	r2, [r2, #4]
	switch (pid) {
   1a6c2:	f000 81c1 	beq.w	1aa48 <usb_isr+0x400>
   1a6c6:	d80c      	bhi.n	1a6e2 <usb_isr+0x9a>
   1a6c8:	3b01      	subs	r3, #1
   1a6ca:	2b01      	cmp	r3, #1
   1a6cc:	f240 819d 	bls.w	1aa0a <usb_isr+0x3c2>
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
   1a6d0:	4b89      	ldr	r3, [pc, #548]	; (1a8f8 <usb_isr+0x2b0>)
   1a6d2:	2201      	movs	r2, #1
   1a6d4:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
   1a6d8:	4b87      	ldr	r3, [pc, #540]	; (1a8f8 <usb_isr+0x2b0>)
   1a6da:	2208      	movs	r2, #8
   1a6dc:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
		goto restart;
   1a6e0:	e7b5      	b.n	1a64e <usb_isr+0x6>
	switch (pid) {
   1a6e2:	2b0d      	cmp	r3, #13
   1a6e4:	d1f4      	bne.n	1a6d0 <usb_isr+0x88>
		setup.word1 = *(uint32_t *)(buf);
   1a6e6:	6810      	ldr	r0, [r2, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
   1a6e8:	4b88      	ldr	r3, [pc, #544]	; (1a90c <usb_isr+0x2c4>)
		ep0_tx_data_toggle = 1;
   1a6ea:	4989      	ldr	r1, [pc, #548]	; (1a910 <usb_isr+0x2c8>)
		setup.word2 = *(uint32_t *)(buf + 4);
   1a6ec:	6852      	ldr	r2, [r2, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
   1a6ee:	f844 3038 	str.w	r3, [r4, r8, lsl #3]
		ep0_tx_data_toggle = 1;
   1a6f2:	2301      	movs	r3, #1
		setup.word1 = *(uint32_t *)(buf);
   1a6f4:	4f87      	ldr	r7, [pc, #540]	; (1a914 <usb_isr+0x2cc>)
		table[index(0, TX, EVEN)].desc = 0;
   1a6f6:	6125      	str	r5, [r4, #16]
		ep0_tx_ptr = NULL;
   1a6f8:	6035      	str	r5, [r6, #0]
		table[index(0, TX, ODD)].desc = 0;
   1a6fa:	61a5      	str	r5, [r4, #24]
		ep0_tx_data_toggle = 1;
   1a6fc:	700b      	strb	r3, [r1, #0]
	switch (setup.wRequestAndType) {
   1a6fe:	f240 6581 	movw	r5, #1665	; 0x681
   1a702:	b281      	uxth	r1, r0
   1a704:	42a9      	cmp	r1, r5
		setup.word1 = *(uint32_t *)(buf);
   1a706:	6038      	str	r0, [r7, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
   1a708:	607a      	str	r2, [r7, #4]
	switch (setup.wRequestAndType) {
   1a70a:	d821      	bhi.n	1a750 <usb_isr+0x108>
   1a70c:	f5b1 6fd0 	cmp.w	r1, #1664	; 0x680
   1a710:	f080 8158 	bcs.w	1a9c4 <usb_isr+0x37c>
   1a714:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
   1a718:	f000 8133 	beq.w	1a982 <usb_isr+0x33a>
   1a71c:	d80e      	bhi.n	1a73c <usb_isr+0xf4>
   1a71e:	2980      	cmp	r1, #128	; 0x80
   1a720:	f000 8118 	beq.w	1a954 <usb_isr+0x30c>
   1a724:	2982      	cmp	r1, #130	; 0x82
   1a726:	f000 811b 	beq.w	1a960 <usb_isr+0x318>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
   1a72a:	4b73      	ldr	r3, [pc, #460]	; (1a8f8 <usb_isr+0x2b0>)
   1a72c:	220f      	movs	r2, #15
   1a72e:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
   1a732:	4b71      	ldr	r3, [pc, #452]	; (1a8f8 <usb_isr+0x2b0>)
   1a734:	2201      	movs	r2, #1
   1a736:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
		break;
   1a73a:	e7c9      	b.n	1a6d0 <usb_isr+0x88>
	switch (setup.wRequestAndType) {
   1a73c:	f240 3302 	movw	r3, #770	; 0x302
   1a740:	4299      	cmp	r1, r3
   1a742:	f000 812e 	beq.w	1a9a2 <usb_isr+0x35a>
   1a746:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
   1a74a:	d1ee      	bne.n	1a72a <usb_isr+0xe2>
   1a74c:	2300      	movs	r3, #0
   1a74e:	e137      	b.n	1a9c0 <usb_isr+0x378>
   1a750:	f242 0521 	movw	r5, #8225	; 0x2021
   1a754:	42a9      	cmp	r1, r5
   1a756:	d0ec      	beq.n	1a732 <usb_isr+0xea>
   1a758:	d83e      	bhi.n	1a7d8 <usb_isr+0x190>
   1a75a:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
   1a75e:	f000 80a3 	beq.w	1a8a8 <usb_isr+0x260>
   1a762:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
   1a766:	d1e0      	bne.n	1a72a <usb_isr+0xe2>
		usb_configuration = setup.wValue;
   1a768:	4a64      	ldr	r2, [pc, #400]	; (1a8fc <usb_isr+0x2b4>)
   1a76a:	f3c0 4307 	ubfx	r3, r0, #16, #8
   1a76e:	7013      	strb	r3, [r2, #0]
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
   1a770:	2504      	movs	r5, #4
			if (table[i].desc & BDT_OWN) {
   1a772:	f854 3035 	ldr.w	r3, [r4, r5, lsl #3]
   1a776:	061a      	lsls	r2, r3, #24
   1a778:	d505      	bpl.n	1a786 <usb_isr+0x13e>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
   1a77a:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   1a77e:	6858      	ldr	r0, [r3, #4]
   1a780:	3808      	subs	r0, #8
   1a782:	f000 fad1 	bl	1ad28 <usb_free>
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
   1a786:	3501      	adds	r5, #1
   1a788:	2d18      	cmp	r5, #24
   1a78a:	d1f2      	bne.n	1a772 <usb_isr+0x12a>
   1a78c:	4b62      	ldr	r3, [pc, #392]	; (1a918 <usb_isr+0x2d0>)
   1a78e:	4d63      	ldr	r5, [pc, #396]	; (1a91c <usb_isr+0x2d4>)
   1a790:	f8df b18c 	ldr.w	fp, [pc, #396]	; 1a920 <usb_isr+0x2d8>
   1a794:	f8df 818c 	ldr.w	r8, [pc, #396]	; 1a924 <usb_isr+0x2dc>
   1a798:	f8df a18c 	ldr.w	sl, [pc, #396]	; 1a928 <usb_isr+0x2e0>
   1a79c:	f8df 918c 	ldr.w	r9, [pc, #396]	; 1a92c <usb_isr+0x2e4>
   1a7a0:	9300      	str	r3, [sp, #0]
			p = rx_first[i];
   1a7a2:	f855 0b04 	ldr.w	r0, [r5], #4
			while (p) {
   1a7a6:	bb00      	cbnz	r0, 1a7ea <usb_isr+0x1a2>
			rx_last[i] = NULL;
   1a7a8:	f849 0b04 	str.w	r0, [r9], #4
			rx_first[i] = NULL;
   1a7ac:	f845 0c04 	str.w	r0, [r5, #-4]
			p = tx_first[i];
   1a7b0:	f8d8 0000 	ldr.w	r0, [r8]
			while (p) {
   1a7b4:	bb00      	cbnz	r0, 1a7f8 <usb_isr+0x1b0>
			tx_last[i] = NULL;
   1a7b6:	9b00      	ldr	r3, [sp, #0]
   1a7b8:	f89b 1000 	ldrb.w	r1, [fp]
   1a7bc:	f843 0b04 	str.w	r0, [r3], #4
   1a7c0:	3902      	subs	r1, #2
			tx_first[i] = NULL;
   1a7c2:	f848 0b04 	str.w	r0, [r8], #4
			usb_rx_byte_count_data[i] = 0;
   1a7c6:	f82a 0b02 	strh.w	r0, [sl], #2
			tx_last[i] = NULL;
   1a7ca:	9300      	str	r3, [sp, #0]
			switch (tx_state[i]) {
   1a7cc:	2903      	cmp	r1, #3
   1a7ce:	d81e      	bhi.n	1a80e <usb_isr+0x1c6>
   1a7d0:	e8df f001 	tbb	[pc, r1]
   1a7d4:	57195719 	.word	0x57195719
	switch (setup.wRequestAndType) {
   1a7d8:	f242 2321 	movw	r3, #8737	; 0x2221
   1a7dc:	4299      	cmp	r1, r3
   1a7de:	f000 8107 	beq.w	1a9f0 <usb_isr+0x3a8>
   1a7e2:	f242 3321 	movw	r3, #8993	; 0x2321
   1a7e6:	4299      	cmp	r1, r3
   1a7e8:	e7af      	b.n	1a74a <usb_isr+0x102>
				n = p->next;
   1a7ea:	6841      	ldr	r1, [r0, #4]
   1a7ec:	9101      	str	r1, [sp, #4]
				usb_free(p);
   1a7ee:	f000 fa9b 	bl	1ad28 <usb_free>
				p = n;
   1a7f2:	9901      	ldr	r1, [sp, #4]
   1a7f4:	4608      	mov	r0, r1
   1a7f6:	e7d6      	b.n	1a7a6 <usb_isr+0x15e>
				n = p->next;
   1a7f8:	6841      	ldr	r1, [r0, #4]
   1a7fa:	9101      	str	r1, [sp, #4]
				usb_free(p);
   1a7fc:	f000 fa94 	bl	1ad28 <usb_free>
				p = n;
   1a800:	9901      	ldr	r1, [sp, #4]
   1a802:	4608      	mov	r0, r1
   1a804:	e7d6      	b.n	1a7b4 <usb_isr+0x16c>
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
   1a806:	f04f 0300 	mov.w	r3, #0
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
   1a80a:	f88b 3000 	strb.w	r3, [fp]
		for (i=0; i < NUM_ENDPOINTS; i++) {
   1a80e:	4b48      	ldr	r3, [pc, #288]	; (1a930 <usb_isr+0x2e8>)
   1a810:	429d      	cmp	r5, r3
   1a812:	f10b 0b01 	add.w	fp, fp, #1
   1a816:	d1c4      	bne.n	1a7a2 <usb_isr+0x15a>
		usb_rx_memory_needed = 0;
   1a818:	f8df b118 	ldr.w	fp, [pc, #280]	; 1a934 <usb_isr+0x2ec>
		reg = &USB0_ENDPT1;
   1a81c:	f8df a118 	ldr.w	sl, [pc, #280]	; 1a938 <usb_isr+0x2f0>
		cfg = usb_endpoint_config_table;
   1a820:	f8df 8118 	ldr.w	r8, [pc, #280]	; 1a93c <usb_isr+0x2f4>
		for (i=1; i <= NUM_ENDPOINTS; i++) {
   1a824:	f8df 9118 	ldr.w	r9, [pc, #280]	; 1a940 <usb_isr+0x2f8>
		usb_rx_memory_needed = 0;
   1a828:	2300      	movs	r3, #0
   1a82a:	f88b 3000 	strb.w	r3, [fp]
			epconf = *cfg++;
   1a82e:	f818 2b01 	ldrb.w	r2, [r8], #1
			*reg = epconf;
   1a832:	f80a 2b04 	strb.w	r2, [sl], #4
			if (epconf & USB_ENDPT_EPRXEN) {
   1a836:	4d43      	ldr	r5, [pc, #268]	; (1a944 <usb_isr+0x2fc>)
   1a838:	0713      	lsls	r3, r2, #28
   1a83a:	4455      	add	r5, sl
   1a83c:	d515      	bpl.n	1a86a <usb_isr+0x222>
				p = usb_malloc();
   1a83e:	f000 fa55 	bl	1acec <usb_malloc>
				if (p) {
   1a842:	b308      	cbz	r0, 1a888 <usb_isr+0x240>
					table[index(i, RX, EVEN)].addr = p->buf;
   1a844:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
   1a848:	3008      	adds	r0, #8
   1a84a:	6050      	str	r0, [r2, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
   1a84c:	4a3e      	ldr	r2, [pc, #248]	; (1a948 <usb_isr+0x300>)
   1a84e:	f844 2035 	str.w	r2, [r4, r5, lsl #3]
				p = usb_malloc();
   1a852:	f000 fa4b 	bl	1acec <usb_malloc>
					table[index(i, RX, ODD)].addr = p->buf;
   1a856:	f045 0201 	orr.w	r2, r5, #1
				if (p) {
   1a85a:	b1e8      	cbz	r0, 1a898 <usb_isr+0x250>
					table[index(i, RX, ODD)].addr = p->buf;
   1a85c:	eb04 01c2 	add.w	r1, r4, r2, lsl #3
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
   1a860:	4b2a      	ldr	r3, [pc, #168]	; (1a90c <usb_isr+0x2c4>)
					table[index(i, RX, ODD)].addr = p->buf;
   1a862:	3008      	adds	r0, #8
   1a864:	6048      	str	r0, [r1, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
   1a866:	f844 3032 	str.w	r3, [r4, r2, lsl #3]
			table[index(i, TX, EVEN)].desc = 0;
   1a86a:	f045 0102 	orr.w	r1, r5, #2
			table[index(i, TX, ODD)].desc = 0;
   1a86e:	f045 0503 	orr.w	r5, r5, #3
			table[index(i, TX, EVEN)].desc = 0;
   1a872:	2200      	movs	r2, #0
		for (i=1; i <= NUM_ENDPOINTS; i++) {
   1a874:	45ca      	cmp	sl, r9
			table[index(i, TX, EVEN)].desc = 0;
   1a876:	f844 2031 	str.w	r2, [r4, r1, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
   1a87a:	f844 2035 	str.w	r2, [r4, r5, lsl #3]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
   1a87e:	d1d6      	bne.n	1a82e <usb_isr+0x1e6>
   1a880:	e764      	b.n	1a74c <usb_isr+0x104>
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
   1a882:	f04f 0301 	mov.w	r3, #1
   1a886:	e7c0      	b.n	1a80a <usb_isr+0x1c2>
					usb_rx_memory_needed++;
   1a888:	f89b 2000 	ldrb.w	r2, [fp]
					table[index(i, RX, EVEN)].desc = 0;
   1a88c:	f844 0035 	str.w	r0, [r4, r5, lsl #3]
					usb_rx_memory_needed++;
   1a890:	3201      	adds	r2, #1
   1a892:	f88b 2000 	strb.w	r2, [fp]
   1a896:	e7dc      	b.n	1a852 <usb_isr+0x20a>
					table[index(i, RX, ODD)].desc = 0;
   1a898:	f844 0032 	str.w	r0, [r4, r2, lsl #3]
					usb_rx_memory_needed++;
   1a89c:	f89b 2000 	ldrb.w	r2, [fp]
   1a8a0:	3201      	adds	r2, #1
   1a8a2:	f88b 2000 	strb.w	r2, [fp]
   1a8a6:	e7e0      	b.n	1a86a <usb_isr+0x222>
		reply_buffer[0] = usb_configuration;
   1a8a8:	4a14      	ldr	r2, [pc, #80]	; (1a8fc <usb_isr+0x2b4>)
   1a8aa:	4c28      	ldr	r4, [pc, #160]	; (1a94c <usb_isr+0x304>)
   1a8ac:	7812      	ldrb	r2, [r2, #0]
   1a8ae:	7022      	strb	r2, [r4, #0]
	if (datalen > setup.wLength) datalen = setup.wLength;
   1a8b0:	88fd      	ldrh	r5, [r7, #6]
   1a8b2:	429d      	cmp	r5, r3
   1a8b4:	bf28      	it	cs
   1a8b6:	461d      	movcs	r5, r3
	if (size > EP0_SIZE) size = EP0_SIZE;
   1a8b8:	2d40      	cmp	r5, #64	; 0x40
   1a8ba:	4629      	mov	r1, r5
	endpoint0_transmit(data, size);
   1a8bc:	4620      	mov	r0, r4
   1a8be:	bf28      	it	cs
   1a8c0:	2140      	movcs	r1, #64	; 0x40
   1a8c2:	f7ff fdf7 	bl	1a4b4 <endpoint0_transmit>
	if (datalen == 0 && size < EP0_SIZE) return;
   1a8c6:	1a6f      	subs	r7, r5, r1
   1a8c8:	d102      	bne.n	1a8d0 <usb_isr+0x288>
   1a8ca:	2d3f      	cmp	r5, #63	; 0x3f
   1a8cc:	f67f af31 	bls.w	1a732 <usb_isr+0xea>
	data += size;
   1a8d0:	440c      	add	r4, r1
	if (size > EP0_SIZE) size = EP0_SIZE;
   1a8d2:	2f40      	cmp	r7, #64	; 0x40
   1a8d4:	4639      	mov	r1, r7
	endpoint0_transmit(data, size);
   1a8d6:	4620      	mov	r0, r4
   1a8d8:	bf28      	it	cs
   1a8da:	2140      	movcs	r1, #64	; 0x40
   1a8dc:	f7ff fdea 	bl	1a4b4 <endpoint0_transmit>
	data += size;
   1a8e0:	440c      	add	r4, r1
	if (datalen == 0 && size < EP0_SIZE) return;
   1a8e2:	1a79      	subs	r1, r7, r1
   1a8e4:	d102      	bne.n	1a8ec <usb_isr+0x2a4>
   1a8e6:	2f3f      	cmp	r7, #63	; 0x3f
   1a8e8:	f67f af23 	bls.w	1a732 <usb_isr+0xea>
	ep0_tx_len = datalen;
   1a8ec:	4b18      	ldr	r3, [pc, #96]	; (1a950 <usb_isr+0x308>)
	ep0_tx_ptr = data;
   1a8ee:	6034      	str	r4, [r6, #0]
	ep0_tx_len = datalen;
   1a8f0:	8019      	strh	r1, [r3, #0]
   1a8f2:	e71e      	b.n	1a732 <usb_isr+0xea>
   1a8f4:	20006688 	.word	0x20006688
   1a8f8:	40072000 	.word	0x40072000
   1a8fc:	200066f1 	.word	0x200066f1
   1a900:	200066f2 	.word	0x200066f2
   1a904:	200068a4 	.word	0x200068a4
   1a908:	1fff8000 	.word	0x1fff8000
   1a90c:	004000c8 	.word	0x004000c8
   1a910:	20006685 	.word	0x20006685
   1a914:	200066bc 	.word	0x200066bc
   1a918:	200066d8 	.word	0x200066d8
   1a91c:	20006694 	.word	0x20006694
   1a920:	200066ec 	.word	0x200066ec
   1a924:	200066c4 	.word	0x200066c4
   1a928:	200066f4 	.word	0x200066f4
   1a92c:	200066a8 	.word	0x200066a8
   1a930:	200066a8 	.word	0x200066a8
   1a934:	200066fe 	.word	0x200066fe
   1a938:	400720c4 	.word	0x400720c4
   1a93c:	00027c80 	.word	0x00027c80
   1a940:	400720d8 	.word	0x400720d8
   1a944:	bff8df3c 	.word	0xbff8df3c
   1a948:	00400088 	.word	0x00400088
   1a94c:	2000668c 	.word	0x2000668c
   1a950:	20006686 	.word	0x20006686
		reply_buffer[0] = 0;
   1a954:	4c9d      	ldr	r4, [pc, #628]	; (1abcc <usb_isr+0x584>)
   1a956:	2300      	movs	r3, #0
   1a958:	7023      	strb	r3, [r4, #0]
		reply_buffer[1] = 0;
   1a95a:	7063      	strb	r3, [r4, #1]
		datalen = 2;
   1a95c:	2302      	movs	r3, #2
   1a95e:	e7a7      	b.n	1a8b0 <usb_isr+0x268>
		i = setup.wIndex & 0x7F;
   1a960:	f002 027f 	and.w	r2, r2, #127	; 0x7f
		if (i > NUM_ENDPOINTS) {
   1a964:	2a05      	cmp	r2, #5
   1a966:	f63f aee0 	bhi.w	1a72a <usb_isr+0xe2>
		reply_buffer[0] = 0;
   1a96a:	4c98      	ldr	r4, [pc, #608]	; (1abcc <usb_isr+0x584>)
   1a96c:	2300      	movs	r3, #0
   1a96e:	7023      	strb	r3, [r4, #0]
		reply_buffer[1] = 0;
   1a970:	7063      	strb	r3, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
   1a972:	4b97      	ldr	r3, [pc, #604]	; (1abd0 <usb_isr+0x588>)
   1a974:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   1a978:	079d      	lsls	r5, r3, #30
   1a97a:	d5ef      	bpl.n	1a95c <usb_isr+0x314>
   1a97c:	2301      	movs	r3, #1
   1a97e:	7023      	strb	r3, [r4, #0]
   1a980:	e7ec      	b.n	1a95c <usb_isr+0x314>
		i = setup.wIndex & 0x7F;
   1a982:	f002 027f 	and.w	r2, r2, #127	; 0x7f
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
   1a986:	2a05      	cmp	r2, #5
   1a988:	f63f aecf 	bhi.w	1a72a <usb_isr+0xe2>
   1a98c:	0c03      	lsrs	r3, r0, #16
   1a98e:	f47f aecc 	bne.w	1a72a <usb_isr+0xe2>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
   1a992:	498f      	ldr	r1, [pc, #572]	; (1abd0 <usb_isr+0x588>)
   1a994:	f811 3022 	ldrb.w	r3, [r1, r2, lsl #2]
   1a998:	f023 0302 	bic.w	r3, r3, #2
   1a99c:	f801 3022 	strb.w	r3, [r1, r2, lsl #2]
		break;
   1a9a0:	e6d4      	b.n	1a74c <usb_isr+0x104>
		i = setup.wIndex & 0x7F;
   1a9a2:	f002 027f 	and.w	r2, r2, #127	; 0x7f
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
   1a9a6:	2a05      	cmp	r2, #5
   1a9a8:	f63f aebf 	bhi.w	1a72a <usb_isr+0xe2>
   1a9ac:	0c03      	lsrs	r3, r0, #16
   1a9ae:	f47f aebc 	bne.w	1a72a <usb_isr+0xe2>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
   1a9b2:	4887      	ldr	r0, [pc, #540]	; (1abd0 <usb_isr+0x588>)
   1a9b4:	f810 1022 	ldrb.w	r1, [r0, r2, lsl #2]
   1a9b8:	f041 0102 	orr.w	r1, r1, #2
   1a9bc:	f800 1022 	strb.w	r1, [r0, r2, lsl #2]
	switch (setup.wRequestAndType) {
   1a9c0:	461c      	mov	r4, r3
   1a9c2:	e775      	b.n	1a8b0 <usb_isr+0x268>
   1a9c4:	4983      	ldr	r1, [pc, #524]	; (1abd4 <usb_isr+0x58c>)
   1a9c6:	f3c0 430f 	ubfx	r3, r0, #16, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
   1a9ca:	b292      	uxth	r2, r2
			if (list->addr == NULL) break;
   1a9cc:	684c      	ldr	r4, [r1, #4]
   1a9ce:	2c00      	cmp	r4, #0
   1a9d0:	f43f aeab 	beq.w	1a72a <usb_isr+0xe2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
   1a9d4:	8808      	ldrh	r0, [r1, #0]
   1a9d6:	4298      	cmp	r0, r3
   1a9d8:	d108      	bne.n	1a9ec <usb_isr+0x3a4>
   1a9da:	884d      	ldrh	r5, [r1, #2]
   1a9dc:	4295      	cmp	r5, r2
   1a9de:	d105      	bne.n	1a9ec <usb_isr+0x3a4>
				if ((setup.wValue >> 8) == 3) {
   1a9e0:	0a00      	lsrs	r0, r0, #8
   1a9e2:	2803      	cmp	r0, #3
					datalen = *(list->addr);
   1a9e4:	bf0c      	ite	eq
   1a9e6:	7823      	ldrbeq	r3, [r4, #0]
					datalen = list->length;
   1a9e8:	890b      	ldrhne	r3, [r1, #8]
   1a9ea:	e761      	b.n	1a8b0 <usb_isr+0x268>
		for (list = usb_descriptor_list; 1; list++) {
   1a9ec:	310c      	adds	r1, #12
			if (list->addr == NULL) break;
   1a9ee:	e7ed      	b.n	1a9cc <usb_isr+0x384>
		switch (setup.wIndex) {
   1a9f0:	b292      	uxth	r2, r2
   1a9f2:	2a00      	cmp	r2, #0
   1a9f4:	f47f aeaa 	bne.w	1a74c <usb_isr+0x104>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
   1a9f8:	4b77      	ldr	r3, [pc, #476]	; (1abd8 <usb_isr+0x590>)
   1a9fa:	681a      	ldr	r2, [r3, #0]
   1a9fc:	4b77      	ldr	r3, [pc, #476]	; (1abdc <usb_isr+0x594>)
   1a9fe:	601a      	str	r2, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
   1aa00:	4a77      	ldr	r2, [pc, #476]	; (1abe0 <usb_isr+0x598>)
   1aa02:	f3c0 4307 	ubfx	r3, r0, #16, #8
   1aa06:	7013      	strb	r3, [r2, #0]
			break;
   1aa08:	e6a0      	b.n	1a74c <usb_isr+0x104>
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
   1aa0a:	4b76      	ldr	r3, [pc, #472]	; (1abe4 <usb_isr+0x59c>)
   1aa0c:	8818      	ldrh	r0, [r3, #0]
   1aa0e:	f242 0121 	movw	r1, #8225	; 0x2021
   1aa12:	4288      	cmp	r0, r1
   1aa14:	d114      	bne.n	1aa40 <usb_isr+0x3f8>
			switch (setup.wIndex) {
   1aa16:	889b      	ldrh	r3, [r3, #4]
   1aa18:	b973      	cbnz	r3, 1aa38 <usb_isr+0x3f0>
   1aa1a:	4b73      	ldr	r3, [pc, #460]	; (1abe8 <usb_isr+0x5a0>)
   1aa1c:	1dd0      	adds	r0, r2, #7
   1aa1e:	4619      	mov	r1, r3
					*dst++ = *buf++;
   1aa20:	f812 5b01 	ldrb.w	r5, [r2], #1
   1aa24:	f803 5b01 	strb.w	r5, [r3], #1
				for (i=0; i<7; i++) {
   1aa28:	4282      	cmp	r2, r0
   1aa2a:	d1f9      	bne.n	1aa20 <usb_isr+0x3d8>
				if (line_coding[0] == 134) usb_reboot_timer = 15;
   1aa2c:	680b      	ldr	r3, [r1, #0]
   1aa2e:	2b86      	cmp	r3, #134	; 0x86
   1aa30:	bf02      	ittt	eq
   1aa32:	4b6e      	ldreq	r3, [pc, #440]	; (1abec <usb_isr+0x5a4>)
   1aa34:	220f      	moveq	r2, #15
   1aa36:	701a      	strbeq	r2, [r3, #0]
			endpoint0_transmit(NULL, 0);
   1aa38:	2100      	movs	r1, #0
   1aa3a:	4608      	mov	r0, r1
   1aa3c:	f7ff fd3a 	bl	1a4b4 <endpoint0_transmit>
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
   1aa40:	4b6b      	ldr	r3, [pc, #428]	; (1abf0 <usb_isr+0x5a8>)
   1aa42:	f844 3038 	str.w	r3, [r4, r8, lsl #3]
		break;
   1aa46:	e643      	b.n	1a6d0 <usb_isr+0x88>
		data = ep0_tx_ptr;
   1aa48:	6834      	ldr	r4, [r6, #0]
		if (data) {
   1aa4a:	b18c      	cbz	r4, 1aa70 <usb_isr+0x428>
			size = ep0_tx_len;
   1aa4c:	4f69      	ldr	r7, [pc, #420]	; (1abf4 <usb_isr+0x5ac>)
   1aa4e:	883d      	ldrh	r5, [r7, #0]
			if (size > EP0_SIZE) size = EP0_SIZE;
   1aa50:	2d40      	cmp	r5, #64	; 0x40
   1aa52:	4629      	mov	r1, r5
			endpoint0_transmit(data, size);
   1aa54:	4620      	mov	r0, r4
   1aa56:	bf28      	it	cs
   1aa58:	2140      	movcs	r1, #64	; 0x40
   1aa5a:	f7ff fd2b 	bl	1a4b4 <endpoint0_transmit>
			data += size;
   1aa5e:	440c      	add	r4, r1
			ep0_tx_len -= size;
   1aa60:	1a69      	subs	r1, r5, r1
   1aa62:	b289      	uxth	r1, r1
   1aa64:	8039      	strh	r1, [r7, #0]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
   1aa66:	b911      	cbnz	r1, 1aa6e <usb_isr+0x426>
   1aa68:	2d3f      	cmp	r5, #63	; 0x3f
   1aa6a:	bf98      	it	ls
   1aa6c:	2400      	movls	r4, #0
   1aa6e:	6034      	str	r4, [r6, #0]
		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
   1aa70:	4b5c      	ldr	r3, [pc, #368]	; (1abe4 <usb_isr+0x59c>)
   1aa72:	881a      	ldrh	r2, [r3, #0]
   1aa74:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
   1aa78:	f47f ae2a 	bne.w	1a6d0 <usb_isr+0x88>
			setup.bRequest = 0;
   1aa7c:	2200      	movs	r2, #0
   1aa7e:	705a      	strb	r2, [r3, #1]
			USB0_ADDR = setup.wValue;
   1aa80:	789a      	ldrb	r2, [r3, #2]
   1aa82:	4b5d      	ldr	r3, [pc, #372]	; (1abf8 <usb_isr+0x5b0>)
   1aa84:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
   1aa88:	e622      	b.n	1a6d0 <usb_isr+0x88>
			bdt_t *b = stat2bufferdescriptor(stat);
   1aa8a:	4647      	mov	r7, r8
   1aa8c:	eb04 08c8 	add.w	r8, r4, r8, lsl #3
			endpoint--;	// endpoint is index to zero-based arrays
   1aa90:	3d01      	subs	r5, #1
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
   1aa92:	f8d8 1004 	ldr.w	r1, [r8, #4]
			if (stat & 0x08) { // transmit
   1aa96:	f013 0308 	ands.w	r3, r3, #8
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
   1aa9a:	f1a1 0008 	sub.w	r0, r1, #8
			endpoint--;	// endpoint is index to zero-based arrays
   1aa9e:	b2ed      	uxtb	r5, r5
			if (stat & 0x08) { // transmit
   1aaa0:	d039      	beq.n	1ab16 <usb_isr+0x4ce>
				usb_free(packet);
   1aaa2:	f000 f941 	bl	1ad28 <usb_free>
				packet = tx_first[endpoint];
   1aaa6:	4b55      	ldr	r3, [pc, #340]	; (1abfc <usb_isr+0x5b4>)
   1aaa8:	4955      	ldr	r1, [pc, #340]	; (1ac00 <usb_isr+0x5b8>)
   1aaaa:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
				if (packet) {
   1aaae:	b300      	cbz	r0, 1aaf2 <usb_isr+0x4aa>
					tx_first[endpoint] = packet->next;
   1aab0:	6842      	ldr	r2, [r0, #4]
   1aab2:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
					b->addr = packet->buf;
   1aab6:	f100 0308 	add.w	r3, r0, #8
   1aaba:	f8c8 3004 	str.w	r3, [r8, #4]
					switch (tx_state[endpoint]) {
   1aabe:	5d4b      	ldrb	r3, [r1, r5]
   1aac0:	2b03      	cmp	r3, #3
   1aac2:	d805      	bhi.n	1aad0 <usb_isr+0x488>
   1aac4:	e8df f003 	tbb	[pc, r3]
   1aac8:	13110f02 	.word	0x13110f02
						tx_state[endpoint] = TX_STATE_ODD_FREE;
   1aacc:	2303      	movs	r3, #3
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
   1aace:	554b      	strb	r3, [r1, r5]
					b->desc = BDT_DESC(packet->len,
   1aad0:	f018 0f08 	tst.w	r8, #8
   1aad4:	8802      	ldrh	r2, [r0, #0]
   1aad6:	bf14      	ite	ne
   1aad8:	23c8      	movne	r3, #200	; 0xc8
   1aada:	2388      	moveq	r3, #136	; 0x88
   1aadc:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
   1aae0:	f844 3037 	str.w	r3, [r4, r7, lsl #3]
   1aae4:	e5f8      	b.n	1a6d8 <usb_isr+0x90>
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
   1aae6:	2302      	movs	r3, #2
   1aae8:	e7f1      	b.n	1aace <usb_isr+0x486>
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
   1aaea:	2305      	movs	r3, #5
   1aaec:	e7ef      	b.n	1aace <usb_isr+0x486>
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
   1aaee:	2304      	movs	r3, #4
   1aaf0:	e7ed      	b.n	1aace <usb_isr+0x486>
					switch (tx_state[endpoint]) {
   1aaf2:	5d4b      	ldrb	r3, [r1, r5]
   1aaf4:	2b02      	cmp	r3, #2
   1aaf6:	d009      	beq.n	1ab0c <usb_isr+0x4c4>
   1aaf8:	f67f adee 	bls.w	1a6d8 <usb_isr+0x90>
   1aafc:	2b03      	cmp	r3, #3
   1aafe:	d007      	beq.n	1ab10 <usb_isr+0x4c8>
						tx_state[endpoint] = ((uint32_t)b & 8) ?
   1ab00:	f018 0f08 	tst.w	r8, #8
   1ab04:	bf14      	ite	ne
   1ab06:	2303      	movne	r3, #3
   1ab08:	2302      	moveq	r3, #2
   1ab0a:	e002      	b.n	1ab12 <usb_isr+0x4ca>
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
   1ab0c:	5548      	strb	r0, [r1, r5]
						break;
   1ab0e:	e5e3      	b.n	1a6d8 <usb_isr+0x90>
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
   1ab10:	2301      	movs	r3, #1
						tx_state[endpoint] = ((uint32_t)b & 8) ?
   1ab12:	554b      	strb	r3, [r1, r5]
						break;
   1ab14:	e5e0      	b.n	1a6d8 <usb_isr+0x90>
				packet->len = b->desc >> 16;
   1ab16:	f854 2037 	ldr.w	r2, [r4, r7, lsl #3]
   1ab1a:	ea4f 4c12 	mov.w	ip, r2, lsr #16
				if (packet->len > 0) {
   1ab1e:	0c12      	lsrs	r2, r2, #16
				packet->len = b->desc >> 16;
   1ab20:	f821 cc08 	strh.w	ip, [r1, #-8]
				if (packet->len > 0) {
   1ab24:	d018      	beq.n	1ab58 <usb_isr+0x510>
					packet->index = 0;
   1ab26:	f821 3c06 	strh.w	r3, [r1, #-6]
					packet->next = NULL;
   1ab2a:	f841 3c04 	str.w	r3, [r1, #-4]
					if (rx_first[endpoint] == NULL) {
   1ab2e:	4935      	ldr	r1, [pc, #212]	; (1ac04 <usb_isr+0x5bc>)
   1ab30:	4b35      	ldr	r3, [pc, #212]	; (1ac08 <usb_isr+0x5c0>)
   1ab32:	f851 2025 	ldr.w	r2, [r1, r5, lsl #2]
   1ab36:	b9b2      	cbnz	r2, 1ab66 <usb_isr+0x51e>
						rx_first[endpoint] = packet;
   1ab38:	f841 0025 	str.w	r0, [r1, r5, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
   1ab3c:	4a33      	ldr	r2, [pc, #204]	; (1ac0c <usb_isr+0x5c4>)
					rx_last[endpoint] = packet;
   1ab3e:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
   1ab42:	f832 3015 	ldrh.w	r3, [r2, r5, lsl #1]
   1ab46:	4463      	add	r3, ip
   1ab48:	f822 3015 	strh.w	r3, [r2, r5, lsl #1]
					packet = usb_malloc();
   1ab4c:	f000 f8ce 	bl	1acec <usb_malloc>
					if (packet) {
   1ab50:	b168      	cbz	r0, 1ab6e <usb_isr+0x526>
						b->addr = packet->buf;
   1ab52:	3008      	adds	r0, #8
   1ab54:	f8c8 0004 	str.w	r0, [r8, #4]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
   1ab58:	4a2d      	ldr	r2, [pc, #180]	; (1ac10 <usb_isr+0x5c8>)
   1ab5a:	4b25      	ldr	r3, [pc, #148]	; (1abf0 <usb_isr+0x5a8>)
   1ab5c:	f018 0f08 	tst.w	r8, #8
   1ab60:	bf08      	it	eq
   1ab62:	4613      	moveq	r3, r2
   1ab64:	e7bc      	b.n	1aae0 <usb_isr+0x498>
						rx_last[endpoint]->next = packet;
   1ab66:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
   1ab6a:	6050      	str	r0, [r2, #4]
   1ab6c:	e7e6      	b.n	1ab3c <usb_isr+0x4f4>
						usb_rx_memory_needed++;
   1ab6e:	4a29      	ldr	r2, [pc, #164]	; (1ac14 <usb_isr+0x5cc>)
						b->desc = 0;
   1ab70:	f844 0037 	str.w	r0, [r4, r7, lsl #3]
						usb_rx_memory_needed++;
   1ab74:	7813      	ldrb	r3, [r2, #0]
   1ab76:	3301      	adds	r3, #1
   1ab78:	7013      	strb	r3, [r2, #0]
   1ab7a:	e5ad      	b.n	1a6d8 <usb_isr+0x90>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
   1ab7c:	07e0      	lsls	r0, r4, #31
   1ab7e:	d553      	bpl.n	1ac28 <usb_isr+0x5e0>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
   1ab80:	4b1d      	ldr	r3, [pc, #116]	; (1abf8 <usb_isr+0x5b0>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
   1ab82:	4823      	ldr	r0, [pc, #140]	; (1ac10 <usb_isr+0x5c8>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
   1ab84:	4c24      	ldr	r4, [pc, #144]	; (1ac18 <usb_isr+0x5d0>)
		USB0_CTL = USB_CTL_ODDRST;
   1ab86:	2202      	movs	r2, #2
   1ab88:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
		ep0_tx_bdt_bank = 0;
   1ab8c:	4a23      	ldr	r2, [pc, #140]	; (1ac1c <usb_isr+0x5d4>)
   1ab8e:	7011      	strb	r1, [r2, #0]
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
   1ab90:	4a23      	ldr	r2, [pc, #140]	; (1ac20 <usb_isr+0x5d8>)
   1ab92:	6010      	str	r0, [r2, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
   1ab94:	6054      	str	r4, [r2, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
   1ab96:	6090      	str	r0, [r2, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
   1ab98:	4822      	ldr	r0, [pc, #136]	; (1ac24 <usb_isr+0x5dc>)
   1ab9a:	60d0      	str	r0, [r2, #12]
		table[index(0, TX, EVEN)].desc = 0;
   1ab9c:	6111      	str	r1, [r2, #16]
		table[index(0, TX, ODD)].desc = 0;
   1ab9e:	6191      	str	r1, [r2, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
   1aba0:	220d      	movs	r2, #13
   1aba2:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
   1aba6:	22ff      	movs	r2, #255	; 0xff
   1aba8:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
		USB0_ISTAT = 0xFF;
   1abac:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

		// set the address to zero during enumeration
		USB0_ADDR = 0;
   1abb0:	f883 1098 	strb.w	r1, [r3, #152]	; 0x98

		// enable other interrupts
		USB0_ERREN = 0xFF;
   1abb4:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		USB0_INTEN = USB_INTEN_TOKDNEEN |
   1abb8:	229f      	movs	r2, #159	; 0x9f
   1abba:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
   1abbe:	2201      	movs	r2, #1
   1abc0:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
   1abc4:	b003      	add	sp, #12
   1abc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1abca:	bf00      	nop
   1abcc:	2000668c 	.word	0x2000668c
   1abd0:	400720c0 	.word	0x400720c0
   1abd4:	00027c20 	.word	0x00027c20
   1abd8:	20006600 	.word	0x20006600
   1abdc:	200068a0 	.word	0x200068a0
   1abe0:	2000689c 	.word	0x2000689c
   1abe4:	200066bc 	.word	0x200066bc
   1abe8:	20006894 	.word	0x20006894
   1abec:	200066f2 	.word	0x200066f2
   1abf0:	004000c8 	.word	0x004000c8
   1abf4:	20006686 	.word	0x20006686
   1abf8:	40072000 	.word	0x40072000
   1abfc:	200066c4 	.word	0x200066c4
   1ac00:	200066ec 	.word	0x200066ec
   1ac04:	20006694 	.word	0x20006694
   1ac08:	200066a8 	.word	0x200066a8
   1ac0c:	200066f4 	.word	0x200066f4
   1ac10:	00400088 	.word	0x00400088
   1ac14:	200066fe 	.word	0x200066fe
   1ac18:	20006604 	.word	0x20006604
   1ac1c:	20006684 	.word	0x20006684
   1ac20:	1fff8000 	.word	0x1fff8000
   1ac24:	20006644 	.word	0x20006644
	if ((status & USB_ISTAT_STALL /* 80 */ )) {
   1ac28:	0621      	lsls	r1, r4, #24
   1ac2a:	d506      	bpl.n	1ac3a <usb_isr+0x5f2>
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
   1ac2c:	4b0c      	ldr	r3, [pc, #48]	; (1ac60 <usb_isr+0x618>)
   1ac2e:	220d      	movs	r2, #13
   1ac30:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
		USB0_ISTAT = USB_ISTAT_STALL;
   1ac34:	2280      	movs	r2, #128	; 0x80
   1ac36:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
   1ac3a:	07a2      	lsls	r2, r4, #30
   1ac3c:	d508      	bpl.n	1ac50 <usb_isr+0x608>
		uint8_t err = USB0_ERRSTAT;
   1ac3e:	4b08      	ldr	r3, [pc, #32]	; (1ac60 <usb_isr+0x618>)
   1ac40:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
   1ac44:	b2d2      	uxtb	r2, r2
		USB0_ERRSTAT = err;
   1ac46:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
		USB0_ISTAT = USB_ISTAT_ERROR;
   1ac4a:	2202      	movs	r2, #2
   1ac4c:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
   1ac50:	06e3      	lsls	r3, r4, #27
		USB0_ISTAT = USB_ISTAT_SLEEP;
   1ac52:	bf42      	ittt	mi
   1ac54:	4b02      	ldrmi	r3, [pc, #8]	; (1ac60 <usb_isr+0x618>)
   1ac56:	2210      	movmi	r2, #16
   1ac58:	f883 2080 	strbmi.w	r2, [r3, #128]	; 0x80
   1ac5c:	e7b2      	b.n	1abc4 <usb_isr+0x57c>
   1ac5e:	bf00      	nop
   1ac60:	40072000 	.word	0x40072000

0001ac64 <usb_init>:



void usb_init(void)
{
   1ac64:	b508      	push	{r3, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
   1ac66:	f000 fc31 	bl	1b4cc <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
   1ac6a:	2300      	movs	r3, #0
		table[i].desc = 0;
   1ac6c:	4a1a      	ldr	r2, [pc, #104]	; (1acd8 <usb_init+0x74>)
   1ac6e:	4619      	mov	r1, r3
   1ac70:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
		table[i].addr = 0;
   1ac74:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
   1ac78:	3301      	adds	r3, #1
   1ac7a:	2b18      	cmp	r3, #24
		table[i].addr = 0;
   1ac7c:	6041      	str	r1, [r0, #4]
	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
   1ac7e:	d1f7      	bne.n	1ac70 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
   1ac80:	4816      	ldr	r0, [pc, #88]	; (1acdc <usb_init+0x78>)
   1ac82:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1ac84:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   1ac88:	6343      	str	r3, [r0, #52]	; 0x34
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
   1ac8a:	4b15      	ldr	r3, [pc, #84]	; (1ace0 <usb_init+0x7c>)
   1ac8c:	f3c2 2007 	ubfx	r0, r2, #8, #8
   1ac90:	f883 009c 	strb.w	r0, [r3, #156]	; 0x9c
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
   1ac94:	f3c2 4007 	ubfx	r0, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
   1ac98:	0e12      	lsrs	r2, r2, #24
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
   1ac9a:	f883 00b0 	strb.w	r0, [r3, #176]	; 0xb0
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
   1ac9e:	f883 20b4 	strb.w	r2, [r3, #180]	; 0xb4

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
   1aca2:	22ff      	movs	r2, #255	; 0xff
   1aca4:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	USB0_ERRSTAT = 0xFF;
   1aca8:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
	USB0_OTGISTAT = 0xFF;
   1acac:	741a      	strb	r2, [r3, #16]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
   1acae:	4a0d      	ldr	r2, [pc, #52]	; (1ace4 <usb_init+0x80>)
	USB0_CTL = USB_CTL_USBENSOFEN;
   1acb0:	2001      	movs	r0, #1
   1acb2:	f883 0094 	strb.w	r0, [r3, #148]	; 0x94
	USB0_USBCTRL = 0;
   1acb6:	7011      	strb	r1, [r2, #0]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
   1acb8:	f883 0084 	strb.w	r0, [r3, #132]	; 0x84

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
   1acbc:	4b0a      	ldr	r3, [pc, #40]	; (1ace8 <usb_init+0x84>)
   1acbe:	2170      	movs	r1, #112	; 0x70
   1acc0:	f883 1049 	strb.w	r1, [r3, #73]	; 0x49
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
   1acc4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
   1acc8:	f44f 7100 	mov.w	r1, #512	; 0x200
   1accc:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
   1acd0:	2310      	movs	r3, #16
   1acd2:	7213      	strb	r3, [r2, #8]
}
   1acd4:	bd08      	pop	{r3, pc}
   1acd6:	bf00      	nop
   1acd8:	1fff8000 	.word	0x1fff8000
   1acdc:	40048000 	.word	0x40048000
   1ace0:	40072000 	.word	0x40072000
   1ace4:	40072100 	.word	0x40072100
   1ace8:	e000e400 	.word	0xe000e400

0001acec <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
   1acec:	b672      	cpsid	i
	avail = usb_buffer_available;
   1acee:	480c      	ldr	r0, [pc, #48]	; (1ad20 <usb_malloc+0x34>)
   1acf0:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
   1acf2:	fab2 f382 	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
   1acf6:	2b1d      	cmp	r3, #29
   1acf8:	dd02      	ble.n	1ad00 <usb_malloc+0x14>
		__enable_irq();
   1acfa:	b662      	cpsie	i
		return NULL;
   1acfc:	2000      	movs	r0, #0
   1acfe:	4770      	bx	lr
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
   1ad00:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1ad04:	40d9      	lsrs	r1, r3
   1ad06:	ea22 0201 	bic.w	r2, r2, r1
   1ad0a:	6002      	str	r2, [r0, #0]
	__enable_irq();
   1ad0c:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
   1ad0e:	4905      	ldr	r1, [pc, #20]	; (1ad24 <usb_malloc+0x38>)
   1ad10:	2248      	movs	r2, #72	; 0x48
   1ad12:	4353      	muls	r3, r2
   1ad14:	18c8      	adds	r0, r1, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
   1ad16:	2200      	movs	r2, #0
   1ad18:	50ca      	str	r2, [r1, r3]
	*(uint32_t *)(p + 4) = 0;
   1ad1a:	6042      	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
   1ad1c:	4770      	bx	lr
   1ad1e:	bf00      	nop
   1ad20:	1fffa1cc 	.word	0x1fffa1cc
   1ad24:	1fff83bc 	.word	0x1fff83bc

0001ad28 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
   1ad28:	4b0d      	ldr	r3, [pc, #52]	; (1ad60 <usb_free+0x38>)
   1ad2a:	1ac3      	subs	r3, r0, r3
	if (n >= NUM_USB_BUFFERS) return;
   1ad2c:	f5b3 6f07 	cmp.w	r3, #2160	; 0x870
   1ad30:	d214      	bcs.n	1ad5c <usb_free+0x34>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
   1ad32:	4a0c      	ldr	r2, [pc, #48]	; (1ad64 <usb_free+0x3c>)
   1ad34:	7812      	ldrb	r2, [r2, #0]
   1ad36:	b122      	cbz	r2, 1ad42 <usb_free+0x1a>
   1ad38:	4a0b      	ldr	r2, [pc, #44]	; (1ad68 <usb_free+0x40>)
   1ad3a:	7812      	ldrb	r2, [r2, #0]
   1ad3c:	b10a      	cbz	r2, 1ad42 <usb_free+0x1a>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
   1ad3e:	f7ff bc07 	b.w	1a550 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
   1ad42:	b672      	cpsid	i
	usb_buffer_available |= mask;
   1ad44:	4909      	ldr	r1, [pc, #36]	; (1ad6c <usb_free+0x44>)
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
   1ad46:	2248      	movs	r2, #72	; 0x48
   1ad48:	fbb3 f3f2 	udiv	r3, r3, r2
	mask = (0x80000000 >> n);
   1ad4c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1ad50:	fa22 f303 	lsr.w	r3, r2, r3
	usb_buffer_available |= mask;
   1ad54:	680a      	ldr	r2, [r1, #0]
   1ad56:	4313      	orrs	r3, r2
   1ad58:	600b      	str	r3, [r1, #0]
	__enable_irq();
   1ad5a:	b662      	cpsie	i

	//serial_print("free:");
	//serial_phex32((int)p);
	//serial_print("\n");
}
   1ad5c:	4770      	bx	lr
   1ad5e:	bf00      	nop
   1ad60:	1fff83bc 	.word	0x1fff83bc
   1ad64:	200066fe 	.word	0x200066fe
   1ad68:	200066f1 	.word	0x200066f1
   1ad6c:	1fffa1cc 	.word	0x1fffa1cc

0001ad70 <sysex_byte>:
		tx_noautoflush = 0;
	}
}

static void sysex_byte(uint8_t b)
{
   1ad70:	b538      	push	{r3, r4, r5, lr}
	if (usb_midi_handleSysExPartial && usb_midi_msg_sysex_len >= USB_MIDI_SYSEX_MAX) {
   1ad72:	4b0b      	ldr	r3, [pc, #44]	; (1ada0 <sysex_byte+0x30>)
   1ad74:	4c0b      	ldr	r4, [pc, #44]	; (1ada4 <sysex_byte+0x34>)
   1ad76:	681b      	ldr	r3, [r3, #0]
{
   1ad78:	4605      	mov	r5, r0
	if (usb_midi_handleSysExPartial && usb_midi_msg_sysex_len >= USB_MIDI_SYSEX_MAX) {
   1ad7a:	b143      	cbz	r3, 1ad8e <sysex_byte+0x1e>
   1ad7c:	8821      	ldrh	r1, [r4, #0]
   1ad7e:	f5b1 7f91 	cmp.w	r1, #290	; 0x122
   1ad82:	d304      	bcc.n	1ad8e <sysex_byte+0x1e>
		// when buffer is full, send another chunk to partial handler.
		(*usb_midi_handleSysExPartial)(usb_midi_msg_sysex, usb_midi_msg_sysex_len, 0);
   1ad84:	4808      	ldr	r0, [pc, #32]	; (1ada8 <sysex_byte+0x38>)
   1ad86:	2200      	movs	r2, #0
   1ad88:	4798      	blx	r3
		usb_midi_msg_sysex_len = 0;
   1ad8a:	2300      	movs	r3, #0
   1ad8c:	8023      	strh	r3, [r4, #0]
	}
	if (usb_midi_msg_sysex_len < USB_MIDI_SYSEX_MAX) {
   1ad8e:	8823      	ldrh	r3, [r4, #0]
   1ad90:	f5b3 7f91 	cmp.w	r3, #290	; 0x122
		usb_midi_msg_sysex[usb_midi_msg_sysex_len++] = b;
   1ad94:	bf3f      	itttt	cc
   1ad96:	1c5a      	addcc	r2, r3, #1
   1ad98:	8022      	strhcc	r2, [r4, #0]
   1ad9a:	4a03      	ldrcc	r2, [pc, #12]	; (1ada8 <sysex_byte+0x38>)
   1ad9c:	54d5      	strbcc	r5, [r2, r3]
	}
}
   1ad9e:	bd38      	pop	{r3, r4, r5, pc}
   1ada0:	20006748 	.word	0x20006748
   1ada4:	20006882 	.word	0x20006882
   1ada8:	20006760 	.word	0x20006760

0001adac <usb_midi_write_packed>:
{
   1adac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	tx_noautoflush = 1;
   1adb0:	4e1e      	ldr	r6, [pc, #120]	; (1ae2c <usb_midi_write_packed+0x80>)
	if (!tx_packet) {
   1adb2:	4c1f      	ldr	r4, [pc, #124]	; (1ae30 <usb_midi_write_packed+0x84>)
	tx_noautoflush = 1;
   1adb4:	2301      	movs	r3, #1
   1adb6:	7033      	strb	r3, [r6, #0]
	if (!tx_packet) {
   1adb8:	6823      	ldr	r3, [r4, #0]
{
   1adba:	4605      	mov	r5, r0
	if (!tx_packet) {
   1adbc:	b9cb      	cbnz	r3, 1adf2 <usb_midi_write_packed+0x46>
                	if (!usb_configuration) {
   1adbe:	f8df 9074 	ldr.w	r9, [pc, #116]	; 1ae34 <usb_midi_write_packed+0x88>
   1adc2:	f8df 8074 	ldr.w	r8, [pc, #116]	; 1ae38 <usb_midi_write_packed+0x8c>
   1adc6:	f247 7761 	movw	r7, #30561	; 0x7761
   1adca:	f899 3000 	ldrb.w	r3, [r9]
   1adce:	b14b      	cbz	r3, 1ade4 <usb_midi_write_packed+0x38>
                	if (usb_tx_packet_count(MIDI_TX_ENDPOINT) < TX_PACKET_LIMIT) {
   1add0:	2004      	movs	r0, #4
   1add2:	f7ff fbab 	bl	1a52c <usb_tx_packet_count>
   1add6:	2805      	cmp	r0, #5
   1add8:	d906      	bls.n	1ade8 <usb_midi_write_packed+0x3c>
                	if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
   1adda:	3f01      	subs	r7, #1
   1addc:	d118      	bne.n	1ae10 <usb_midi_write_packed+0x64>
                        	transmit_previous_timeout = 1;
   1adde:	2301      	movs	r3, #1
   1ade0:	f888 3000 	strb.w	r3, [r8]
}
   1ade4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                        	tx_packet = usb_malloc();
   1ade8:	f7ff ff80 	bl	1acec <usb_malloc>
   1adec:	6020      	str	r0, [r4, #0]
                        	if (tx_packet) break;
   1adee:	2800      	cmp	r0, #0
   1adf0:	d0f3      	beq.n	1adda <usb_midi_write_packed+0x2e>
	transmit_previous_timeout = 0;
   1adf2:	4b11      	ldr	r3, [pc, #68]	; (1ae38 <usb_midi_write_packed+0x8c>)
	index = tx_packet->index;
   1adf4:	6821      	ldr	r1, [r4, #0]
	transmit_previous_timeout = 0;
   1adf6:	2700      	movs	r7, #0
   1adf8:	701f      	strb	r7, [r3, #0]
	index = tx_packet->index;
   1adfa:	884b      	ldrh	r3, [r1, #2]
	((uint32_t *)(tx_packet->buf))[index++] = n;
   1adfc:	eb01 0283 	add.w	r2, r1, r3, lsl #2
   1ae00:	3301      	adds	r3, #1
	if (index < MIDI_TX_SIZE/4) {
   1ae02:	2b0f      	cmp	r3, #15
	((uint32_t *)(tx_packet->buf))[index++] = n;
   1ae04:	6095      	str	r5, [r2, #8]
	if (index < MIDI_TX_SIZE/4) {
   1ae06:	d80a      	bhi.n	1ae1e <usb_midi_write_packed+0x72>
		tx_packet->index = index;
   1ae08:	804b      	strh	r3, [r1, #2]
	tx_noautoflush = 0;
   1ae0a:	2300      	movs	r3, #0
   1ae0c:	7033      	strb	r3, [r6, #0]
   1ae0e:	e7e9      	b.n	1ade4 <usb_midi_write_packed+0x38>
                	if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
   1ae10:	f898 3000 	ldrb.w	r3, [r8]
   1ae14:	2b00      	cmp	r3, #0
   1ae16:	d1e2      	bne.n	1adde <usb_midi_write_packed+0x32>
                	yield();
   1ae18:	f000 faa0 	bl	1b35c <yield>
                	if (!usb_configuration) {
   1ae1c:	e7d5      	b.n	1adca <usb_midi_write_packed+0x1e>
		tx_packet->len = MIDI_TX_SIZE;
   1ae1e:	2340      	movs	r3, #64	; 0x40
   1ae20:	800b      	strh	r3, [r1, #0]
		usb_tx(MIDI_TX_ENDPOINT, tx_packet);
   1ae22:	2004      	movs	r0, #4
   1ae24:	f7ff fbd0 	bl	1a5c8 <usb_tx>
		tx_packet = NULL;
   1ae28:	6027      	str	r7, [r4, #0]
   1ae2a:	e7ee      	b.n	1ae0a <usb_midi_write_packed+0x5e>
   1ae2c:	20006705 	.word	0x20006705
   1ae30:	20006708 	.word	0x20006708
   1ae34:	200066f1 	.word	0x200066f1
   1ae38:	20006704 	.word	0x20006704

0001ae3c <usb_midi_send_sysex_add_term_bytes>:
{
   1ae3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	cable = (cable & 0x0F) << 4;
   1ae3e:	0114      	lsls	r4, r2, #4
{
   1ae40:	4606      	mov	r6, r0
	cable = (cable & 0x0F) << 4;
   1ae42:	b2e4      	uxtb	r4, r4
	if (length == 0) {
   1ae44:	460d      	mov	r5, r1
   1ae46:	b929      	cbnz	r1, 1ae54 <usb_midi_send_sysex_add_term_bytes+0x18>
		usb_midi_write_packed(0x06 | cable | (0xF0 << 8) | (0xF7 << 16));
   1ae48:	4824      	ldr	r0, [pc, #144]	; (1aedc <usb_midi_send_sysex_add_term_bytes+0xa0>)
		usb_midi_write_packed(0x07 | cable | (0xF0 << 8) | (data[0] << 16) | (0xF7 << 24));
   1ae4a:	4320      	orrs	r0, r4
}
   1ae4c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                usb_midi_write_packed(0x05 | cable | (0xF7 << 8));
   1ae50:	f7ff bfac 	b.w	1adac <usb_midi_write_packed>
		usb_midi_write_packed(0x07 | cable | (0xF0 << 8) | (data[0] << 16) | (0xF7 << 24));
   1ae54:	7800      	ldrb	r0, [r0, #0]
	} else if (length == 1) {
   1ae56:	2901      	cmp	r1, #1
		usb_midi_write_packed(0x07 | cable | (0xF0 << 8) | (data[0] << 16) | (0xF7 << 24));
   1ae58:	ea4f 4000 	mov.w	r0, r0, lsl #16
	} else if (length == 1) {
   1ae5c:	d102      	bne.n	1ae64 <usb_midi_send_sysex_add_term_bytes+0x28>
		usb_midi_write_packed(0x07 | cable | (0xF0 << 8) | (data[0] << 16) | (0xF7 << 24));
   1ae5e:	4304      	orrs	r4, r0
   1ae60:	481f      	ldr	r0, [pc, #124]	; (1aee0 <usb_midi_send_sysex_add_term_bytes+0xa4>)
   1ae62:	e7f2      	b.n	1ae4a <usb_midi_send_sysex_add_term_bytes+0xe>
		usb_midi_write_packed(0x04 | cable | (0xF0 << 8) | (data[0] << 16) | (data[1] << 24));
   1ae64:	7873      	ldrb	r3, [r6, #1]
   1ae66:	f044 0704 	orr.w	r7, r4, #4
   1ae6a:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
   1ae6e:	4338      	orrs	r0, r7
   1ae70:	f440 4070 	orr.w	r0, r0, #61440	; 0xf000
   1ae74:	f7ff ff9a 	bl	1adac <usb_midi_write_packed>
		length -= 2;
   1ae78:	3d02      	subs	r5, #2
		data += 2;
   1ae7a:	3602      	adds	r6, #2
	while (length >= 3) {
   1ae7c:	2d02      	cmp	r5, #2
   1ae7e:	4633      	mov	r3, r6
   1ae80:	f106 0603 	add.w	r6, r6, #3
   1ae84:	d80b      	bhi.n	1ae9e <usb_midi_send_sysex_add_term_bytes+0x62>
	if (length == 2) {
   1ae86:	d11a      	bne.n	1aebe <usb_midi_send_sysex_add_term_bytes+0x82>
		usb_midi_write_packed(0x07 | cable | (data[0] << 8) | (data[1] << 16) | (0xF7 << 24));
   1ae88:	7858      	ldrb	r0, [r3, #1]
   1ae8a:	781a      	ldrb	r2, [r3, #0]
   1ae8c:	0400      	lsls	r0, r0, #16
   1ae8e:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
   1ae92:	4320      	orrs	r0, r4
   1ae94:	f040 4077 	orr.w	r0, r0, #4143972352	; 0xf7000000
   1ae98:	f040 0007 	orr.w	r0, r0, #7
   1ae9c:	e7d6      	b.n	1ae4c <usb_midi_send_sysex_add_term_bytes+0x10>
		usb_midi_write_packed(0x04 | cable | (data[0] << 8) | (data[1] << 16) | (data[2] << 24));
   1ae9e:	f816 3c02 	ldrb.w	r3, [r6, #-2]
   1aea2:	f816 2c03 	ldrb.w	r2, [r6, #-3]
   1aea6:	f816 0c01 	ldrb.w	r0, [r6, #-1]
   1aeaa:	041b      	lsls	r3, r3, #16
   1aeac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1aeb0:	433b      	orrs	r3, r7
   1aeb2:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
   1aeb6:	f7ff ff79 	bl	1adac <usb_midi_write_packed>
		length -= 3;
   1aeba:	3d03      	subs	r5, #3
   1aebc:	e7de      	b.n	1ae7c <usb_midi_send_sysex_add_term_bytes+0x40>
	} else if (length == 1) {
   1aebe:	2d01      	cmp	r5, #1
                usb_midi_write_packed(0x06 | cable | (data[0] << 8) | (0xF7 << 16));
   1aec0:	bf03      	ittte	eq
   1aec2:	781b      	ldrbeq	r3, [r3, #0]
   1aec4:	f044 0006 	orreq.w	r0, r4, #6
   1aec8:	ea40 2003 	orreq.w	r0, r0, r3, lsl #8
                usb_midi_write_packed(0x05 | cable | (0xF7 << 8));
   1aecc:	f444 4077 	orrne.w	r0, r4, #63232	; 0xf700
                usb_midi_write_packed(0x06 | cable | (data[0] << 8) | (0xF7 << 16));
   1aed0:	bf0c      	ite	eq
   1aed2:	f440 0077 	orreq.w	r0, r0, #16187392	; 0xf70000
                usb_midi_write_packed(0x05 | cable | (0xF7 << 8));
   1aed6:	f040 0005 	orrne.w	r0, r0, #5
   1aeda:	e7b7      	b.n	1ae4c <usb_midi_send_sysex_add_term_bytes+0x10>
   1aedc:	00f7f006 	.word	0x00f7f006
   1aee0:	f700f007 	.word	0xf700f007

0001aee4 <usb_midi_flush_output>:
{
   1aee4:	b570      	push	{r4, r5, r6, lr}
	if (tx_noautoflush == 0) {
   1aee6:	4c09      	ldr	r4, [pc, #36]	; (1af0c <usb_midi_flush_output+0x28>)
   1aee8:	7826      	ldrb	r6, [r4, #0]
   1aeea:	b976      	cbnz	r6, 1af0a <usb_midi_flush_output+0x26>
		if (tx_packet && tx_packet->index > 0) {
   1aeec:	4d08      	ldr	r5, [pc, #32]	; (1af10 <usb_midi_flush_output+0x2c>)
   1aeee:	6829      	ldr	r1, [r5, #0]
		tx_noautoflush = 1;
   1aef0:	2301      	movs	r3, #1
   1aef2:	7023      	strb	r3, [r4, #0]
		if (tx_packet && tx_packet->index > 0) {
   1aef4:	b139      	cbz	r1, 1af06 <usb_midi_flush_output+0x22>
   1aef6:	884b      	ldrh	r3, [r1, #2]
   1aef8:	b12b      	cbz	r3, 1af06 <usb_midi_flush_output+0x22>
			tx_packet->len = tx_packet->index * 4;
   1aefa:	009b      	lsls	r3, r3, #2
   1aefc:	800b      	strh	r3, [r1, #0]
			usb_tx(MIDI_TX_ENDPOINT, tx_packet);
   1aefe:	2004      	movs	r0, #4
   1af00:	f7ff fb62 	bl	1a5c8 <usb_tx>
			tx_packet = NULL;
   1af04:	602e      	str	r6, [r5, #0]
		tx_noautoflush = 0;
   1af06:	2300      	movs	r3, #0
   1af08:	7023      	strb	r3, [r4, #0]
}
   1af0a:	bd70      	pop	{r4, r5, r6, pc}
   1af0c:	20006705 	.word	0x20006705
   1af10:	20006708 	.word	0x20006708

0001af14 <usb_midi_read>:
	}
	return n;
}

int usb_midi_read(uint32_t channel)
{
   1af14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t n, index, ch, type1, type2, b1;

	if (!rx_packet) {
   1af18:	4d96      	ldr	r5, [pc, #600]	; (1b174 <usb_midi_read+0x260>)
   1af1a:	682b      	ldr	r3, [r5, #0]
{
   1af1c:	4607      	mov	r7, r0
	if (!rx_packet) {
   1af1e:	b98b      	cbnz	r3, 1af44 <usb_midi_read+0x30>
		if (!usb_configuration) return 0;
   1af20:	4b95      	ldr	r3, [pc, #596]	; (1b178 <usb_midi_read+0x264>)
   1af22:	781b      	ldrb	r3, [r3, #0]
   1af24:	b913      	cbnz	r3, 1af2c <usb_midi_read+0x18>
		return 1;
	}
	if (type1 == 0x02 || type1 == 0x03 || (type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7)) {
		// system common or system realtime message
		system_common_or_realtime:
		switch (b1) {
   1af26:	2000      	movs	r0, #0
			// send bytes in the middle of a SYSEX message.
			sysex_byte(b1);
		}
	}
	return 0;
}
   1af28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx_packet = usb_rx(MIDI_RX_ENDPOINT);
   1af2c:	2005      	movs	r0, #5
   1af2e:	f7ff fae1 	bl	1a4f4 <usb_rx>
   1af32:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return 0;
   1af34:	2800      	cmp	r0, #0
   1af36:	d0f6      	beq.n	1af26 <usb_midi_read+0x12>
		if (rx_packet->len == 0) {
   1af38:	8804      	ldrh	r4, [r0, #0]
   1af3a:	b91c      	cbnz	r4, 1af44 <usb_midi_read+0x30>
			usb_free(rx_packet);
   1af3c:	f7ff fef4 	bl	1ad28 <usb_free>
			rx_packet = NULL;
   1af40:	602c      	str	r4, [r5, #0]
			return 0;
   1af42:	e7f0      	b.n	1af26 <usb_midi_read+0x12>
	index = rx_packet->index;
   1af44:	6828      	ldr	r0, [r5, #0]
   1af46:	8843      	ldrh	r3, [r0, #2]
	n = ((uint32_t *)rx_packet->buf)[index/4];
   1af48:	f023 0203 	bic.w	r2, r3, #3
   1af4c:	4402      	add	r2, r0
	index += 4;
   1af4e:	3304      	adds	r3, #4
	n = ((uint32_t *)rx_packet->buf)[index/4];
   1af50:	6894      	ldr	r4, [r2, #8]
	if (index < rx_packet->len) {
   1af52:	8802      	ldrh	r2, [r0, #0]
   1af54:	429a      	cmp	r2, r3
   1af56:	d924      	bls.n	1afa2 <usb_midi_read+0x8e>
		rx_packet->index = index;
   1af58:	8043      	strh	r3, [r0, #2]
	usb_midi_msg_cable = (n >> 4) & 15;
   1af5a:	4a88      	ldr	r2, [pc, #544]	; (1b17c <usb_midi_read+0x268>)
   1af5c:	f3c4 1303 	ubfx	r3, r4, #4, #4
	type1 = n & 15;
   1af60:	f004 050f 	and.w	r5, r4, #15
	usb_midi_msg_cable = (n >> 4) & 15;
   1af64:	7013      	strb	r3, [r2, #0]
	if (type1 >= 0x08 && type1 <= 0x0E) {
   1af66:	f1a5 0308 	sub.w	r3, r5, #8
	ch = (b1 & 15) + 1;
   1af6a:	f3c4 2603 	ubfx	r6, r4, #8, #4
	if (type1 >= 0x08 && type1 <= 0x0E) {
   1af6e:	2b06      	cmp	r3, #6
	b1 = (n >> 8) & 0xFF;
   1af70:	ea4f 2814 	mov.w	r8, r4, lsr #8
	ch = (b1 & 15) + 1;
   1af74:	f106 0601 	add.w	r6, r6, #1
	if (type1 >= 0x08 && type1 <= 0x0E) {
   1af78:	d879      	bhi.n	1b06e <usb_midi_read+0x15a>
		if (channel && channel != ch) {
   1af7a:	b10f      	cbz	r7, 1af80 <usb_midi_read+0x6c>
   1af7c:	42be      	cmp	r6, r7
   1af7e:	d1d2      	bne.n	1af26 <usb_midi_read+0x12>
		if (type1 == 0x08 && type2 == 0x08) {
   1af80:	2d08      	cmp	r5, #8
	type2 = (n >> 12) & 15;
   1af82:	f3c4 3303 	ubfx	r3, r4, #12, #4
		if (type1 == 0x08 && type2 == 0x08) {
   1af86:	d113      	bne.n	1afb0 <usb_midi_read+0x9c>
   1af88:	2b08      	cmp	r3, #8
   1af8a:	d1cc      	bne.n	1af26 <usb_midi_read+0x12>
			usb_midi_msg_type = 0x80;		// 0x80 = usbMIDI.NoteOff
   1af8c:	4b7c      	ldr	r3, [pc, #496]	; (1b180 <usb_midi_read+0x26c>)
   1af8e:	2280      	movs	r2, #128	; 0x80
   1af90:	701a      	strb	r2, [r3, #0]
			if (usb_midi_handleNoteOff)
   1af92:	4b7c      	ldr	r3, [pc, #496]	; (1b184 <usb_midi_read+0x270>)
			if (usb_midi_handleVelocityChange)
   1af94:	681b      	ldr	r3, [r3, #0]
   1af96:	b1fb      	cbz	r3, 1afd8 <usb_midi_read+0xc4>
				(*usb_midi_handleVelocityChange)(ch, (n >> 16), (n >> 24));
   1af98:	0e22      	lsrs	r2, r4, #24
   1af9a:	f3c4 4107 	ubfx	r1, r4, #16, #8
   1af9e:	b2f0      	uxtb	r0, r6
   1afa0:	e019      	b.n	1afd6 <usb_midi_read+0xc2>
		usb_free(rx_packet);
   1afa2:	f7ff fec1 	bl	1ad28 <usb_free>
		rx_packet = usb_rx(MIDI_RX_ENDPOINT);
   1afa6:	2005      	movs	r0, #5
   1afa8:	f7ff faa4 	bl	1a4f4 <usb_rx>
   1afac:	6028      	str	r0, [r5, #0]
   1afae:	e7d4      	b.n	1af5a <usb_midi_read+0x46>
		if (type1 == 0x09 && type2 == 0x09) {
   1afb0:	2d09      	cmp	r5, #9
   1afb2:	d11b      	bne.n	1afec <usb_midi_read+0xd8>
   1afb4:	2b09      	cmp	r3, #9
   1afb6:	d1b6      	bne.n	1af26 <usb_midi_read+0x12>
			if ((n >> 24) > 0) {
   1afb8:	0e22      	lsrs	r2, r4, #24
   1afba:	4b71      	ldr	r3, [pc, #452]	; (1b180 <usb_midi_read+0x26c>)
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
   1afbc:	bf15      	itete	ne
   1afbe:	2590      	movne	r5, #144	; 0x90
				usb_midi_msg_type = 0x80;	// 0x80 = usbMIDI.NoteOff
   1afc0:	2580      	moveq	r5, #128	; 0x80
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
   1afc2:	701d      	strbne	r5, [r3, #0]
				usb_midi_msg_type = 0x80;	// 0x80 = usbMIDI.NoteOff
   1afc4:	701d      	strbeq	r5, [r3, #0]
				if (usb_midi_handleNoteOn)
   1afc6:	bf14      	ite	ne
   1afc8:	4b6f      	ldrne	r3, [pc, #444]	; (1b188 <usb_midi_read+0x274>)
				if (usb_midi_handleNoteOff)
   1afca:	4b6e      	ldreq	r3, [pc, #440]	; (1b184 <usb_midi_read+0x270>)
   1afcc:	681b      	ldr	r3, [r3, #0]
				(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
   1afce:	b2f0      	uxtb	r0, r6
   1afd0:	f3c4 4107 	ubfx	r1, r4, #16, #8
				if (usb_midi_handleNoteOff)
   1afd4:	b103      	cbz	r3, 1afd8 <usb_midi_read+0xc4>
				(*usb_midi_handleVelocityChange)(ch, (n >> 16), (n >> 24));
   1afd6:	4798      	blx	r3
		usb_midi_msg_channel = ch;
   1afd8:	4b6c      	ldr	r3, [pc, #432]	; (1b18c <usb_midi_read+0x278>)
   1afda:	701e      	strb	r6, [r3, #0]
		usb_midi_msg_data1 = (n >> 16);
   1afdc:	4b6c      	ldr	r3, [pc, #432]	; (1b190 <usb_midi_read+0x27c>)
   1afde:	0c22      	lsrs	r2, r4, #16
   1afe0:	701a      	strb	r2, [r3, #0]
		usb_midi_msg_data2 = (n >> 24);
   1afe2:	4b6c      	ldr	r3, [pc, #432]	; (1b194 <usb_midi_read+0x280>)
   1afe4:	0e24      	lsrs	r4, r4, #24
   1afe6:	701c      	strb	r4, [r3, #0]
		return 1;
   1afe8:	2001      	movs	r0, #1
   1afea:	e79d      	b.n	1af28 <usb_midi_read+0x14>
		if (type1 == 0x0A && type2 == 0x0A) {
   1afec:	2d0a      	cmp	r5, #10
   1afee:	d106      	bne.n	1affe <usb_midi_read+0xea>
   1aff0:	2b0a      	cmp	r3, #10
   1aff2:	d198      	bne.n	1af26 <usb_midi_read+0x12>
			usb_midi_msg_type = 0xA0;		// 0xA0 = usbMIDI.AfterTouchPoly
   1aff4:	4b62      	ldr	r3, [pc, #392]	; (1b180 <usb_midi_read+0x26c>)
   1aff6:	22a0      	movs	r2, #160	; 0xa0
   1aff8:	701a      	strb	r2, [r3, #0]
			if (usb_midi_handleVelocityChange)
   1affa:	4b67      	ldr	r3, [pc, #412]	; (1b198 <usb_midi_read+0x284>)
   1affc:	e7ca      	b.n	1af94 <usb_midi_read+0x80>
		if (type1 == 0x0B && type2 == 0x0B) {
   1affe:	2d0b      	cmp	r5, #11
   1b000:	d106      	bne.n	1b010 <usb_midi_read+0xfc>
   1b002:	2b0b      	cmp	r3, #11
   1b004:	d18f      	bne.n	1af26 <usb_midi_read+0x12>
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
   1b006:	4b5e      	ldr	r3, [pc, #376]	; (1b180 <usb_midi_read+0x26c>)
   1b008:	22b0      	movs	r2, #176	; 0xb0
   1b00a:	701a      	strb	r2, [r3, #0]
			if (usb_midi_handleControlChange)
   1b00c:	4b63      	ldr	r3, [pc, #396]	; (1b19c <usb_midi_read+0x288>)
   1b00e:	e7c1      	b.n	1af94 <usb_midi_read+0x80>
		if (type1 == 0x0C && type2 == 0x0C) {
   1b010:	2d0c      	cmp	r5, #12
   1b012:	d10d      	bne.n	1b030 <usb_midi_read+0x11c>
   1b014:	2b0c      	cmp	r3, #12
   1b016:	d186      	bne.n	1af26 <usb_midi_read+0x12>
			usb_midi_msg_type = 0xC0;		// 0xC0 = usbMIDI.ProgramChange
   1b018:	4b59      	ldr	r3, [pc, #356]	; (1b180 <usb_midi_read+0x26c>)
   1b01a:	22c0      	movs	r2, #192	; 0xc0
   1b01c:	701a      	strb	r2, [r3, #0]
			if (usb_midi_handleProgramChange)
   1b01e:	4b60      	ldr	r3, [pc, #384]	; (1b1a0 <usb_midi_read+0x28c>)
			if (usb_midi_handleAfterTouch)
   1b020:	681b      	ldr	r3, [r3, #0]
   1b022:	2b00      	cmp	r3, #0
   1b024:	d0d8      	beq.n	1afd8 <usb_midi_read+0xc4>
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
   1b026:	f3c4 4107 	ubfx	r1, r4, #16, #8
   1b02a:	b2f0      	uxtb	r0, r6
   1b02c:	4798      	blx	r3
   1b02e:	e7d3      	b.n	1afd8 <usb_midi_read+0xc4>
		if (type1 == 0x0D && type2 == 0x0D) {
   1b030:	2d0d      	cmp	r5, #13
   1b032:	d107      	bne.n	1b044 <usb_midi_read+0x130>
   1b034:	2b0d      	cmp	r3, #13
   1b036:	f47f af76 	bne.w	1af26 <usb_midi_read+0x12>
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
   1b03a:	4b51      	ldr	r3, [pc, #324]	; (1b180 <usb_midi_read+0x26c>)
   1b03c:	22d0      	movs	r2, #208	; 0xd0
   1b03e:	701a      	strb	r2, [r3, #0]
			if (usb_midi_handleAfterTouch)
   1b040:	4b58      	ldr	r3, [pc, #352]	; (1b1a4 <usb_midi_read+0x290>)
   1b042:	e7ed      	b.n	1b020 <usb_midi_read+0x10c>
		if (type1 == 0x0E && type2 == 0x0E) {
   1b044:	2b0e      	cmp	r3, #14
   1b046:	f47f af6e 	bne.w	1af26 <usb_midi_read+0x12>
			usb_midi_msg_type = 0xE0;		// 0xE0 = usbMIDI.PitchBend
   1b04a:	4b4d      	ldr	r3, [pc, #308]	; (1b180 <usb_midi_read+0x26c>)
   1b04c:	22e0      	movs	r2, #224	; 0xe0
   1b04e:	701a      	strb	r2, [r3, #0]
			if (usb_midi_handlePitchChange) {
   1b050:	4b55      	ldr	r3, [pc, #340]	; (1b1a8 <usb_midi_read+0x294>)
   1b052:	681a      	ldr	r2, [r3, #0]
   1b054:	2a00      	cmp	r2, #0
   1b056:	d0bf      	beq.n	1afd8 <usb_midi_read+0xc4>
				int value = ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80);
   1b058:	0c63      	lsrs	r3, r4, #17
   1b05a:	f3c4 4106 	ubfx	r1, r4, #16, #7
   1b05e:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
   1b062:	4319      	orrs	r1, r3
				(*usb_midi_handlePitchChange)(ch, value);
   1b064:	f5a1 5100 	sub.w	r1, r1, #8192	; 0x2000
   1b068:	b2f0      	uxtb	r0, r6
   1b06a:	4790      	blx	r2
   1b06c:	e7b4      	b.n	1afd8 <usb_midi_read+0xc4>
	if (type1 == 0x02 || type1 == 0x03 || (type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7)) {
   1b06e:	1eab      	subs	r3, r5, #2
   1b070:	2b01      	cmp	r3, #1
	b1 = (n >> 8) & 0xFF;
   1b072:	fa5f f088 	uxtb.w	r0, r8
	if (type1 == 0x02 || type1 == 0x03 || (type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7)) {
   1b076:	d908      	bls.n	1b08a <usb_midi_read+0x176>
   1b078:	2d05      	cmp	r5, #5
   1b07a:	f040 80b5 	bne.w	1b1e8 <usb_midi_read+0x2d4>
   1b07e:	28f0      	cmp	r0, #240	; 0xf0
   1b080:	f240 80c1 	bls.w	1b206 <usb_midi_read+0x2f2>
   1b084:	28f7      	cmp	r0, #247	; 0xf7
   1b086:	f000 80be 	beq.w	1b206 <usb_midi_read+0x2f2>
		switch (b1) {
   1b08a:	38f1      	subs	r0, #241	; 0xf1
   1b08c:	280e      	cmp	r0, #14
   1b08e:	f63f af4a 	bhi.w	1af26 <usb_midi_read+0x12>
   1b092:	a301      	add	r3, pc, #4	; (adr r3, 1b098 <usb_midi_read+0x184>)
   1b094:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
   1b098:	0001b0d5 	.word	0x0001b0d5
   1b09c:	0001b0e3 	.word	0x0001b0e3
   1b0a0:	0001b0ff 	.word	0x0001b0ff
   1b0a4:	0001af27 	.word	0x0001af27
   1b0a8:	0001af27 	.word	0x0001af27
   1b0ac:	0001b103 	.word	0x0001b103
   1b0b0:	0001af27 	.word	0x0001af27
   1b0b4:	0001b10f 	.word	0x0001b10f
   1b0b8:	0001af27 	.word	0x0001af27
   1b0bc:	0001b123 	.word	0x0001b123
   1b0c0:	0001b137 	.word	0x0001b137
   1b0c4:	0001b14b 	.word	0x0001b14b
   1b0c8:	0001af27 	.word	0x0001af27
   1b0cc:	0001b15f 	.word	0x0001b15f
   1b0d0:	0001b1d5 	.word	0x0001b1d5
			if (usb_midi_handleTimeCodeQuarterFrame) {
   1b0d4:	4b35      	ldr	r3, [pc, #212]	; (1b1ac <usb_midi_read+0x298>)
			if (usb_midi_handleSongSelect) {
   1b0d6:	681b      	ldr	r3, [r3, #0]
   1b0d8:	b16b      	cbz	r3, 1b0f6 <usb_midi_read+0x1e2>
				(*usb_midi_handleSongSelect)(n >> 16);
   1b0da:	f3c4 4007 	ubfx	r0, r4, #16, #8
				(*usb_midi_handleRealTimeSystem)(0xFF);
   1b0de:	4798      	blx	r3
   1b0e0:	e009      	b.n	1b0f6 <usb_midi_read+0x1e2>
			if (usb_midi_handleSongPosition) {
   1b0e2:	4b33      	ldr	r3, [pc, #204]	; (1b1b0 <usb_midi_read+0x29c>)
   1b0e4:	681a      	ldr	r2, [r3, #0]
   1b0e6:	b132      	cbz	r2, 1b0f6 <usb_midi_read+0x1e2>
				  ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80));
   1b0e8:	0c63      	lsrs	r3, r4, #17
   1b0ea:	f3c4 4006 	ubfx	r0, r4, #16, #7
   1b0ee:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
				(*usb_midi_handleSongPosition)(
   1b0f2:	4318      	orrs	r0, r3
   1b0f4:	4790      	blx	r2
		usb_midi_msg_type = b1;
   1b0f6:	4b22      	ldr	r3, [pc, #136]	; (1b180 <usb_midi_read+0x26c>)
   1b0f8:	f883 8000 	strb.w	r8, [r3]
		goto return_message;
   1b0fc:	e76c      	b.n	1afd8 <usb_midi_read+0xc4>
			if (usb_midi_handleSongSelect) {
   1b0fe:	4b2d      	ldr	r3, [pc, #180]	; (1b1b4 <usb_midi_read+0x2a0>)
   1b100:	e7e9      	b.n	1b0d6 <usb_midi_read+0x1c2>
			if (usb_midi_handleTuneRequest) {
   1b102:	4b2d      	ldr	r3, [pc, #180]	; (1b1b8 <usb_midi_read+0x2a4>)
   1b104:	681b      	ldr	r3, [r3, #0]
   1b106:	2b00      	cmp	r3, #0
   1b108:	d0f5      	beq.n	1b0f6 <usb_midi_read+0x1e2>
				(*usb_midi_handleSystemReset)();
   1b10a:	4798      	blx	r3
   1b10c:	e7f3      	b.n	1b0f6 <usb_midi_read+0x1e2>
			if (usb_midi_handleClock) {
   1b10e:	4b2b      	ldr	r3, [pc, #172]	; (1b1bc <usb_midi_read+0x2a8>)
   1b110:	681b      	ldr	r3, [r3, #0]
   1b112:	2b00      	cmp	r3, #0
   1b114:	d1f9      	bne.n	1b10a <usb_midi_read+0x1f6>
			} else if (usb_midi_handleRealTimeSystem) {
   1b116:	4b2a      	ldr	r3, [pc, #168]	; (1b1c0 <usb_midi_read+0x2ac>)
   1b118:	681b      	ldr	r3, [r3, #0]
   1b11a:	2b00      	cmp	r3, #0
   1b11c:	d0eb      	beq.n	1b0f6 <usb_midi_read+0x1e2>
				(*usb_midi_handleRealTimeSystem)(0xF8);
   1b11e:	20f8      	movs	r0, #248	; 0xf8
   1b120:	e7dd      	b.n	1b0de <usb_midi_read+0x1ca>
			if (usb_midi_handleStart) {
   1b122:	4b28      	ldr	r3, [pc, #160]	; (1b1c4 <usb_midi_read+0x2b0>)
   1b124:	681b      	ldr	r3, [r3, #0]
   1b126:	2b00      	cmp	r3, #0
   1b128:	d1ef      	bne.n	1b10a <usb_midi_read+0x1f6>
			} else if (usb_midi_handleRealTimeSystem) {
   1b12a:	4b25      	ldr	r3, [pc, #148]	; (1b1c0 <usb_midi_read+0x2ac>)
   1b12c:	681b      	ldr	r3, [r3, #0]
   1b12e:	2b00      	cmp	r3, #0
   1b130:	d0e1      	beq.n	1b0f6 <usb_midi_read+0x1e2>
				(*usb_midi_handleRealTimeSystem)(0xFA);
   1b132:	20fa      	movs	r0, #250	; 0xfa
   1b134:	e7d3      	b.n	1b0de <usb_midi_read+0x1ca>
			if (usb_midi_handleContinue) {
   1b136:	4b24      	ldr	r3, [pc, #144]	; (1b1c8 <usb_midi_read+0x2b4>)
   1b138:	681b      	ldr	r3, [r3, #0]
   1b13a:	2b00      	cmp	r3, #0
   1b13c:	d1e5      	bne.n	1b10a <usb_midi_read+0x1f6>
			} else if (usb_midi_handleRealTimeSystem) {
   1b13e:	4b20      	ldr	r3, [pc, #128]	; (1b1c0 <usb_midi_read+0x2ac>)
   1b140:	681b      	ldr	r3, [r3, #0]
   1b142:	2b00      	cmp	r3, #0
   1b144:	d0d7      	beq.n	1b0f6 <usb_midi_read+0x1e2>
				(*usb_midi_handleRealTimeSystem)(0xFB);
   1b146:	20fb      	movs	r0, #251	; 0xfb
   1b148:	e7c9      	b.n	1b0de <usb_midi_read+0x1ca>
			if (usb_midi_handleStop) {
   1b14a:	4b20      	ldr	r3, [pc, #128]	; (1b1cc <usb_midi_read+0x2b8>)
   1b14c:	681b      	ldr	r3, [r3, #0]
   1b14e:	2b00      	cmp	r3, #0
   1b150:	d1db      	bne.n	1b10a <usb_midi_read+0x1f6>
			} else if (usb_midi_handleRealTimeSystem) {
   1b152:	4b1b      	ldr	r3, [pc, #108]	; (1b1c0 <usb_midi_read+0x2ac>)
   1b154:	681b      	ldr	r3, [r3, #0]
   1b156:	2b00      	cmp	r3, #0
   1b158:	d0cd      	beq.n	1b0f6 <usb_midi_read+0x1e2>
				(*usb_midi_handleRealTimeSystem)(0xFC);
   1b15a:	20fc      	movs	r0, #252	; 0xfc
   1b15c:	e7bf      	b.n	1b0de <usb_midi_read+0x1ca>
			if (usb_midi_handleActiveSensing) {
   1b15e:	4b1c      	ldr	r3, [pc, #112]	; (1b1d0 <usb_midi_read+0x2bc>)
   1b160:	681b      	ldr	r3, [r3, #0]
   1b162:	2b00      	cmp	r3, #0
   1b164:	d1d1      	bne.n	1b10a <usb_midi_read+0x1f6>
			} else if (usb_midi_handleRealTimeSystem) {
   1b166:	4b16      	ldr	r3, [pc, #88]	; (1b1c0 <usb_midi_read+0x2ac>)
   1b168:	681b      	ldr	r3, [r3, #0]
   1b16a:	2b00      	cmp	r3, #0
   1b16c:	d0c3      	beq.n	1b0f6 <usb_midi_read+0x1e2>
				(*usb_midi_handleRealTimeSystem)(0xFE);
   1b16e:	20fe      	movs	r0, #254	; 0xfe
   1b170:	e7b5      	b.n	1b0de <usb_midi_read+0x1ca>
   1b172:	bf00      	nop
   1b174:	20006700 	.word	0x20006700
   1b178:	200066f1 	.word	0x200066f1
   1b17c:	2000675c 	.word	0x2000675c
   1b180:	20006884 	.word	0x20006884
   1b184:	20006720 	.word	0x20006720
   1b188:	20006724 	.word	0x20006724
   1b18c:	2000675d 	.word	0x2000675d
   1b190:	2000675e 	.word	0x2000675e
   1b194:	2000675f 	.word	0x2000675f
   1b198:	20006758 	.word	0x20006758
   1b19c:	2000671c 	.word	0x2000671c
   1b1a0:	2000672c 	.word	0x2000672c
   1b1a4:	20006710 	.word	0x20006710
   1b1a8:	20006728 	.word	0x20006728
   1b1ac:	20006750 	.word	0x20006750
   1b1b0:	20006734 	.word	0x20006734
   1b1b4:	20006738 	.word	0x20006738
   1b1b8:	20006754 	.word	0x20006754
   1b1bc:	20006714 	.word	0x20006714
   1b1c0:	20006730 	.word	0x20006730
   1b1c4:	2000673c 	.word	0x2000673c
   1b1c8:	20006718 	.word	0x20006718
   1b1cc:	20006740 	.word	0x20006740
   1b1d0:	2000670c 	.word	0x2000670c
			if (usb_midi_handleSystemReset) {
   1b1d4:	4b27      	ldr	r3, [pc, #156]	; (1b274 <usb_midi_read+0x360>)
   1b1d6:	681b      	ldr	r3, [r3, #0]
   1b1d8:	2b00      	cmp	r3, #0
   1b1da:	d196      	bne.n	1b10a <usb_midi_read+0x1f6>
			} else if (usb_midi_handleRealTimeSystem) {
   1b1dc:	4b26      	ldr	r3, [pc, #152]	; (1b278 <usb_midi_read+0x364>)
   1b1de:	681b      	ldr	r3, [r3, #0]
   1b1e0:	2b00      	cmp	r3, #0
   1b1e2:	d088      	beq.n	1b0f6 <usb_midi_read+0x1e2>
				(*usb_midi_handleRealTimeSystem)(0xFF);
   1b1e4:	20ff      	movs	r0, #255	; 0xff
   1b1e6:	e77a      	b.n	1b0de <usb_midi_read+0x1ca>
	if (type1 == 0x04) {
   1b1e8:	2d04      	cmp	r5, #4
   1b1ea:	d109      	bne.n	1b200 <usb_midi_read+0x2ec>
		sysex_byte(n >> 8);
   1b1ec:	f7ff fdc0 	bl	1ad70 <sysex_byte>
		sysex_byte(n >> 16);
   1b1f0:	f3c4 4007 	ubfx	r0, r4, #16, #8
   1b1f4:	f7ff fdbc 	bl	1ad70 <sysex_byte>
		sysex_byte(n >> 24);
   1b1f8:	0e20      	lsrs	r0, r4, #24
			sysex_byte(b1);
   1b1fa:	f7ff fdb9 	bl	1ad70 <sysex_byte>
   1b1fe:	e692      	b.n	1af26 <usb_midi_read+0x12>
	if (type1 >= 0x05 && type1 <= 0x07) {
   1b200:	1f6b      	subs	r3, r5, #5
   1b202:	2b02      	cmp	r3, #2
   1b204:	d827      	bhi.n	1b256 <usb_midi_read+0x342>
		sysex_byte(b1);
   1b206:	f7ff fdb3 	bl	1ad70 <sysex_byte>
		if (type1 >= 0x06) sysex_byte(n >> 16);
   1b20a:	2d05      	cmp	r5, #5
   1b20c:	d008      	beq.n	1b220 <usb_midi_read+0x30c>
   1b20e:	f3c4 4007 	ubfx	r0, r4, #16, #8
   1b212:	f7ff fdad 	bl	1ad70 <sysex_byte>
		if (type1 == 0x07) sysex_byte(n >> 24);
   1b216:	2d07      	cmp	r5, #7
   1b218:	d102      	bne.n	1b220 <usb_midi_read+0x30c>
   1b21a:	0e20      	lsrs	r0, r4, #24
   1b21c:	f7ff fda8 	bl	1ad70 <sysex_byte>
		uint16_t len = usb_midi_msg_sysex_len;
   1b220:	4b16      	ldr	r3, [pc, #88]	; (1b27c <usb_midi_read+0x368>)
		usb_midi_msg_data1 = len;
   1b222:	4a17      	ldr	r2, [pc, #92]	; (1b280 <usb_midi_read+0x36c>)
		uint16_t len = usb_midi_msg_sysex_len;
   1b224:	8819      	ldrh	r1, [r3, #0]
		usb_midi_msg_data1 = len;
   1b226:	7011      	strb	r1, [r2, #0]
		usb_midi_msg_data2 = len >> 8;
   1b228:	4a16      	ldr	r2, [pc, #88]	; (1b284 <usb_midi_read+0x370>)
   1b22a:	0a08      	lsrs	r0, r1, #8
   1b22c:	7010      	strb	r0, [r2, #0]
		usb_midi_msg_sysex_len = 0;
   1b22e:	2200      	movs	r2, #0
   1b230:	801a      	strh	r2, [r3, #0]
		usb_midi_msg_type = 0xF0;			// 0xF0 = usbMIDI.SystemExclusive
   1b232:	4b15      	ldr	r3, [pc, #84]	; (1b288 <usb_midi_read+0x374>)
   1b234:	22f0      	movs	r2, #240	; 0xf0
   1b236:	701a      	strb	r2, [r3, #0]
		if (usb_midi_handleSysExPartial) {
   1b238:	4b14      	ldr	r3, [pc, #80]	; (1b28c <usb_midi_read+0x378>)
   1b23a:	681b      	ldr	r3, [r3, #0]
   1b23c:	b11b      	cbz	r3, 1b246 <usb_midi_read+0x332>
			(*usb_midi_handleSysExPartial)(usb_midi_msg_sysex, len, 1);
   1b23e:	4814      	ldr	r0, [pc, #80]	; (1b290 <usb_midi_read+0x37c>)
   1b240:	2201      	movs	r2, #1
   1b242:	4798      	blx	r3
   1b244:	e6d0      	b.n	1afe8 <usb_midi_read+0xd4>
		} else if (usb_midi_handleSysExComplete) {
   1b246:	4b13      	ldr	r3, [pc, #76]	; (1b294 <usb_midi_read+0x380>)
   1b248:	681b      	ldr	r3, [r3, #0]
   1b24a:	2b00      	cmp	r3, #0
   1b24c:	f43f aecc 	beq.w	1afe8 <usb_midi_read+0xd4>
			(*usb_midi_handleSysExComplete)(usb_midi_msg_sysex, len);
   1b250:	480f      	ldr	r0, [pc, #60]	; (1b290 <usb_midi_read+0x37c>)
   1b252:	4798      	blx	r3
   1b254:	e6c8      	b.n	1afe8 <usb_midi_read+0xd4>
	if (type1 == 0x0F) {
   1b256:	2d0f      	cmp	r5, #15
   1b258:	f47f ae65 	bne.w	1af26 <usb_midi_read+0x12>
		if (b1 >= 0xF8) {
   1b25c:	28f7      	cmp	r0, #247	; 0xf7
   1b25e:	f63f af14 	bhi.w	1b08a <usb_midi_read+0x176>
		if (b1 == 0xF0 || usb_midi_msg_sysex_len > 0) {
   1b262:	28f0      	cmp	r0, #240	; 0xf0
   1b264:	d0c9      	beq.n	1b1fa <usb_midi_read+0x2e6>
   1b266:	4b05      	ldr	r3, [pc, #20]	; (1b27c <usb_midi_read+0x368>)
   1b268:	881b      	ldrh	r3, [r3, #0]
   1b26a:	2b00      	cmp	r3, #0
   1b26c:	f43f ae5b 	beq.w	1af26 <usb_midi_read+0x12>
   1b270:	e7c3      	b.n	1b1fa <usb_midi_read+0x2e6>
   1b272:	bf00      	nop
   1b274:	2000674c 	.word	0x2000674c
   1b278:	20006730 	.word	0x20006730
   1b27c:	20006882 	.word	0x20006882
   1b280:	2000675e 	.word	0x2000675e
   1b284:	2000675f 	.word	0x2000675f
   1b288:	20006884 	.word	0x20006884
   1b28c:	20006748 	.word	0x20006748
   1b290:	20006760 	.word	0x20006760
   1b294:	20006744 	.word	0x20006744

0001b298 <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
   1b298:	4b07      	ldr	r3, [pc, #28]	; (1b2b8 <usb_serial_available+0x20>)
	return rx_packet->buf[rx_packet->index];
}

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
   1b29a:	b510      	push	{r4, lr}
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
   1b29c:	885c      	ldrh	r4, [r3, #2]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
   1b29e:	4b07      	ldr	r3, [pc, #28]	; (1b2bc <usb_serial_available+0x24>)
   1b2a0:	681a      	ldr	r2, [r3, #0]
   1b2a2:	b11a      	cbz	r2, 1b2ac <usb_serial_available+0x14>
   1b2a4:	8813      	ldrh	r3, [r2, #0]
   1b2a6:	8852      	ldrh	r2, [r2, #2]
   1b2a8:	1a9b      	subs	r3, r3, r2
   1b2aa:	441c      	add	r4, r3
	if (count == 0) yield();
   1b2ac:	b90c      	cbnz	r4, 1b2b2 <usb_serial_available+0x1a>
   1b2ae:	f000 f855 	bl	1b35c <yield>
	return count;
}
   1b2b2:	4620      	mov	r0, r4
   1b2b4:	bd10      	pop	{r4, pc}
   1b2b6:	bf00      	nop
   1b2b8:	200066f4 	.word	0x200066f4
   1b2bc:	20006888 	.word	0x20006888

0001b2c0 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
   1b2c0:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
   1b2c2:	4b0e      	ldr	r3, [pc, #56]	; (1b2fc <usb_serial_flush_callback+0x3c>)
   1b2c4:	781b      	ldrb	r3, [r3, #0]
   1b2c6:	f003 05ff 	and.w	r5, r3, #255	; 0xff
   1b2ca:	b943      	cbnz	r3, 1b2de <usb_serial_flush_callback+0x1e>
	if (tx_packet) {
   1b2cc:	4c0c      	ldr	r4, [pc, #48]	; (1b300 <usb_serial_flush_callback+0x40>)
   1b2ce:	6821      	ldr	r1, [r4, #0]
   1b2d0:	b131      	cbz	r1, 1b2e0 <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
   1b2d2:	884b      	ldrh	r3, [r1, #2]
   1b2d4:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
   1b2d6:	2003      	movs	r0, #3
   1b2d8:	f7ff f976 	bl	1a5c8 <usb_tx>
		tx_packet = NULL;
   1b2dc:	6025      	str	r5, [r4, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
   1b2de:	bd38      	pop	{r3, r4, r5, pc}
		usb_packet_t *tx = usb_malloc();
   1b2e0:	f7ff fd04 	bl	1acec <usb_malloc>
		if (tx) {
   1b2e4:	4601      	mov	r1, r0
   1b2e6:	b120      	cbz	r0, 1b2f2 <usb_serial_flush_callback+0x32>
}
   1b2e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			usb_tx(CDC_TX_ENDPOINT, tx);
   1b2ec:	2003      	movs	r0, #3
   1b2ee:	f7ff b96b 	b.w	1a5c8 <usb_tx>
			usb_cdc_transmit_flush_timer = 1;
   1b2f2:	4b04      	ldr	r3, [pc, #16]	; (1b304 <usb_serial_flush_callback+0x44>)
   1b2f4:	2201      	movs	r2, #1
   1b2f6:	701a      	strb	r2, [r3, #0]
   1b2f8:	e7f1      	b.n	1b2de <usb_serial_flush_callback+0x1e>
   1b2fa:	bf00      	nop
   1b2fc:	2000688c 	.word	0x2000688c
   1b300:	20006890 	.word	0x20006890
   1b304:	200068a4 	.word	0x200068a4

0001b308 <EventResponder::runFromYield()>:
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
   1b308:	4911      	ldr	r1, [pc, #68]	; (1b350 <EventResponder::runFromYield()+0x48>)
	static void runFromYield() {
   1b30a:	b538      	push	{r3, r4, r5, lr}
		if (!firstYield) return;  
   1b30c:	680b      	ldr	r3, [r1, #0]
   1b30e:	b14b      	cbz	r3, 1b324 <EventResponder::runFromYield()+0x1c>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
   1b310:	f3ef 8305 	mrs	r3, IPSR
		if (ipsr != 0) return;
   1b314:	b933      	cbnz	r3, 1b324 <EventResponder::runFromYield()+0x1c>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
   1b316:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
   1b31a:	b672      	cpsid	i
		EventResponder *first = firstYield;
   1b31c:	6808      	ldr	r0, [r1, #0]
		if (first == nullptr) {
   1b31e:	b910      	cbnz	r0, 1b326 <EventResponder::runFromYield()+0x1e>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
   1b320:	b902      	cbnz	r2, 1b324 <EventResponder::runFromYield()+0x1c>
   1b322:	b662      	cpsie	i
	}
   1b324:	bd38      	pop	{r3, r4, r5, pc}
		if (runningFromYield) {
   1b326:	4c0b      	ldr	r4, [pc, #44]	; (1b354 <EventResponder::runFromYield()+0x4c>)
   1b328:	7825      	ldrb	r5, [r4, #0]
   1b32a:	2d00      	cmp	r5, #0
   1b32c:	d1f8      	bne.n	1b320 <EventResponder::runFromYield()+0x18>
		runningFromYield = true;
   1b32e:	2301      	movs	r3, #1
   1b330:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
   1b332:	6943      	ldr	r3, [r0, #20]
   1b334:	600b      	str	r3, [r1, #0]
		if (firstYield) {
   1b336:	b143      	cbz	r3, 1b34a <EventResponder::runFromYield()+0x42>
			firstYield->_prev = nullptr;
   1b338:	619d      	str	r5, [r3, #24]
		if (doit) __enable_irq();
   1b33a:	b902      	cbnz	r2, 1b33e <EventResponder::runFromYield()+0x36>
   1b33c:	b662      	cpsie	i
		first->_triggered = false;
   1b33e:	2500      	movs	r5, #0
		(*(first->_function))(*first);
   1b340:	6883      	ldr	r3, [r0, #8]
		first->_triggered = false;
   1b342:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
   1b344:	4798      	blx	r3
		runningFromYield = false;
   1b346:	7025      	strb	r5, [r4, #0]
   1b348:	e7ec      	b.n	1b324 <EventResponder::runFromYield()+0x1c>
			lastYield = nullptr;
   1b34a:	4903      	ldr	r1, [pc, #12]	; (1b358 <EventResponder::runFromYield()+0x50>)
   1b34c:	600b      	str	r3, [r1, #0]
   1b34e:	e7f4      	b.n	1b33a <EventResponder::runFromYield()+0x32>
   1b350:	200068a8 	.word	0x200068a8
   1b354:	200068b4 	.word	0x200068b4
   1b358:	200068b8 	.word	0x200068b8

0001b35c <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
   1b35c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
   1b360:	4c1b      	ldr	r4, [pc, #108]	; (1b3d0 <yield+0x74>)
   1b362:	7823      	ldrb	r3, [r4, #0]
   1b364:	b1e3      	cbz	r3, 1b3a0 <yield+0x44>
	if (running) return; // TODO: does this need to be atomic?
   1b366:	4d1b      	ldr	r5, [pc, #108]	; (1b3d4 <yield+0x78>)
   1b368:	782a      	ldrb	r2, [r5, #0]
   1b36a:	b9ca      	cbnz	r2, 1b3a0 <yield+0x44>
	running = 1;
   1b36c:	2201      	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
   1b36e:	07d9      	lsls	r1, r3, #31
	running = 1;
   1b370:	702a      	strb	r2, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
   1b372:	d50b      	bpl.n	1b38c <yield+0x30>
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
   1b374:	f7ff ff90 	bl	1b298 <usb_serial_available>
		if (Serial.available()) serialEvent();
   1b378:	b108      	cbz	r0, 1b37e <yield+0x22>
   1b37a:	f000 f8a5 	bl	1b4c8 <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
   1b37e:	4a16      	ldr	r2, [pc, #88]	; (1b3d8 <yield+0x7c>)
   1b380:	7823      	ldrb	r3, [r4, #0]
   1b382:	7812      	ldrb	r2, [r2, #0]
   1b384:	b112      	cbz	r2, 1b38c <yield+0x30>
   1b386:	f023 0301 	bic.w	r3, r3, #1
   1b38a:	7023      	strb	r3, [r4, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
   1b38c:	7823      	ldrb	r3, [r4, #0]
   1b38e:	079a      	lsls	r2, r3, #30
   1b390:	d418      	bmi.n	1b3c4 <yield+0x68>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
   1b392:	2300      	movs	r3, #0
   1b394:	702b      	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
   1b396:	7823      	ldrb	r3, [r4, #0]
   1b398:	075b      	lsls	r3, r3, #29
   1b39a:	d501      	bpl.n	1b3a0 <yield+0x44>
   1b39c:	f7ff ffb4 	bl	1b308 <EventResponder::runFromYield()>
	
};
   1b3a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
			s_serials_with_serial_events[i]->doYieldCode();
   1b3a4:	f859 7023 	ldr.w	r7, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
   1b3a8:	683b      	ldr	r3, [r7, #0]
   1b3aa:	4638      	mov	r0, r7
   1b3ac:	691b      	ldr	r3, [r3, #16]
   1b3ae:	4798      	blx	r3
   1b3b0:	b108      	cbz	r0, 1b3b6 <yield+0x5a>
   1b3b2:	693b      	ldr	r3, [r7, #16]
   1b3b4:	4798      	blx	r3
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
   1b3b6:	3601      	adds	r6, #1
   1b3b8:	f898 2000 	ldrb.w	r2, [r8]
   1b3bc:	b2f3      	uxtb	r3, r6
   1b3be:	429a      	cmp	r2, r3
   1b3c0:	d8f0      	bhi.n	1b3a4 <yield+0x48>
   1b3c2:	e7e6      	b.n	1b392 <yield+0x36>
   1b3c4:	f8df 8014 	ldr.w	r8, [pc, #20]	; 1b3dc <yield+0x80>
			s_serials_with_serial_events[i]->doYieldCode();
   1b3c8:	f8df 9014 	ldr.w	r9, [pc, #20]	; 1b3e0 <yield+0x84>
   1b3cc:	2600      	movs	r6, #0
   1b3ce:	e7f3      	b.n	1b3b8 <yield+0x5c>
   1b3d0:	1fffa1d0 	.word	0x1fffa1d0
   1b3d4:	200068a5 	.word	0x200068a5
   1b3d8:	00027c1c 	.word	0x00027c1c
   1b3dc:	200068c8 	.word	0x200068c8
   1b3e0:	200068bc 	.word	0x200068bc

0001b3e4 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
   1b3e4:	b570      	push	{r4, r5, r6, lr}
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
   1b3e6:	4d0b      	ldr	r5, [pc, #44]	; (1b414 <EventResponder::runFromInterrupt()+0x30>)
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
   1b3e8:	4e0b      	ldr	r6, [pc, #44]	; (1b418 <EventResponder::runFromInterrupt()+0x34>)
				firstInterrupt->_prev = nullptr;
   1b3ea:	2400      	movs	r4, #0
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
   1b3ec:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
   1b3f0:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
   1b3f2:	6828      	ldr	r0, [r5, #0]
		if (first) {
   1b3f4:	b158      	cbz	r0, 1b40e <EventResponder::runFromInterrupt()+0x2a>
			firstInterrupt = first->_next;
   1b3f6:	6943      	ldr	r3, [r0, #20]
   1b3f8:	602b      	str	r3, [r5, #0]
			if (firstInterrupt) {
   1b3fa:	b133      	cbz	r3, 1b40a <EventResponder::runFromInterrupt()+0x26>
				firstInterrupt->_prev = nullptr;
   1b3fc:	619c      	str	r4, [r3, #24]
		if (doit) __enable_irq();
   1b3fe:	b902      	cbnz	r2, 1b402 <EventResponder::runFromInterrupt()+0x1e>
   1b400:	b662      	cpsie	i
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
   1b402:	6883      	ldr	r3, [r0, #8]
			first->_triggered = false;
   1b404:	7744      	strb	r4, [r0, #29]
			(*(first->_function))(*first);
   1b406:	4798      	blx	r3
		} else {
			enableInterrupts(irq);
			break;
		}
	}
   1b408:	e7f0      	b.n	1b3ec <EventResponder::runFromInterrupt()+0x8>
				lastInterrupt = nullptr;
   1b40a:	6033      	str	r3, [r6, #0]
   1b40c:	e7f7      	b.n	1b3fe <EventResponder::runFromInterrupt()+0x1a>
   1b40e:	b902      	cbnz	r2, 1b412 <EventResponder::runFromInterrupt()+0x2e>
   1b410:	b662      	cpsie	i
}
   1b412:	bd70      	pop	{r4, r5, r6, pc}
   1b414:	200068b0 	.word	0x200068b0
   1b418:	200068ac 	.word	0x200068ac

0001b41c <pendablesrvreq_isr>:
	EventResponder::runFromInterrupt();
   1b41c:	f7ff bfe2 	b.w	1b3e4 <EventResponder::runFromInterrupt()>

0001b420 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
   1b420:	4a02      	ldr	r2, [pc, #8]	; (1b42c <systick_isr+0xc>)
   1b422:	6813      	ldr	r3, [r2, #0]
   1b424:	3301      	adds	r3, #1
   1b426:	6013      	str	r3, [r2, #0]
}
   1b428:	4770      	bx	lr
   1b42a:	bf00      	nop
   1b42c:	20006600 	.word	0x20006600

0001b430 <analog_init>:
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
   1b430:	4b1e      	ldr	r3, [pc, #120]	; (1b4ac <analog_init+0x7c>)
   1b432:	2260      	movs	r2, #96	; 0x60
   1b434:	701a      	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
   1b436:	22e1      	movs	r2, #225	; 0xe1
   1b438:	705a      	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
   1b43a:	4b1d      	ldr	r3, [pc, #116]	; (1b4b0 <analog_init+0x80>)
   1b43c:	4a1d      	ldr	r2, [pc, #116]	; (1b4b4 <analog_init+0x84>)
   1b43e:	7819      	ldrb	r1, [r3, #0]
   1b440:	4b1d      	ldr	r3, [pc, #116]	; (1b4b8 <analog_init+0x88>)
   1b442:	2908      	cmp	r1, #8
   1b444:	d11a      	bne.n	1b47c <analog_init+0x4c>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
   1b446:	2021      	movs	r0, #33	; 0x21
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
   1b448:	6090      	str	r0, [r2, #8]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
   1b44a:	2113      	movs	r1, #19
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
   1b44c:	60d1      	str	r1, [r2, #12]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
   1b44e:	6098      	str	r0, [r3, #8]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
   1b450:	60d9      	str	r1, [r3, #12]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
   1b452:	4b1a      	ldr	r3, [pc, #104]	; (1b4bc <analog_init+0x8c>)
   1b454:	4917      	ldr	r1, [pc, #92]	; (1b4b4 <analog_init+0x84>)
   1b456:	781b      	ldrb	r3, [r3, #0]
   1b458:	4a17      	ldr	r2, [pc, #92]	; (1b4b8 <analog_init+0x88>)
   1b45a:	b103      	cbz	r3, 1b45e <analog_init+0x2e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
   1b45c:	2301      	movs	r3, #1
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
   1b45e:	620b      	str	r3, [r1, #32]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
   1b460:	6213      	str	r3, [r2, #32]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
   1b462:	4b17      	ldr	r3, [pc, #92]	; (1b4c0 <analog_init+0x90>)
   1b464:	4a13      	ldr	r2, [pc, #76]	; (1b4b4 <analog_init+0x84>)
   1b466:	7819      	ldrb	r1, [r3, #0]
	if (num <= 1) {
   1b468:	4b13      	ldr	r3, [pc, #76]	; (1b4b8 <analog_init+0x88>)
   1b46a:	2901      	cmp	r1, #1
   1b46c:	d811      	bhi.n	1b492 <analog_init+0x62>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
   1b46e:	2180      	movs	r1, #128	; 0x80
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
   1b470:	6251      	str	r1, [r2, #36]	; 0x24
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
   1b472:	6259      	str	r1, [r3, #36]	; 0x24
		#endif
	}
	calibrating = 1;
   1b474:	4b13      	ldr	r3, [pc, #76]	; (1b4c4 <analog_init+0x94>)
   1b476:	2201      	movs	r2, #1
   1b478:	701a      	strb	r2, [r3, #0]
}
   1b47a:	4770      	bx	lr
	} else if (analog_config_bits == 10) {
   1b47c:	290a      	cmp	r1, #10
   1b47e:	d101      	bne.n	1b484 <analog_init+0x54>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
   1b480:	2039      	movs	r0, #57	; 0x39
   1b482:	e7e1      	b.n	1b448 <analog_init+0x18>
	} else if (analog_config_bits == 12) {
   1b484:	290c      	cmp	r1, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
   1b486:	bf0c      	ite	eq
   1b488:	2035      	moveq	r0, #53	; 0x35
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
   1b48a:	205d      	movne	r0, #93	; 0x5d
   1b48c:	2112      	movs	r1, #18
   1b48e:	6090      	str	r0, [r2, #8]
   1b490:	e7dc      	b.n	1b44c <analog_init+0x1c>
	} else if (num <= 4) {
   1b492:	2904      	cmp	r1, #4
   1b494:	d801      	bhi.n	1b49a <analog_init+0x6a>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
   1b496:	2184      	movs	r1, #132	; 0x84
   1b498:	e7ea      	b.n	1b470 <analog_init+0x40>
	} else if (num <= 8) {
   1b49a:	2908      	cmp	r1, #8
   1b49c:	d801      	bhi.n	1b4a2 <analog_init+0x72>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
   1b49e:	2185      	movs	r1, #133	; 0x85
   1b4a0:	e7e6      	b.n	1b470 <analog_init+0x40>
	} else if (num <= 16) {
   1b4a2:	2910      	cmp	r1, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
   1b4a4:	bf94      	ite	ls
   1b4a6:	2186      	movls	r1, #134	; 0x86
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
   1b4a8:	2187      	movhi	r1, #135	; 0x87
   1b4aa:	e7e1      	b.n	1b470 <analog_init+0x40>
   1b4ac:	40074000 	.word	0x40074000
   1b4b0:	1fffa1d1 	.word	0x1fffa1d1
   1b4b4:	4003b000 	.word	0x4003b000
   1b4b8:	400bb000 	.word	0x400bb000
   1b4bc:	200068c9 	.word	0x200068c9
   1b4c0:	1fffa1d2 	.word	0x1fffa1d2
   1b4c4:	200068ca 	.word	0x200068ca

0001b4c8 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
}
   1b4c8:	4770      	bx	lr
   1b4ca:	Address 0x000000000001b4ca is out of bounds.


0001b4cc <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
   1b4cc:	b530      	push	{r4, r5, lr}
   1b4ce:	b085      	sub	sp, #20
	char buf[11];
	uint32_t i, num;

	__disable_irq();
   1b4d0:	b672      	cpsid	i
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
   1b4d2:	4b16      	ldr	r3, [pc, #88]	; (1b52c <usb_init_serialnumber+0x60>)
   1b4d4:	2270      	movs	r2, #112	; 0x70
   1b4d6:	701a      	strb	r2, [r3, #0]
	FTFL_FCCOB0 = 0x41;
   1b4d8:	2241      	movs	r2, #65	; 0x41
   1b4da:	71da      	strb	r2, [r3, #7]
	FTFL_FCCOB1 = 15;
   1b4dc:	220f      	movs	r2, #15
   1b4de:	719a      	strb	r2, [r3, #6]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
   1b4e0:	2280      	movs	r2, #128	; 0x80
   1b4e2:	701a      	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
   1b4e4:	781a      	ldrb	r2, [r3, #0]
   1b4e6:	0612      	lsls	r2, r2, #24
   1b4e8:	d5fc      	bpl.n	1b4e4 <usb_init_serialnumber+0x18>
	num = *(uint32_t *)&FTFL_FCCOB7;
   1b4ea:	6898      	ldr	r0, [r3, #8]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
   1b4ec:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
   1b4ee:	4b10      	ldr	r3, [pc, #64]	; (1b530 <usb_init_serialnumber+0x64>)
   1b4f0:	4298      	cmp	r0, r3
   1b4f2:	bf38      	it	cc
   1b4f4:	230a      	movcc	r3, #10
	ultoa(num, buf, 10);
   1b4f6:	f04f 020a 	mov.w	r2, #10
   1b4fa:	a901      	add	r1, sp, #4
	if (num < 10000000) num = num * 10;
   1b4fc:	bf38      	it	cc
   1b4fe:	4358      	mulcc	r0, r3
	ultoa(num, buf, 10);
   1b500:	f000 f81a 	bl	1b538 <ultoa>
	for (i=0; i<10; i++) {
   1b504:	480b      	ldr	r0, [pc, #44]	; (1b534 <usb_init_serialnumber+0x68>)
   1b506:	aa01      	add	r2, sp, #4
   1b508:	2100      	movs	r1, #0
   1b50a:	4605      	mov	r5, r0
		char c = buf[i];
   1b50c:	f812 4b01 	ldrb.w	r4, [r2], #1
		if (!c) break;
   1b510:	460b      	mov	r3, r1
	for (i=0; i<10; i++) {
   1b512:	3101      	adds	r1, #1
		if (!c) break;
   1b514:	b124      	cbz	r4, 1b520 <usb_init_serialnumber+0x54>
	for (i=0; i<10; i++) {
   1b516:	290a      	cmp	r1, #10
		usb_string_serial_number_default.wString[i] = c;
   1b518:	f820 4f02 	strh.w	r4, [r0, #2]!
	for (i=0; i<10; i++) {
   1b51c:	d1f6      	bne.n	1b50c <usb_init_serialnumber+0x40>
   1b51e:	460b      	mov	r3, r1
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
   1b520:	3301      	adds	r3, #1
   1b522:	005b      	lsls	r3, r3, #1
   1b524:	702b      	strb	r3, [r5, #0]
}
   1b526:	b005      	add	sp, #20
   1b528:	bd30      	pop	{r4, r5, pc}
   1b52a:	bf00      	nop
   1b52c:	40020000 	.word	0x40020000
   1b530:	00989680 	.word	0x00989680
   1b534:	1fffa2bc 	.word	0x1fffa2bc

0001b538 <ultoa>:
{
   1b538:	b570      	push	{r4, r5, r6, lr}
   1b53a:	4604      	mov	r4, r0
   1b53c:	4608      	mov	r0, r1
	int i=0, j;
   1b53e:	2100      	movs	r1, #0
		digit = val % radix;
   1b540:	fbb4 f5f2 	udiv	r5, r4, r2
   1b544:	fb02 4615 	mls	r6, r2, r5, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
   1b548:	b2f3      	uxtb	r3, r6
   1b54a:	2e09      	cmp	r6, #9
   1b54c:	bf94      	ite	ls
   1b54e:	3330      	addls	r3, #48	; 0x30
   1b550:	3337      	addhi	r3, #55	; 0x37
   1b552:	b2db      	uxtb	r3, r3
		if (val == 0) break;
   1b554:	42a2      	cmp	r2, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
   1b556:	5443      	strb	r3, [r0, r1]
		if (val == 0) break;
   1b558:	d802      	bhi.n	1b560 <ultoa+0x28>
		i++;
   1b55a:	3101      	adds	r1, #1
		val /= radix;
   1b55c:	462c      	mov	r4, r5
		digit = val % radix;
   1b55e:	e7ef      	b.n	1b540 <ultoa+0x8>
	buf[i + 1] = 0;
   1b560:	1843      	adds	r3, r0, r1
   1b562:	2200      	movs	r2, #0
   1b564:	705a      	strb	r2, [r3, #1]
	for (j=0; j < i; j++, i--) {
   1b566:	1e44      	subs	r4, r0, #1
   1b568:	1a8d      	subs	r5, r1, r2
   1b56a:	42aa      	cmp	r2, r5
   1b56c:	db00      	blt.n	1b570 <ultoa+0x38>
}
   1b56e:	bd70      	pop	{r4, r5, r6, pc}
		t = buf[j];
   1b570:	f814 5f01 	ldrb.w	r5, [r4, #1]!
		buf[j] = buf[i];
   1b574:	781e      	ldrb	r6, [r3, #0]
   1b576:	7026      	strb	r6, [r4, #0]
	for (j=0; j < i; j++, i--) {
   1b578:	3201      	adds	r2, #1
		buf[i] = t;
   1b57a:	f803 5901 	strb.w	r5, [r3], #-1
	for (j=0; j < i; j++, i--) {
   1b57e:	e7f3      	b.n	1b568 <ultoa+0x30>

0001b580 <cosf>:
   1b580:	4a17      	ldr	r2, [pc, #92]	; (1b5e0 <cosf+0x60>)
   1b582:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
   1b586:	4293      	cmp	r3, r2
   1b588:	dd1a      	ble.n	1b5c0 <cosf+0x40>
   1b58a:	b500      	push	{lr}
   1b58c:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   1b590:	b083      	sub	sp, #12
   1b592:	db05      	blt.n	1b5a0 <cosf+0x20>
   1b594:	4601      	mov	r1, r0
   1b596:	f001 fcd9 	bl	1cf4c <__aeabi_fsub>
   1b59a:	b003      	add	sp, #12
   1b59c:	f85d fb04 	ldr.w	pc, [sp], #4
   1b5a0:	4669      	mov	r1, sp
   1b5a2:	f000 f99d 	bl	1b8e0 <__ieee754_rem_pio2f>
   1b5a6:	f000 0203 	and.w	r2, r0, #3
   1b5aa:	2a01      	cmp	r2, #1
   1b5ac:	9901      	ldr	r1, [sp, #4]
   1b5ae:	9800      	ldr	r0, [sp, #0]
   1b5b0:	d009      	beq.n	1b5c6 <cosf+0x46>
   1b5b2:	2a02      	cmp	r2, #2
   1b5b4:	d00f      	beq.n	1b5d6 <cosf+0x56>
   1b5b6:	b15a      	cbz	r2, 1b5d0 <cosf+0x50>
   1b5b8:	2201      	movs	r2, #1
   1b5ba:	f000 f91b 	bl	1b7f4 <__kernel_sinf>
   1b5be:	e7ec      	b.n	1b59a <cosf+0x1a>
   1b5c0:	2100      	movs	r1, #0
   1b5c2:	f000 b851 	b.w	1b668 <__kernel_cosf>
   1b5c6:	f000 f915 	bl	1b7f4 <__kernel_sinf>
   1b5ca:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   1b5ce:	e7e4      	b.n	1b59a <cosf+0x1a>
   1b5d0:	f000 f84a 	bl	1b668 <__kernel_cosf>
   1b5d4:	e7e1      	b.n	1b59a <cosf+0x1a>
   1b5d6:	f000 f847 	bl	1b668 <__kernel_cosf>
   1b5da:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   1b5de:	e7dc      	b.n	1b59a <cosf+0x1a>
   1b5e0:	3f490fd8 	.word	0x3f490fd8

0001b5e4 <sinf>:
   1b5e4:	4a1a      	ldr	r2, [pc, #104]	; (1b650 <sinf+0x6c>)
   1b5e6:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
   1b5ea:	4293      	cmp	r3, r2
   1b5ec:	dd1b      	ble.n	1b626 <sinf+0x42>
   1b5ee:	b500      	push	{lr}
   1b5f0:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   1b5f4:	b083      	sub	sp, #12
   1b5f6:	db05      	blt.n	1b604 <sinf+0x20>
   1b5f8:	4601      	mov	r1, r0
   1b5fa:	f001 fca7 	bl	1cf4c <__aeabi_fsub>
   1b5fe:	b003      	add	sp, #12
   1b600:	f85d fb04 	ldr.w	pc, [sp], #4
   1b604:	4669      	mov	r1, sp
   1b606:	f000 f96b 	bl	1b8e0 <__ieee754_rem_pio2f>
   1b60a:	f000 0003 	and.w	r0, r0, #3
   1b60e:	2801      	cmp	r0, #1
   1b610:	9901      	ldr	r1, [sp, #4]
   1b612:	d00c      	beq.n	1b62e <sinf+0x4a>
   1b614:	2802      	cmp	r0, #2
   1b616:	d013      	beq.n	1b640 <sinf+0x5c>
   1b618:	b168      	cbz	r0, 1b636 <sinf+0x52>
   1b61a:	9800      	ldr	r0, [sp, #0]
   1b61c:	f000 f824 	bl	1b668 <__kernel_cosf>
   1b620:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   1b624:	e7eb      	b.n	1b5fe <sinf+0x1a>
   1b626:	2100      	movs	r1, #0
   1b628:	2200      	movs	r2, #0
   1b62a:	f000 b8e3 	b.w	1b7f4 <__kernel_sinf>
   1b62e:	9800      	ldr	r0, [sp, #0]
   1b630:	f000 f81a 	bl	1b668 <__kernel_cosf>
   1b634:	e7e3      	b.n	1b5fe <sinf+0x1a>
   1b636:	9800      	ldr	r0, [sp, #0]
   1b638:	2201      	movs	r2, #1
   1b63a:	f000 f8db 	bl	1b7f4 <__kernel_sinf>
   1b63e:	e7de      	b.n	1b5fe <sinf+0x1a>
   1b640:	9800      	ldr	r0, [sp, #0]
   1b642:	2201      	movs	r2, #1
   1b644:	f000 f8d6 	bl	1b7f4 <__kernel_sinf>
   1b648:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   1b64c:	e7d7      	b.n	1b5fe <sinf+0x1a>
   1b64e:	bf00      	nop
   1b650:	3f490fd8 	.word	0x3f490fd8

0001b654 <log2f>:
   1b654:	b508      	push	{r3, lr}
   1b656:	f000 faf9 	bl	1bc4c <logf>
   1b65a:	4902      	ldr	r1, [pc, #8]	; (1b664 <log2f+0x10>)
   1b65c:	f001 fe34 	bl	1d2c8 <__aeabi_fdiv>
   1b660:	bd08      	pop	{r3, pc}
   1b662:	bf00      	nop
   1b664:	3f317218 	.word	0x3f317218

0001b668 <__kernel_cosf>:
   1b668:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1b66c:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
   1b670:	f1b5 5f48 	cmp.w	r5, #838860800	; 0x32000000
   1b674:	4606      	mov	r6, r0
   1b676:	4688      	mov	r8, r1
   1b678:	da4a      	bge.n	1b710 <__kernel_cosf+0xa8>
   1b67a:	f001 ff4d 	bl	1d518 <__aeabi_f2iz>
   1b67e:	2800      	cmp	r0, #0
   1b680:	f000 809f 	beq.w	1b7c2 <__kernel_cosf+0x15a>
   1b684:	4631      	mov	r1, r6
   1b686:	4630      	mov	r0, r6
   1b688:	f001 fd6a 	bl	1d160 <__aeabi_fmul>
   1b68c:	494f      	ldr	r1, [pc, #316]	; (1b7cc <__kernel_cosf+0x164>)
   1b68e:	4604      	mov	r4, r0
   1b690:	f001 fd66 	bl	1d160 <__aeabi_fmul>
   1b694:	494e      	ldr	r1, [pc, #312]	; (1b7d0 <__kernel_cosf+0x168>)
   1b696:	f001 fc5b 	bl	1cf50 <__addsf3>
   1b69a:	4621      	mov	r1, r4
   1b69c:	f001 fd60 	bl	1d160 <__aeabi_fmul>
   1b6a0:	494c      	ldr	r1, [pc, #304]	; (1b7d4 <__kernel_cosf+0x16c>)
   1b6a2:	f001 fc53 	bl	1cf4c <__aeabi_fsub>
   1b6a6:	4621      	mov	r1, r4
   1b6a8:	f001 fd5a 	bl	1d160 <__aeabi_fmul>
   1b6ac:	494a      	ldr	r1, [pc, #296]	; (1b7d8 <__kernel_cosf+0x170>)
   1b6ae:	f001 fc4f 	bl	1cf50 <__addsf3>
   1b6b2:	4621      	mov	r1, r4
   1b6b4:	f001 fd54 	bl	1d160 <__aeabi_fmul>
   1b6b8:	4948      	ldr	r1, [pc, #288]	; (1b7dc <__kernel_cosf+0x174>)
   1b6ba:	f001 fc47 	bl	1cf4c <__aeabi_fsub>
   1b6be:	4621      	mov	r1, r4
   1b6c0:	f001 fd4e 	bl	1d160 <__aeabi_fmul>
   1b6c4:	4946      	ldr	r1, [pc, #280]	; (1b7e0 <__kernel_cosf+0x178>)
   1b6c6:	f001 fc43 	bl	1cf50 <__addsf3>
   1b6ca:	4621      	mov	r1, r4
   1b6cc:	f001 fd48 	bl	1d160 <__aeabi_fmul>
   1b6d0:	4607      	mov	r7, r0
   1b6d2:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   1b6d6:	4620      	mov	r0, r4
   1b6d8:	f001 fd42 	bl	1d160 <__aeabi_fmul>
   1b6dc:	4639      	mov	r1, r7
   1b6de:	4603      	mov	r3, r0
   1b6e0:	4620      	mov	r0, r4
   1b6e2:	461c      	mov	r4, r3
   1b6e4:	f001 fd3c 	bl	1d160 <__aeabi_fmul>
   1b6e8:	4641      	mov	r1, r8
   1b6ea:	4605      	mov	r5, r0
   1b6ec:	4630      	mov	r0, r6
   1b6ee:	f001 fd37 	bl	1d160 <__aeabi_fmul>
   1b6f2:	4601      	mov	r1, r0
   1b6f4:	4628      	mov	r0, r5
   1b6f6:	f001 fc29 	bl	1cf4c <__aeabi_fsub>
   1b6fa:	4601      	mov	r1, r0
   1b6fc:	4620      	mov	r0, r4
   1b6fe:	f001 fc25 	bl	1cf4c <__aeabi_fsub>
   1b702:	4601      	mov	r1, r0
   1b704:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   1b708:	f001 fc20 	bl	1cf4c <__aeabi_fsub>
   1b70c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b710:	4601      	mov	r1, r0
   1b712:	f001 fd25 	bl	1d160 <__aeabi_fmul>
   1b716:	492d      	ldr	r1, [pc, #180]	; (1b7cc <__kernel_cosf+0x164>)
   1b718:	4604      	mov	r4, r0
   1b71a:	f001 fd21 	bl	1d160 <__aeabi_fmul>
   1b71e:	492c      	ldr	r1, [pc, #176]	; (1b7d0 <__kernel_cosf+0x168>)
   1b720:	f001 fc16 	bl	1cf50 <__addsf3>
   1b724:	4621      	mov	r1, r4
   1b726:	f001 fd1b 	bl	1d160 <__aeabi_fmul>
   1b72a:	492a      	ldr	r1, [pc, #168]	; (1b7d4 <__kernel_cosf+0x16c>)
   1b72c:	f001 fc0e 	bl	1cf4c <__aeabi_fsub>
   1b730:	4621      	mov	r1, r4
   1b732:	f001 fd15 	bl	1d160 <__aeabi_fmul>
   1b736:	4928      	ldr	r1, [pc, #160]	; (1b7d8 <__kernel_cosf+0x170>)
   1b738:	f001 fc0a 	bl	1cf50 <__addsf3>
   1b73c:	4621      	mov	r1, r4
   1b73e:	f001 fd0f 	bl	1d160 <__aeabi_fmul>
   1b742:	4926      	ldr	r1, [pc, #152]	; (1b7dc <__kernel_cosf+0x174>)
   1b744:	f001 fc02 	bl	1cf4c <__aeabi_fsub>
   1b748:	4621      	mov	r1, r4
   1b74a:	f001 fd09 	bl	1d160 <__aeabi_fmul>
   1b74e:	4924      	ldr	r1, [pc, #144]	; (1b7e0 <__kernel_cosf+0x178>)
   1b750:	f001 fbfe 	bl	1cf50 <__addsf3>
   1b754:	4621      	mov	r1, r4
   1b756:	f001 fd03 	bl	1d160 <__aeabi_fmul>
   1b75a:	4b22      	ldr	r3, [pc, #136]	; (1b7e4 <__kernel_cosf+0x17c>)
   1b75c:	429d      	cmp	r5, r3
   1b75e:	4607      	mov	r7, r0
   1b760:	ddb7      	ble.n	1b6d2 <__kernel_cosf+0x6a>
   1b762:	4b21      	ldr	r3, [pc, #132]	; (1b7e8 <__kernel_cosf+0x180>)
   1b764:	429d      	cmp	r5, r3
   1b766:	dc28      	bgt.n	1b7ba <__kernel_cosf+0x152>
   1b768:	f105 457f 	add.w	r5, r5, #4278190080	; 0xff000000
   1b76c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   1b770:	4629      	mov	r1, r5
   1b772:	f001 fbeb 	bl	1cf4c <__aeabi_fsub>
   1b776:	4681      	mov	r9, r0
   1b778:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   1b77c:	4620      	mov	r0, r4
   1b77e:	f001 fcef 	bl	1d160 <__aeabi_fmul>
   1b782:	4629      	mov	r1, r5
   1b784:	f001 fbe2 	bl	1cf4c <__aeabi_fsub>
   1b788:	4639      	mov	r1, r7
   1b78a:	4603      	mov	r3, r0
   1b78c:	4620      	mov	r0, r4
   1b78e:	461c      	mov	r4, r3
   1b790:	f001 fce6 	bl	1d160 <__aeabi_fmul>
   1b794:	4641      	mov	r1, r8
   1b796:	4605      	mov	r5, r0
   1b798:	4630      	mov	r0, r6
   1b79a:	f001 fce1 	bl	1d160 <__aeabi_fmul>
   1b79e:	4601      	mov	r1, r0
   1b7a0:	4628      	mov	r0, r5
   1b7a2:	f001 fbd3 	bl	1cf4c <__aeabi_fsub>
   1b7a6:	4601      	mov	r1, r0
   1b7a8:	4620      	mov	r0, r4
   1b7aa:	f001 fbcf 	bl	1cf4c <__aeabi_fsub>
   1b7ae:	4601      	mov	r1, r0
   1b7b0:	4648      	mov	r0, r9
   1b7b2:	f001 fbcb 	bl	1cf4c <__aeabi_fsub>
   1b7b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b7ba:	f8df 9030 	ldr.w	r9, [pc, #48]	; 1b7ec <__kernel_cosf+0x184>
   1b7be:	4d0c      	ldr	r5, [pc, #48]	; (1b7f0 <__kernel_cosf+0x188>)
   1b7c0:	e7da      	b.n	1b778 <__kernel_cosf+0x110>
   1b7c2:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   1b7c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b7ca:	bf00      	nop
   1b7cc:	ad47d74e 	.word	0xad47d74e
   1b7d0:	310f74f6 	.word	0x310f74f6
   1b7d4:	3493f27c 	.word	0x3493f27c
   1b7d8:	37d00d01 	.word	0x37d00d01
   1b7dc:	3ab60b61 	.word	0x3ab60b61
   1b7e0:	3d2aaaab 	.word	0x3d2aaaab
   1b7e4:	3e999999 	.word	0x3e999999
   1b7e8:	3f480000 	.word	0x3f480000
   1b7ec:	3f380000 	.word	0x3f380000
   1b7f0:	3e900000 	.word	0x3e900000

0001b7f4 <__kernel_sinf>:
   1b7f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1b7f8:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
   1b7fc:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   1b800:	4604      	mov	r4, r0
   1b802:	460e      	mov	r6, r1
   1b804:	4690      	mov	r8, r2
   1b806:	da03      	bge.n	1b810 <__kernel_sinf+0x1c>
   1b808:	f001 fe86 	bl	1d518 <__aeabi_f2iz>
   1b80c:	2800      	cmp	r0, #0
   1b80e:	d058      	beq.n	1b8c2 <__kernel_sinf+0xce>
   1b810:	4621      	mov	r1, r4
   1b812:	4620      	mov	r0, r4
   1b814:	f001 fca4 	bl	1d160 <__aeabi_fmul>
   1b818:	4605      	mov	r5, r0
   1b81a:	4601      	mov	r1, r0
   1b81c:	4620      	mov	r0, r4
   1b81e:	f001 fc9f 	bl	1d160 <__aeabi_fmul>
   1b822:	4929      	ldr	r1, [pc, #164]	; (1b8c8 <__kernel_sinf+0xd4>)
   1b824:	4681      	mov	r9, r0
   1b826:	4628      	mov	r0, r5
   1b828:	f001 fc9a 	bl	1d160 <__aeabi_fmul>
   1b82c:	4927      	ldr	r1, [pc, #156]	; (1b8cc <__kernel_sinf+0xd8>)
   1b82e:	f001 fb8d 	bl	1cf4c <__aeabi_fsub>
   1b832:	4629      	mov	r1, r5
   1b834:	f001 fc94 	bl	1d160 <__aeabi_fmul>
   1b838:	4925      	ldr	r1, [pc, #148]	; (1b8d0 <__kernel_sinf+0xdc>)
   1b83a:	f001 fb89 	bl	1cf50 <__addsf3>
   1b83e:	4629      	mov	r1, r5
   1b840:	f001 fc8e 	bl	1d160 <__aeabi_fmul>
   1b844:	4923      	ldr	r1, [pc, #140]	; (1b8d4 <__kernel_sinf+0xe0>)
   1b846:	f001 fb81 	bl	1cf4c <__aeabi_fsub>
   1b84a:	4629      	mov	r1, r5
   1b84c:	f001 fc88 	bl	1d160 <__aeabi_fmul>
   1b850:	4921      	ldr	r1, [pc, #132]	; (1b8d8 <__kernel_sinf+0xe4>)
   1b852:	f001 fb7d 	bl	1cf50 <__addsf3>
   1b856:	4607      	mov	r7, r0
   1b858:	f1b8 0f00 	cmp.w	r8, #0
   1b85c:	d022      	beq.n	1b8a4 <__kernel_sinf+0xb0>
   1b85e:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   1b862:	4630      	mov	r0, r6
   1b864:	f001 fc7c 	bl	1d160 <__aeabi_fmul>
   1b868:	4639      	mov	r1, r7
   1b86a:	4680      	mov	r8, r0
   1b86c:	4648      	mov	r0, r9
   1b86e:	f001 fc77 	bl	1d160 <__aeabi_fmul>
   1b872:	4601      	mov	r1, r0
   1b874:	4640      	mov	r0, r8
   1b876:	f001 fb69 	bl	1cf4c <__aeabi_fsub>
   1b87a:	4629      	mov	r1, r5
   1b87c:	f001 fc70 	bl	1d160 <__aeabi_fmul>
   1b880:	4631      	mov	r1, r6
   1b882:	f001 fb63 	bl	1cf4c <__aeabi_fsub>
   1b886:	4915      	ldr	r1, [pc, #84]	; (1b8dc <__kernel_sinf+0xe8>)
   1b888:	4605      	mov	r5, r0
   1b88a:	4648      	mov	r0, r9
   1b88c:	f001 fc68 	bl	1d160 <__aeabi_fmul>
   1b890:	4601      	mov	r1, r0
   1b892:	4628      	mov	r0, r5
   1b894:	f001 fb5c 	bl	1cf50 <__addsf3>
   1b898:	4601      	mov	r1, r0
   1b89a:	4620      	mov	r0, r4
   1b89c:	f001 fb56 	bl	1cf4c <__aeabi_fsub>
   1b8a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b8a4:	4601      	mov	r1, r0
   1b8a6:	4628      	mov	r0, r5
   1b8a8:	f001 fc5a 	bl	1d160 <__aeabi_fmul>
   1b8ac:	490b      	ldr	r1, [pc, #44]	; (1b8dc <__kernel_sinf+0xe8>)
   1b8ae:	f001 fb4d 	bl	1cf4c <__aeabi_fsub>
   1b8b2:	4649      	mov	r1, r9
   1b8b4:	f001 fc54 	bl	1d160 <__aeabi_fmul>
   1b8b8:	4621      	mov	r1, r4
   1b8ba:	f001 fb49 	bl	1cf50 <__addsf3>
   1b8be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b8c2:	4620      	mov	r0, r4
   1b8c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b8c8:	2f2ec9d3 	.word	0x2f2ec9d3
   1b8cc:	32d72f34 	.word	0x32d72f34
   1b8d0:	3638ef1b 	.word	0x3638ef1b
   1b8d4:	39500d01 	.word	0x39500d01
   1b8d8:	3c088889 	.word	0x3c088889
   1b8dc:	3e2aaaab 	.word	0x3e2aaaab

0001b8e0 <__ieee754_rem_pio2f>:
   1b8e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b8e4:	4aab      	ldr	r2, [pc, #684]	; (1bb94 <__ieee754_rem_pio2f+0x2b4>)
   1b8e6:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
   1b8ea:	4294      	cmp	r4, r2
   1b8ec:	b089      	sub	sp, #36	; 0x24
   1b8ee:	460d      	mov	r5, r1
   1b8f0:	dd6c      	ble.n	1b9cc <__ieee754_rem_pio2f+0xec>
   1b8f2:	4aa9      	ldr	r2, [pc, #676]	; (1bb98 <__ieee754_rem_pio2f+0x2b8>)
   1b8f4:	4294      	cmp	r4, r2
   1b8f6:	4607      	mov	r7, r0
   1b8f8:	dc1c      	bgt.n	1b934 <__ieee754_rem_pio2f+0x54>
   1b8fa:	2800      	cmp	r0, #0
   1b8fc:	49a7      	ldr	r1, [pc, #668]	; (1bb9c <__ieee754_rem_pio2f+0x2bc>)
   1b8fe:	f340 811e 	ble.w	1bb3e <__ieee754_rem_pio2f+0x25e>
   1b902:	f001 fb23 	bl	1cf4c <__aeabi_fsub>
   1b906:	4ba6      	ldr	r3, [pc, #664]	; (1bba0 <__ieee754_rem_pio2f+0x2c0>)
   1b908:	f024 040f 	bic.w	r4, r4, #15
   1b90c:	429c      	cmp	r4, r3
   1b90e:	4606      	mov	r6, r0
   1b910:	d06b      	beq.n	1b9ea <__ieee754_rem_pio2f+0x10a>
   1b912:	49a4      	ldr	r1, [pc, #656]	; (1bba4 <__ieee754_rem_pio2f+0x2c4>)
   1b914:	f001 fb1a 	bl	1cf4c <__aeabi_fsub>
   1b918:	4601      	mov	r1, r0
   1b91a:	6028      	str	r0, [r5, #0]
   1b91c:	4630      	mov	r0, r6
   1b91e:	f001 fb15 	bl	1cf4c <__aeabi_fsub>
   1b922:	49a0      	ldr	r1, [pc, #640]	; (1bba4 <__ieee754_rem_pio2f+0x2c4>)
   1b924:	f001 fb12 	bl	1cf4c <__aeabi_fsub>
   1b928:	2601      	movs	r6, #1
   1b92a:	6068      	str	r0, [r5, #4]
   1b92c:	4630      	mov	r0, r6
   1b92e:	b009      	add	sp, #36	; 0x24
   1b930:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1b934:	4a9c      	ldr	r2, [pc, #624]	; (1bba8 <__ieee754_rem_pio2f+0x2c8>)
   1b936:	4294      	cmp	r4, r2
   1b938:	dd6c      	ble.n	1ba14 <__ieee754_rem_pio2f+0x134>
   1b93a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   1b93e:	da4d      	bge.n	1b9dc <__ieee754_rem_pio2f+0xfc>
   1b940:	15e6      	asrs	r6, r4, #23
   1b942:	3e86      	subs	r6, #134	; 0x86
   1b944:	eba4 54c6 	sub.w	r4, r4, r6, lsl #23
   1b948:	4620      	mov	r0, r4
   1b94a:	f001 fde5 	bl	1d518 <__aeabi_f2iz>
   1b94e:	f001 fbb3 	bl	1d0b8 <__aeabi_i2f>
   1b952:	4601      	mov	r1, r0
   1b954:	4620      	mov	r0, r4
   1b956:	9105      	str	r1, [sp, #20]
   1b958:	f001 faf8 	bl	1cf4c <__aeabi_fsub>
   1b95c:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
   1b960:	f001 fbfe 	bl	1d160 <__aeabi_fmul>
   1b964:	4680      	mov	r8, r0
   1b966:	f001 fdd7 	bl	1d518 <__aeabi_f2iz>
   1b96a:	f001 fba5 	bl	1d0b8 <__aeabi_i2f>
   1b96e:	4604      	mov	r4, r0
   1b970:	4621      	mov	r1, r4
   1b972:	4640      	mov	r0, r8
   1b974:	9406      	str	r4, [sp, #24]
   1b976:	f001 fae9 	bl	1cf4c <__aeabi_fsub>
   1b97a:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
   1b97e:	f001 fbef 	bl	1d160 <__aeabi_fmul>
   1b982:	2100      	movs	r1, #0
   1b984:	9007      	str	r0, [sp, #28]
   1b986:	f001 fd7f 	bl	1d488 <__aeabi_fcmpeq>
   1b98a:	2800      	cmp	r0, #0
   1b98c:	f000 80b8 	beq.w	1bb00 <__ieee754_rem_pio2f+0x220>
   1b990:	2100      	movs	r1, #0
   1b992:	4620      	mov	r0, r4
   1b994:	f001 fd78 	bl	1d488 <__aeabi_fcmpeq>
   1b998:	2800      	cmp	r0, #0
   1b99a:	bf14      	ite	ne
   1b99c:	2301      	movne	r3, #1
   1b99e:	2302      	moveq	r3, #2
   1b9a0:	4a82      	ldr	r2, [pc, #520]	; (1bbac <__ieee754_rem_pio2f+0x2cc>)
   1b9a2:	9201      	str	r2, [sp, #4]
   1b9a4:	2202      	movs	r2, #2
   1b9a6:	9200      	str	r2, [sp, #0]
   1b9a8:	4629      	mov	r1, r5
   1b9aa:	4632      	mov	r2, r6
   1b9ac:	a805      	add	r0, sp, #20
   1b9ae:	f000 f97f 	bl	1bcb0 <__kernel_rem_pio2f>
   1b9b2:	2f00      	cmp	r7, #0
   1b9b4:	4606      	mov	r6, r0
   1b9b6:	dab9      	bge.n	1b92c <__ieee754_rem_pio2f+0x4c>
   1b9b8:	e9d5 2300 	ldrd	r2, r3, [r5]
   1b9bc:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
   1b9c0:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
   1b9c4:	602a      	str	r2, [r5, #0]
   1b9c6:	606b      	str	r3, [r5, #4]
   1b9c8:	4246      	negs	r6, r0
   1b9ca:	e7af      	b.n	1b92c <__ieee754_rem_pio2f+0x4c>
   1b9cc:	2600      	movs	r6, #0
   1b9ce:	6028      	str	r0, [r5, #0]
   1b9d0:	2200      	movs	r2, #0
   1b9d2:	4630      	mov	r0, r6
   1b9d4:	604a      	str	r2, [r1, #4]
   1b9d6:	b009      	add	sp, #36	; 0x24
   1b9d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1b9dc:	4601      	mov	r1, r0
   1b9de:	f001 fab5 	bl	1cf4c <__aeabi_fsub>
   1b9e2:	2600      	movs	r6, #0
   1b9e4:	6068      	str	r0, [r5, #4]
   1b9e6:	6028      	str	r0, [r5, #0]
   1b9e8:	e7a0      	b.n	1b92c <__ieee754_rem_pio2f+0x4c>
   1b9ea:	4971      	ldr	r1, [pc, #452]	; (1bbb0 <__ieee754_rem_pio2f+0x2d0>)
   1b9ec:	f001 faae 	bl	1cf4c <__aeabi_fsub>
   1b9f0:	4970      	ldr	r1, [pc, #448]	; (1bbb4 <__ieee754_rem_pio2f+0x2d4>)
   1b9f2:	4604      	mov	r4, r0
   1b9f4:	f001 faaa 	bl	1cf4c <__aeabi_fsub>
   1b9f8:	4601      	mov	r1, r0
   1b9fa:	6028      	str	r0, [r5, #0]
   1b9fc:	4620      	mov	r0, r4
   1b9fe:	f001 faa5 	bl	1cf4c <__aeabi_fsub>
   1ba02:	496c      	ldr	r1, [pc, #432]	; (1bbb4 <__ieee754_rem_pio2f+0x2d4>)
   1ba04:	f001 faa2 	bl	1cf4c <__aeabi_fsub>
   1ba08:	2601      	movs	r6, #1
   1ba0a:	6068      	str	r0, [r5, #4]
   1ba0c:	4630      	mov	r0, r6
   1ba0e:	b009      	add	sp, #36	; 0x24
   1ba10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ba14:	f000 f944 	bl	1bca0 <fabsf>
   1ba18:	4967      	ldr	r1, [pc, #412]	; (1bbb8 <__ieee754_rem_pio2f+0x2d8>)
   1ba1a:	4680      	mov	r8, r0
   1ba1c:	f001 fba0 	bl	1d160 <__aeabi_fmul>
   1ba20:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   1ba24:	f001 fa94 	bl	1cf50 <__addsf3>
   1ba28:	f001 fd76 	bl	1d518 <__aeabi_f2iz>
   1ba2c:	4606      	mov	r6, r0
   1ba2e:	f001 fb43 	bl	1d0b8 <__aeabi_i2f>
   1ba32:	495a      	ldr	r1, [pc, #360]	; (1bb9c <__ieee754_rem_pio2f+0x2bc>)
   1ba34:	4683      	mov	fp, r0
   1ba36:	f001 fb93 	bl	1d160 <__aeabi_fmul>
   1ba3a:	4601      	mov	r1, r0
   1ba3c:	4640      	mov	r0, r8
   1ba3e:	f001 fa85 	bl	1cf4c <__aeabi_fsub>
   1ba42:	4958      	ldr	r1, [pc, #352]	; (1bba4 <__ieee754_rem_pio2f+0x2c4>)
   1ba44:	4682      	mov	sl, r0
   1ba46:	4658      	mov	r0, fp
   1ba48:	f001 fb8a 	bl	1d160 <__aeabi_fmul>
   1ba4c:	2e1f      	cmp	r6, #31
   1ba4e:	4681      	mov	r9, r0
   1ba50:	4601      	mov	r1, r0
   1ba52:	4650      	mov	r0, sl
   1ba54:	dc20      	bgt.n	1ba98 <__ieee754_rem_pio2f+0x1b8>
   1ba56:	1e72      	subs	r2, r6, #1
   1ba58:	4b58      	ldr	r3, [pc, #352]	; (1bbbc <__ieee754_rem_pio2f+0x2dc>)
   1ba5a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1ba5e:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
   1ba62:	429a      	cmp	r2, r3
   1ba64:	d018      	beq.n	1ba98 <__ieee754_rem_pio2f+0x1b8>
   1ba66:	f001 fa71 	bl	1cf4c <__aeabi_fsub>
   1ba6a:	4680      	mov	r8, r0
   1ba6c:	f8c5 8000 	str.w	r8, [r5]
   1ba70:	4641      	mov	r1, r8
   1ba72:	4650      	mov	r0, sl
   1ba74:	f001 fa6a 	bl	1cf4c <__aeabi_fsub>
   1ba78:	4649      	mov	r1, r9
   1ba7a:	f001 fa67 	bl	1cf4c <__aeabi_fsub>
   1ba7e:	2f00      	cmp	r7, #0
   1ba80:	6068      	str	r0, [r5, #4]
   1ba82:	f6bf af53 	bge.w	1b92c <__ieee754_rem_pio2f+0x4c>
   1ba86:	f108 4800 	add.w	r8, r8, #2147483648	; 0x80000000
   1ba8a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   1ba8e:	f8c5 8000 	str.w	r8, [r5]
   1ba92:	6068      	str	r0, [r5, #4]
   1ba94:	4276      	negs	r6, r6
   1ba96:	e749      	b.n	1b92c <__ieee754_rem_pio2f+0x4c>
   1ba98:	f001 fa58 	bl	1cf4c <__aeabi_fsub>
   1ba9c:	f3c0 53c7 	ubfx	r3, r0, #23, #8
   1baa0:	ebc3 53d4 	rsb	r3, r3, r4, lsr #23
   1baa4:	2b08      	cmp	r3, #8
   1baa6:	4680      	mov	r8, r0
   1baa8:	ea4f 52e4 	mov.w	r2, r4, asr #23
   1baac:	ddde      	ble.n	1ba6c <__ieee754_rem_pio2f+0x18c>
   1baae:	4940      	ldr	r1, [pc, #256]	; (1bbb0 <__ieee754_rem_pio2f+0x2d0>)
   1bab0:	9203      	str	r2, [sp, #12]
   1bab2:	4658      	mov	r0, fp
   1bab4:	f001 fb54 	bl	1d160 <__aeabi_fmul>
   1bab8:	4680      	mov	r8, r0
   1baba:	4601      	mov	r1, r0
   1babc:	4650      	mov	r0, sl
   1babe:	f001 fa45 	bl	1cf4c <__aeabi_fsub>
   1bac2:	4604      	mov	r4, r0
   1bac4:	4621      	mov	r1, r4
   1bac6:	4650      	mov	r0, sl
   1bac8:	f001 fa40 	bl	1cf4c <__aeabi_fsub>
   1bacc:	4641      	mov	r1, r8
   1bace:	f001 fa3d 	bl	1cf4c <__aeabi_fsub>
   1bad2:	4938      	ldr	r1, [pc, #224]	; (1bbb4 <__ieee754_rem_pio2f+0x2d4>)
   1bad4:	4680      	mov	r8, r0
   1bad6:	4658      	mov	r0, fp
   1bad8:	f001 fb42 	bl	1d160 <__aeabi_fmul>
   1badc:	4641      	mov	r1, r8
   1bade:	f001 fa35 	bl	1cf4c <__aeabi_fsub>
   1bae2:	4601      	mov	r1, r0
   1bae4:	4681      	mov	r9, r0
   1bae6:	4620      	mov	r0, r4
   1bae8:	f001 fa30 	bl	1cf4c <__aeabi_fsub>
   1baec:	9a03      	ldr	r2, [sp, #12]
   1baee:	f3c0 53c7 	ubfx	r3, r0, #23, #8
   1baf2:	1ad2      	subs	r2, r2, r3
   1baf4:	2a19      	cmp	r2, #25
   1baf6:	4680      	mov	r8, r0
   1baf8:	dc04      	bgt.n	1bb04 <__ieee754_rem_pio2f+0x224>
   1bafa:	6028      	str	r0, [r5, #0]
   1bafc:	46a2      	mov	sl, r4
   1bafe:	e7b7      	b.n	1ba70 <__ieee754_rem_pio2f+0x190>
   1bb00:	2303      	movs	r3, #3
   1bb02:	e74d      	b.n	1b9a0 <__ieee754_rem_pio2f+0xc0>
   1bb04:	492e      	ldr	r1, [pc, #184]	; (1bbc0 <__ieee754_rem_pio2f+0x2e0>)
   1bb06:	4658      	mov	r0, fp
   1bb08:	f001 fb2a 	bl	1d160 <__aeabi_fmul>
   1bb0c:	4601      	mov	r1, r0
   1bb0e:	4680      	mov	r8, r0
   1bb10:	4620      	mov	r0, r4
   1bb12:	f001 fa1b 	bl	1cf4c <__aeabi_fsub>
   1bb16:	4682      	mov	sl, r0
   1bb18:	4651      	mov	r1, sl
   1bb1a:	4620      	mov	r0, r4
   1bb1c:	f001 fa16 	bl	1cf4c <__aeabi_fsub>
   1bb20:	4641      	mov	r1, r8
   1bb22:	f001 fa13 	bl	1cf4c <__aeabi_fsub>
   1bb26:	4927      	ldr	r1, [pc, #156]	; (1bbc4 <__ieee754_rem_pio2f+0x2e4>)
   1bb28:	4604      	mov	r4, r0
   1bb2a:	4658      	mov	r0, fp
   1bb2c:	f001 fb18 	bl	1d160 <__aeabi_fmul>
   1bb30:	4621      	mov	r1, r4
   1bb32:	f001 fa0b 	bl	1cf4c <__aeabi_fsub>
   1bb36:	4681      	mov	r9, r0
   1bb38:	4601      	mov	r1, r0
   1bb3a:	4650      	mov	r0, sl
   1bb3c:	e793      	b.n	1ba66 <__ieee754_rem_pio2f+0x186>
   1bb3e:	f001 fa07 	bl	1cf50 <__addsf3>
   1bb42:	4b17      	ldr	r3, [pc, #92]	; (1bba0 <__ieee754_rem_pio2f+0x2c0>)
   1bb44:	f024 040f 	bic.w	r4, r4, #15
   1bb48:	429c      	cmp	r4, r3
   1bb4a:	4606      	mov	r6, r0
   1bb4c:	d00e      	beq.n	1bb6c <__ieee754_rem_pio2f+0x28c>
   1bb4e:	4915      	ldr	r1, [pc, #84]	; (1bba4 <__ieee754_rem_pio2f+0x2c4>)
   1bb50:	f001 f9fe 	bl	1cf50 <__addsf3>
   1bb54:	4601      	mov	r1, r0
   1bb56:	6028      	str	r0, [r5, #0]
   1bb58:	4630      	mov	r0, r6
   1bb5a:	f001 f9f7 	bl	1cf4c <__aeabi_fsub>
   1bb5e:	4911      	ldr	r1, [pc, #68]	; (1bba4 <__ieee754_rem_pio2f+0x2c4>)
   1bb60:	f001 f9f6 	bl	1cf50 <__addsf3>
   1bb64:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   1bb68:	6068      	str	r0, [r5, #4]
   1bb6a:	e6df      	b.n	1b92c <__ieee754_rem_pio2f+0x4c>
   1bb6c:	4910      	ldr	r1, [pc, #64]	; (1bbb0 <__ieee754_rem_pio2f+0x2d0>)
   1bb6e:	f001 f9ef 	bl	1cf50 <__addsf3>
   1bb72:	4910      	ldr	r1, [pc, #64]	; (1bbb4 <__ieee754_rem_pio2f+0x2d4>)
   1bb74:	4604      	mov	r4, r0
   1bb76:	f001 f9eb 	bl	1cf50 <__addsf3>
   1bb7a:	4601      	mov	r1, r0
   1bb7c:	6028      	str	r0, [r5, #0]
   1bb7e:	4620      	mov	r0, r4
   1bb80:	f001 f9e4 	bl	1cf4c <__aeabi_fsub>
   1bb84:	490b      	ldr	r1, [pc, #44]	; (1bbb4 <__ieee754_rem_pio2f+0x2d4>)
   1bb86:	f001 f9e3 	bl	1cf50 <__addsf3>
   1bb8a:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   1bb8e:	6068      	str	r0, [r5, #4]
   1bb90:	e6cc      	b.n	1b92c <__ieee754_rem_pio2f+0x4c>
   1bb92:	bf00      	nop
   1bb94:	3f490fd8 	.word	0x3f490fd8
   1bb98:	4016cbe3 	.word	0x4016cbe3
   1bb9c:	3fc90f80 	.word	0x3fc90f80
   1bba0:	3fc90fd0 	.word	0x3fc90fd0
   1bba4:	37354443 	.word	0x37354443
   1bba8:	43490f80 	.word	0x43490f80
   1bbac:	00027d08 	.word	0x00027d08
   1bbb0:	37354400 	.word	0x37354400
   1bbb4:	2e85a308 	.word	0x2e85a308
   1bbb8:	3f22f984 	.word	0x3f22f984
   1bbbc:	00027c88 	.word	0x00027c88
   1bbc0:	2e85a300 	.word	0x2e85a300
   1bbc4:	248d3132 	.word	0x248d3132

0001bbc8 <floorf>:
   1bbc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bbcc:	f3c0 55c7 	ubfx	r5, r0, #23, #8
   1bbd0:	3d7f      	subs	r5, #127	; 0x7f
   1bbd2:	2d16      	cmp	r5, #22
   1bbd4:	4604      	mov	r4, r0
   1bbd6:	f020 4700 	bic.w	r7, r0, #2147483648	; 0x80000000
   1bbda:	dc25      	bgt.n	1bc28 <floorf+0x60>
   1bbdc:	2d00      	cmp	r5, #0
   1bbde:	4680      	mov	r8, r0
   1bbe0:	db14      	blt.n	1bc0c <floorf+0x44>
   1bbe2:	4f17      	ldr	r7, [pc, #92]	; (1bc40 <floorf+0x78>)
   1bbe4:	412f      	asrs	r7, r5
   1bbe6:	4238      	tst	r0, r7
   1bbe8:	d01b      	beq.n	1bc22 <floorf+0x5a>
   1bbea:	4916      	ldr	r1, [pc, #88]	; (1bc44 <floorf+0x7c>)
   1bbec:	f001 f9b0 	bl	1cf50 <__addsf3>
   1bbf0:	2100      	movs	r1, #0
   1bbf2:	f001 fc71 	bl	1d4d8 <__aeabi_fcmpgt>
   1bbf6:	b1a0      	cbz	r0, 1bc22 <floorf+0x5a>
   1bbf8:	2c00      	cmp	r4, #0
   1bbfa:	da03      	bge.n	1bc04 <floorf+0x3c>
   1bbfc:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   1bc00:	412b      	asrs	r3, r5
   1bc02:	4498      	add	r8, r3
   1bc04:	ea28 0007 	bic.w	r0, r8, r7
   1bc08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1bc0c:	490d      	ldr	r1, [pc, #52]	; (1bc44 <floorf+0x7c>)
   1bc0e:	f001 f99f 	bl	1cf50 <__addsf3>
   1bc12:	2100      	movs	r1, #0
   1bc14:	f001 fc60 	bl	1d4d8 <__aeabi_fcmpgt>
   1bc18:	b118      	cbz	r0, 1bc22 <floorf+0x5a>
   1bc1a:	2c00      	cmp	r4, #0
   1bc1c:	db0c      	blt.n	1bc38 <floorf+0x70>
   1bc1e:	2000      	movs	r0, #0
   1bc20:	e000      	b.n	1bc24 <floorf+0x5c>
   1bc22:	4620      	mov	r0, r4
   1bc24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1bc28:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
   1bc2c:	d3f9      	bcc.n	1bc22 <floorf+0x5a>
   1bc2e:	4601      	mov	r1, r0
   1bc30:	f001 f98e 	bl	1cf50 <__addsf3>
   1bc34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1bc38:	2f00      	cmp	r7, #0
   1bc3a:	d0f2      	beq.n	1bc22 <floorf+0x5a>
   1bc3c:	4802      	ldr	r0, [pc, #8]	; (1bc48 <floorf+0x80>)
   1bc3e:	e7f1      	b.n	1bc24 <floorf+0x5c>
   1bc40:	007fffff 	.word	0x007fffff
   1bc44:	7149f2ca 	.word	0x7149f2ca
   1bc48:	bf800000 	.word	0xbf800000

0001bc4c <logf>:
   1bc4c:	b538      	push	{r3, r4, r5, lr}
   1bc4e:	4604      	mov	r4, r0
   1bc50:	f000 fb9e 	bl	1c390 <__ieee754_logf>
   1bc54:	4621      	mov	r1, r4
   1bc56:	4605      	mov	r5, r0
   1bc58:	4620      	mov	r0, r4
   1bc5a:	f001 fc47 	bl	1d4ec <__aeabi_fcmpun>
   1bc5e:	b970      	cbnz	r0, 1bc7e <logf+0x32>
   1bc60:	2100      	movs	r1, #0
   1bc62:	4620      	mov	r0, r4
   1bc64:	f001 fc38 	bl	1d4d8 <__aeabi_fcmpgt>
   1bc68:	b948      	cbnz	r0, 1bc7e <logf+0x32>
   1bc6a:	2100      	movs	r1, #0
   1bc6c:	4620      	mov	r0, r4
   1bc6e:	f001 fc0b 	bl	1d488 <__aeabi_fcmpeq>
   1bc72:	b130      	cbz	r0, 1bc82 <logf+0x36>
   1bc74:	f001 fdb8 	bl	1d7e8 <__errno>
   1bc78:	4d07      	ldr	r5, [pc, #28]	; (1bc98 <logf+0x4c>)
   1bc7a:	2322      	movs	r3, #34	; 0x22
   1bc7c:	6003      	str	r3, [r0, #0]
   1bc7e:	4628      	mov	r0, r5
   1bc80:	bd38      	pop	{r3, r4, r5, pc}
   1bc82:	f001 fdb1 	bl	1d7e8 <__errno>
   1bc86:	4603      	mov	r3, r0
   1bc88:	2221      	movs	r2, #33	; 0x21
   1bc8a:	601a      	str	r2, [r3, #0]
   1bc8c:	4803      	ldr	r0, [pc, #12]	; (1bc9c <logf+0x50>)
   1bc8e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1bc92:	f000 b809 	b.w	1bca8 <nanf>
   1bc96:	bf00      	nop
   1bc98:	ff800000 	.word	0xff800000
   1bc9c:	00028020 	.word	0x00028020

0001bca0 <fabsf>:
   1bca0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   1bca4:	4770      	bx	lr
   1bca6:	bf00      	nop

0001bca8 <nanf>:
   1bca8:	4800      	ldr	r0, [pc, #0]	; (1bcac <nanf+0x4>)
   1bcaa:	4770      	bx	lr
   1bcac:	7fc00000 	.word	0x7fc00000

0001bcb0 <__kernel_rem_pio2f>:
   1bcb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1bcb4:	b0dd      	sub	sp, #372	; 0x174
   1bcb6:	461c      	mov	r4, r3
   1bcb8:	9306      	str	r3, [sp, #24]
   1bcba:	9109      	str	r1, [sp, #36]	; 0x24
   1bcbc:	4ba6      	ldr	r3, [pc, #664]	; (1bf58 <__kernel_rem_pio2f+0x2a8>)
   1bcbe:	9966      	ldr	r1, [sp, #408]	; 0x198
   1bcc0:	920b      	str	r2, [sp, #44]	; 0x2c
   1bcc2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1bcc6:	9303      	str	r3, [sp, #12]
   1bcc8:	1d11      	adds	r1, r2, #4
   1bcca:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
   1bcce:	4605      	mov	r5, r0
   1bcd0:	9301      	str	r3, [sp, #4]
   1bcd2:	f2c0 82ec 	blt.w	1c2ae <__kernel_rem_pio2f+0x5fe>
   1bcd6:	1ed3      	subs	r3, r2, #3
   1bcd8:	bf48      	it	mi
   1bcda:	1d13      	addmi	r3, r2, #4
   1bcdc:	10db      	asrs	r3, r3, #3
   1bcde:	9305      	str	r3, [sp, #20]
   1bce0:	3301      	adds	r3, #1
   1bce2:	00db      	lsls	r3, r3, #3
   1bce4:	930a      	str	r3, [sp, #40]	; 0x28
   1bce6:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   1bcea:	1a9b      	subs	r3, r3, r2
   1bcec:	9304      	str	r3, [sp, #16]
   1bcee:	9a05      	ldr	r2, [sp, #20]
   1bcf0:	9b01      	ldr	r3, [sp, #4]
   1bcf2:	1ad6      	subs	r6, r2, r3
   1bcf4:	9a03      	ldr	r2, [sp, #12]
   1bcf6:	eb12 0803 	adds.w	r8, r2, r3
   1bcfa:	d418      	bmi.n	1bd2e <__kernel_rem_pio2f+0x7e>
   1bcfc:	f108 0801 	add.w	r8, r8, #1
   1bd00:	f8dd 919c 	ldr.w	r9, [sp, #412]	; 0x19c
   1bd04:	44b0      	add	r8, r6
   1bd06:	2400      	movs	r4, #0
   1bd08:	af20      	add	r7, sp, #128	; 0x80
   1bd0a:	e008      	b.n	1bd1e <__kernel_rem_pio2f+0x6e>
   1bd0c:	f859 0026 	ldr.w	r0, [r9, r6, lsl #2]
   1bd10:	f001 f9d2 	bl	1d0b8 <__aeabi_i2f>
   1bd14:	3601      	adds	r6, #1
   1bd16:	4546      	cmp	r6, r8
   1bd18:	f847 0b04 	str.w	r0, [r7], #4
   1bd1c:	d007      	beq.n	1bd2e <__kernel_rem_pio2f+0x7e>
   1bd1e:	2e00      	cmp	r6, #0
   1bd20:	daf4      	bge.n	1bd0c <__kernel_rem_pio2f+0x5c>
   1bd22:	3601      	adds	r6, #1
   1bd24:	4620      	mov	r0, r4
   1bd26:	4546      	cmp	r6, r8
   1bd28:	f847 0b04 	str.w	r0, [r7], #4
   1bd2c:	d1f7      	bne.n	1bd1e <__kernel_rem_pio2f+0x6e>
   1bd2e:	9b03      	ldr	r3, [sp, #12]
   1bd30:	2b00      	cmp	r3, #0
   1bd32:	f2c0 8311 	blt.w	1c358 <__kernel_rem_pio2f+0x6a8>
   1bd36:	9b06      	ldr	r3, [sp, #24]
   1bd38:	9e01      	ldr	r6, [sp, #4]
   1bd3a:	aa20      	add	r2, sp, #128	; 0x80
   1bd3c:	eb02 0783 	add.w	r7, r2, r3, lsl #2
   1bd40:	009a      	lsls	r2, r3, #2
   1bd42:	9200      	str	r2, [sp, #0]
   1bd44:	9a03      	ldr	r2, [sp, #12]
   1bd46:	1f29      	subs	r1, r5, #4
   1bd48:	9102      	str	r1, [sp, #8]
   1bd4a:	f50d 7890 	add.w	r8, sp, #288	; 0x120
   1bd4e:	eb02 0903 	add.w	r9, r2, r3
   1bd52:	eb01 0583 	add.w	r5, r1, r3, lsl #2
   1bd56:	9b01      	ldr	r3, [sp, #4]
   1bd58:	2b00      	cmp	r3, #0
   1bd5a:	bfb8      	it	lt
   1bd5c:	2400      	movlt	r4, #0
   1bd5e:	db10      	blt.n	1bd82 <__kernel_rem_pio2f+0xd2>
   1bd60:	f8dd a008 	ldr.w	sl, [sp, #8]
   1bd64:	46bb      	mov	fp, r7
   1bd66:	2400      	movs	r4, #0
   1bd68:	f85b 1d04 	ldr.w	r1, [fp, #-4]!
   1bd6c:	f85a 0f04 	ldr.w	r0, [sl, #4]!
   1bd70:	f001 f9f6 	bl	1d160 <__aeabi_fmul>
   1bd74:	4601      	mov	r1, r0
   1bd76:	4620      	mov	r0, r4
   1bd78:	f001 f8ea 	bl	1cf50 <__addsf3>
   1bd7c:	45aa      	cmp	sl, r5
   1bd7e:	4604      	mov	r4, r0
   1bd80:	d1f2      	bne.n	1bd68 <__kernel_rem_pio2f+0xb8>
   1bd82:	3601      	adds	r6, #1
   1bd84:	454e      	cmp	r6, r9
   1bd86:	f848 4b04 	str.w	r4, [r8], #4
   1bd8a:	f107 0704 	add.w	r7, r7, #4
   1bd8e:	d1e2      	bne.n	1bd56 <__kernel_rem_pio2f+0xa6>
   1bd90:	9b02      	ldr	r3, [sp, #8]
   1bd92:	9d00      	ldr	r5, [sp, #0]
   1bd94:	9a03      	ldr	r2, [sp, #12]
   1bd96:	441d      	add	r5, r3
   1bd98:	ab0c      	add	r3, sp, #48	; 0x30
   1bd9a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1bd9e:	3b04      	subs	r3, #4
   1bda0:	9307      	str	r3, [sp, #28]
   1bda2:	ab0c      	add	r3, sp, #48	; 0x30
   1bda4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1bda8:	9308      	str	r3, [sp, #32]
   1bdaa:	4690      	mov	r8, r2
   1bdac:	ab5c      	add	r3, sp, #368	; 0x170
   1bdae:	eb03 0388 	add.w	r3, r3, r8, lsl #2
   1bdb2:	f1b8 0f00 	cmp.w	r8, #0
   1bdb6:	f853 ac50 	ldr.w	sl, [r3, #-80]
   1bdba:	ea4f 0988 	mov.w	r9, r8, lsl #2
   1bdbe:	dd21      	ble.n	1be04 <__kernel_rem_pio2f+0x154>
   1bdc0:	af48      	add	r7, sp, #288	; 0x120
   1bdc2:	eb07 0488 	add.w	r4, r7, r8, lsl #2
   1bdc6:	ae0c      	add	r6, sp, #48	; 0x30
   1bdc8:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
   1bdcc:	4650      	mov	r0, sl
   1bdce:	f001 f9c7 	bl	1d160 <__aeabi_fmul>
   1bdd2:	f001 fba1 	bl	1d518 <__aeabi_f2iz>
   1bdd6:	f001 f96f 	bl	1d0b8 <__aeabi_i2f>
   1bdda:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
   1bdde:	4683      	mov	fp, r0
   1bde0:	f001 f9be 	bl	1d160 <__aeabi_fmul>
   1bde4:	4601      	mov	r1, r0
   1bde6:	4650      	mov	r0, sl
   1bde8:	f001 f8b0 	bl	1cf4c <__aeabi_fsub>
   1bdec:	f001 fb94 	bl	1d518 <__aeabi_f2iz>
   1bdf0:	f854 1d04 	ldr.w	r1, [r4, #-4]!
   1bdf4:	f846 0b04 	str.w	r0, [r6], #4
   1bdf8:	4658      	mov	r0, fp
   1bdfa:	f001 f8a9 	bl	1cf50 <__addsf3>
   1bdfe:	42bc      	cmp	r4, r7
   1be00:	4682      	mov	sl, r0
   1be02:	d1e1      	bne.n	1bdc8 <__kernel_rem_pio2f+0x118>
   1be04:	9e04      	ldr	r6, [sp, #16]
   1be06:	4650      	mov	r0, sl
   1be08:	4631      	mov	r1, r6
   1be0a:	f000 fbff 	bl	1c60c <scalbnf>
   1be0e:	f04f 5178 	mov.w	r1, #1040187392	; 0x3e000000
   1be12:	4604      	mov	r4, r0
   1be14:	f001 f9a4 	bl	1d160 <__aeabi_fmul>
   1be18:	f7ff fed6 	bl	1bbc8 <floorf>
   1be1c:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
   1be20:	f001 f99e 	bl	1d160 <__aeabi_fmul>
   1be24:	4601      	mov	r1, r0
   1be26:	4620      	mov	r0, r4
   1be28:	f001 f890 	bl	1cf4c <__aeabi_fsub>
   1be2c:	4604      	mov	r4, r0
   1be2e:	f001 fb73 	bl	1d518 <__aeabi_f2iz>
   1be32:	4682      	mov	sl, r0
   1be34:	f001 f940 	bl	1d0b8 <__aeabi_i2f>
   1be38:	4601      	mov	r1, r0
   1be3a:	4620      	mov	r0, r4
   1be3c:	f001 f886 	bl	1cf4c <__aeabi_fsub>
   1be40:	2e00      	cmp	r6, #0
   1be42:	4604      	mov	r4, r0
   1be44:	4631      	mov	r1, r6
   1be46:	f340 8089 	ble.w	1bf5c <__kernel_rem_pio2f+0x2ac>
   1be4a:	f108 36ff 	add.w	r6, r8, #4294967295	; 0xffffffff
   1be4e:	aa0c      	add	r2, sp, #48	; 0x30
   1be50:	f1c1 0308 	rsb	r3, r1, #8
   1be54:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
   1be58:	fa42 f003 	asr.w	r0, r2, r3
   1be5c:	fa00 f303 	lsl.w	r3, r0, r3
   1be60:	1ad2      	subs	r2, r2, r3
   1be62:	f1c1 0107 	rsb	r1, r1, #7
   1be66:	ab0c      	add	r3, sp, #48	; 0x30
   1be68:	fa42 f701 	asr.w	r7, r2, r1
   1be6c:	2f00      	cmp	r7, #0
   1be6e:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   1be72:	4482      	add	sl, r0
   1be74:	dc7c      	bgt.n	1bf70 <__kernel_rem_pio2f+0x2c0>
   1be76:	2100      	movs	r1, #0
   1be78:	4620      	mov	r0, r4
   1be7a:	f001 fb05 	bl	1d488 <__aeabi_fcmpeq>
   1be7e:	2800      	cmp	r0, #0
   1be80:	f000 80d3 	beq.w	1c02a <__kernel_rem_pio2f+0x37a>
   1be84:	9b03      	ldr	r3, [sp, #12]
   1be86:	f108 34ff 	add.w	r4, r8, #4294967295	; 0xffffffff
   1be8a:	42a3      	cmp	r3, r4
   1be8c:	f108 4080 	add.w	r0, r8, #1073741824	; 0x40000000
   1be90:	dc10      	bgt.n	1beb4 <__kernel_rem_pio2f+0x204>
   1be92:	ab0c      	add	r3, sp, #48	; 0x30
   1be94:	f8dd c020 	ldr.w	ip, [sp, #32]
   1be98:	ea4f 0688 	mov.w	r6, r8, lsl #2
   1be9c:	eb03 0388 	add.w	r3, r3, r8, lsl #2
   1bea0:	2200      	movs	r2, #0
   1bea2:	f853 1d04 	ldr.w	r1, [r3, #-4]!
   1bea6:	4563      	cmp	r3, ip
   1bea8:	ea42 0201 	orr.w	r2, r2, r1
   1beac:	d1f9      	bne.n	1bea2 <__kernel_rem_pio2f+0x1f2>
   1beae:	2a00      	cmp	r2, #0
   1beb0:	f040 8111 	bne.w	1c0d6 <__kernel_rem_pio2f+0x426>
   1beb4:	9b03      	ldr	r3, [sp, #12]
   1beb6:	aa0c      	add	r2, sp, #48	; 0x30
   1beb8:	3b01      	subs	r3, #1
   1beba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1bebe:	2b00      	cmp	r3, #0
   1bec0:	f040 8105 	bne.w	1c0ce <__kernel_rem_pio2f+0x41e>
   1bec4:	9b07      	ldr	r3, [sp, #28]
   1bec6:	2601      	movs	r6, #1
   1bec8:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   1becc:	3601      	adds	r6, #1
   1bece:	2a00      	cmp	r2, #0
   1bed0:	d0fa      	beq.n	1bec8 <__kernel_rem_pio2f+0x218>
   1bed2:	eb08 0306 	add.w	r3, r8, r6
   1bed6:	9300      	str	r3, [sp, #0]
   1bed8:	f108 0701 	add.w	r7, r8, #1
   1bedc:	9a05      	ldr	r2, [sp, #20]
   1bede:	eb02 0907 	add.w	r9, r2, r7
   1bee2:	9a06      	ldr	r2, [sp, #24]
   1bee4:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
   1bee8:	4499      	add	r9, r3
   1beea:	4413      	add	r3, r2
   1beec:	9a67      	ldr	r2, [sp, #412]	; 0x19c
   1beee:	4443      	add	r3, r8
   1bef0:	eb02 0989 	add.w	r9, r2, r9, lsl #2
   1bef4:	aa20      	add	r2, sp, #128	; 0x80
   1bef6:	eb02 0883 	add.w	r8, r2, r3, lsl #2
   1befa:	ab48      	add	r3, sp, #288	; 0x120
   1befc:	eb03 0a80 	add.w	sl, r3, r0, lsl #2
   1bf00:	f859 0f04 	ldr.w	r0, [r9, #4]!
   1bf04:	f001 f8d8 	bl	1d0b8 <__aeabi_i2f>
   1bf08:	9b01      	ldr	r3, [sp, #4]
   1bf0a:	f848 0f04 	str.w	r0, [r8, #4]!
   1bf0e:	2b00      	cmp	r3, #0
   1bf10:	db19      	blt.n	1bf46 <__kernel_rem_pio2f+0x296>
   1bf12:	f8dd b008 	ldr.w	fp, [sp, #8]
   1bf16:	4644      	mov	r4, r8
   1bf18:	2600      	movs	r6, #0
   1bf1a:	e001      	b.n	1bf20 <__kernel_rem_pio2f+0x270>
   1bf1c:	f854 0d04 	ldr.w	r0, [r4, #-4]!
   1bf20:	f85b 1f04 	ldr.w	r1, [fp, #4]!
   1bf24:	f001 f91c 	bl	1d160 <__aeabi_fmul>
   1bf28:	4601      	mov	r1, r0
   1bf2a:	4630      	mov	r0, r6
   1bf2c:	f001 f810 	bl	1cf50 <__addsf3>
   1bf30:	45ab      	cmp	fp, r5
   1bf32:	4606      	mov	r6, r0
   1bf34:	d1f2      	bne.n	1bf1c <__kernel_rem_pio2f+0x26c>
   1bf36:	9b00      	ldr	r3, [sp, #0]
   1bf38:	f84a 6f04 	str.w	r6, [sl, #4]!
   1bf3c:	3701      	adds	r7, #1
   1bf3e:	429f      	cmp	r7, r3
   1bf40:	ddde      	ble.n	1bf00 <__kernel_rem_pio2f+0x250>
   1bf42:	4698      	mov	r8, r3
   1bf44:	e732      	b.n	1bdac <__kernel_rem_pio2f+0xfc>
   1bf46:	9b00      	ldr	r3, [sp, #0]
   1bf48:	3701      	adds	r7, #1
   1bf4a:	2600      	movs	r6, #0
   1bf4c:	429f      	cmp	r7, r3
   1bf4e:	f84a 6f04 	str.w	r6, [sl, #4]!
   1bf52:	ddd5      	ble.n	1bf00 <__kernel_rem_pio2f+0x250>
   1bf54:	e7f5      	b.n	1bf42 <__kernel_rem_pio2f+0x292>
   1bf56:	bf00      	nop
   1bf58:	00028050 	.word	0x00028050
   1bf5c:	f040 809f 	bne.w	1c09e <__kernel_rem_pio2f+0x3ee>
   1bf60:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   1bf64:	aa0c      	add	r2, sp, #48	; 0x30
   1bf66:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
   1bf6a:	11ff      	asrs	r7, r7, #7
   1bf6c:	2f00      	cmp	r7, #0
   1bf6e:	dd82      	ble.n	1be76 <__kernel_rem_pio2f+0x1c6>
   1bf70:	f1b8 0f00 	cmp.w	r8, #0
   1bf74:	f10a 0a01 	add.w	sl, sl, #1
   1bf78:	f340 819e 	ble.w	1c2b8 <__kernel_rem_pio2f+0x608>
   1bf7c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   1bf7e:	2e00      	cmp	r6, #0
   1bf80:	f040 8085 	bne.w	1c08e <__kernel_rem_pio2f+0x3de>
   1bf84:	f1b8 0f01 	cmp.w	r8, #1
   1bf88:	d020      	beq.n	1bfcc <__kernel_rem_pio2f+0x31c>
   1bf8a:	ab0c      	add	r3, sp, #48	; 0x30
   1bf8c:	2201      	movs	r2, #1
   1bf8e:	f853 6f04 	ldr.w	r6, [r3, #4]!
   1bf92:	2e00      	cmp	r6, #0
   1bf94:	d07e      	beq.n	1c094 <__kernel_rem_pio2f+0x3e4>
   1bf96:	1c53      	adds	r3, r2, #1
   1bf98:	a90c      	add	r1, sp, #48	; 0x30
   1bf9a:	f5c6 7680 	rsb	r6, r6, #256	; 0x100
   1bf9e:	4598      	cmp	r8, r3
   1bfa0:	f841 6022 	str.w	r6, [r1, r2, lsl #2]
   1bfa4:	dd11      	ble.n	1bfca <__kernel_rem_pio2f+0x31a>
   1bfa6:	f109 0230 	add.w	r2, r9, #48	; 0x30
   1bfaa:	eb0d 0102 	add.w	r1, sp, r2
   1bfae:	aa0c      	add	r2, sp, #48	; 0x30
   1bfb0:	a80c      	add	r0, sp, #48	; 0x30
   1bfb2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   1bfb6:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   1bfba:	e000      	b.n	1bfbe <__kernel_rem_pio2f+0x30e>
   1bfbc:	681a      	ldr	r2, [r3, #0]
   1bfbe:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
   1bfc2:	f843 2b04 	str.w	r2, [r3], #4
   1bfc6:	428b      	cmp	r3, r1
   1bfc8:	d1f8      	bne.n	1bfbc <__kernel_rem_pio2f+0x30c>
   1bfca:	2601      	movs	r6, #1
   1bfcc:	9b04      	ldr	r3, [sp, #16]
   1bfce:	2b00      	cmp	r3, #0
   1bfd0:	dd0e      	ble.n	1bff0 <__kernel_rem_pio2f+0x340>
   1bfd2:	2b01      	cmp	r3, #1
   1bfd4:	f000 8160 	beq.w	1c298 <__kernel_rem_pio2f+0x5e8>
   1bfd8:	2b02      	cmp	r3, #2
   1bfda:	d109      	bne.n	1bff0 <__kernel_rem_pio2f+0x340>
   1bfdc:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
   1bfe0:	ab0c      	add	r3, sp, #48	; 0x30
   1bfe2:	a90c      	add	r1, sp, #48	; 0x30
   1bfe4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1bfe8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1bfec:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
   1bff0:	2f02      	cmp	r7, #2
   1bff2:	f47f af40 	bne.w	1be76 <__kernel_rem_pio2f+0x1c6>
   1bff6:	4621      	mov	r1, r4
   1bff8:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   1bffc:	f000 ffa6 	bl	1cf4c <__aeabi_fsub>
   1c000:	4604      	mov	r4, r0
   1c002:	2e00      	cmp	r6, #0
   1c004:	f43f af37 	beq.w	1be76 <__kernel_rem_pio2f+0x1c6>
   1c008:	9904      	ldr	r1, [sp, #16]
   1c00a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   1c00e:	f000 fafd 	bl	1c60c <scalbnf>
   1c012:	4601      	mov	r1, r0
   1c014:	4620      	mov	r0, r4
   1c016:	f000 ff99 	bl	1cf4c <__aeabi_fsub>
   1c01a:	4604      	mov	r4, r0
   1c01c:	2100      	movs	r1, #0
   1c01e:	4620      	mov	r0, r4
   1c020:	f001 fa32 	bl	1d488 <__aeabi_fcmpeq>
   1c024:	2800      	cmp	r0, #0
   1c026:	f47f af2d 	bne.w	1be84 <__kernel_rem_pio2f+0x1d4>
   1c02a:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	; 0x28
   1c02e:	4620      	mov	r0, r4
   1c030:	1a99      	subs	r1, r3, r2
   1c032:	9700      	str	r7, [sp, #0]
   1c034:	f000 faea 	bl	1c60c <scalbnf>
   1c038:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
   1c03c:	4604      	mov	r4, r0
   1c03e:	f001 fa41 	bl	1d4c4 <__aeabi_fcmpge>
   1c042:	2800      	cmp	r0, #0
   1c044:	f000 8164 	beq.w	1c310 <__kernel_rem_pio2f+0x660>
   1c048:	9b04      	ldr	r3, [sp, #16]
   1c04a:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
   1c04e:	3308      	adds	r3, #8
   1c050:	4620      	mov	r0, r4
   1c052:	9304      	str	r3, [sp, #16]
   1c054:	f001 f884 	bl	1d160 <__aeabi_fmul>
   1c058:	f001 fa5e 	bl	1d518 <__aeabi_f2iz>
   1c05c:	f001 f82c 	bl	1d0b8 <__aeabi_i2f>
   1c060:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
   1c064:	4605      	mov	r5, r0
   1c066:	f001 f87b 	bl	1d160 <__aeabi_fmul>
   1c06a:	4601      	mov	r1, r0
   1c06c:	4620      	mov	r0, r4
   1c06e:	f000 ff6d 	bl	1cf4c <__aeabi_fsub>
   1c072:	f001 fa51 	bl	1d518 <__aeabi_f2iz>
   1c076:	ab0c      	add	r3, sp, #48	; 0x30
   1c078:	f108 0401 	add.w	r4, r8, #1
   1c07c:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
   1c080:	4628      	mov	r0, r5
   1c082:	f001 fa49 	bl	1d518 <__aeabi_f2iz>
   1c086:	ab0c      	add	r3, sp, #48	; 0x30
   1c088:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
   1c08c:	e036      	b.n	1c0fc <__kernel_rem_pio2f+0x44c>
   1c08e:	2301      	movs	r3, #1
   1c090:	2200      	movs	r2, #0
   1c092:	e781      	b.n	1bf98 <__kernel_rem_pio2f+0x2e8>
   1c094:	3201      	adds	r2, #1
   1c096:	4542      	cmp	r2, r8
   1c098:	f47f af79 	bne.w	1bf8e <__kernel_rem_pio2f+0x2de>
   1c09c:	e796      	b.n	1bfcc <__kernel_rem_pio2f+0x31c>
   1c09e:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   1c0a2:	f001 fa0f 	bl	1d4c4 <__aeabi_fcmpge>
   1c0a6:	4607      	mov	r7, r0
   1c0a8:	2800      	cmp	r0, #0
   1c0aa:	f43f aee4 	beq.w	1be76 <__kernel_rem_pio2f+0x1c6>
   1c0ae:	f1b8 0f00 	cmp.w	r8, #0
   1c0b2:	f10a 0a01 	add.w	sl, sl, #1
   1c0b6:	bfc8      	it	gt
   1c0b8:	2702      	movgt	r7, #2
   1c0ba:	f73f af5f 	bgt.w	1bf7c <__kernel_rem_pio2f+0x2cc>
   1c0be:	4621      	mov	r1, r4
   1c0c0:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   1c0c4:	f000 ff42 	bl	1cf4c <__aeabi_fsub>
   1c0c8:	2702      	movs	r7, #2
   1c0ca:	4604      	mov	r4, r0
   1c0cc:	e6d3      	b.n	1be76 <__kernel_rem_pio2f+0x1c6>
   1c0ce:	f108 0701 	add.w	r7, r8, #1
   1c0d2:	9700      	str	r7, [sp, #0]
   1c0d4:	e702      	b.n	1bedc <__kernel_rem_pio2f+0x22c>
   1c0d6:	9b04      	ldr	r3, [sp, #16]
   1c0d8:	9700      	str	r7, [sp, #0]
   1c0da:	f1a3 0208 	sub.w	r2, r3, #8
   1c0de:	ab0c      	add	r3, sp, #48	; 0x30
   1c0e0:	9204      	str	r2, [sp, #16]
   1c0e2:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   1c0e6:	b94b      	cbnz	r3, 1c0fc <__kernel_rem_pio2f+0x44c>
   1c0e8:	1f33      	subs	r3, r6, #4
   1c0ea:	a90c      	add	r1, sp, #48	; 0x30
   1c0ec:	440b      	add	r3, r1
   1c0ee:	f853 1d04 	ldr.w	r1, [r3, #-4]!
   1c0f2:	3c01      	subs	r4, #1
   1c0f4:	3a08      	subs	r2, #8
   1c0f6:	2900      	cmp	r1, #0
   1c0f8:	d0f9      	beq.n	1c0ee <__kernel_rem_pio2f+0x43e>
   1c0fa:	9204      	str	r2, [sp, #16]
   1c0fc:	9904      	ldr	r1, [sp, #16]
   1c0fe:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
   1c102:	f000 fa83 	bl	1c60c <scalbnf>
   1c106:	2c00      	cmp	r4, #0
   1c108:	4607      	mov	r7, r0
   1c10a:	f2c0 812b 	blt.w	1c364 <__kernel_rem_pio2f+0x6b4>
   1c10e:	1c63      	adds	r3, r4, #1
   1c110:	009a      	lsls	r2, r3, #2
   1c112:	9201      	str	r2, [sp, #4]
   1c114:	aa0c      	add	r2, sp, #48	; 0x30
   1c116:	eb02 0883 	add.w	r8, r2, r3, lsl #2
   1c11a:	aa48      	add	r2, sp, #288	; 0x120
   1c11c:	9302      	str	r3, [sp, #8]
   1c11e:	f04f 566e 	mov.w	r6, #998244352	; 0x3b800000
   1c122:	eb02 0583 	add.w	r5, r2, r3, lsl #2
   1c126:	f858 0d04 	ldr.w	r0, [r8, #-4]!
   1c12a:	f000 ffc5 	bl	1d0b8 <__aeabi_i2f>
   1c12e:	4639      	mov	r1, r7
   1c130:	f001 f816 	bl	1d160 <__aeabi_fmul>
   1c134:	4631      	mov	r1, r6
   1c136:	f845 0d04 	str.w	r0, [r5, #-4]!
   1c13a:	4638      	mov	r0, r7
   1c13c:	f001 f810 	bl	1d160 <__aeabi_fmul>
   1c140:	ab0c      	add	r3, sp, #48	; 0x30
   1c142:	4598      	cmp	r8, r3
   1c144:	4607      	mov	r7, r0
   1c146:	d1ee      	bne.n	1c126 <__kernel_rem_pio2f+0x476>
   1c148:	9b01      	ldr	r3, [sp, #4]
   1c14a:	f8dd 900c 	ldr.w	r9, [sp, #12]
   1c14e:	f8cd a010 	str.w	sl, [sp, #16]
   1c152:	3b08      	subs	r3, #8
   1c154:	aa48      	add	r2, sp, #288	; 0x120
   1c156:	eb02 0803 	add.w	r8, r2, r3
   1c15a:	2700      	movs	r7, #0
   1c15c:	46a3      	mov	fp, r4
   1c15e:	f1b9 0f00 	cmp.w	r9, #0
   1c162:	bfb8      	it	lt
   1c164:	2500      	movlt	r5, #0
   1c166:	db15      	blt.n	1c194 <__kernel_rem_pio2f+0x4e4>
   1c168:	4c87      	ldr	r4, [pc, #540]	; (1c388 <__kernel_rem_pio2f+0x6d8>)
   1c16a:	4888      	ldr	r0, [pc, #544]	; (1c38c <__kernel_rem_pio2f+0x6dc>)
   1c16c:	46c2      	mov	sl, r8
   1c16e:	2500      	movs	r5, #0
   1c170:	2600      	movs	r6, #0
   1c172:	e003      	b.n	1c17c <__kernel_rem_pio2f+0x4cc>
   1c174:	42b7      	cmp	r7, r6
   1c176:	db0d      	blt.n	1c194 <__kernel_rem_pio2f+0x4e4>
   1c178:	f854 0f04 	ldr.w	r0, [r4, #4]!
   1c17c:	f85a 1f04 	ldr.w	r1, [sl, #4]!
   1c180:	f000 ffee 	bl	1d160 <__aeabi_fmul>
   1c184:	4601      	mov	r1, r0
   1c186:	4628      	mov	r0, r5
   1c188:	f000 fee2 	bl	1cf50 <__addsf3>
   1c18c:	3601      	adds	r6, #1
   1c18e:	45b1      	cmp	r9, r6
   1c190:	4605      	mov	r5, r0
   1c192:	daef      	bge.n	1c174 <__kernel_rem_pio2f+0x4c4>
   1c194:	ab5c      	add	r3, sp, #368	; 0x170
   1c196:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   1c19a:	455f      	cmp	r7, fp
   1c19c:	f843 5ca0 	str.w	r5, [r3, #-160]
   1c1a0:	f1a8 0804 	sub.w	r8, r8, #4
   1c1a4:	ea4f 0687 	mov.w	r6, r7, lsl #2
   1c1a8:	f107 0301 	add.w	r3, r7, #1
   1c1ac:	d001      	beq.n	1c1b2 <__kernel_rem_pio2f+0x502>
   1c1ae:	461f      	mov	r7, r3
   1c1b0:	e7d5      	b.n	1c15e <__kernel_rem_pio2f+0x4ae>
   1c1b2:	9b66      	ldr	r3, [sp, #408]	; 0x198
   1c1b4:	f8dd a010 	ldr.w	sl, [sp, #16]
   1c1b8:	2b02      	cmp	r3, #2
   1c1ba:	465c      	mov	r4, fp
   1c1bc:	dc17      	bgt.n	1c1ee <__kernel_rem_pio2f+0x53e>
   1c1be:	2b00      	cmp	r3, #0
   1c1c0:	dc7c      	bgt.n	1c2bc <__kernel_rem_pio2f+0x60c>
   1c1c2:	d10f      	bne.n	1c1e4 <__kernel_rem_pio2f+0x534>
   1c1c4:	9c01      	ldr	r4, [sp, #4]
   1c1c6:	ad34      	add	r5, sp, #208	; 0xd0
   1c1c8:	442c      	add	r4, r5
   1c1ca:	2000      	movs	r0, #0
   1c1cc:	f854 1d04 	ldr.w	r1, [r4, #-4]!
   1c1d0:	f000 febe 	bl	1cf50 <__addsf3>
   1c1d4:	42a5      	cmp	r5, r4
   1c1d6:	d1f9      	bne.n	1c1cc <__kernel_rem_pio2f+0x51c>
   1c1d8:	9b00      	ldr	r3, [sp, #0]
   1c1da:	b10b      	cbz	r3, 1c1e0 <__kernel_rem_pio2f+0x530>
   1c1dc:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   1c1e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1c1e2:	6018      	str	r0, [r3, #0]
   1c1e4:	f00a 0007 	and.w	r0, sl, #7
   1c1e8:	b05d      	add	sp, #372	; 0x174
   1c1ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c1ee:	9b66      	ldr	r3, [sp, #408]	; 0x198
   1c1f0:	2b03      	cmp	r3, #3
   1c1f2:	d1f7      	bne.n	1c1e4 <__kernel_rem_pio2f+0x534>
   1c1f4:	2c00      	cmp	r4, #0
   1c1f6:	f000 80c2 	beq.w	1c37e <__kernel_rem_pio2f+0x6ce>
   1c1fa:	af34      	add	r7, sp, #208	; 0xd0
   1c1fc:	eb07 0806 	add.w	r8, r7, r6
   1c200:	f858 bc04 	ldr.w	fp, [r8, #-4]
   1c204:	4628      	mov	r0, r5
   1c206:	4659      	mov	r1, fp
   1c208:	f000 fea2 	bl	1cf50 <__addsf3>
   1c20c:	46a9      	mov	r9, r5
   1c20e:	4605      	mov	r5, r0
   1c210:	4629      	mov	r1, r5
   1c212:	4658      	mov	r0, fp
   1c214:	f000 fe9a 	bl	1cf4c <__aeabi_fsub>
   1c218:	4649      	mov	r1, r9
   1c21a:	f000 fe99 	bl	1cf50 <__addsf3>
   1c21e:	f8c8 0000 	str.w	r0, [r8]
   1c222:	f848 5d04 	str.w	r5, [r8, #-4]!
   1c226:	4547      	cmp	r7, r8
   1c228:	d1ea      	bne.n	1c200 <__kernel_rem_pio2f+0x550>
   1c22a:	2c01      	cmp	r4, #1
   1c22c:	f340 80a7 	ble.w	1c37e <__kernel_rem_pio2f+0x6ce>
   1c230:	f506 73b8 	add.w	r3, r6, #368	; 0x170
   1c234:	446b      	add	r3, sp
   1c236:	19bd      	adds	r5, r7, r6
   1c238:	f853 4ca0 	ldr.w	r4, [r3, #-160]
   1c23c:	f10d 08d4 	add.w	r8, sp, #212	; 0xd4
   1c240:	f855 bc04 	ldr.w	fp, [r5, #-4]
   1c244:	4620      	mov	r0, r4
   1c246:	4659      	mov	r1, fp
   1c248:	f000 fe82 	bl	1cf50 <__addsf3>
   1c24c:	46a1      	mov	r9, r4
   1c24e:	4604      	mov	r4, r0
   1c250:	4621      	mov	r1, r4
   1c252:	4658      	mov	r0, fp
   1c254:	f000 fe7a 	bl	1cf4c <__aeabi_fsub>
   1c258:	4649      	mov	r1, r9
   1c25a:	f000 fe79 	bl	1cf50 <__addsf3>
   1c25e:	6028      	str	r0, [r5, #0]
   1c260:	f845 4d04 	str.w	r4, [r5, #-4]!
   1c264:	45a8      	cmp	r8, r5
   1c266:	d1eb      	bne.n	1c240 <__kernel_rem_pio2f+0x590>
   1c268:	1d34      	adds	r4, r6, #4
   1c26a:	443c      	add	r4, r7
   1c26c:	2000      	movs	r0, #0
   1c26e:	3708      	adds	r7, #8
   1c270:	f854 1d04 	ldr.w	r1, [r4, #-4]!
   1c274:	f000 fe6c 	bl	1cf50 <__addsf3>
   1c278:	42a7      	cmp	r7, r4
   1c27a:	d1f9      	bne.n	1c270 <__kernel_rem_pio2f+0x5c0>
   1c27c:	9b00      	ldr	r3, [sp, #0]
   1c27e:	2b00      	cmp	r3, #0
   1c280:	d14e      	bne.n	1c320 <__kernel_rem_pio2f+0x670>
   1c282:	9909      	ldr	r1, [sp, #36]	; 0x24
   1c284:	9a34      	ldr	r2, [sp, #208]	; 0xd0
   1c286:	9b35      	ldr	r3, [sp, #212]	; 0xd4
   1c288:	6088      	str	r0, [r1, #8]
   1c28a:	f00a 0007 	and.w	r0, sl, #7
   1c28e:	600a      	str	r2, [r1, #0]
   1c290:	604b      	str	r3, [r1, #4]
   1c292:	b05d      	add	sp, #372	; 0x174
   1c294:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c298:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
   1c29c:	ab0c      	add	r3, sp, #48	; 0x30
   1c29e:	a90c      	add	r1, sp, #48	; 0x30
   1c2a0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1c2a4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1c2a8:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
   1c2ac:	e6a0      	b.n	1bff0 <__kernel_rem_pio2f+0x340>
   1c2ae:	2308      	movs	r3, #8
   1c2b0:	930a      	str	r3, [sp, #40]	; 0x28
   1c2b2:	2300      	movs	r3, #0
   1c2b4:	9305      	str	r3, [sp, #20]
   1c2b6:	e516      	b.n	1bce6 <__kernel_rem_pio2f+0x36>
   1c2b8:	2600      	movs	r6, #0
   1c2ba:	e687      	b.n	1bfcc <__kernel_rem_pio2f+0x31c>
   1c2bc:	9b02      	ldr	r3, [sp, #8]
   1c2be:	ad34      	add	r5, sp, #208	; 0xd0
   1c2c0:	eb05 0683 	add.w	r6, r5, r3, lsl #2
   1c2c4:	2000      	movs	r0, #0
   1c2c6:	f856 1d04 	ldr.w	r1, [r6, #-4]!
   1c2ca:	f000 fe41 	bl	1cf50 <__addsf3>
   1c2ce:	42b5      	cmp	r5, r6
   1c2d0:	d1f9      	bne.n	1c2c6 <__kernel_rem_pio2f+0x616>
   1c2d2:	9b00      	ldr	r3, [sp, #0]
   1c2d4:	2b00      	cmp	r3, #0
   1c2d6:	d134      	bne.n	1c342 <__kernel_rem_pio2f+0x692>
   1c2d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1c2da:	4601      	mov	r1, r0
   1c2dc:	6018      	str	r0, [r3, #0]
   1c2de:	9834      	ldr	r0, [sp, #208]	; 0xd0
   1c2e0:	f000 fe34 	bl	1cf4c <__aeabi_fsub>
   1c2e4:	2c00      	cmp	r4, #0
   1c2e6:	dd0c      	ble.n	1c302 <__kernel_rem_pio2f+0x652>
   1c2e8:	ae34      	add	r6, sp, #208	; 0xd0
   1c2ea:	2501      	movs	r5, #1
   1c2ec:	f856 1f04 	ldr.w	r1, [r6, #4]!
   1c2f0:	3501      	adds	r5, #1
   1c2f2:	f000 fe2d 	bl	1cf50 <__addsf3>
   1c2f6:	42ac      	cmp	r4, r5
   1c2f8:	daf8      	bge.n	1c2ec <__kernel_rem_pio2f+0x63c>
   1c2fa:	9b00      	ldr	r3, [sp, #0]
   1c2fc:	b10b      	cbz	r3, 1c302 <__kernel_rem_pio2f+0x652>
   1c2fe:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   1c302:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1c304:	6058      	str	r0, [r3, #4]
   1c306:	f00a 0007 	and.w	r0, sl, #7
   1c30a:	b05d      	add	sp, #372	; 0x174
   1c30c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c310:	4620      	mov	r0, r4
   1c312:	f001 f901 	bl	1d518 <__aeabi_f2iz>
   1c316:	ab0c      	add	r3, sp, #48	; 0x30
   1c318:	4644      	mov	r4, r8
   1c31a:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
   1c31e:	e6ed      	b.n	1c0fc <__kernel_rem_pio2f+0x44c>
   1c320:	e9dd 2334 	ldrd	r2, r3, [sp, #208]	; 0xd0
   1c324:	9909      	ldr	r1, [sp, #36]	; 0x24
   1c326:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   1c32a:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
   1c32e:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
   1c332:	6088      	str	r0, [r1, #8]
   1c334:	f00a 0007 	and.w	r0, sl, #7
   1c338:	600a      	str	r2, [r1, #0]
   1c33a:	604b      	str	r3, [r1, #4]
   1c33c:	b05d      	add	sp, #372	; 0x174
   1c33e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c342:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1c344:	f100 4300 	add.w	r3, r0, #2147483648	; 0x80000000
   1c348:	4601      	mov	r1, r0
   1c34a:	6013      	str	r3, [r2, #0]
   1c34c:	9834      	ldr	r0, [sp, #208]	; 0xd0
   1c34e:	f000 fdfd 	bl	1cf4c <__aeabi_fsub>
   1c352:	2c00      	cmp	r4, #0
   1c354:	dcc8      	bgt.n	1c2e8 <__kernel_rem_pio2f+0x638>
   1c356:	e7d2      	b.n	1c2fe <__kernel_rem_pio2f+0x64e>
   1c358:	1f2b      	subs	r3, r5, #4
   1c35a:	9302      	str	r3, [sp, #8]
   1c35c:	9b06      	ldr	r3, [sp, #24]
   1c35e:	009b      	lsls	r3, r3, #2
   1c360:	9300      	str	r3, [sp, #0]
   1c362:	e515      	b.n	1bd90 <__kernel_rem_pio2f+0xe0>
   1c364:	9b66      	ldr	r3, [sp, #408]	; 0x198
   1c366:	2b02      	cmp	r3, #2
   1c368:	dc05      	bgt.n	1c376 <__kernel_rem_pio2f+0x6c6>
   1c36a:	2b00      	cmp	r3, #0
   1c36c:	dc09      	bgt.n	1c382 <__kernel_rem_pio2f+0x6d2>
   1c36e:	f47f af39 	bne.w	1c1e4 <__kernel_rem_pio2f+0x534>
   1c372:	2000      	movs	r0, #0
   1c374:	e730      	b.n	1c1d8 <__kernel_rem_pio2f+0x528>
   1c376:	9b66      	ldr	r3, [sp, #408]	; 0x198
   1c378:	2b03      	cmp	r3, #3
   1c37a:	f47f af33 	bne.w	1c1e4 <__kernel_rem_pio2f+0x534>
   1c37e:	2000      	movs	r0, #0
   1c380:	e77c      	b.n	1c27c <__kernel_rem_pio2f+0x5cc>
   1c382:	2000      	movs	r0, #0
   1c384:	e7a5      	b.n	1c2d2 <__kernel_rem_pio2f+0x622>
   1c386:	bf00      	nop
   1c388:	00028024 	.word	0x00028024
   1c38c:	3fc90000 	.word	0x3fc90000

0001c390 <__ieee754_logf>:
   1c390:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
   1c394:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c398:	d02b      	beq.n	1c3f2 <__ieee754_logf+0x62>
   1c39a:	2800      	cmp	r0, #0
   1c39c:	4601      	mov	r1, r0
   1c39e:	4603      	mov	r3, r0
   1c3a0:	db40      	blt.n	1c424 <__ieee754_logf+0x94>
   1c3a2:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
   1c3a6:	da39      	bge.n	1c41c <__ieee754_logf+0x8c>
   1c3a8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   1c3ac:	db41      	blt.n	1c432 <__ieee754_logf+0xa2>
   1c3ae:	2100      	movs	r1, #0
   1c3b0:	4a89      	ldr	r2, [pc, #548]	; (1c5d8 <__ieee754_logf+0x248>)
   1c3b2:	f3c3 0516 	ubfx	r5, r3, #0, #23
   1c3b6:	442a      	add	r2, r5
   1c3b8:	15dc      	asrs	r4, r3, #23
   1c3ba:	f402 0000 	and.w	r0, r2, #8388608	; 0x800000
   1c3be:	3c7f      	subs	r4, #127	; 0x7f
   1c3c0:	f080 507e 	eor.w	r0, r0, #1065353216	; 0x3f800000
   1c3c4:	440c      	add	r4, r1
   1c3c6:	4328      	orrs	r0, r5
   1c3c8:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
   1c3cc:	eb04 54d2 	add.w	r4, r4, r2, lsr #23
   1c3d0:	f000 fdbc 	bl	1cf4c <__aeabi_fsub>
   1c3d4:	4b81      	ldr	r3, [pc, #516]	; (1c5dc <__ieee754_logf+0x24c>)
   1c3d6:	f105 020f 	add.w	r2, r5, #15
   1c3da:	4013      	ands	r3, r2
   1c3dc:	4606      	mov	r6, r0
   1c3de:	bb83      	cbnz	r3, 1c442 <__ieee754_logf+0xb2>
   1c3e0:	2100      	movs	r1, #0
   1c3e2:	f001 f851 	bl	1d488 <__aeabi_fcmpeq>
   1c3e6:	2800      	cmp	r0, #0
   1c3e8:	f000 80a2 	beq.w	1c530 <__ieee754_logf+0x1a0>
   1c3ec:	b944      	cbnz	r4, 1c400 <__ieee754_logf+0x70>
   1c3ee:	2000      	movs	r0, #0
   1c3f0:	e004      	b.n	1c3fc <__ieee754_logf+0x6c>
   1c3f2:	2100      	movs	r1, #0
   1c3f4:	f04f 404c 	mov.w	r0, #3422552064	; 0xcc000000
   1c3f8:	f000 ff66 	bl	1d2c8 <__aeabi_fdiv>
   1c3fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c400:	4620      	mov	r0, r4
   1c402:	f000 fe59 	bl	1d0b8 <__aeabi_i2f>
   1c406:	4976      	ldr	r1, [pc, #472]	; (1c5e0 <__ieee754_logf+0x250>)
   1c408:	4605      	mov	r5, r0
   1c40a:	f000 fea9 	bl	1d160 <__aeabi_fmul>
   1c40e:	4975      	ldr	r1, [pc, #468]	; (1c5e4 <__ieee754_logf+0x254>)
   1c410:	4604      	mov	r4, r0
   1c412:	4628      	mov	r0, r5
   1c414:	f000 fea4 	bl	1d160 <__aeabi_fmul>
   1c418:	4601      	mov	r1, r0
   1c41a:	4620      	mov	r0, r4
   1c41c:	f000 fd98 	bl	1cf50 <__addsf3>
   1c420:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c424:	f000 fd92 	bl	1cf4c <__aeabi_fsub>
   1c428:	2100      	movs	r1, #0
   1c42a:	f000 ff4d 	bl	1d2c8 <__aeabi_fdiv>
   1c42e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c432:	f04f 4198 	mov.w	r1, #1275068416	; 0x4c000000
   1c436:	f000 fe93 	bl	1d160 <__aeabi_fmul>
   1c43a:	f06f 0118 	mvn.w	r1, #24
   1c43e:	4603      	mov	r3, r0
   1c440:	e7b6      	b.n	1c3b0 <__ieee754_logf+0x20>
   1c442:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
   1c446:	f000 fd83 	bl	1cf50 <__addsf3>
   1c44a:	4601      	mov	r1, r0
   1c44c:	4630      	mov	r0, r6
   1c44e:	f000 ff3b 	bl	1d2c8 <__aeabi_fdiv>
   1c452:	4680      	mov	r8, r0
   1c454:	4620      	mov	r0, r4
   1c456:	f000 fe2f 	bl	1d0b8 <__aeabi_i2f>
   1c45a:	4641      	mov	r1, r8
   1c45c:	4681      	mov	r9, r0
   1c45e:	4640      	mov	r0, r8
   1c460:	f000 fe7e 	bl	1d160 <__aeabi_fmul>
   1c464:	4601      	mov	r1, r0
   1c466:	4682      	mov	sl, r0
   1c468:	f000 fe7a 	bl	1d160 <__aeabi_fmul>
   1c46c:	495e      	ldr	r1, [pc, #376]	; (1c5e8 <__ieee754_logf+0x258>)
   1c46e:	4607      	mov	r7, r0
   1c470:	f000 fe76 	bl	1d160 <__aeabi_fmul>
   1c474:	495d      	ldr	r1, [pc, #372]	; (1c5ec <__ieee754_logf+0x25c>)
   1c476:	f000 fd6b 	bl	1cf50 <__addsf3>
   1c47a:	4639      	mov	r1, r7
   1c47c:	f000 fe70 	bl	1d160 <__aeabi_fmul>
   1c480:	495b      	ldr	r1, [pc, #364]	; (1c5f0 <__ieee754_logf+0x260>)
   1c482:	f000 fd65 	bl	1cf50 <__addsf3>
   1c486:	4639      	mov	r1, r7
   1c488:	f000 fe6a 	bl	1d160 <__aeabi_fmul>
   1c48c:	4959      	ldr	r1, [pc, #356]	; (1c5f4 <__ieee754_logf+0x264>)
   1c48e:	f000 fd5f 	bl	1cf50 <__addsf3>
   1c492:	4651      	mov	r1, sl
   1c494:	f000 fe64 	bl	1d160 <__aeabi_fmul>
   1c498:	4957      	ldr	r1, [pc, #348]	; (1c5f8 <__ieee754_logf+0x268>)
   1c49a:	4682      	mov	sl, r0
   1c49c:	4638      	mov	r0, r7
   1c49e:	f000 fe5f 	bl	1d160 <__aeabi_fmul>
   1c4a2:	4956      	ldr	r1, [pc, #344]	; (1c5fc <__ieee754_logf+0x26c>)
   1c4a4:	f000 fd54 	bl	1cf50 <__addsf3>
   1c4a8:	4639      	mov	r1, r7
   1c4aa:	f000 fe59 	bl	1d160 <__aeabi_fmul>
   1c4ae:	4954      	ldr	r1, [pc, #336]	; (1c600 <__ieee754_logf+0x270>)
   1c4b0:	f000 fd4e 	bl	1cf50 <__addsf3>
   1c4b4:	4639      	mov	r1, r7
   1c4b6:	f000 fe53 	bl	1d160 <__aeabi_fmul>
   1c4ba:	4601      	mov	r1, r0
   1c4bc:	4650      	mov	r0, sl
   1c4be:	f000 fd47 	bl	1cf50 <__addsf3>
   1c4c2:	4b50      	ldr	r3, [pc, #320]	; (1c604 <__ieee754_logf+0x274>)
   1c4c4:	442b      	add	r3, r5
   1c4c6:	f5c5 1557 	rsb	r5, r5, #3522560	; 0x35c000
   1c4ca:	f505 7522 	add.w	r5, r5, #648	; 0x288
   1c4ce:	431d      	orrs	r5, r3
   1c4d0:	2d00      	cmp	r5, #0
   1c4d2:	4607      	mov	r7, r0
   1c4d4:	dd4d      	ble.n	1c572 <__ieee754_logf+0x1e2>
   1c4d6:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   1c4da:	4630      	mov	r0, r6
   1c4dc:	f000 fe40 	bl	1d160 <__aeabi_fmul>
   1c4e0:	4631      	mov	r1, r6
   1c4e2:	f000 fe3d 	bl	1d160 <__aeabi_fmul>
   1c4e6:	4605      	mov	r5, r0
   1c4e8:	2c00      	cmp	r4, #0
   1c4ea:	d04f      	beq.n	1c58c <__ieee754_logf+0x1fc>
   1c4ec:	493c      	ldr	r1, [pc, #240]	; (1c5e0 <__ieee754_logf+0x250>)
   1c4ee:	4648      	mov	r0, r9
   1c4f0:	f000 fe36 	bl	1d160 <__aeabi_fmul>
   1c4f4:	4629      	mov	r1, r5
   1c4f6:	4604      	mov	r4, r0
   1c4f8:	4638      	mov	r0, r7
   1c4fa:	f000 fd29 	bl	1cf50 <__addsf3>
   1c4fe:	4641      	mov	r1, r8
   1c500:	f000 fe2e 	bl	1d160 <__aeabi_fmul>
   1c504:	4937      	ldr	r1, [pc, #220]	; (1c5e4 <__ieee754_logf+0x254>)
   1c506:	4607      	mov	r7, r0
   1c508:	4648      	mov	r0, r9
   1c50a:	f000 fe29 	bl	1d160 <__aeabi_fmul>
   1c50e:	4601      	mov	r1, r0
   1c510:	4638      	mov	r0, r7
   1c512:	f000 fd1d 	bl	1cf50 <__addsf3>
   1c516:	4601      	mov	r1, r0
   1c518:	4628      	mov	r0, r5
   1c51a:	f000 fd17 	bl	1cf4c <__aeabi_fsub>
   1c51e:	4631      	mov	r1, r6
   1c520:	f000 fd14 	bl	1cf4c <__aeabi_fsub>
   1c524:	4601      	mov	r1, r0
   1c526:	4620      	mov	r0, r4
   1c528:	f000 fd10 	bl	1cf4c <__aeabi_fsub>
   1c52c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c530:	4935      	ldr	r1, [pc, #212]	; (1c608 <__ieee754_logf+0x278>)
   1c532:	4630      	mov	r0, r6
   1c534:	f000 fe14 	bl	1d160 <__aeabi_fmul>
   1c538:	4601      	mov	r1, r0
   1c53a:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
   1c53e:	f000 fd05 	bl	1cf4c <__aeabi_fsub>
   1c542:	4631      	mov	r1, r6
   1c544:	4605      	mov	r5, r0
   1c546:	4630      	mov	r0, r6
   1c548:	f000 fe0a 	bl	1d160 <__aeabi_fmul>
   1c54c:	4601      	mov	r1, r0
   1c54e:	4628      	mov	r0, r5
   1c550:	f000 fe06 	bl	1d160 <__aeabi_fmul>
   1c554:	4605      	mov	r5, r0
   1c556:	b34c      	cbz	r4, 1c5ac <__ieee754_logf+0x21c>
   1c558:	4620      	mov	r0, r4
   1c55a:	f000 fdad 	bl	1d0b8 <__aeabi_i2f>
   1c55e:	4920      	ldr	r1, [pc, #128]	; (1c5e0 <__ieee754_logf+0x250>)
   1c560:	4607      	mov	r7, r0
   1c562:	f000 fdfd 	bl	1d160 <__aeabi_fmul>
   1c566:	491f      	ldr	r1, [pc, #124]	; (1c5e4 <__ieee754_logf+0x254>)
   1c568:	4604      	mov	r4, r0
   1c56a:	4638      	mov	r0, r7
   1c56c:	f000 fdf8 	bl	1d160 <__aeabi_fmul>
   1c570:	e7d1      	b.n	1c516 <__ieee754_logf+0x186>
   1c572:	bb04      	cbnz	r4, 1c5b6 <__ieee754_logf+0x226>
   1c574:	4601      	mov	r1, r0
   1c576:	4630      	mov	r0, r6
   1c578:	f000 fce8 	bl	1cf4c <__aeabi_fsub>
   1c57c:	4641      	mov	r1, r8
   1c57e:	f000 fdef 	bl	1d160 <__aeabi_fmul>
   1c582:	4601      	mov	r1, r0
   1c584:	4630      	mov	r0, r6
   1c586:	f000 fce1 	bl	1cf4c <__aeabi_fsub>
   1c58a:	e737      	b.n	1c3fc <__ieee754_logf+0x6c>
   1c58c:	4601      	mov	r1, r0
   1c58e:	4638      	mov	r0, r7
   1c590:	f000 fcde 	bl	1cf50 <__addsf3>
   1c594:	4641      	mov	r1, r8
   1c596:	f000 fde3 	bl	1d160 <__aeabi_fmul>
   1c59a:	4601      	mov	r1, r0
   1c59c:	4628      	mov	r0, r5
   1c59e:	f000 fcd5 	bl	1cf4c <__aeabi_fsub>
   1c5a2:	4601      	mov	r1, r0
   1c5a4:	4630      	mov	r0, r6
   1c5a6:	f000 fcd1 	bl	1cf4c <__aeabi_fsub>
   1c5aa:	e727      	b.n	1c3fc <__ieee754_logf+0x6c>
   1c5ac:	4601      	mov	r1, r0
   1c5ae:	4630      	mov	r0, r6
   1c5b0:	f000 fccc 	bl	1cf4c <__aeabi_fsub>
   1c5b4:	e722      	b.n	1c3fc <__ieee754_logf+0x6c>
   1c5b6:	490a      	ldr	r1, [pc, #40]	; (1c5e0 <__ieee754_logf+0x250>)
   1c5b8:	4648      	mov	r0, r9
   1c5ba:	f000 fdd1 	bl	1d160 <__aeabi_fmul>
   1c5be:	4639      	mov	r1, r7
   1c5c0:	4604      	mov	r4, r0
   1c5c2:	4630      	mov	r0, r6
   1c5c4:	f000 fcc2 	bl	1cf4c <__aeabi_fsub>
   1c5c8:	4641      	mov	r1, r8
   1c5ca:	f000 fdc9 	bl	1d160 <__aeabi_fmul>
   1c5ce:	4905      	ldr	r1, [pc, #20]	; (1c5e4 <__ieee754_logf+0x254>)
   1c5d0:	4605      	mov	r5, r0
   1c5d2:	4648      	mov	r0, r9
   1c5d4:	e7ca      	b.n	1c56c <__ieee754_logf+0x1dc>
   1c5d6:	bf00      	nop
   1c5d8:	004afb20 	.word	0x004afb20
   1c5dc:	007ffff0 	.word	0x007ffff0
   1c5e0:	3f317180 	.word	0x3f317180
   1c5e4:	3717f7d1 	.word	0x3717f7d1
   1c5e8:	3e178897 	.word	0x3e178897
   1c5ec:	3e3a3325 	.word	0x3e3a3325
   1c5f0:	3e924925 	.word	0x3e924925
   1c5f4:	3f2aaaab 	.word	0x3f2aaaab
   1c5f8:	3e1cd04f 	.word	0x3e1cd04f
   1c5fc:	3e638e29 	.word	0x3e638e29
   1c600:	3ecccccd 	.word	0x3ecccccd
   1c604:	ffcf5c30 	.word	0xffcf5c30
   1c608:	3eaaaaab 	.word	0x3eaaaaab

0001c60c <scalbnf>:
   1c60c:	b510      	push	{r4, lr}
   1c60e:	460c      	mov	r4, r1
   1c610:	f030 4100 	bics.w	r1, r0, #2147483648	; 0x80000000
   1c614:	4603      	mov	r3, r0
   1c616:	d01d      	beq.n	1c654 <scalbnf+0x48>
   1c618:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   1c61c:	d21b      	bcs.n	1c656 <scalbnf+0x4a>
   1c61e:	f010 4fff 	tst.w	r0, #2139095040	; 0x7f800000
   1c622:	4602      	mov	r2, r0
   1c624:	d11b      	bne.n	1c65e <scalbnf+0x52>
   1c626:	f04f 4198 	mov.w	r1, #1275068416	; 0x4c000000
   1c62a:	f000 fd99 	bl	1d160 <__aeabi_fmul>
   1c62e:	4a20      	ldr	r2, [pc, #128]	; (1c6b0 <scalbnf+0xa4>)
   1c630:	4294      	cmp	r4, r2
   1c632:	4603      	mov	r3, r0
   1c634:	db2c      	blt.n	1c690 <scalbnf+0x84>
   1c636:	f3c0 51c7 	ubfx	r1, r0, #23, #8
   1c63a:	4602      	mov	r2, r0
   1c63c:	f24c 3050 	movw	r0, #50000	; 0xc350
   1c640:	4284      	cmp	r4, r0
   1c642:	f1a1 0119 	sub.w	r1, r1, #25
   1c646:	dd10      	ble.n	1c66a <scalbnf+0x5e>
   1c648:	491a      	ldr	r1, [pc, #104]	; (1c6b4 <scalbnf+0xa8>)
   1c64a:	4618      	mov	r0, r3
   1c64c:	f361 001e 	bfi	r0, r1, #0, #31
   1c650:	f000 fd86 	bl	1d160 <__aeabi_fmul>
   1c654:	bd10      	pop	{r4, pc}
   1c656:	4601      	mov	r1, r0
   1c658:	f000 fc7a 	bl	1cf50 <__addsf3>
   1c65c:	bd10      	pop	{r4, pc}
   1c65e:	f24c 3050 	movw	r0, #50000	; 0xc350
   1c662:	4284      	cmp	r4, r0
   1c664:	ea4f 51d1 	mov.w	r1, r1, lsr #23
   1c668:	dcee      	bgt.n	1c648 <scalbnf+0x3c>
   1c66a:	4421      	add	r1, r4
   1c66c:	29fe      	cmp	r1, #254	; 0xfe
   1c66e:	dceb      	bgt.n	1c648 <scalbnf+0x3c>
   1c670:	2900      	cmp	r1, #0
   1c672:	dc11      	bgt.n	1c698 <scalbnf+0x8c>
   1c674:	f111 0f16 	cmn.w	r1, #22
   1c678:	db13      	blt.n	1c6a2 <scalbnf+0x96>
   1c67a:	f101 0019 	add.w	r0, r1, #25
   1c67e:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
   1c682:	f04f 514c 	mov.w	r1, #855638016	; 0x33000000
   1c686:	ea42 50c0 	orr.w	r0, r2, r0, lsl #23
   1c68a:	f000 fd69 	bl	1d160 <__aeabi_fmul>
   1c68e:	bd10      	pop	{r4, pc}
   1c690:	4909      	ldr	r1, [pc, #36]	; (1c6b8 <scalbnf+0xac>)
   1c692:	f000 fd65 	bl	1d160 <__aeabi_fmul>
   1c696:	bd10      	pop	{r4, pc}
   1c698:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
   1c69c:	ea42 50c1 	orr.w	r0, r2, r1, lsl #23
   1c6a0:	bd10      	pop	{r4, pc}
   1c6a2:	4905      	ldr	r1, [pc, #20]	; (1c6b8 <scalbnf+0xac>)
   1c6a4:	4618      	mov	r0, r3
   1c6a6:	f361 001e 	bfi	r0, r1, #0, #31
   1c6aa:	f000 fd59 	bl	1d160 <__aeabi_fmul>
   1c6ae:	bd10      	pop	{r4, pc}
   1c6b0:	ffff3cb0 	.word	0xffff3cb0
   1c6b4:	7149f2ca 	.word	0x7149f2ca
   1c6b8:	0da24260 	.word	0x0da24260

0001c6bc <__aeabi_atexit>:
   1c6bc:	460b      	mov	r3, r1
   1c6be:	4601      	mov	r1, r0
   1c6c0:	4618      	mov	r0, r3
   1c6c2:	f001 b8bd 	b.w	1d840 <__cxa_atexit>
   1c6c6:	Address 0x000000000001c6c6 is out of bounds.


0001c6c8 <__aeabi_drsub>:
   1c6c8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   1c6cc:	e002      	b.n	1c6d4 <__adddf3>
   1c6ce:	bf00      	nop

0001c6d0 <__aeabi_dsub>:
   1c6d0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0001c6d4 <__adddf3>:
   1c6d4:	b530      	push	{r4, r5, lr}
   1c6d6:	ea4f 0441 	mov.w	r4, r1, lsl #1
   1c6da:	ea4f 0543 	mov.w	r5, r3, lsl #1
   1c6de:	ea94 0f05 	teq	r4, r5
   1c6e2:	bf08      	it	eq
   1c6e4:	ea90 0f02 	teqeq	r0, r2
   1c6e8:	bf1f      	itttt	ne
   1c6ea:	ea54 0c00 	orrsne.w	ip, r4, r0
   1c6ee:	ea55 0c02 	orrsne.w	ip, r5, r2
   1c6f2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   1c6f6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   1c6fa:	f000 80e2 	beq.w	1c8c2 <__adddf3+0x1ee>
   1c6fe:	ea4f 5454 	mov.w	r4, r4, lsr #21
   1c702:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   1c706:	bfb8      	it	lt
   1c708:	426d      	neglt	r5, r5
   1c70a:	dd0c      	ble.n	1c726 <__adddf3+0x52>
   1c70c:	442c      	add	r4, r5
   1c70e:	ea80 0202 	eor.w	r2, r0, r2
   1c712:	ea81 0303 	eor.w	r3, r1, r3
   1c716:	ea82 0000 	eor.w	r0, r2, r0
   1c71a:	ea83 0101 	eor.w	r1, r3, r1
   1c71e:	ea80 0202 	eor.w	r2, r0, r2
   1c722:	ea81 0303 	eor.w	r3, r1, r3
   1c726:	2d36      	cmp	r5, #54	; 0x36
   1c728:	bf88      	it	hi
   1c72a:	bd30      	pophi	{r4, r5, pc}
   1c72c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1c730:	ea4f 3101 	mov.w	r1, r1, lsl #12
   1c734:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   1c738:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   1c73c:	d002      	beq.n	1c744 <__adddf3+0x70>
   1c73e:	4240      	negs	r0, r0
   1c740:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1c744:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   1c748:	ea4f 3303 	mov.w	r3, r3, lsl #12
   1c74c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   1c750:	d002      	beq.n	1c758 <__adddf3+0x84>
   1c752:	4252      	negs	r2, r2
   1c754:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1c758:	ea94 0f05 	teq	r4, r5
   1c75c:	f000 80a7 	beq.w	1c8ae <__adddf3+0x1da>
   1c760:	f1a4 0401 	sub.w	r4, r4, #1
   1c764:	f1d5 0e20 	rsbs	lr, r5, #32
   1c768:	db0d      	blt.n	1c786 <__adddf3+0xb2>
   1c76a:	fa02 fc0e 	lsl.w	ip, r2, lr
   1c76e:	fa22 f205 	lsr.w	r2, r2, r5
   1c772:	1880      	adds	r0, r0, r2
   1c774:	f141 0100 	adc.w	r1, r1, #0
   1c778:	fa03 f20e 	lsl.w	r2, r3, lr
   1c77c:	1880      	adds	r0, r0, r2
   1c77e:	fa43 f305 	asr.w	r3, r3, r5
   1c782:	4159      	adcs	r1, r3
   1c784:	e00e      	b.n	1c7a4 <__adddf3+0xd0>
   1c786:	f1a5 0520 	sub.w	r5, r5, #32
   1c78a:	f10e 0e20 	add.w	lr, lr, #32
   1c78e:	2a01      	cmp	r2, #1
   1c790:	fa03 fc0e 	lsl.w	ip, r3, lr
   1c794:	bf28      	it	cs
   1c796:	f04c 0c02 	orrcs.w	ip, ip, #2
   1c79a:	fa43 f305 	asr.w	r3, r3, r5
   1c79e:	18c0      	adds	r0, r0, r3
   1c7a0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   1c7a4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c7a8:	d507      	bpl.n	1c7ba <__adddf3+0xe6>
   1c7aa:	f04f 0e00 	mov.w	lr, #0
   1c7ae:	f1dc 0c00 	rsbs	ip, ip, #0
   1c7b2:	eb7e 0000 	sbcs.w	r0, lr, r0
   1c7b6:	eb6e 0101 	sbc.w	r1, lr, r1
   1c7ba:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   1c7be:	d31b      	bcc.n	1c7f8 <__adddf3+0x124>
   1c7c0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   1c7c4:	d30c      	bcc.n	1c7e0 <__adddf3+0x10c>
   1c7c6:	0849      	lsrs	r1, r1, #1
   1c7c8:	ea5f 0030 	movs.w	r0, r0, rrx
   1c7cc:	ea4f 0c3c 	mov.w	ip, ip, rrx
   1c7d0:	f104 0401 	add.w	r4, r4, #1
   1c7d4:	ea4f 5244 	mov.w	r2, r4, lsl #21
   1c7d8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   1c7dc:	f080 809a 	bcs.w	1c914 <__adddf3+0x240>
   1c7e0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   1c7e4:	bf08      	it	eq
   1c7e6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   1c7ea:	f150 0000 	adcs.w	r0, r0, #0
   1c7ee:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1c7f2:	ea41 0105 	orr.w	r1, r1, r5
   1c7f6:	bd30      	pop	{r4, r5, pc}
   1c7f8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   1c7fc:	4140      	adcs	r0, r0
   1c7fe:	eb41 0101 	adc.w	r1, r1, r1
   1c802:	3c01      	subs	r4, #1
   1c804:	bf28      	it	cs
   1c806:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   1c80a:	d2e9      	bcs.n	1c7e0 <__adddf3+0x10c>
   1c80c:	f091 0f00 	teq	r1, #0
   1c810:	bf04      	itt	eq
   1c812:	4601      	moveq	r1, r0
   1c814:	2000      	moveq	r0, #0
   1c816:	fab1 f381 	clz	r3, r1
   1c81a:	bf08      	it	eq
   1c81c:	3320      	addeq	r3, #32
   1c81e:	f1a3 030b 	sub.w	r3, r3, #11
   1c822:	f1b3 0220 	subs.w	r2, r3, #32
   1c826:	da0c      	bge.n	1c842 <__adddf3+0x16e>
   1c828:	320c      	adds	r2, #12
   1c82a:	dd08      	ble.n	1c83e <__adddf3+0x16a>
   1c82c:	f102 0c14 	add.w	ip, r2, #20
   1c830:	f1c2 020c 	rsb	r2, r2, #12
   1c834:	fa01 f00c 	lsl.w	r0, r1, ip
   1c838:	fa21 f102 	lsr.w	r1, r1, r2
   1c83c:	e00c      	b.n	1c858 <__adddf3+0x184>
   1c83e:	f102 0214 	add.w	r2, r2, #20
   1c842:	bfd8      	it	le
   1c844:	f1c2 0c20 	rsble	ip, r2, #32
   1c848:	fa01 f102 	lsl.w	r1, r1, r2
   1c84c:	fa20 fc0c 	lsr.w	ip, r0, ip
   1c850:	bfdc      	itt	le
   1c852:	ea41 010c 	orrle.w	r1, r1, ip
   1c856:	4090      	lslle	r0, r2
   1c858:	1ae4      	subs	r4, r4, r3
   1c85a:	bfa2      	ittt	ge
   1c85c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   1c860:	4329      	orrge	r1, r5
   1c862:	bd30      	popge	{r4, r5, pc}
   1c864:	ea6f 0404 	mvn.w	r4, r4
   1c868:	3c1f      	subs	r4, #31
   1c86a:	da1c      	bge.n	1c8a6 <__adddf3+0x1d2>
   1c86c:	340c      	adds	r4, #12
   1c86e:	dc0e      	bgt.n	1c88e <__adddf3+0x1ba>
   1c870:	f104 0414 	add.w	r4, r4, #20
   1c874:	f1c4 0220 	rsb	r2, r4, #32
   1c878:	fa20 f004 	lsr.w	r0, r0, r4
   1c87c:	fa01 f302 	lsl.w	r3, r1, r2
   1c880:	ea40 0003 	orr.w	r0, r0, r3
   1c884:	fa21 f304 	lsr.w	r3, r1, r4
   1c888:	ea45 0103 	orr.w	r1, r5, r3
   1c88c:	bd30      	pop	{r4, r5, pc}
   1c88e:	f1c4 040c 	rsb	r4, r4, #12
   1c892:	f1c4 0220 	rsb	r2, r4, #32
   1c896:	fa20 f002 	lsr.w	r0, r0, r2
   1c89a:	fa01 f304 	lsl.w	r3, r1, r4
   1c89e:	ea40 0003 	orr.w	r0, r0, r3
   1c8a2:	4629      	mov	r1, r5
   1c8a4:	bd30      	pop	{r4, r5, pc}
   1c8a6:	fa21 f004 	lsr.w	r0, r1, r4
   1c8aa:	4629      	mov	r1, r5
   1c8ac:	bd30      	pop	{r4, r5, pc}
   1c8ae:	f094 0f00 	teq	r4, #0
   1c8b2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   1c8b6:	bf06      	itte	eq
   1c8b8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   1c8bc:	3401      	addeq	r4, #1
   1c8be:	3d01      	subne	r5, #1
   1c8c0:	e74e      	b.n	1c760 <__adddf3+0x8c>
   1c8c2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   1c8c6:	bf18      	it	ne
   1c8c8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   1c8cc:	d029      	beq.n	1c922 <__adddf3+0x24e>
   1c8ce:	ea94 0f05 	teq	r4, r5
   1c8d2:	bf08      	it	eq
   1c8d4:	ea90 0f02 	teqeq	r0, r2
   1c8d8:	d005      	beq.n	1c8e6 <__adddf3+0x212>
   1c8da:	ea54 0c00 	orrs.w	ip, r4, r0
   1c8de:	bf04      	itt	eq
   1c8e0:	4619      	moveq	r1, r3
   1c8e2:	4610      	moveq	r0, r2
   1c8e4:	bd30      	pop	{r4, r5, pc}
   1c8e6:	ea91 0f03 	teq	r1, r3
   1c8ea:	bf1e      	ittt	ne
   1c8ec:	2100      	movne	r1, #0
   1c8ee:	2000      	movne	r0, #0
   1c8f0:	bd30      	popne	{r4, r5, pc}
   1c8f2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   1c8f6:	d105      	bne.n	1c904 <__adddf3+0x230>
   1c8f8:	0040      	lsls	r0, r0, #1
   1c8fa:	4149      	adcs	r1, r1
   1c8fc:	bf28      	it	cs
   1c8fe:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   1c902:	bd30      	pop	{r4, r5, pc}
   1c904:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   1c908:	bf3c      	itt	cc
   1c90a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   1c90e:	bd30      	popcc	{r4, r5, pc}
   1c910:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c914:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   1c918:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   1c91c:	f04f 0000 	mov.w	r0, #0
   1c920:	bd30      	pop	{r4, r5, pc}
   1c922:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   1c926:	bf1a      	itte	ne
   1c928:	4619      	movne	r1, r3
   1c92a:	4610      	movne	r0, r2
   1c92c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   1c930:	bf1c      	itt	ne
   1c932:	460b      	movne	r3, r1
   1c934:	4602      	movne	r2, r0
   1c936:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   1c93a:	bf06      	itte	eq
   1c93c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   1c940:	ea91 0f03 	teqeq	r1, r3
   1c944:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   1c948:	bd30      	pop	{r4, r5, pc}
   1c94a:	bf00      	nop

0001c94c <__aeabi_ui2d>:
   1c94c:	f090 0f00 	teq	r0, #0
   1c950:	bf04      	itt	eq
   1c952:	2100      	moveq	r1, #0
   1c954:	4770      	bxeq	lr
   1c956:	b530      	push	{r4, r5, lr}
   1c958:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c95c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1c960:	f04f 0500 	mov.w	r5, #0
   1c964:	f04f 0100 	mov.w	r1, #0
   1c968:	e750      	b.n	1c80c <__adddf3+0x138>
   1c96a:	bf00      	nop

0001c96c <__aeabi_i2d>:
   1c96c:	f090 0f00 	teq	r0, #0
   1c970:	bf04      	itt	eq
   1c972:	2100      	moveq	r1, #0
   1c974:	4770      	bxeq	lr
   1c976:	b530      	push	{r4, r5, lr}
   1c978:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c97c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1c980:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   1c984:	bf48      	it	mi
   1c986:	4240      	negmi	r0, r0
   1c988:	f04f 0100 	mov.w	r1, #0
   1c98c:	e73e      	b.n	1c80c <__adddf3+0x138>
   1c98e:	bf00      	nop

0001c990 <__aeabi_f2d>:
   1c990:	0042      	lsls	r2, r0, #1
   1c992:	ea4f 01e2 	mov.w	r1, r2, asr #3
   1c996:	ea4f 0131 	mov.w	r1, r1, rrx
   1c99a:	ea4f 7002 	mov.w	r0, r2, lsl #28
   1c99e:	bf1f      	itttt	ne
   1c9a0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   1c9a4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   1c9a8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   1c9ac:	4770      	bxne	lr
   1c9ae:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   1c9b2:	bf08      	it	eq
   1c9b4:	4770      	bxeq	lr
   1c9b6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   1c9ba:	bf04      	itt	eq
   1c9bc:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   1c9c0:	4770      	bxeq	lr
   1c9c2:	b530      	push	{r4, r5, lr}
   1c9c4:	f44f 7460 	mov.w	r4, #896	; 0x380
   1c9c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c9cc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1c9d0:	e71c      	b.n	1c80c <__adddf3+0x138>
   1c9d2:	bf00      	nop

0001c9d4 <__aeabi_ul2d>:
   1c9d4:	ea50 0201 	orrs.w	r2, r0, r1
   1c9d8:	bf08      	it	eq
   1c9da:	4770      	bxeq	lr
   1c9dc:	b530      	push	{r4, r5, lr}
   1c9de:	f04f 0500 	mov.w	r5, #0
   1c9e2:	e00a      	b.n	1c9fa <__aeabi_l2d+0x16>

0001c9e4 <__aeabi_l2d>:
   1c9e4:	ea50 0201 	orrs.w	r2, r0, r1
   1c9e8:	bf08      	it	eq
   1c9ea:	4770      	bxeq	lr
   1c9ec:	b530      	push	{r4, r5, lr}
   1c9ee:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   1c9f2:	d502      	bpl.n	1c9fa <__aeabi_l2d+0x16>
   1c9f4:	4240      	negs	r0, r0
   1c9f6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1c9fa:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c9fe:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1ca02:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   1ca06:	f43f aed8 	beq.w	1c7ba <__adddf3+0xe6>
   1ca0a:	f04f 0203 	mov.w	r2, #3
   1ca0e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1ca12:	bf18      	it	ne
   1ca14:	3203      	addne	r2, #3
   1ca16:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1ca1a:	bf18      	it	ne
   1ca1c:	3203      	addne	r2, #3
   1ca1e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   1ca22:	f1c2 0320 	rsb	r3, r2, #32
   1ca26:	fa00 fc03 	lsl.w	ip, r0, r3
   1ca2a:	fa20 f002 	lsr.w	r0, r0, r2
   1ca2e:	fa01 fe03 	lsl.w	lr, r1, r3
   1ca32:	ea40 000e 	orr.w	r0, r0, lr
   1ca36:	fa21 f102 	lsr.w	r1, r1, r2
   1ca3a:	4414      	add	r4, r2
   1ca3c:	e6bd      	b.n	1c7ba <__adddf3+0xe6>
   1ca3e:	bf00      	nop

0001ca40 <__aeabi_dmul>:
   1ca40:	b570      	push	{r4, r5, r6, lr}
   1ca42:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1ca46:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1ca4a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   1ca4e:	bf1d      	ittte	ne
   1ca50:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   1ca54:	ea94 0f0c 	teqne	r4, ip
   1ca58:	ea95 0f0c 	teqne	r5, ip
   1ca5c:	f000 f8de 	bleq	1cc1c <__aeabi_dmul+0x1dc>
   1ca60:	442c      	add	r4, r5
   1ca62:	ea81 0603 	eor.w	r6, r1, r3
   1ca66:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   1ca6a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   1ca6e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   1ca72:	bf18      	it	ne
   1ca74:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   1ca78:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1ca7c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   1ca80:	d038      	beq.n	1caf4 <__aeabi_dmul+0xb4>
   1ca82:	fba0 ce02 	umull	ip, lr, r0, r2
   1ca86:	f04f 0500 	mov.w	r5, #0
   1ca8a:	fbe1 e502 	umlal	lr, r5, r1, r2
   1ca8e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   1ca92:	fbe0 e503 	umlal	lr, r5, r0, r3
   1ca96:	f04f 0600 	mov.w	r6, #0
   1ca9a:	fbe1 5603 	umlal	r5, r6, r1, r3
   1ca9e:	f09c 0f00 	teq	ip, #0
   1caa2:	bf18      	it	ne
   1caa4:	f04e 0e01 	orrne.w	lr, lr, #1
   1caa8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   1caac:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   1cab0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   1cab4:	d204      	bcs.n	1cac0 <__aeabi_dmul+0x80>
   1cab6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   1caba:	416d      	adcs	r5, r5
   1cabc:	eb46 0606 	adc.w	r6, r6, r6
   1cac0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   1cac4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   1cac8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   1cacc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   1cad0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   1cad4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   1cad8:	bf88      	it	hi
   1cada:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   1cade:	d81e      	bhi.n	1cb1e <__aeabi_dmul+0xde>
   1cae0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   1cae4:	bf08      	it	eq
   1cae6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   1caea:	f150 0000 	adcs.w	r0, r0, #0
   1caee:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1caf2:	bd70      	pop	{r4, r5, r6, pc}
   1caf4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   1caf8:	ea46 0101 	orr.w	r1, r6, r1
   1cafc:	ea40 0002 	orr.w	r0, r0, r2
   1cb00:	ea81 0103 	eor.w	r1, r1, r3
   1cb04:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   1cb08:	bfc2      	ittt	gt
   1cb0a:	ebd4 050c 	rsbsgt	r5, r4, ip
   1cb0e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   1cb12:	bd70      	popgt	{r4, r5, r6, pc}
   1cb14:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1cb18:	f04f 0e00 	mov.w	lr, #0
   1cb1c:	3c01      	subs	r4, #1
   1cb1e:	f300 80ab 	bgt.w	1cc78 <__aeabi_dmul+0x238>
   1cb22:	f114 0f36 	cmn.w	r4, #54	; 0x36
   1cb26:	bfde      	ittt	le
   1cb28:	2000      	movle	r0, #0
   1cb2a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   1cb2e:	bd70      	pople	{r4, r5, r6, pc}
   1cb30:	f1c4 0400 	rsb	r4, r4, #0
   1cb34:	3c20      	subs	r4, #32
   1cb36:	da35      	bge.n	1cba4 <__aeabi_dmul+0x164>
   1cb38:	340c      	adds	r4, #12
   1cb3a:	dc1b      	bgt.n	1cb74 <__aeabi_dmul+0x134>
   1cb3c:	f104 0414 	add.w	r4, r4, #20
   1cb40:	f1c4 0520 	rsb	r5, r4, #32
   1cb44:	fa00 f305 	lsl.w	r3, r0, r5
   1cb48:	fa20 f004 	lsr.w	r0, r0, r4
   1cb4c:	fa01 f205 	lsl.w	r2, r1, r5
   1cb50:	ea40 0002 	orr.w	r0, r0, r2
   1cb54:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   1cb58:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1cb5c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   1cb60:	fa21 f604 	lsr.w	r6, r1, r4
   1cb64:	eb42 0106 	adc.w	r1, r2, r6
   1cb68:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1cb6c:	bf08      	it	eq
   1cb6e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1cb72:	bd70      	pop	{r4, r5, r6, pc}
   1cb74:	f1c4 040c 	rsb	r4, r4, #12
   1cb78:	f1c4 0520 	rsb	r5, r4, #32
   1cb7c:	fa00 f304 	lsl.w	r3, r0, r4
   1cb80:	fa20 f005 	lsr.w	r0, r0, r5
   1cb84:	fa01 f204 	lsl.w	r2, r1, r4
   1cb88:	ea40 0002 	orr.w	r0, r0, r2
   1cb8c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1cb90:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   1cb94:	f141 0100 	adc.w	r1, r1, #0
   1cb98:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1cb9c:	bf08      	it	eq
   1cb9e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1cba2:	bd70      	pop	{r4, r5, r6, pc}
   1cba4:	f1c4 0520 	rsb	r5, r4, #32
   1cba8:	fa00 f205 	lsl.w	r2, r0, r5
   1cbac:	ea4e 0e02 	orr.w	lr, lr, r2
   1cbb0:	fa20 f304 	lsr.w	r3, r0, r4
   1cbb4:	fa01 f205 	lsl.w	r2, r1, r5
   1cbb8:	ea43 0302 	orr.w	r3, r3, r2
   1cbbc:	fa21 f004 	lsr.w	r0, r1, r4
   1cbc0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1cbc4:	fa21 f204 	lsr.w	r2, r1, r4
   1cbc8:	ea20 0002 	bic.w	r0, r0, r2
   1cbcc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   1cbd0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1cbd4:	bf08      	it	eq
   1cbd6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1cbda:	bd70      	pop	{r4, r5, r6, pc}
   1cbdc:	f094 0f00 	teq	r4, #0
   1cbe0:	d10f      	bne.n	1cc02 <__aeabi_dmul+0x1c2>
   1cbe2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   1cbe6:	0040      	lsls	r0, r0, #1
   1cbe8:	eb41 0101 	adc.w	r1, r1, r1
   1cbec:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1cbf0:	bf08      	it	eq
   1cbf2:	3c01      	subeq	r4, #1
   1cbf4:	d0f7      	beq.n	1cbe6 <__aeabi_dmul+0x1a6>
   1cbf6:	ea41 0106 	orr.w	r1, r1, r6
   1cbfa:	f095 0f00 	teq	r5, #0
   1cbfe:	bf18      	it	ne
   1cc00:	4770      	bxne	lr
   1cc02:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   1cc06:	0052      	lsls	r2, r2, #1
   1cc08:	eb43 0303 	adc.w	r3, r3, r3
   1cc0c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   1cc10:	bf08      	it	eq
   1cc12:	3d01      	subeq	r5, #1
   1cc14:	d0f7      	beq.n	1cc06 <__aeabi_dmul+0x1c6>
   1cc16:	ea43 0306 	orr.w	r3, r3, r6
   1cc1a:	4770      	bx	lr
   1cc1c:	ea94 0f0c 	teq	r4, ip
   1cc20:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   1cc24:	bf18      	it	ne
   1cc26:	ea95 0f0c 	teqne	r5, ip
   1cc2a:	d00c      	beq.n	1cc46 <__aeabi_dmul+0x206>
   1cc2c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1cc30:	bf18      	it	ne
   1cc32:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1cc36:	d1d1      	bne.n	1cbdc <__aeabi_dmul+0x19c>
   1cc38:	ea81 0103 	eor.w	r1, r1, r3
   1cc3c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1cc40:	f04f 0000 	mov.w	r0, #0
   1cc44:	bd70      	pop	{r4, r5, r6, pc}
   1cc46:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1cc4a:	bf06      	itte	eq
   1cc4c:	4610      	moveq	r0, r2
   1cc4e:	4619      	moveq	r1, r3
   1cc50:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1cc54:	d019      	beq.n	1cc8a <__aeabi_dmul+0x24a>
   1cc56:	ea94 0f0c 	teq	r4, ip
   1cc5a:	d102      	bne.n	1cc62 <__aeabi_dmul+0x222>
   1cc5c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   1cc60:	d113      	bne.n	1cc8a <__aeabi_dmul+0x24a>
   1cc62:	ea95 0f0c 	teq	r5, ip
   1cc66:	d105      	bne.n	1cc74 <__aeabi_dmul+0x234>
   1cc68:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   1cc6c:	bf1c      	itt	ne
   1cc6e:	4610      	movne	r0, r2
   1cc70:	4619      	movne	r1, r3
   1cc72:	d10a      	bne.n	1cc8a <__aeabi_dmul+0x24a>
   1cc74:	ea81 0103 	eor.w	r1, r1, r3
   1cc78:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1cc7c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   1cc80:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   1cc84:	f04f 0000 	mov.w	r0, #0
   1cc88:	bd70      	pop	{r4, r5, r6, pc}
   1cc8a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   1cc8e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   1cc92:	bd70      	pop	{r4, r5, r6, pc}

0001cc94 <__aeabi_ddiv>:
   1cc94:	b570      	push	{r4, r5, r6, lr}
   1cc96:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1cc9a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1cc9e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   1cca2:	bf1d      	ittte	ne
   1cca4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   1cca8:	ea94 0f0c 	teqne	r4, ip
   1ccac:	ea95 0f0c 	teqne	r5, ip
   1ccb0:	f000 f8a7 	bleq	1ce02 <__aeabi_ddiv+0x16e>
   1ccb4:	eba4 0405 	sub.w	r4, r4, r5
   1ccb8:	ea81 0e03 	eor.w	lr, r1, r3
   1ccbc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   1ccc0:	ea4f 3101 	mov.w	r1, r1, lsl #12
   1ccc4:	f000 8088 	beq.w	1cdd8 <__aeabi_ddiv+0x144>
   1ccc8:	ea4f 3303 	mov.w	r3, r3, lsl #12
   1cccc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   1ccd0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   1ccd4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   1ccd8:	ea4f 2202 	mov.w	r2, r2, lsl #8
   1ccdc:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   1cce0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   1cce4:	ea4f 2600 	mov.w	r6, r0, lsl #8
   1cce8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   1ccec:	429d      	cmp	r5, r3
   1ccee:	bf08      	it	eq
   1ccf0:	4296      	cmpeq	r6, r2
   1ccf2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   1ccf6:	f504 7440 	add.w	r4, r4, #768	; 0x300
   1ccfa:	d202      	bcs.n	1cd02 <__aeabi_ddiv+0x6e>
   1ccfc:	085b      	lsrs	r3, r3, #1
   1ccfe:	ea4f 0232 	mov.w	r2, r2, rrx
   1cd02:	1ab6      	subs	r6, r6, r2
   1cd04:	eb65 0503 	sbc.w	r5, r5, r3
   1cd08:	085b      	lsrs	r3, r3, #1
   1cd0a:	ea4f 0232 	mov.w	r2, r2, rrx
   1cd0e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   1cd12:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   1cd16:	ebb6 0e02 	subs.w	lr, r6, r2
   1cd1a:	eb75 0e03 	sbcs.w	lr, r5, r3
   1cd1e:	bf22      	ittt	cs
   1cd20:	1ab6      	subcs	r6, r6, r2
   1cd22:	4675      	movcs	r5, lr
   1cd24:	ea40 000c 	orrcs.w	r0, r0, ip
   1cd28:	085b      	lsrs	r3, r3, #1
   1cd2a:	ea4f 0232 	mov.w	r2, r2, rrx
   1cd2e:	ebb6 0e02 	subs.w	lr, r6, r2
   1cd32:	eb75 0e03 	sbcs.w	lr, r5, r3
   1cd36:	bf22      	ittt	cs
   1cd38:	1ab6      	subcs	r6, r6, r2
   1cd3a:	4675      	movcs	r5, lr
   1cd3c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   1cd40:	085b      	lsrs	r3, r3, #1
   1cd42:	ea4f 0232 	mov.w	r2, r2, rrx
   1cd46:	ebb6 0e02 	subs.w	lr, r6, r2
   1cd4a:	eb75 0e03 	sbcs.w	lr, r5, r3
   1cd4e:	bf22      	ittt	cs
   1cd50:	1ab6      	subcs	r6, r6, r2
   1cd52:	4675      	movcs	r5, lr
   1cd54:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   1cd58:	085b      	lsrs	r3, r3, #1
   1cd5a:	ea4f 0232 	mov.w	r2, r2, rrx
   1cd5e:	ebb6 0e02 	subs.w	lr, r6, r2
   1cd62:	eb75 0e03 	sbcs.w	lr, r5, r3
   1cd66:	bf22      	ittt	cs
   1cd68:	1ab6      	subcs	r6, r6, r2
   1cd6a:	4675      	movcs	r5, lr
   1cd6c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   1cd70:	ea55 0e06 	orrs.w	lr, r5, r6
   1cd74:	d018      	beq.n	1cda8 <__aeabi_ddiv+0x114>
   1cd76:	ea4f 1505 	mov.w	r5, r5, lsl #4
   1cd7a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   1cd7e:	ea4f 1606 	mov.w	r6, r6, lsl #4
   1cd82:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1cd86:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   1cd8a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   1cd8e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   1cd92:	d1c0      	bne.n	1cd16 <__aeabi_ddiv+0x82>
   1cd94:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1cd98:	d10b      	bne.n	1cdb2 <__aeabi_ddiv+0x11e>
   1cd9a:	ea41 0100 	orr.w	r1, r1, r0
   1cd9e:	f04f 0000 	mov.w	r0, #0
   1cda2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   1cda6:	e7b6      	b.n	1cd16 <__aeabi_ddiv+0x82>
   1cda8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1cdac:	bf04      	itt	eq
   1cdae:	4301      	orreq	r1, r0
   1cdb0:	2000      	moveq	r0, #0
   1cdb2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   1cdb6:	bf88      	it	hi
   1cdb8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   1cdbc:	f63f aeaf 	bhi.w	1cb1e <__aeabi_dmul+0xde>
   1cdc0:	ebb5 0c03 	subs.w	ip, r5, r3
   1cdc4:	bf04      	itt	eq
   1cdc6:	ebb6 0c02 	subseq.w	ip, r6, r2
   1cdca:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   1cdce:	f150 0000 	adcs.w	r0, r0, #0
   1cdd2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1cdd6:	bd70      	pop	{r4, r5, r6, pc}
   1cdd8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   1cddc:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   1cde0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   1cde4:	bfc2      	ittt	gt
   1cde6:	ebd4 050c 	rsbsgt	r5, r4, ip
   1cdea:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   1cdee:	bd70      	popgt	{r4, r5, r6, pc}
   1cdf0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1cdf4:	f04f 0e00 	mov.w	lr, #0
   1cdf8:	3c01      	subs	r4, #1
   1cdfa:	e690      	b.n	1cb1e <__aeabi_dmul+0xde>
   1cdfc:	ea45 0e06 	orr.w	lr, r5, r6
   1ce00:	e68d      	b.n	1cb1e <__aeabi_dmul+0xde>
   1ce02:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   1ce06:	ea94 0f0c 	teq	r4, ip
   1ce0a:	bf08      	it	eq
   1ce0c:	ea95 0f0c 	teqeq	r5, ip
   1ce10:	f43f af3b 	beq.w	1cc8a <__aeabi_dmul+0x24a>
   1ce14:	ea94 0f0c 	teq	r4, ip
   1ce18:	d10a      	bne.n	1ce30 <__aeabi_ddiv+0x19c>
   1ce1a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   1ce1e:	f47f af34 	bne.w	1cc8a <__aeabi_dmul+0x24a>
   1ce22:	ea95 0f0c 	teq	r5, ip
   1ce26:	f47f af25 	bne.w	1cc74 <__aeabi_dmul+0x234>
   1ce2a:	4610      	mov	r0, r2
   1ce2c:	4619      	mov	r1, r3
   1ce2e:	e72c      	b.n	1cc8a <__aeabi_dmul+0x24a>
   1ce30:	ea95 0f0c 	teq	r5, ip
   1ce34:	d106      	bne.n	1ce44 <__aeabi_ddiv+0x1b0>
   1ce36:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   1ce3a:	f43f aefd 	beq.w	1cc38 <__aeabi_dmul+0x1f8>
   1ce3e:	4610      	mov	r0, r2
   1ce40:	4619      	mov	r1, r3
   1ce42:	e722      	b.n	1cc8a <__aeabi_dmul+0x24a>
   1ce44:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1ce48:	bf18      	it	ne
   1ce4a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1ce4e:	f47f aec5 	bne.w	1cbdc <__aeabi_dmul+0x19c>
   1ce52:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   1ce56:	f47f af0d 	bne.w	1cc74 <__aeabi_dmul+0x234>
   1ce5a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   1ce5e:	f47f aeeb 	bne.w	1cc38 <__aeabi_dmul+0x1f8>
   1ce62:	e712      	b.n	1cc8a <__aeabi_dmul+0x24a>

0001ce64 <__aeabi_d2uiz>:
   1ce64:	004a      	lsls	r2, r1, #1
   1ce66:	d211      	bcs.n	1ce8c <__aeabi_d2uiz+0x28>
   1ce68:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1ce6c:	d211      	bcs.n	1ce92 <__aeabi_d2uiz+0x2e>
   1ce6e:	d50d      	bpl.n	1ce8c <__aeabi_d2uiz+0x28>
   1ce70:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1ce74:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1ce78:	d40e      	bmi.n	1ce98 <__aeabi_d2uiz+0x34>
   1ce7a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1ce7e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1ce82:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1ce86:	fa23 f002 	lsr.w	r0, r3, r2
   1ce8a:	4770      	bx	lr
   1ce8c:	f04f 0000 	mov.w	r0, #0
   1ce90:	4770      	bx	lr
   1ce92:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1ce96:	d102      	bne.n	1ce9e <__aeabi_d2uiz+0x3a>
   1ce98:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1ce9c:	4770      	bx	lr
   1ce9e:	f04f 0000 	mov.w	r0, #0
   1cea2:	4770      	bx	lr

0001cea4 <__aeabi_d2f>:
   1cea4:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1cea8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   1ceac:	bf24      	itt	cs
   1ceae:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   1ceb2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1ceb6:	d90d      	bls.n	1ced4 <__aeabi_d2f+0x30>
   1ceb8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   1cebc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   1cec0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   1cec4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   1cec8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   1cecc:	bf08      	it	eq
   1cece:	f020 0001 	biceq.w	r0, r0, #1
   1ced2:	4770      	bx	lr
   1ced4:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   1ced8:	d121      	bne.n	1cf1e <__aeabi_d2f+0x7a>
   1ceda:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   1cede:	bfbc      	itt	lt
   1cee0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   1cee4:	4770      	bxlt	lr
   1cee6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1ceea:	ea4f 5252 	mov.w	r2, r2, lsr #21
   1ceee:	f1c2 0218 	rsb	r2, r2, #24
   1cef2:	f1c2 0c20 	rsb	ip, r2, #32
   1cef6:	fa10 f30c 	lsls.w	r3, r0, ip
   1cefa:	fa20 f002 	lsr.w	r0, r0, r2
   1cefe:	bf18      	it	ne
   1cf00:	f040 0001 	orrne.w	r0, r0, #1
   1cf04:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1cf08:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   1cf0c:	fa03 fc0c 	lsl.w	ip, r3, ip
   1cf10:	ea40 000c 	orr.w	r0, r0, ip
   1cf14:	fa23 f302 	lsr.w	r3, r3, r2
   1cf18:	ea4f 0343 	mov.w	r3, r3, lsl #1
   1cf1c:	e7cc      	b.n	1ceb8 <__aeabi_d2f+0x14>
   1cf1e:	ea7f 5362 	mvns.w	r3, r2, asr #21
   1cf22:	d107      	bne.n	1cf34 <__aeabi_d2f+0x90>
   1cf24:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   1cf28:	bf1e      	ittt	ne
   1cf2a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   1cf2e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   1cf32:	4770      	bxne	lr
   1cf34:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   1cf38:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   1cf3c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1cf40:	4770      	bx	lr
   1cf42:	bf00      	nop

0001cf44 <__aeabi_frsub>:
   1cf44:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
   1cf48:	e002      	b.n	1cf50 <__addsf3>
   1cf4a:	bf00      	nop

0001cf4c <__aeabi_fsub>:
   1cf4c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0001cf50 <__addsf3>:
   1cf50:	0042      	lsls	r2, r0, #1
   1cf52:	bf1f      	itttt	ne
   1cf54:	ea5f 0341 	movsne.w	r3, r1, lsl #1
   1cf58:	ea92 0f03 	teqne	r2, r3
   1cf5c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
   1cf60:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   1cf64:	d06a      	beq.n	1d03c <__addsf3+0xec>
   1cf66:	ea4f 6212 	mov.w	r2, r2, lsr #24
   1cf6a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
   1cf6e:	bfc1      	itttt	gt
   1cf70:	18d2      	addgt	r2, r2, r3
   1cf72:	4041      	eorgt	r1, r0
   1cf74:	4048      	eorgt	r0, r1
   1cf76:	4041      	eorgt	r1, r0
   1cf78:	bfb8      	it	lt
   1cf7a:	425b      	neglt	r3, r3
   1cf7c:	2b19      	cmp	r3, #25
   1cf7e:	bf88      	it	hi
   1cf80:	4770      	bxhi	lr
   1cf82:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   1cf86:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1cf8a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   1cf8e:	bf18      	it	ne
   1cf90:	4240      	negne	r0, r0
   1cf92:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1cf96:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
   1cf9a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
   1cf9e:	bf18      	it	ne
   1cfa0:	4249      	negne	r1, r1
   1cfa2:	ea92 0f03 	teq	r2, r3
   1cfa6:	d03f      	beq.n	1d028 <__addsf3+0xd8>
   1cfa8:	f1a2 0201 	sub.w	r2, r2, #1
   1cfac:	fa41 fc03 	asr.w	ip, r1, r3
   1cfb0:	eb10 000c 	adds.w	r0, r0, ip
   1cfb4:	f1c3 0320 	rsb	r3, r3, #32
   1cfb8:	fa01 f103 	lsl.w	r1, r1, r3
   1cfbc:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   1cfc0:	d502      	bpl.n	1cfc8 <__addsf3+0x78>
   1cfc2:	4249      	negs	r1, r1
   1cfc4:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
   1cfc8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   1cfcc:	d313      	bcc.n	1cff6 <__addsf3+0xa6>
   1cfce:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
   1cfd2:	d306      	bcc.n	1cfe2 <__addsf3+0x92>
   1cfd4:	0840      	lsrs	r0, r0, #1
   1cfd6:	ea4f 0131 	mov.w	r1, r1, rrx
   1cfda:	f102 0201 	add.w	r2, r2, #1
   1cfde:	2afe      	cmp	r2, #254	; 0xfe
   1cfe0:	d251      	bcs.n	1d086 <__addsf3+0x136>
   1cfe2:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
   1cfe6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   1cfea:	bf08      	it	eq
   1cfec:	f020 0001 	biceq.w	r0, r0, #1
   1cff0:	ea40 0003 	orr.w	r0, r0, r3
   1cff4:	4770      	bx	lr
   1cff6:	0049      	lsls	r1, r1, #1
   1cff8:	eb40 0000 	adc.w	r0, r0, r0
   1cffc:	3a01      	subs	r2, #1
   1cffe:	bf28      	it	cs
   1d000:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
   1d004:	d2ed      	bcs.n	1cfe2 <__addsf3+0x92>
   1d006:	fab0 fc80 	clz	ip, r0
   1d00a:	f1ac 0c08 	sub.w	ip, ip, #8
   1d00e:	ebb2 020c 	subs.w	r2, r2, ip
   1d012:	fa00 f00c 	lsl.w	r0, r0, ip
   1d016:	bfaa      	itet	ge
   1d018:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
   1d01c:	4252      	neglt	r2, r2
   1d01e:	4318      	orrge	r0, r3
   1d020:	bfbc      	itt	lt
   1d022:	40d0      	lsrlt	r0, r2
   1d024:	4318      	orrlt	r0, r3
   1d026:	4770      	bx	lr
   1d028:	f092 0f00 	teq	r2, #0
   1d02c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
   1d030:	bf06      	itte	eq
   1d032:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
   1d036:	3201      	addeq	r2, #1
   1d038:	3b01      	subne	r3, #1
   1d03a:	e7b5      	b.n	1cfa8 <__addsf3+0x58>
   1d03c:	ea4f 0341 	mov.w	r3, r1, lsl #1
   1d040:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   1d044:	bf18      	it	ne
   1d046:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   1d04a:	d021      	beq.n	1d090 <__addsf3+0x140>
   1d04c:	ea92 0f03 	teq	r2, r3
   1d050:	d004      	beq.n	1d05c <__addsf3+0x10c>
   1d052:	f092 0f00 	teq	r2, #0
   1d056:	bf08      	it	eq
   1d058:	4608      	moveq	r0, r1
   1d05a:	4770      	bx	lr
   1d05c:	ea90 0f01 	teq	r0, r1
   1d060:	bf1c      	itt	ne
   1d062:	2000      	movne	r0, #0
   1d064:	4770      	bxne	lr
   1d066:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
   1d06a:	d104      	bne.n	1d076 <__addsf3+0x126>
   1d06c:	0040      	lsls	r0, r0, #1
   1d06e:	bf28      	it	cs
   1d070:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
   1d074:	4770      	bx	lr
   1d076:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
   1d07a:	bf3c      	itt	cc
   1d07c:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
   1d080:	4770      	bxcc	lr
   1d082:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   1d086:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
   1d08a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1d08e:	4770      	bx	lr
   1d090:	ea7f 6222 	mvns.w	r2, r2, asr #24
   1d094:	bf16      	itet	ne
   1d096:	4608      	movne	r0, r1
   1d098:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
   1d09c:	4601      	movne	r1, r0
   1d09e:	0242      	lsls	r2, r0, #9
   1d0a0:	bf06      	itte	eq
   1d0a2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
   1d0a6:	ea90 0f01 	teqeq	r0, r1
   1d0aa:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
   1d0ae:	4770      	bx	lr

0001d0b0 <__aeabi_ui2f>:
   1d0b0:	f04f 0300 	mov.w	r3, #0
   1d0b4:	e004      	b.n	1d0c0 <__aeabi_i2f+0x8>
   1d0b6:	bf00      	nop

0001d0b8 <__aeabi_i2f>:
   1d0b8:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
   1d0bc:	bf48      	it	mi
   1d0be:	4240      	negmi	r0, r0
   1d0c0:	ea5f 0c00 	movs.w	ip, r0
   1d0c4:	bf08      	it	eq
   1d0c6:	4770      	bxeq	lr
   1d0c8:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
   1d0cc:	4601      	mov	r1, r0
   1d0ce:	f04f 0000 	mov.w	r0, #0
   1d0d2:	e01c      	b.n	1d10e <__aeabi_l2f+0x2a>

0001d0d4 <__aeabi_ul2f>:
   1d0d4:	ea50 0201 	orrs.w	r2, r0, r1
   1d0d8:	bf08      	it	eq
   1d0da:	4770      	bxeq	lr
   1d0dc:	f04f 0300 	mov.w	r3, #0
   1d0e0:	e00a      	b.n	1d0f8 <__aeabi_l2f+0x14>
   1d0e2:	bf00      	nop

0001d0e4 <__aeabi_l2f>:
   1d0e4:	ea50 0201 	orrs.w	r2, r0, r1
   1d0e8:	bf08      	it	eq
   1d0ea:	4770      	bxeq	lr
   1d0ec:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
   1d0f0:	d502      	bpl.n	1d0f8 <__aeabi_l2f+0x14>
   1d0f2:	4240      	negs	r0, r0
   1d0f4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1d0f8:	ea5f 0c01 	movs.w	ip, r1
   1d0fc:	bf02      	ittt	eq
   1d0fe:	4684      	moveq	ip, r0
   1d100:	4601      	moveq	r1, r0
   1d102:	2000      	moveq	r0, #0
   1d104:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
   1d108:	bf08      	it	eq
   1d10a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
   1d10e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   1d112:	fabc f28c 	clz	r2, ip
   1d116:	3a08      	subs	r2, #8
   1d118:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
   1d11c:	db10      	blt.n	1d140 <__aeabi_l2f+0x5c>
   1d11e:	fa01 fc02 	lsl.w	ip, r1, r2
   1d122:	4463      	add	r3, ip
   1d124:	fa00 fc02 	lsl.w	ip, r0, r2
   1d128:	f1c2 0220 	rsb	r2, r2, #32
   1d12c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   1d130:	fa20 f202 	lsr.w	r2, r0, r2
   1d134:	eb43 0002 	adc.w	r0, r3, r2
   1d138:	bf08      	it	eq
   1d13a:	f020 0001 	biceq.w	r0, r0, #1
   1d13e:	4770      	bx	lr
   1d140:	f102 0220 	add.w	r2, r2, #32
   1d144:	fa01 fc02 	lsl.w	ip, r1, r2
   1d148:	f1c2 0220 	rsb	r2, r2, #32
   1d14c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
   1d150:	fa21 f202 	lsr.w	r2, r1, r2
   1d154:	eb43 0002 	adc.w	r0, r3, r2
   1d158:	bf08      	it	eq
   1d15a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   1d15e:	4770      	bx	lr

0001d160 <__aeabi_fmul>:
   1d160:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1d164:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   1d168:	bf1e      	ittt	ne
   1d16a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   1d16e:	ea92 0f0c 	teqne	r2, ip
   1d172:	ea93 0f0c 	teqne	r3, ip
   1d176:	d06f      	beq.n	1d258 <__aeabi_fmul+0xf8>
   1d178:	441a      	add	r2, r3
   1d17a:	ea80 0c01 	eor.w	ip, r0, r1
   1d17e:	0240      	lsls	r0, r0, #9
   1d180:	bf18      	it	ne
   1d182:	ea5f 2141 	movsne.w	r1, r1, lsl #9
   1d186:	d01e      	beq.n	1d1c6 <__aeabi_fmul+0x66>
   1d188:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   1d18c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
   1d190:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
   1d194:	fba0 3101 	umull	r3, r1, r0, r1
   1d198:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   1d19c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   1d1a0:	bf3e      	ittt	cc
   1d1a2:	0049      	lslcc	r1, r1, #1
   1d1a4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
   1d1a8:	005b      	lslcc	r3, r3, #1
   1d1aa:	ea40 0001 	orr.w	r0, r0, r1
   1d1ae:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
   1d1b2:	2afd      	cmp	r2, #253	; 0xfd
   1d1b4:	d81d      	bhi.n	1d1f2 <__aeabi_fmul+0x92>
   1d1b6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   1d1ba:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   1d1be:	bf08      	it	eq
   1d1c0:	f020 0001 	biceq.w	r0, r0, #1
   1d1c4:	4770      	bx	lr
   1d1c6:	f090 0f00 	teq	r0, #0
   1d1ca:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   1d1ce:	bf08      	it	eq
   1d1d0:	0249      	lsleq	r1, r1, #9
   1d1d2:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   1d1d6:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
   1d1da:	3a7f      	subs	r2, #127	; 0x7f
   1d1dc:	bfc2      	ittt	gt
   1d1de:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   1d1e2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   1d1e6:	4770      	bxgt	lr
   1d1e8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1d1ec:	f04f 0300 	mov.w	r3, #0
   1d1f0:	3a01      	subs	r2, #1
   1d1f2:	dc5d      	bgt.n	1d2b0 <__aeabi_fmul+0x150>
   1d1f4:	f112 0f19 	cmn.w	r2, #25
   1d1f8:	bfdc      	itt	le
   1d1fa:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
   1d1fe:	4770      	bxle	lr
   1d200:	f1c2 0200 	rsb	r2, r2, #0
   1d204:	0041      	lsls	r1, r0, #1
   1d206:	fa21 f102 	lsr.w	r1, r1, r2
   1d20a:	f1c2 0220 	rsb	r2, r2, #32
   1d20e:	fa00 fc02 	lsl.w	ip, r0, r2
   1d212:	ea5f 0031 	movs.w	r0, r1, rrx
   1d216:	f140 0000 	adc.w	r0, r0, #0
   1d21a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
   1d21e:	bf08      	it	eq
   1d220:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   1d224:	4770      	bx	lr
   1d226:	f092 0f00 	teq	r2, #0
   1d22a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   1d22e:	bf02      	ittt	eq
   1d230:	0040      	lsleq	r0, r0, #1
   1d232:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   1d236:	3a01      	subeq	r2, #1
   1d238:	d0f9      	beq.n	1d22e <__aeabi_fmul+0xce>
   1d23a:	ea40 000c 	orr.w	r0, r0, ip
   1d23e:	f093 0f00 	teq	r3, #0
   1d242:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   1d246:	bf02      	ittt	eq
   1d248:	0049      	lsleq	r1, r1, #1
   1d24a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   1d24e:	3b01      	subeq	r3, #1
   1d250:	d0f9      	beq.n	1d246 <__aeabi_fmul+0xe6>
   1d252:	ea41 010c 	orr.w	r1, r1, ip
   1d256:	e78f      	b.n	1d178 <__aeabi_fmul+0x18>
   1d258:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   1d25c:	ea92 0f0c 	teq	r2, ip
   1d260:	bf18      	it	ne
   1d262:	ea93 0f0c 	teqne	r3, ip
   1d266:	d00a      	beq.n	1d27e <__aeabi_fmul+0x11e>
   1d268:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   1d26c:	bf18      	it	ne
   1d26e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   1d272:	d1d8      	bne.n	1d226 <__aeabi_fmul+0xc6>
   1d274:	ea80 0001 	eor.w	r0, r0, r1
   1d278:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   1d27c:	4770      	bx	lr
   1d27e:	f090 0f00 	teq	r0, #0
   1d282:	bf17      	itett	ne
   1d284:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
   1d288:	4608      	moveq	r0, r1
   1d28a:	f091 0f00 	teqne	r1, #0
   1d28e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
   1d292:	d014      	beq.n	1d2be <__aeabi_fmul+0x15e>
   1d294:	ea92 0f0c 	teq	r2, ip
   1d298:	d101      	bne.n	1d29e <__aeabi_fmul+0x13e>
   1d29a:	0242      	lsls	r2, r0, #9
   1d29c:	d10f      	bne.n	1d2be <__aeabi_fmul+0x15e>
   1d29e:	ea93 0f0c 	teq	r3, ip
   1d2a2:	d103      	bne.n	1d2ac <__aeabi_fmul+0x14c>
   1d2a4:	024b      	lsls	r3, r1, #9
   1d2a6:	bf18      	it	ne
   1d2a8:	4608      	movne	r0, r1
   1d2aa:	d108      	bne.n	1d2be <__aeabi_fmul+0x15e>
   1d2ac:	ea80 0001 	eor.w	r0, r0, r1
   1d2b0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   1d2b4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   1d2b8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1d2bc:	4770      	bx	lr
   1d2be:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   1d2c2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
   1d2c6:	4770      	bx	lr

0001d2c8 <__aeabi_fdiv>:
   1d2c8:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1d2cc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   1d2d0:	bf1e      	ittt	ne
   1d2d2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   1d2d6:	ea92 0f0c 	teqne	r2, ip
   1d2da:	ea93 0f0c 	teqne	r3, ip
   1d2de:	d069      	beq.n	1d3b4 <__aeabi_fdiv+0xec>
   1d2e0:	eba2 0203 	sub.w	r2, r2, r3
   1d2e4:	ea80 0c01 	eor.w	ip, r0, r1
   1d2e8:	0249      	lsls	r1, r1, #9
   1d2ea:	ea4f 2040 	mov.w	r0, r0, lsl #9
   1d2ee:	d037      	beq.n	1d360 <__aeabi_fdiv+0x98>
   1d2f0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1d2f4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
   1d2f8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
   1d2fc:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   1d300:	428b      	cmp	r3, r1
   1d302:	bf38      	it	cc
   1d304:	005b      	lslcc	r3, r3, #1
   1d306:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
   1d30a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
   1d30e:	428b      	cmp	r3, r1
   1d310:	bf24      	itt	cs
   1d312:	1a5b      	subcs	r3, r3, r1
   1d314:	ea40 000c 	orrcs.w	r0, r0, ip
   1d318:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
   1d31c:	bf24      	itt	cs
   1d31e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
   1d322:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   1d326:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
   1d32a:	bf24      	itt	cs
   1d32c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
   1d330:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   1d334:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   1d338:	bf24      	itt	cs
   1d33a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
   1d33e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   1d342:	011b      	lsls	r3, r3, #4
   1d344:	bf18      	it	ne
   1d346:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
   1d34a:	d1e0      	bne.n	1d30e <__aeabi_fdiv+0x46>
   1d34c:	2afd      	cmp	r2, #253	; 0xfd
   1d34e:	f63f af50 	bhi.w	1d1f2 <__aeabi_fmul+0x92>
   1d352:	428b      	cmp	r3, r1
   1d354:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   1d358:	bf08      	it	eq
   1d35a:	f020 0001 	biceq.w	r0, r0, #1
   1d35e:	4770      	bx	lr
   1d360:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   1d364:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   1d368:	327f      	adds	r2, #127	; 0x7f
   1d36a:	bfc2      	ittt	gt
   1d36c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   1d370:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   1d374:	4770      	bxgt	lr
   1d376:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1d37a:	f04f 0300 	mov.w	r3, #0
   1d37e:	3a01      	subs	r2, #1
   1d380:	e737      	b.n	1d1f2 <__aeabi_fmul+0x92>
   1d382:	f092 0f00 	teq	r2, #0
   1d386:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   1d38a:	bf02      	ittt	eq
   1d38c:	0040      	lsleq	r0, r0, #1
   1d38e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   1d392:	3a01      	subeq	r2, #1
   1d394:	d0f9      	beq.n	1d38a <__aeabi_fdiv+0xc2>
   1d396:	ea40 000c 	orr.w	r0, r0, ip
   1d39a:	f093 0f00 	teq	r3, #0
   1d39e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   1d3a2:	bf02      	ittt	eq
   1d3a4:	0049      	lsleq	r1, r1, #1
   1d3a6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   1d3aa:	3b01      	subeq	r3, #1
   1d3ac:	d0f9      	beq.n	1d3a2 <__aeabi_fdiv+0xda>
   1d3ae:	ea41 010c 	orr.w	r1, r1, ip
   1d3b2:	e795      	b.n	1d2e0 <__aeabi_fdiv+0x18>
   1d3b4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   1d3b8:	ea92 0f0c 	teq	r2, ip
   1d3bc:	d108      	bne.n	1d3d0 <__aeabi_fdiv+0x108>
   1d3be:	0242      	lsls	r2, r0, #9
   1d3c0:	f47f af7d 	bne.w	1d2be <__aeabi_fmul+0x15e>
   1d3c4:	ea93 0f0c 	teq	r3, ip
   1d3c8:	f47f af70 	bne.w	1d2ac <__aeabi_fmul+0x14c>
   1d3cc:	4608      	mov	r0, r1
   1d3ce:	e776      	b.n	1d2be <__aeabi_fmul+0x15e>
   1d3d0:	ea93 0f0c 	teq	r3, ip
   1d3d4:	d104      	bne.n	1d3e0 <__aeabi_fdiv+0x118>
   1d3d6:	024b      	lsls	r3, r1, #9
   1d3d8:	f43f af4c 	beq.w	1d274 <__aeabi_fmul+0x114>
   1d3dc:	4608      	mov	r0, r1
   1d3de:	e76e      	b.n	1d2be <__aeabi_fmul+0x15e>
   1d3e0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   1d3e4:	bf18      	it	ne
   1d3e6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   1d3ea:	d1ca      	bne.n	1d382 <__aeabi_fdiv+0xba>
   1d3ec:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
   1d3f0:	f47f af5c 	bne.w	1d2ac <__aeabi_fmul+0x14c>
   1d3f4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
   1d3f8:	f47f af3c 	bne.w	1d274 <__aeabi_fmul+0x114>
   1d3fc:	e75f      	b.n	1d2be <__aeabi_fmul+0x15e>
   1d3fe:	bf00      	nop

0001d400 <__gesf2>:
   1d400:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   1d404:	e006      	b.n	1d414 <__cmpsf2+0x4>
   1d406:	bf00      	nop

0001d408 <__lesf2>:
   1d408:	f04f 0c01 	mov.w	ip, #1
   1d40c:	e002      	b.n	1d414 <__cmpsf2+0x4>
   1d40e:	bf00      	nop

0001d410 <__cmpsf2>:
   1d410:	f04f 0c01 	mov.w	ip, #1
   1d414:	f84d cd04 	str.w	ip, [sp, #-4]!
   1d418:	ea4f 0240 	mov.w	r2, r0, lsl #1
   1d41c:	ea4f 0341 	mov.w	r3, r1, lsl #1
   1d420:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   1d424:	bf18      	it	ne
   1d426:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   1d42a:	d011      	beq.n	1d450 <__cmpsf2+0x40>
   1d42c:	b001      	add	sp, #4
   1d42e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
   1d432:	bf18      	it	ne
   1d434:	ea90 0f01 	teqne	r0, r1
   1d438:	bf58      	it	pl
   1d43a:	ebb2 0003 	subspl.w	r0, r2, r3
   1d43e:	bf88      	it	hi
   1d440:	17c8      	asrhi	r0, r1, #31
   1d442:	bf38      	it	cc
   1d444:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
   1d448:	bf18      	it	ne
   1d44a:	f040 0001 	orrne.w	r0, r0, #1
   1d44e:	4770      	bx	lr
   1d450:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   1d454:	d102      	bne.n	1d45c <__cmpsf2+0x4c>
   1d456:	ea5f 2c40 	movs.w	ip, r0, lsl #9
   1d45a:	d105      	bne.n	1d468 <__cmpsf2+0x58>
   1d45c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
   1d460:	d1e4      	bne.n	1d42c <__cmpsf2+0x1c>
   1d462:	ea5f 2c41 	movs.w	ip, r1, lsl #9
   1d466:	d0e1      	beq.n	1d42c <__cmpsf2+0x1c>
   1d468:	f85d 0b04 	ldr.w	r0, [sp], #4
   1d46c:	4770      	bx	lr
   1d46e:	bf00      	nop

0001d470 <__aeabi_cfrcmple>:
   1d470:	4684      	mov	ip, r0
   1d472:	4608      	mov	r0, r1
   1d474:	4661      	mov	r1, ip
   1d476:	e7ff      	b.n	1d478 <__aeabi_cfcmpeq>

0001d478 <__aeabi_cfcmpeq>:
   1d478:	b50f      	push	{r0, r1, r2, r3, lr}
   1d47a:	f7ff ffc9 	bl	1d410 <__cmpsf2>
   1d47e:	2800      	cmp	r0, #0
   1d480:	bf48      	it	mi
   1d482:	f110 0f00 	cmnmi.w	r0, #0
   1d486:	bd0f      	pop	{r0, r1, r2, r3, pc}

0001d488 <__aeabi_fcmpeq>:
   1d488:	f84d ed08 	str.w	lr, [sp, #-8]!
   1d48c:	f7ff fff4 	bl	1d478 <__aeabi_cfcmpeq>
   1d490:	bf0c      	ite	eq
   1d492:	2001      	moveq	r0, #1
   1d494:	2000      	movne	r0, #0
   1d496:	f85d fb08 	ldr.w	pc, [sp], #8
   1d49a:	bf00      	nop

0001d49c <__aeabi_fcmplt>:
   1d49c:	f84d ed08 	str.w	lr, [sp, #-8]!
   1d4a0:	f7ff ffea 	bl	1d478 <__aeabi_cfcmpeq>
   1d4a4:	bf34      	ite	cc
   1d4a6:	2001      	movcc	r0, #1
   1d4a8:	2000      	movcs	r0, #0
   1d4aa:	f85d fb08 	ldr.w	pc, [sp], #8
   1d4ae:	bf00      	nop

0001d4b0 <__aeabi_fcmple>:
   1d4b0:	f84d ed08 	str.w	lr, [sp, #-8]!
   1d4b4:	f7ff ffe0 	bl	1d478 <__aeabi_cfcmpeq>
   1d4b8:	bf94      	ite	ls
   1d4ba:	2001      	movls	r0, #1
   1d4bc:	2000      	movhi	r0, #0
   1d4be:	f85d fb08 	ldr.w	pc, [sp], #8
   1d4c2:	bf00      	nop

0001d4c4 <__aeabi_fcmpge>:
   1d4c4:	f84d ed08 	str.w	lr, [sp, #-8]!
   1d4c8:	f7ff ffd2 	bl	1d470 <__aeabi_cfrcmple>
   1d4cc:	bf94      	ite	ls
   1d4ce:	2001      	movls	r0, #1
   1d4d0:	2000      	movhi	r0, #0
   1d4d2:	f85d fb08 	ldr.w	pc, [sp], #8
   1d4d6:	bf00      	nop

0001d4d8 <__aeabi_fcmpgt>:
   1d4d8:	f84d ed08 	str.w	lr, [sp, #-8]!
   1d4dc:	f7ff ffc8 	bl	1d470 <__aeabi_cfrcmple>
   1d4e0:	bf34      	ite	cc
   1d4e2:	2001      	movcc	r0, #1
   1d4e4:	2000      	movcs	r0, #0
   1d4e6:	f85d fb08 	ldr.w	pc, [sp], #8
   1d4ea:	bf00      	nop

0001d4ec <__aeabi_fcmpun>:
   1d4ec:	ea4f 0240 	mov.w	r2, r0, lsl #1
   1d4f0:	ea4f 0341 	mov.w	r3, r1, lsl #1
   1d4f4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   1d4f8:	d102      	bne.n	1d500 <__aeabi_fcmpun+0x14>
   1d4fa:	ea5f 2c40 	movs.w	ip, r0, lsl #9
   1d4fe:	d108      	bne.n	1d512 <__aeabi_fcmpun+0x26>
   1d500:	ea7f 6c23 	mvns.w	ip, r3, asr #24
   1d504:	d102      	bne.n	1d50c <__aeabi_fcmpun+0x20>
   1d506:	ea5f 2c41 	movs.w	ip, r1, lsl #9
   1d50a:	d102      	bne.n	1d512 <__aeabi_fcmpun+0x26>
   1d50c:	f04f 0000 	mov.w	r0, #0
   1d510:	4770      	bx	lr
   1d512:	f04f 0001 	mov.w	r0, #1
   1d516:	4770      	bx	lr

0001d518 <__aeabi_f2iz>:
   1d518:	ea4f 0240 	mov.w	r2, r0, lsl #1
   1d51c:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   1d520:	d30f      	bcc.n	1d542 <__aeabi_f2iz+0x2a>
   1d522:	f04f 039e 	mov.w	r3, #158	; 0x9e
   1d526:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
   1d52a:	d90d      	bls.n	1d548 <__aeabi_f2iz+0x30>
   1d52c:	ea4f 2300 	mov.w	r3, r0, lsl #8
   1d530:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1d534:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   1d538:	fa23 f002 	lsr.w	r0, r3, r2
   1d53c:	bf18      	it	ne
   1d53e:	4240      	negne	r0, r0
   1d540:	4770      	bx	lr
   1d542:	f04f 0000 	mov.w	r0, #0
   1d546:	4770      	bx	lr
   1d548:	f112 0f61 	cmn.w	r2, #97	; 0x61
   1d54c:	d101      	bne.n	1d552 <__aeabi_f2iz+0x3a>
   1d54e:	0242      	lsls	r2, r0, #9
   1d550:	d105      	bne.n	1d55e <__aeabi_f2iz+0x46>
   1d552:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
   1d556:	bf08      	it	eq
   1d558:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   1d55c:	4770      	bx	lr
   1d55e:	f04f 0000 	mov.w	r0, #0
   1d562:	4770      	bx	lr

0001d564 <__aeabi_f2lz>:
   1d564:	b510      	push	{r4, lr}
   1d566:	2100      	movs	r1, #0
   1d568:	4604      	mov	r4, r0
   1d56a:	f7ff ff97 	bl	1d49c <__aeabi_fcmplt>
   1d56e:	b920      	cbnz	r0, 1d57a <__aeabi_f2lz+0x16>
   1d570:	4620      	mov	r0, r4
   1d572:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1d576:	f000 b809 	b.w	1d58c <__aeabi_f2ulz>
   1d57a:	f104 4000 	add.w	r0, r4, #2147483648	; 0x80000000
   1d57e:	f000 f805 	bl	1d58c <__aeabi_f2ulz>
   1d582:	4240      	negs	r0, r0
   1d584:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1d588:	bd10      	pop	{r4, pc}
   1d58a:	bf00      	nop

0001d58c <__aeabi_f2ulz>:
   1d58c:	b5d0      	push	{r4, r6, r7, lr}
   1d58e:	f7ff f9ff 	bl	1c990 <__aeabi_f2d>
   1d592:	4b0c      	ldr	r3, [pc, #48]	; (1d5c4 <__aeabi_f2ulz+0x38>)
   1d594:	2200      	movs	r2, #0
   1d596:	4606      	mov	r6, r0
   1d598:	460f      	mov	r7, r1
   1d59a:	f7ff fa51 	bl	1ca40 <__aeabi_dmul>
   1d59e:	f7ff fc61 	bl	1ce64 <__aeabi_d2uiz>
   1d5a2:	4604      	mov	r4, r0
   1d5a4:	f7ff f9d2 	bl	1c94c <__aeabi_ui2d>
   1d5a8:	4b07      	ldr	r3, [pc, #28]	; (1d5c8 <__aeabi_f2ulz+0x3c>)
   1d5aa:	2200      	movs	r2, #0
   1d5ac:	f7ff fa48 	bl	1ca40 <__aeabi_dmul>
   1d5b0:	4602      	mov	r2, r0
   1d5b2:	460b      	mov	r3, r1
   1d5b4:	4630      	mov	r0, r6
   1d5b6:	4639      	mov	r1, r7
   1d5b8:	f7ff f88a 	bl	1c6d0 <__aeabi_dsub>
   1d5bc:	f7ff fc52 	bl	1ce64 <__aeabi_d2uiz>
   1d5c0:	4621      	mov	r1, r4
   1d5c2:	bdd0      	pop	{r4, r6, r7, pc}
   1d5c4:	3df00000 	.word	0x3df00000
   1d5c8:	41f00000 	.word	0x41f00000

0001d5cc <malloc>:
   1d5cc:	4b02      	ldr	r3, [pc, #8]	; (1d5d8 <malloc+0xc>)
   1d5ce:	4601      	mov	r1, r0
   1d5d0:	6818      	ldr	r0, [r3, #0]
   1d5d2:	f000 b823 	b.w	1d61c <_malloc_r>
   1d5d6:	bf00      	nop
   1d5d8:	1fffa320 	.word	0x1fffa320

0001d5dc <sbrk_aligned>:
   1d5dc:	b570      	push	{r4, r5, r6, lr}
   1d5de:	4e0e      	ldr	r6, [pc, #56]	; (1d618 <sbrk_aligned+0x3c>)
   1d5e0:	460c      	mov	r4, r1
   1d5e2:	6831      	ldr	r1, [r6, #0]
   1d5e4:	4605      	mov	r5, r0
   1d5e6:	b911      	cbnz	r1, 1d5ee <sbrk_aligned+0x12>
   1d5e8:	f000 f8ee 	bl	1d7c8 <_sbrk_r>
   1d5ec:	6030      	str	r0, [r6, #0]
   1d5ee:	4621      	mov	r1, r4
   1d5f0:	4628      	mov	r0, r5
   1d5f2:	f000 f8e9 	bl	1d7c8 <_sbrk_r>
   1d5f6:	1c43      	adds	r3, r0, #1
   1d5f8:	d00a      	beq.n	1d610 <sbrk_aligned+0x34>
   1d5fa:	1cc4      	adds	r4, r0, #3
   1d5fc:	f024 0403 	bic.w	r4, r4, #3
   1d600:	42a0      	cmp	r0, r4
   1d602:	d007      	beq.n	1d614 <sbrk_aligned+0x38>
   1d604:	1a21      	subs	r1, r4, r0
   1d606:	4628      	mov	r0, r5
   1d608:	f000 f8de 	bl	1d7c8 <_sbrk_r>
   1d60c:	3001      	adds	r0, #1
   1d60e:	d101      	bne.n	1d614 <sbrk_aligned+0x38>
   1d610:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1d614:	4620      	mov	r0, r4
   1d616:	bd70      	pop	{r4, r5, r6, pc}
   1d618:	200068d0 	.word	0x200068d0

0001d61c <_malloc_r>:
   1d61c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d620:	1ccd      	adds	r5, r1, #3
   1d622:	f025 0503 	bic.w	r5, r5, #3
   1d626:	3508      	adds	r5, #8
   1d628:	2d0c      	cmp	r5, #12
   1d62a:	bf38      	it	cc
   1d62c:	250c      	movcc	r5, #12
   1d62e:	2d00      	cmp	r5, #0
   1d630:	4607      	mov	r7, r0
   1d632:	db01      	blt.n	1d638 <_malloc_r+0x1c>
   1d634:	42a9      	cmp	r1, r5
   1d636:	d905      	bls.n	1d644 <_malloc_r+0x28>
   1d638:	230c      	movs	r3, #12
   1d63a:	603b      	str	r3, [r7, #0]
   1d63c:	2600      	movs	r6, #0
   1d63e:	4630      	mov	r0, r6
   1d640:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1d644:	4e2f      	ldr	r6, [pc, #188]	; (1d704 <_malloc_r+0xe8>)
   1d646:	f000 f85f 	bl	1d708 <__malloc_lock>
   1d64a:	6833      	ldr	r3, [r6, #0]
   1d64c:	461c      	mov	r4, r3
   1d64e:	bb44      	cbnz	r4, 1d6a2 <_malloc_r+0x86>
   1d650:	4629      	mov	r1, r5
   1d652:	4638      	mov	r0, r7
   1d654:	f7ff ffc2 	bl	1d5dc <sbrk_aligned>
   1d658:	1c43      	adds	r3, r0, #1
   1d65a:	4604      	mov	r4, r0
   1d65c:	d14f      	bne.n	1d6fe <_malloc_r+0xe2>
   1d65e:	6834      	ldr	r4, [r6, #0]
   1d660:	4626      	mov	r6, r4
   1d662:	2e00      	cmp	r6, #0
   1d664:	d142      	bne.n	1d6ec <_malloc_r+0xd0>
   1d666:	2c00      	cmp	r4, #0
   1d668:	d043      	beq.n	1d6f2 <_malloc_r+0xd6>
   1d66a:	6823      	ldr	r3, [r4, #0]
   1d66c:	4631      	mov	r1, r6
   1d66e:	4638      	mov	r0, r7
   1d670:	eb04 0803 	add.w	r8, r4, r3
   1d674:	f000 f8a8 	bl	1d7c8 <_sbrk_r>
   1d678:	4580      	cmp	r8, r0
   1d67a:	d13a      	bne.n	1d6f2 <_malloc_r+0xd6>
   1d67c:	6823      	ldr	r3, [r4, #0]
   1d67e:	3503      	adds	r5, #3
   1d680:	1aed      	subs	r5, r5, r3
   1d682:	f025 0503 	bic.w	r5, r5, #3
   1d686:	3508      	adds	r5, #8
   1d688:	2d0c      	cmp	r5, #12
   1d68a:	bf38      	it	cc
   1d68c:	250c      	movcc	r5, #12
   1d68e:	4629      	mov	r1, r5
   1d690:	4638      	mov	r0, r7
   1d692:	f7ff ffa3 	bl	1d5dc <sbrk_aligned>
   1d696:	3001      	adds	r0, #1
   1d698:	d02b      	beq.n	1d6f2 <_malloc_r+0xd6>
   1d69a:	6823      	ldr	r3, [r4, #0]
   1d69c:	442b      	add	r3, r5
   1d69e:	6023      	str	r3, [r4, #0]
   1d6a0:	e00e      	b.n	1d6c0 <_malloc_r+0xa4>
   1d6a2:	6822      	ldr	r2, [r4, #0]
   1d6a4:	1b52      	subs	r2, r2, r5
   1d6a6:	d41e      	bmi.n	1d6e6 <_malloc_r+0xca>
   1d6a8:	2a0b      	cmp	r2, #11
   1d6aa:	d916      	bls.n	1d6da <_malloc_r+0xbe>
   1d6ac:	1961      	adds	r1, r4, r5
   1d6ae:	42a3      	cmp	r3, r4
   1d6b0:	6025      	str	r5, [r4, #0]
   1d6b2:	bf18      	it	ne
   1d6b4:	6059      	strne	r1, [r3, #4]
   1d6b6:	6863      	ldr	r3, [r4, #4]
   1d6b8:	bf08      	it	eq
   1d6ba:	6031      	streq	r1, [r6, #0]
   1d6bc:	5162      	str	r2, [r4, r5]
   1d6be:	604b      	str	r3, [r1, #4]
   1d6c0:	4638      	mov	r0, r7
   1d6c2:	f104 060b 	add.w	r6, r4, #11
   1d6c6:	f000 f825 	bl	1d714 <__malloc_unlock>
   1d6ca:	f026 0607 	bic.w	r6, r6, #7
   1d6ce:	1d23      	adds	r3, r4, #4
   1d6d0:	1af2      	subs	r2, r6, r3
   1d6d2:	d0b4      	beq.n	1d63e <_malloc_r+0x22>
   1d6d4:	1b9b      	subs	r3, r3, r6
   1d6d6:	50a3      	str	r3, [r4, r2]
   1d6d8:	e7b1      	b.n	1d63e <_malloc_r+0x22>
   1d6da:	6862      	ldr	r2, [r4, #4]
   1d6dc:	42a3      	cmp	r3, r4
   1d6de:	bf0c      	ite	eq
   1d6e0:	6032      	streq	r2, [r6, #0]
   1d6e2:	605a      	strne	r2, [r3, #4]
   1d6e4:	e7ec      	b.n	1d6c0 <_malloc_r+0xa4>
   1d6e6:	4623      	mov	r3, r4
   1d6e8:	6864      	ldr	r4, [r4, #4]
   1d6ea:	e7b0      	b.n	1d64e <_malloc_r+0x32>
   1d6ec:	4634      	mov	r4, r6
   1d6ee:	6876      	ldr	r6, [r6, #4]
   1d6f0:	e7b7      	b.n	1d662 <_malloc_r+0x46>
   1d6f2:	230c      	movs	r3, #12
   1d6f4:	603b      	str	r3, [r7, #0]
   1d6f6:	4638      	mov	r0, r7
   1d6f8:	f000 f80c 	bl	1d714 <__malloc_unlock>
   1d6fc:	e79f      	b.n	1d63e <_malloc_r+0x22>
   1d6fe:	6025      	str	r5, [r4, #0]
   1d700:	e7de      	b.n	1d6c0 <_malloc_r+0xa4>
   1d702:	bf00      	nop
   1d704:	200068cc 	.word	0x200068cc

0001d708 <__malloc_lock>:
   1d708:	4801      	ldr	r0, [pc, #4]	; (1d710 <__malloc_lock+0x8>)
   1d70a:	f000 b897 	b.w	1d83c <__retarget_lock_acquire_recursive>
   1d70e:	bf00      	nop
   1d710:	20006a0c 	.word	0x20006a0c

0001d714 <__malloc_unlock>:
   1d714:	4801      	ldr	r0, [pc, #4]	; (1d71c <__malloc_unlock+0x8>)
   1d716:	f000 b892 	b.w	1d83e <__retarget_lock_release_recursive>
   1d71a:	bf00      	nop
   1d71c:	20006a0c 	.word	0x20006a0c

0001d720 <_vsniprintf_r>:
   1d720:	b530      	push	{r4, r5, lr}
   1d722:	4614      	mov	r4, r2
   1d724:	2c00      	cmp	r4, #0
   1d726:	b09b      	sub	sp, #108	; 0x6c
   1d728:	4605      	mov	r5, r0
   1d72a:	461a      	mov	r2, r3
   1d72c:	da05      	bge.n	1d73a <_vsniprintf_r+0x1a>
   1d72e:	238b      	movs	r3, #139	; 0x8b
   1d730:	6003      	str	r3, [r0, #0]
   1d732:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1d736:	b01b      	add	sp, #108	; 0x6c
   1d738:	bd30      	pop	{r4, r5, pc}
   1d73a:	f44f 7302 	mov.w	r3, #520	; 0x208
   1d73e:	f8ad 300c 	strh.w	r3, [sp, #12]
   1d742:	bf14      	ite	ne
   1d744:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
   1d748:	4623      	moveq	r3, r4
   1d74a:	9302      	str	r3, [sp, #8]
   1d74c:	9305      	str	r3, [sp, #20]
   1d74e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1d752:	9100      	str	r1, [sp, #0]
   1d754:	9104      	str	r1, [sp, #16]
   1d756:	f8ad 300e 	strh.w	r3, [sp, #14]
   1d75a:	4669      	mov	r1, sp
   1d75c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1d75e:	f000 f921 	bl	1d9a4 <_svfiprintf_r>
   1d762:	1c43      	adds	r3, r0, #1
   1d764:	bfbc      	itt	lt
   1d766:	238b      	movlt	r3, #139	; 0x8b
   1d768:	602b      	strlt	r3, [r5, #0]
   1d76a:	2c00      	cmp	r4, #0
   1d76c:	d0e3      	beq.n	1d736 <_vsniprintf_r+0x16>
   1d76e:	9b00      	ldr	r3, [sp, #0]
   1d770:	2200      	movs	r2, #0
   1d772:	701a      	strb	r2, [r3, #0]
   1d774:	e7df      	b.n	1d736 <_vsniprintf_r+0x16>
   1d776:	Address 0x000000000001d776 is out of bounds.


0001d778 <vsniprintf>:
   1d778:	b507      	push	{r0, r1, r2, lr}
   1d77a:	9300      	str	r3, [sp, #0]
   1d77c:	4613      	mov	r3, r2
   1d77e:	460a      	mov	r2, r1
   1d780:	4601      	mov	r1, r0
   1d782:	4803      	ldr	r0, [pc, #12]	; (1d790 <vsniprintf+0x18>)
   1d784:	6800      	ldr	r0, [r0, #0]
   1d786:	f7ff ffcb 	bl	1d720 <_vsniprintf_r>
   1d78a:	b003      	add	sp, #12
   1d78c:	f85d fb04 	ldr.w	pc, [sp], #4
   1d790:	1fffa320 	.word	0x1fffa320

0001d794 <memmove>:
   1d794:	4288      	cmp	r0, r1
   1d796:	b510      	push	{r4, lr}
   1d798:	eb01 0402 	add.w	r4, r1, r2
   1d79c:	d902      	bls.n	1d7a4 <memmove+0x10>
   1d79e:	4284      	cmp	r4, r0
   1d7a0:	4623      	mov	r3, r4
   1d7a2:	d807      	bhi.n	1d7b4 <memmove+0x20>
   1d7a4:	1e43      	subs	r3, r0, #1
   1d7a6:	42a1      	cmp	r1, r4
   1d7a8:	d008      	beq.n	1d7bc <memmove+0x28>
   1d7aa:	f811 2b01 	ldrb.w	r2, [r1], #1
   1d7ae:	f803 2f01 	strb.w	r2, [r3, #1]!
   1d7b2:	e7f8      	b.n	1d7a6 <memmove+0x12>
   1d7b4:	4402      	add	r2, r0
   1d7b6:	4601      	mov	r1, r0
   1d7b8:	428a      	cmp	r2, r1
   1d7ba:	d100      	bne.n	1d7be <memmove+0x2a>
   1d7bc:	bd10      	pop	{r4, pc}
   1d7be:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   1d7c2:	f802 4d01 	strb.w	r4, [r2, #-1]!
   1d7c6:	e7f7      	b.n	1d7b8 <memmove+0x24>

0001d7c8 <_sbrk_r>:
   1d7c8:	b538      	push	{r3, r4, r5, lr}
   1d7ca:	4d06      	ldr	r5, [pc, #24]	; (1d7e4 <_sbrk_r+0x1c>)
   1d7cc:	2300      	movs	r3, #0
   1d7ce:	4604      	mov	r4, r0
   1d7d0:	4608      	mov	r0, r1
   1d7d2:	602b      	str	r3, [r5, #0]
   1d7d4:	f7fc fd28 	bl	1a228 <_sbrk>
   1d7d8:	1c43      	adds	r3, r0, #1
   1d7da:	d102      	bne.n	1d7e2 <_sbrk_r+0x1a>
   1d7dc:	682b      	ldr	r3, [r5, #0]
   1d7de:	b103      	cbz	r3, 1d7e2 <_sbrk_r+0x1a>
   1d7e0:	6023      	str	r3, [r4, #0]
   1d7e2:	bd38      	pop	{r3, r4, r5, pc}
   1d7e4:	20006a10 	.word	0x20006a10

0001d7e8 <__errno>:
   1d7e8:	4b01      	ldr	r3, [pc, #4]	; (1d7f0 <__errno+0x8>)
   1d7ea:	6818      	ldr	r0, [r3, #0]
   1d7ec:	4770      	bx	lr
   1d7ee:	bf00      	nop
   1d7f0:	1fffa320 	.word	0x1fffa320

0001d7f4 <__libc_init_array>:
   1d7f4:	b570      	push	{r4, r5, r6, lr}
   1d7f6:	4d0d      	ldr	r5, [pc, #52]	; (1d82c <__libc_init_array+0x38>)
   1d7f8:	4c0d      	ldr	r4, [pc, #52]	; (1d830 <__libc_init_array+0x3c>)
   1d7fa:	1b64      	subs	r4, r4, r5
   1d7fc:	10a4      	asrs	r4, r4, #2
   1d7fe:	2600      	movs	r6, #0
   1d800:	42a6      	cmp	r6, r4
   1d802:	d109      	bne.n	1d818 <__libc_init_array+0x24>
   1d804:	4d0b      	ldr	r5, [pc, #44]	; (1d834 <__libc_init_array+0x40>)
   1d806:	4c0c      	ldr	r4, [pc, #48]	; (1d838 <__libc_init_array+0x44>)
   1d808:	f00a fc42 	bl	28090 <_init>
   1d80c:	1b64      	subs	r4, r4, r5
   1d80e:	10a4      	asrs	r4, r4, #2
   1d810:	2600      	movs	r6, #0
   1d812:	42a6      	cmp	r6, r4
   1d814:	d105      	bne.n	1d822 <__libc_init_array+0x2e>
   1d816:	bd70      	pop	{r4, r5, r6, pc}
   1d818:	f855 3b04 	ldr.w	r3, [r5], #4
   1d81c:	4798      	blx	r3
   1d81e:	3601      	adds	r6, #1
   1d820:	e7ee      	b.n	1d800 <__libc_init_array+0xc>
   1d822:	f855 3b04 	ldr.w	r3, [r5], #4
   1d826:	4798      	blx	r3
   1d828:	3601      	adds	r6, #1
   1d82a:	e7f2      	b.n	1d812 <__libc_init_array+0x1e>
   1d82c:	000280a8 	.word	0x000280a8
   1d830:	000280a8 	.word	0x000280a8
   1d834:	000280a8 	.word	0x000280a8
   1d838:	000280c4 	.word	0x000280c4

0001d83c <__retarget_lock_acquire_recursive>:
   1d83c:	4770      	bx	lr

0001d83e <__retarget_lock_release_recursive>:
   1d83e:	4770      	bx	lr

0001d840 <__cxa_atexit>:
   1d840:	b510      	push	{r4, lr}
   1d842:	4604      	mov	r4, r0
   1d844:	4804      	ldr	r0, [pc, #16]	; (1d858 <__cxa_atexit+0x18>)
   1d846:	4613      	mov	r3, r2
   1d848:	b120      	cbz	r0, 1d854 <__cxa_atexit+0x14>
   1d84a:	460a      	mov	r2, r1
   1d84c:	2002      	movs	r0, #2
   1d84e:	4621      	mov	r1, r4
   1d850:	f3af 8000 	nop.w
   1d854:	bd10      	pop	{r4, pc}
   1d856:	bf00      	nop
   1d858:	00000000 	.word	0x00000000

0001d85c <_free_r>:
   1d85c:	b538      	push	{r3, r4, r5, lr}
   1d85e:	4605      	mov	r5, r0
   1d860:	2900      	cmp	r1, #0
   1d862:	d041      	beq.n	1d8e8 <_free_r+0x8c>
   1d864:	f851 3c04 	ldr.w	r3, [r1, #-4]
   1d868:	1f0c      	subs	r4, r1, #4
   1d86a:	2b00      	cmp	r3, #0
   1d86c:	bfb8      	it	lt
   1d86e:	18e4      	addlt	r4, r4, r3
   1d870:	f7ff ff4a 	bl	1d708 <__malloc_lock>
   1d874:	4a1d      	ldr	r2, [pc, #116]	; (1d8ec <_free_r+0x90>)
   1d876:	6813      	ldr	r3, [r2, #0]
   1d878:	b933      	cbnz	r3, 1d888 <_free_r+0x2c>
   1d87a:	6063      	str	r3, [r4, #4]
   1d87c:	6014      	str	r4, [r2, #0]
   1d87e:	4628      	mov	r0, r5
   1d880:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1d884:	f7ff bf46 	b.w	1d714 <__malloc_unlock>
   1d888:	42a3      	cmp	r3, r4
   1d88a:	d908      	bls.n	1d89e <_free_r+0x42>
   1d88c:	6820      	ldr	r0, [r4, #0]
   1d88e:	1821      	adds	r1, r4, r0
   1d890:	428b      	cmp	r3, r1
   1d892:	bf01      	itttt	eq
   1d894:	6819      	ldreq	r1, [r3, #0]
   1d896:	685b      	ldreq	r3, [r3, #4]
   1d898:	1809      	addeq	r1, r1, r0
   1d89a:	6021      	streq	r1, [r4, #0]
   1d89c:	e7ed      	b.n	1d87a <_free_r+0x1e>
   1d89e:	461a      	mov	r2, r3
   1d8a0:	685b      	ldr	r3, [r3, #4]
   1d8a2:	b10b      	cbz	r3, 1d8a8 <_free_r+0x4c>
   1d8a4:	42a3      	cmp	r3, r4
   1d8a6:	d9fa      	bls.n	1d89e <_free_r+0x42>
   1d8a8:	6811      	ldr	r1, [r2, #0]
   1d8aa:	1850      	adds	r0, r2, r1
   1d8ac:	42a0      	cmp	r0, r4
   1d8ae:	d10b      	bne.n	1d8c8 <_free_r+0x6c>
   1d8b0:	6820      	ldr	r0, [r4, #0]
   1d8b2:	4401      	add	r1, r0
   1d8b4:	1850      	adds	r0, r2, r1
   1d8b6:	4283      	cmp	r3, r0
   1d8b8:	6011      	str	r1, [r2, #0]
   1d8ba:	d1e0      	bne.n	1d87e <_free_r+0x22>
   1d8bc:	6818      	ldr	r0, [r3, #0]
   1d8be:	685b      	ldr	r3, [r3, #4]
   1d8c0:	6053      	str	r3, [r2, #4]
   1d8c2:	4408      	add	r0, r1
   1d8c4:	6010      	str	r0, [r2, #0]
   1d8c6:	e7da      	b.n	1d87e <_free_r+0x22>
   1d8c8:	d902      	bls.n	1d8d0 <_free_r+0x74>
   1d8ca:	230c      	movs	r3, #12
   1d8cc:	602b      	str	r3, [r5, #0]
   1d8ce:	e7d6      	b.n	1d87e <_free_r+0x22>
   1d8d0:	6820      	ldr	r0, [r4, #0]
   1d8d2:	1821      	adds	r1, r4, r0
   1d8d4:	428b      	cmp	r3, r1
   1d8d6:	bf04      	itt	eq
   1d8d8:	6819      	ldreq	r1, [r3, #0]
   1d8da:	685b      	ldreq	r3, [r3, #4]
   1d8dc:	6063      	str	r3, [r4, #4]
   1d8de:	bf04      	itt	eq
   1d8e0:	1809      	addeq	r1, r1, r0
   1d8e2:	6021      	streq	r1, [r4, #0]
   1d8e4:	6054      	str	r4, [r2, #4]
   1d8e6:	e7ca      	b.n	1d87e <_free_r+0x22>
   1d8e8:	bd38      	pop	{r3, r4, r5, pc}
   1d8ea:	bf00      	nop
   1d8ec:	200068cc 	.word	0x200068cc

0001d8f0 <__ssputs_r>:
   1d8f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d8f4:	688e      	ldr	r6, [r1, #8]
   1d8f6:	461f      	mov	r7, r3
   1d8f8:	42be      	cmp	r6, r7
   1d8fa:	680b      	ldr	r3, [r1, #0]
   1d8fc:	4682      	mov	sl, r0
   1d8fe:	460c      	mov	r4, r1
   1d900:	4690      	mov	r8, r2
   1d902:	d82c      	bhi.n	1d95e <__ssputs_r+0x6e>
   1d904:	898a      	ldrh	r2, [r1, #12]
   1d906:	f412 6f90 	tst.w	r2, #1152	; 0x480
   1d90a:	d026      	beq.n	1d95a <__ssputs_r+0x6a>
   1d90c:	6965      	ldr	r5, [r4, #20]
   1d90e:	6909      	ldr	r1, [r1, #16]
   1d910:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   1d914:	eba3 0901 	sub.w	r9, r3, r1
   1d918:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   1d91c:	1c7b      	adds	r3, r7, #1
   1d91e:	444b      	add	r3, r9
   1d920:	106d      	asrs	r5, r5, #1
   1d922:	429d      	cmp	r5, r3
   1d924:	bf38      	it	cc
   1d926:	461d      	movcc	r5, r3
   1d928:	0553      	lsls	r3, r2, #21
   1d92a:	d527      	bpl.n	1d97c <__ssputs_r+0x8c>
   1d92c:	4629      	mov	r1, r5
   1d92e:	f7ff fe75 	bl	1d61c <_malloc_r>
   1d932:	4606      	mov	r6, r0
   1d934:	b360      	cbz	r0, 1d990 <__ssputs_r+0xa0>
   1d936:	6921      	ldr	r1, [r4, #16]
   1d938:	464a      	mov	r2, r9
   1d93a:	f7fc fb59 	bl	19ff0 <memcpy>
   1d93e:	89a3      	ldrh	r3, [r4, #12]
   1d940:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   1d944:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1d948:	81a3      	strh	r3, [r4, #12]
   1d94a:	6126      	str	r6, [r4, #16]
   1d94c:	6165      	str	r5, [r4, #20]
   1d94e:	444e      	add	r6, r9
   1d950:	eba5 0509 	sub.w	r5, r5, r9
   1d954:	6026      	str	r6, [r4, #0]
   1d956:	60a5      	str	r5, [r4, #8]
   1d958:	463e      	mov	r6, r7
   1d95a:	42be      	cmp	r6, r7
   1d95c:	d900      	bls.n	1d960 <__ssputs_r+0x70>
   1d95e:	463e      	mov	r6, r7
   1d960:	6820      	ldr	r0, [r4, #0]
   1d962:	4632      	mov	r2, r6
   1d964:	4641      	mov	r1, r8
   1d966:	f7ff ff15 	bl	1d794 <memmove>
   1d96a:	68a3      	ldr	r3, [r4, #8]
   1d96c:	1b9b      	subs	r3, r3, r6
   1d96e:	60a3      	str	r3, [r4, #8]
   1d970:	6823      	ldr	r3, [r4, #0]
   1d972:	4433      	add	r3, r6
   1d974:	6023      	str	r3, [r4, #0]
   1d976:	2000      	movs	r0, #0
   1d978:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1d97c:	462a      	mov	r2, r5
   1d97e:	f000 fa9f 	bl	1dec0 <_realloc_r>
   1d982:	4606      	mov	r6, r0
   1d984:	2800      	cmp	r0, #0
   1d986:	d1e0      	bne.n	1d94a <__ssputs_r+0x5a>
   1d988:	6921      	ldr	r1, [r4, #16]
   1d98a:	4650      	mov	r0, sl
   1d98c:	f7ff ff66 	bl	1d85c <_free_r>
   1d990:	230c      	movs	r3, #12
   1d992:	f8ca 3000 	str.w	r3, [sl]
   1d996:	89a3      	ldrh	r3, [r4, #12]
   1d998:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1d99c:	81a3      	strh	r3, [r4, #12]
   1d99e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1d9a2:	e7e9      	b.n	1d978 <__ssputs_r+0x88>

0001d9a4 <_svfiprintf_r>:
   1d9a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d9a8:	4698      	mov	r8, r3
   1d9aa:	898b      	ldrh	r3, [r1, #12]
   1d9ac:	061b      	lsls	r3, r3, #24
   1d9ae:	b09d      	sub	sp, #116	; 0x74
   1d9b0:	4607      	mov	r7, r0
   1d9b2:	460d      	mov	r5, r1
   1d9b4:	4614      	mov	r4, r2
   1d9b6:	d50e      	bpl.n	1d9d6 <_svfiprintf_r+0x32>
   1d9b8:	690b      	ldr	r3, [r1, #16]
   1d9ba:	b963      	cbnz	r3, 1d9d6 <_svfiprintf_r+0x32>
   1d9bc:	2140      	movs	r1, #64	; 0x40
   1d9be:	f7ff fe2d 	bl	1d61c <_malloc_r>
   1d9c2:	6028      	str	r0, [r5, #0]
   1d9c4:	6128      	str	r0, [r5, #16]
   1d9c6:	b920      	cbnz	r0, 1d9d2 <_svfiprintf_r+0x2e>
   1d9c8:	230c      	movs	r3, #12
   1d9ca:	603b      	str	r3, [r7, #0]
   1d9cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1d9d0:	e0d0      	b.n	1db74 <_svfiprintf_r+0x1d0>
   1d9d2:	2340      	movs	r3, #64	; 0x40
   1d9d4:	616b      	str	r3, [r5, #20]
   1d9d6:	2300      	movs	r3, #0
   1d9d8:	9309      	str	r3, [sp, #36]	; 0x24
   1d9da:	2320      	movs	r3, #32
   1d9dc:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   1d9e0:	f8cd 800c 	str.w	r8, [sp, #12]
   1d9e4:	2330      	movs	r3, #48	; 0x30
   1d9e6:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 1db8c <_svfiprintf_r+0x1e8>
   1d9ea:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   1d9ee:	f04f 0901 	mov.w	r9, #1
   1d9f2:	4623      	mov	r3, r4
   1d9f4:	469a      	mov	sl, r3
   1d9f6:	f813 2b01 	ldrb.w	r2, [r3], #1
   1d9fa:	b10a      	cbz	r2, 1da00 <_svfiprintf_r+0x5c>
   1d9fc:	2a25      	cmp	r2, #37	; 0x25
   1d9fe:	d1f9      	bne.n	1d9f4 <_svfiprintf_r+0x50>
   1da00:	ebba 0b04 	subs.w	fp, sl, r4
   1da04:	d00b      	beq.n	1da1e <_svfiprintf_r+0x7a>
   1da06:	465b      	mov	r3, fp
   1da08:	4622      	mov	r2, r4
   1da0a:	4629      	mov	r1, r5
   1da0c:	4638      	mov	r0, r7
   1da0e:	f7ff ff6f 	bl	1d8f0 <__ssputs_r>
   1da12:	3001      	adds	r0, #1
   1da14:	f000 80a9 	beq.w	1db6a <_svfiprintf_r+0x1c6>
   1da18:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1da1a:	445a      	add	r2, fp
   1da1c:	9209      	str	r2, [sp, #36]	; 0x24
   1da1e:	f89a 3000 	ldrb.w	r3, [sl]
   1da22:	2b00      	cmp	r3, #0
   1da24:	f000 80a1 	beq.w	1db6a <_svfiprintf_r+0x1c6>
   1da28:	2300      	movs	r3, #0
   1da2a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1da2e:	e9cd 2305 	strd	r2, r3, [sp, #20]
   1da32:	f10a 0a01 	add.w	sl, sl, #1
   1da36:	9304      	str	r3, [sp, #16]
   1da38:	9307      	str	r3, [sp, #28]
   1da3a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   1da3e:	931a      	str	r3, [sp, #104]	; 0x68
   1da40:	4654      	mov	r4, sl
   1da42:	2205      	movs	r2, #5
   1da44:	f814 1b01 	ldrb.w	r1, [r4], #1
   1da48:	4850      	ldr	r0, [pc, #320]	; (1db8c <_svfiprintf_r+0x1e8>)
   1da4a:	f000 fa69 	bl	1df20 <memchr>
   1da4e:	9a04      	ldr	r2, [sp, #16]
   1da50:	b9d8      	cbnz	r0, 1da8a <_svfiprintf_r+0xe6>
   1da52:	06d0      	lsls	r0, r2, #27
   1da54:	bf44      	itt	mi
   1da56:	2320      	movmi	r3, #32
   1da58:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   1da5c:	0711      	lsls	r1, r2, #28
   1da5e:	bf44      	itt	mi
   1da60:	232b      	movmi	r3, #43	; 0x2b
   1da62:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   1da66:	f89a 3000 	ldrb.w	r3, [sl]
   1da6a:	2b2a      	cmp	r3, #42	; 0x2a
   1da6c:	d015      	beq.n	1da9a <_svfiprintf_r+0xf6>
   1da6e:	9a07      	ldr	r2, [sp, #28]
   1da70:	4654      	mov	r4, sl
   1da72:	2000      	movs	r0, #0
   1da74:	f04f 0c0a 	mov.w	ip, #10
   1da78:	4621      	mov	r1, r4
   1da7a:	f811 3b01 	ldrb.w	r3, [r1], #1
   1da7e:	3b30      	subs	r3, #48	; 0x30
   1da80:	2b09      	cmp	r3, #9
   1da82:	d94d      	bls.n	1db20 <_svfiprintf_r+0x17c>
   1da84:	b1b0      	cbz	r0, 1dab4 <_svfiprintf_r+0x110>
   1da86:	9207      	str	r2, [sp, #28]
   1da88:	e014      	b.n	1dab4 <_svfiprintf_r+0x110>
   1da8a:	eba0 0308 	sub.w	r3, r0, r8
   1da8e:	fa09 f303 	lsl.w	r3, r9, r3
   1da92:	4313      	orrs	r3, r2
   1da94:	9304      	str	r3, [sp, #16]
   1da96:	46a2      	mov	sl, r4
   1da98:	e7d2      	b.n	1da40 <_svfiprintf_r+0x9c>
   1da9a:	9b03      	ldr	r3, [sp, #12]
   1da9c:	1d19      	adds	r1, r3, #4
   1da9e:	681b      	ldr	r3, [r3, #0]
   1daa0:	9103      	str	r1, [sp, #12]
   1daa2:	2b00      	cmp	r3, #0
   1daa4:	bfbb      	ittet	lt
   1daa6:	425b      	neglt	r3, r3
   1daa8:	f042 0202 	orrlt.w	r2, r2, #2
   1daac:	9307      	strge	r3, [sp, #28]
   1daae:	9307      	strlt	r3, [sp, #28]
   1dab0:	bfb8      	it	lt
   1dab2:	9204      	strlt	r2, [sp, #16]
   1dab4:	7823      	ldrb	r3, [r4, #0]
   1dab6:	2b2e      	cmp	r3, #46	; 0x2e
   1dab8:	d10c      	bne.n	1dad4 <_svfiprintf_r+0x130>
   1daba:	7863      	ldrb	r3, [r4, #1]
   1dabc:	2b2a      	cmp	r3, #42	; 0x2a
   1dabe:	d134      	bne.n	1db2a <_svfiprintf_r+0x186>
   1dac0:	9b03      	ldr	r3, [sp, #12]
   1dac2:	1d1a      	adds	r2, r3, #4
   1dac4:	681b      	ldr	r3, [r3, #0]
   1dac6:	9203      	str	r2, [sp, #12]
   1dac8:	2b00      	cmp	r3, #0
   1daca:	bfb8      	it	lt
   1dacc:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   1dad0:	3402      	adds	r4, #2
   1dad2:	9305      	str	r3, [sp, #20]
   1dad4:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 1db90 <_svfiprintf_r+0x1ec>
   1dad8:	7821      	ldrb	r1, [r4, #0]
   1dada:	2203      	movs	r2, #3
   1dadc:	4650      	mov	r0, sl
   1dade:	f000 fa1f 	bl	1df20 <memchr>
   1dae2:	b138      	cbz	r0, 1daf4 <_svfiprintf_r+0x150>
   1dae4:	9b04      	ldr	r3, [sp, #16]
   1dae6:	eba0 000a 	sub.w	r0, r0, sl
   1daea:	2240      	movs	r2, #64	; 0x40
   1daec:	4082      	lsls	r2, r0
   1daee:	4313      	orrs	r3, r2
   1daf0:	3401      	adds	r4, #1
   1daf2:	9304      	str	r3, [sp, #16]
   1daf4:	f814 1b01 	ldrb.w	r1, [r4], #1
   1daf8:	4826      	ldr	r0, [pc, #152]	; (1db94 <_svfiprintf_r+0x1f0>)
   1dafa:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   1dafe:	2206      	movs	r2, #6
   1db00:	f000 fa0e 	bl	1df20 <memchr>
   1db04:	2800      	cmp	r0, #0
   1db06:	d038      	beq.n	1db7a <_svfiprintf_r+0x1d6>
   1db08:	4b23      	ldr	r3, [pc, #140]	; (1db98 <_svfiprintf_r+0x1f4>)
   1db0a:	bb1b      	cbnz	r3, 1db54 <_svfiprintf_r+0x1b0>
   1db0c:	9b03      	ldr	r3, [sp, #12]
   1db0e:	3307      	adds	r3, #7
   1db10:	f023 0307 	bic.w	r3, r3, #7
   1db14:	3308      	adds	r3, #8
   1db16:	9303      	str	r3, [sp, #12]
   1db18:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1db1a:	4433      	add	r3, r6
   1db1c:	9309      	str	r3, [sp, #36]	; 0x24
   1db1e:	e768      	b.n	1d9f2 <_svfiprintf_r+0x4e>
   1db20:	fb0c 3202 	mla	r2, ip, r2, r3
   1db24:	460c      	mov	r4, r1
   1db26:	2001      	movs	r0, #1
   1db28:	e7a6      	b.n	1da78 <_svfiprintf_r+0xd4>
   1db2a:	2300      	movs	r3, #0
   1db2c:	3401      	adds	r4, #1
   1db2e:	9305      	str	r3, [sp, #20]
   1db30:	4619      	mov	r1, r3
   1db32:	f04f 0c0a 	mov.w	ip, #10
   1db36:	4620      	mov	r0, r4
   1db38:	f810 2b01 	ldrb.w	r2, [r0], #1
   1db3c:	3a30      	subs	r2, #48	; 0x30
   1db3e:	2a09      	cmp	r2, #9
   1db40:	d903      	bls.n	1db4a <_svfiprintf_r+0x1a6>
   1db42:	2b00      	cmp	r3, #0
   1db44:	d0c6      	beq.n	1dad4 <_svfiprintf_r+0x130>
   1db46:	9105      	str	r1, [sp, #20]
   1db48:	e7c4      	b.n	1dad4 <_svfiprintf_r+0x130>
   1db4a:	fb0c 2101 	mla	r1, ip, r1, r2
   1db4e:	4604      	mov	r4, r0
   1db50:	2301      	movs	r3, #1
   1db52:	e7f0      	b.n	1db36 <_svfiprintf_r+0x192>
   1db54:	ab03      	add	r3, sp, #12
   1db56:	9300      	str	r3, [sp, #0]
   1db58:	462a      	mov	r2, r5
   1db5a:	4b10      	ldr	r3, [pc, #64]	; (1db9c <_svfiprintf_r+0x1f8>)
   1db5c:	a904      	add	r1, sp, #16
   1db5e:	4638      	mov	r0, r7
   1db60:	f3af 8000 	nop.w
   1db64:	1c42      	adds	r2, r0, #1
   1db66:	4606      	mov	r6, r0
   1db68:	d1d6      	bne.n	1db18 <_svfiprintf_r+0x174>
   1db6a:	89ab      	ldrh	r3, [r5, #12]
   1db6c:	065b      	lsls	r3, r3, #25
   1db6e:	f53f af2d 	bmi.w	1d9cc <_svfiprintf_r+0x28>
   1db72:	9809      	ldr	r0, [sp, #36]	; 0x24
   1db74:	b01d      	add	sp, #116	; 0x74
   1db76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1db7a:	ab03      	add	r3, sp, #12
   1db7c:	9300      	str	r3, [sp, #0]
   1db7e:	462a      	mov	r2, r5
   1db80:	4b06      	ldr	r3, [pc, #24]	; (1db9c <_svfiprintf_r+0x1f8>)
   1db82:	a904      	add	r1, sp, #16
   1db84:	4638      	mov	r0, r7
   1db86:	f000 f879 	bl	1dc7c <_printf_i>
   1db8a:	e7eb      	b.n	1db64 <_svfiprintf_r+0x1c0>
   1db8c:	0002805c 	.word	0x0002805c
   1db90:	00028062 	.word	0x00028062
   1db94:	00028066 	.word	0x00028066
   1db98:	00000000 	.word	0x00000000
   1db9c:	0001d8f1 	.word	0x0001d8f1

0001dba0 <_printf_common>:
   1dba0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1dba4:	4616      	mov	r6, r2
   1dba6:	4699      	mov	r9, r3
   1dba8:	688a      	ldr	r2, [r1, #8]
   1dbaa:	690b      	ldr	r3, [r1, #16]
   1dbac:	f8dd 8020 	ldr.w	r8, [sp, #32]
   1dbb0:	4293      	cmp	r3, r2
   1dbb2:	bfb8      	it	lt
   1dbb4:	4613      	movlt	r3, r2
   1dbb6:	6033      	str	r3, [r6, #0]
   1dbb8:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   1dbbc:	4607      	mov	r7, r0
   1dbbe:	460c      	mov	r4, r1
   1dbc0:	b10a      	cbz	r2, 1dbc6 <_printf_common+0x26>
   1dbc2:	3301      	adds	r3, #1
   1dbc4:	6033      	str	r3, [r6, #0]
   1dbc6:	6823      	ldr	r3, [r4, #0]
   1dbc8:	0699      	lsls	r1, r3, #26
   1dbca:	bf42      	ittt	mi
   1dbcc:	6833      	ldrmi	r3, [r6, #0]
   1dbce:	3302      	addmi	r3, #2
   1dbd0:	6033      	strmi	r3, [r6, #0]
   1dbd2:	6825      	ldr	r5, [r4, #0]
   1dbd4:	f015 0506 	ands.w	r5, r5, #6
   1dbd8:	d106      	bne.n	1dbe8 <_printf_common+0x48>
   1dbda:	f104 0a19 	add.w	sl, r4, #25
   1dbde:	68e3      	ldr	r3, [r4, #12]
   1dbe0:	6832      	ldr	r2, [r6, #0]
   1dbe2:	1a9b      	subs	r3, r3, r2
   1dbe4:	42ab      	cmp	r3, r5
   1dbe6:	dc26      	bgt.n	1dc36 <_printf_common+0x96>
   1dbe8:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   1dbec:	1e13      	subs	r3, r2, #0
   1dbee:	6822      	ldr	r2, [r4, #0]
   1dbf0:	bf18      	it	ne
   1dbf2:	2301      	movne	r3, #1
   1dbf4:	0692      	lsls	r2, r2, #26
   1dbf6:	d42b      	bmi.n	1dc50 <_printf_common+0xb0>
   1dbf8:	f104 0243 	add.w	r2, r4, #67	; 0x43
   1dbfc:	4649      	mov	r1, r9
   1dbfe:	4638      	mov	r0, r7
   1dc00:	47c0      	blx	r8
   1dc02:	3001      	adds	r0, #1
   1dc04:	d01e      	beq.n	1dc44 <_printf_common+0xa4>
   1dc06:	6823      	ldr	r3, [r4, #0]
   1dc08:	6922      	ldr	r2, [r4, #16]
   1dc0a:	f003 0306 	and.w	r3, r3, #6
   1dc0e:	2b04      	cmp	r3, #4
   1dc10:	bf02      	ittt	eq
   1dc12:	68e5      	ldreq	r5, [r4, #12]
   1dc14:	6833      	ldreq	r3, [r6, #0]
   1dc16:	1aed      	subeq	r5, r5, r3
   1dc18:	68a3      	ldr	r3, [r4, #8]
   1dc1a:	bf0c      	ite	eq
   1dc1c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   1dc20:	2500      	movne	r5, #0
   1dc22:	4293      	cmp	r3, r2
   1dc24:	bfc4      	itt	gt
   1dc26:	1a9b      	subgt	r3, r3, r2
   1dc28:	18ed      	addgt	r5, r5, r3
   1dc2a:	2600      	movs	r6, #0
   1dc2c:	341a      	adds	r4, #26
   1dc2e:	42b5      	cmp	r5, r6
   1dc30:	d11a      	bne.n	1dc68 <_printf_common+0xc8>
   1dc32:	2000      	movs	r0, #0
   1dc34:	e008      	b.n	1dc48 <_printf_common+0xa8>
   1dc36:	2301      	movs	r3, #1
   1dc38:	4652      	mov	r2, sl
   1dc3a:	4649      	mov	r1, r9
   1dc3c:	4638      	mov	r0, r7
   1dc3e:	47c0      	blx	r8
   1dc40:	3001      	adds	r0, #1
   1dc42:	d103      	bne.n	1dc4c <_printf_common+0xac>
   1dc44:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1dc48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1dc4c:	3501      	adds	r5, #1
   1dc4e:	e7c6      	b.n	1dbde <_printf_common+0x3e>
   1dc50:	18e1      	adds	r1, r4, r3
   1dc52:	1c5a      	adds	r2, r3, #1
   1dc54:	2030      	movs	r0, #48	; 0x30
   1dc56:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   1dc5a:	4422      	add	r2, r4
   1dc5c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   1dc60:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   1dc64:	3302      	adds	r3, #2
   1dc66:	e7c7      	b.n	1dbf8 <_printf_common+0x58>
   1dc68:	2301      	movs	r3, #1
   1dc6a:	4622      	mov	r2, r4
   1dc6c:	4649      	mov	r1, r9
   1dc6e:	4638      	mov	r0, r7
   1dc70:	47c0      	blx	r8
   1dc72:	3001      	adds	r0, #1
   1dc74:	d0e6      	beq.n	1dc44 <_printf_common+0xa4>
   1dc76:	3601      	adds	r6, #1
   1dc78:	e7d9      	b.n	1dc2e <_printf_common+0x8e>
   1dc7a:	Address 0x000000000001dc7a is out of bounds.


0001dc7c <_printf_i>:
   1dc7c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   1dc80:	7e0f      	ldrb	r7, [r1, #24]
   1dc82:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   1dc84:	2f78      	cmp	r7, #120	; 0x78
   1dc86:	4691      	mov	r9, r2
   1dc88:	4680      	mov	r8, r0
   1dc8a:	460c      	mov	r4, r1
   1dc8c:	469a      	mov	sl, r3
   1dc8e:	f101 0243 	add.w	r2, r1, #67	; 0x43
   1dc92:	d807      	bhi.n	1dca4 <_printf_i+0x28>
   1dc94:	2f62      	cmp	r7, #98	; 0x62
   1dc96:	d80a      	bhi.n	1dcae <_printf_i+0x32>
   1dc98:	2f00      	cmp	r7, #0
   1dc9a:	f000 80d4 	beq.w	1de46 <_printf_i+0x1ca>
   1dc9e:	2f58      	cmp	r7, #88	; 0x58
   1dca0:	f000 80c0 	beq.w	1de24 <_printf_i+0x1a8>
   1dca4:	f104 0542 	add.w	r5, r4, #66	; 0x42
   1dca8:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
   1dcac:	e03a      	b.n	1dd24 <_printf_i+0xa8>
   1dcae:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
   1dcb2:	2b15      	cmp	r3, #21
   1dcb4:	d8f6      	bhi.n	1dca4 <_printf_i+0x28>
   1dcb6:	a101      	add	r1, pc, #4	; (adr r1, 1dcbc <_printf_i+0x40>)
   1dcb8:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
   1dcbc:	0001dd15 	.word	0x0001dd15
   1dcc0:	0001dd29 	.word	0x0001dd29
   1dcc4:	0001dca5 	.word	0x0001dca5
   1dcc8:	0001dca5 	.word	0x0001dca5
   1dccc:	0001dca5 	.word	0x0001dca5
   1dcd0:	0001dca5 	.word	0x0001dca5
   1dcd4:	0001dd29 	.word	0x0001dd29
   1dcd8:	0001dca5 	.word	0x0001dca5
   1dcdc:	0001dca5 	.word	0x0001dca5
   1dce0:	0001dca5 	.word	0x0001dca5
   1dce4:	0001dca5 	.word	0x0001dca5
   1dce8:	0001de2d 	.word	0x0001de2d
   1dcec:	0001dd55 	.word	0x0001dd55
   1dcf0:	0001dde7 	.word	0x0001dde7
   1dcf4:	0001dca5 	.word	0x0001dca5
   1dcf8:	0001dca5 	.word	0x0001dca5
   1dcfc:	0001de4f 	.word	0x0001de4f
   1dd00:	0001dca5 	.word	0x0001dca5
   1dd04:	0001dd55 	.word	0x0001dd55
   1dd08:	0001dca5 	.word	0x0001dca5
   1dd0c:	0001dca5 	.word	0x0001dca5
   1dd10:	0001ddef 	.word	0x0001ddef
   1dd14:	682b      	ldr	r3, [r5, #0]
   1dd16:	1d1a      	adds	r2, r3, #4
   1dd18:	681b      	ldr	r3, [r3, #0]
   1dd1a:	602a      	str	r2, [r5, #0]
   1dd1c:	f104 0542 	add.w	r5, r4, #66	; 0x42
   1dd20:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   1dd24:	2301      	movs	r3, #1
   1dd26:	e09f      	b.n	1de68 <_printf_i+0x1ec>
   1dd28:	6820      	ldr	r0, [r4, #0]
   1dd2a:	682b      	ldr	r3, [r5, #0]
   1dd2c:	0607      	lsls	r7, r0, #24
   1dd2e:	f103 0104 	add.w	r1, r3, #4
   1dd32:	6029      	str	r1, [r5, #0]
   1dd34:	d501      	bpl.n	1dd3a <_printf_i+0xbe>
   1dd36:	681e      	ldr	r6, [r3, #0]
   1dd38:	e003      	b.n	1dd42 <_printf_i+0xc6>
   1dd3a:	0646      	lsls	r6, r0, #25
   1dd3c:	d5fb      	bpl.n	1dd36 <_printf_i+0xba>
   1dd3e:	f9b3 6000 	ldrsh.w	r6, [r3]
   1dd42:	2e00      	cmp	r6, #0
   1dd44:	da03      	bge.n	1dd4e <_printf_i+0xd2>
   1dd46:	232d      	movs	r3, #45	; 0x2d
   1dd48:	4276      	negs	r6, r6
   1dd4a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   1dd4e:	485a      	ldr	r0, [pc, #360]	; (1deb8 <_printf_i+0x23c>)
   1dd50:	230a      	movs	r3, #10
   1dd52:	e012      	b.n	1dd7a <_printf_i+0xfe>
   1dd54:	682b      	ldr	r3, [r5, #0]
   1dd56:	6820      	ldr	r0, [r4, #0]
   1dd58:	1d19      	adds	r1, r3, #4
   1dd5a:	6029      	str	r1, [r5, #0]
   1dd5c:	0605      	lsls	r5, r0, #24
   1dd5e:	d501      	bpl.n	1dd64 <_printf_i+0xe8>
   1dd60:	681e      	ldr	r6, [r3, #0]
   1dd62:	e002      	b.n	1dd6a <_printf_i+0xee>
   1dd64:	0641      	lsls	r1, r0, #25
   1dd66:	d5fb      	bpl.n	1dd60 <_printf_i+0xe4>
   1dd68:	881e      	ldrh	r6, [r3, #0]
   1dd6a:	4853      	ldr	r0, [pc, #332]	; (1deb8 <_printf_i+0x23c>)
   1dd6c:	2f6f      	cmp	r7, #111	; 0x6f
   1dd6e:	bf0c      	ite	eq
   1dd70:	2308      	moveq	r3, #8
   1dd72:	230a      	movne	r3, #10
   1dd74:	2100      	movs	r1, #0
   1dd76:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   1dd7a:	6865      	ldr	r5, [r4, #4]
   1dd7c:	60a5      	str	r5, [r4, #8]
   1dd7e:	2d00      	cmp	r5, #0
   1dd80:	bfa2      	ittt	ge
   1dd82:	6821      	ldrge	r1, [r4, #0]
   1dd84:	f021 0104 	bicge.w	r1, r1, #4
   1dd88:	6021      	strge	r1, [r4, #0]
   1dd8a:	b90e      	cbnz	r6, 1dd90 <_printf_i+0x114>
   1dd8c:	2d00      	cmp	r5, #0
   1dd8e:	d04b      	beq.n	1de28 <_printf_i+0x1ac>
   1dd90:	4615      	mov	r5, r2
   1dd92:	fbb6 f1f3 	udiv	r1, r6, r3
   1dd96:	fb03 6711 	mls	r7, r3, r1, r6
   1dd9a:	5dc7      	ldrb	r7, [r0, r7]
   1dd9c:	f805 7d01 	strb.w	r7, [r5, #-1]!
   1dda0:	4637      	mov	r7, r6
   1dda2:	42bb      	cmp	r3, r7
   1dda4:	460e      	mov	r6, r1
   1dda6:	d9f4      	bls.n	1dd92 <_printf_i+0x116>
   1dda8:	2b08      	cmp	r3, #8
   1ddaa:	d10b      	bne.n	1ddc4 <_printf_i+0x148>
   1ddac:	6823      	ldr	r3, [r4, #0]
   1ddae:	07de      	lsls	r6, r3, #31
   1ddb0:	d508      	bpl.n	1ddc4 <_printf_i+0x148>
   1ddb2:	6923      	ldr	r3, [r4, #16]
   1ddb4:	6861      	ldr	r1, [r4, #4]
   1ddb6:	4299      	cmp	r1, r3
   1ddb8:	bfde      	ittt	le
   1ddba:	2330      	movle	r3, #48	; 0x30
   1ddbc:	f805 3c01 	strble.w	r3, [r5, #-1]
   1ddc0:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
   1ddc4:	1b52      	subs	r2, r2, r5
   1ddc6:	6122      	str	r2, [r4, #16]
   1ddc8:	f8cd a000 	str.w	sl, [sp]
   1ddcc:	464b      	mov	r3, r9
   1ddce:	aa03      	add	r2, sp, #12
   1ddd0:	4621      	mov	r1, r4
   1ddd2:	4640      	mov	r0, r8
   1ddd4:	f7ff fee4 	bl	1dba0 <_printf_common>
   1ddd8:	3001      	adds	r0, #1
   1ddda:	d14a      	bne.n	1de72 <_printf_i+0x1f6>
   1dddc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1dde0:	b004      	add	sp, #16
   1dde2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1dde6:	6823      	ldr	r3, [r4, #0]
   1dde8:	f043 0320 	orr.w	r3, r3, #32
   1ddec:	6023      	str	r3, [r4, #0]
   1ddee:	4833      	ldr	r0, [pc, #204]	; (1debc <_printf_i+0x240>)
   1ddf0:	2778      	movs	r7, #120	; 0x78
   1ddf2:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
   1ddf6:	6823      	ldr	r3, [r4, #0]
   1ddf8:	6829      	ldr	r1, [r5, #0]
   1ddfa:	061f      	lsls	r7, r3, #24
   1ddfc:	f851 6b04 	ldr.w	r6, [r1], #4
   1de00:	d402      	bmi.n	1de08 <_printf_i+0x18c>
   1de02:	065f      	lsls	r7, r3, #25
   1de04:	bf48      	it	mi
   1de06:	b2b6      	uxthmi	r6, r6
   1de08:	07df      	lsls	r7, r3, #31
   1de0a:	bf48      	it	mi
   1de0c:	f043 0320 	orrmi.w	r3, r3, #32
   1de10:	6029      	str	r1, [r5, #0]
   1de12:	bf48      	it	mi
   1de14:	6023      	strmi	r3, [r4, #0]
   1de16:	b91e      	cbnz	r6, 1de20 <_printf_i+0x1a4>
   1de18:	6823      	ldr	r3, [r4, #0]
   1de1a:	f023 0320 	bic.w	r3, r3, #32
   1de1e:	6023      	str	r3, [r4, #0]
   1de20:	2310      	movs	r3, #16
   1de22:	e7a7      	b.n	1dd74 <_printf_i+0xf8>
   1de24:	4824      	ldr	r0, [pc, #144]	; (1deb8 <_printf_i+0x23c>)
   1de26:	e7e4      	b.n	1ddf2 <_printf_i+0x176>
   1de28:	4615      	mov	r5, r2
   1de2a:	e7bd      	b.n	1dda8 <_printf_i+0x12c>
   1de2c:	682b      	ldr	r3, [r5, #0]
   1de2e:	6826      	ldr	r6, [r4, #0]
   1de30:	6961      	ldr	r1, [r4, #20]
   1de32:	1d18      	adds	r0, r3, #4
   1de34:	6028      	str	r0, [r5, #0]
   1de36:	0635      	lsls	r5, r6, #24
   1de38:	681b      	ldr	r3, [r3, #0]
   1de3a:	d501      	bpl.n	1de40 <_printf_i+0x1c4>
   1de3c:	6019      	str	r1, [r3, #0]
   1de3e:	e002      	b.n	1de46 <_printf_i+0x1ca>
   1de40:	0670      	lsls	r0, r6, #25
   1de42:	d5fb      	bpl.n	1de3c <_printf_i+0x1c0>
   1de44:	8019      	strh	r1, [r3, #0]
   1de46:	2300      	movs	r3, #0
   1de48:	6123      	str	r3, [r4, #16]
   1de4a:	4615      	mov	r5, r2
   1de4c:	e7bc      	b.n	1ddc8 <_printf_i+0x14c>
   1de4e:	682b      	ldr	r3, [r5, #0]
   1de50:	1d1a      	adds	r2, r3, #4
   1de52:	602a      	str	r2, [r5, #0]
   1de54:	681d      	ldr	r5, [r3, #0]
   1de56:	6862      	ldr	r2, [r4, #4]
   1de58:	2100      	movs	r1, #0
   1de5a:	4628      	mov	r0, r5
   1de5c:	f000 f860 	bl	1df20 <memchr>
   1de60:	b108      	cbz	r0, 1de66 <_printf_i+0x1ea>
   1de62:	1b40      	subs	r0, r0, r5
   1de64:	6060      	str	r0, [r4, #4]
   1de66:	6863      	ldr	r3, [r4, #4]
   1de68:	6123      	str	r3, [r4, #16]
   1de6a:	2300      	movs	r3, #0
   1de6c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   1de70:	e7aa      	b.n	1ddc8 <_printf_i+0x14c>
   1de72:	6923      	ldr	r3, [r4, #16]
   1de74:	462a      	mov	r2, r5
   1de76:	4649      	mov	r1, r9
   1de78:	4640      	mov	r0, r8
   1de7a:	47d0      	blx	sl
   1de7c:	3001      	adds	r0, #1
   1de7e:	d0ad      	beq.n	1dddc <_printf_i+0x160>
   1de80:	6823      	ldr	r3, [r4, #0]
   1de82:	079b      	lsls	r3, r3, #30
   1de84:	d413      	bmi.n	1deae <_printf_i+0x232>
   1de86:	68e0      	ldr	r0, [r4, #12]
   1de88:	9b03      	ldr	r3, [sp, #12]
   1de8a:	4298      	cmp	r0, r3
   1de8c:	bfb8      	it	lt
   1de8e:	4618      	movlt	r0, r3
   1de90:	e7a6      	b.n	1dde0 <_printf_i+0x164>
   1de92:	2301      	movs	r3, #1
   1de94:	4632      	mov	r2, r6
   1de96:	4649      	mov	r1, r9
   1de98:	4640      	mov	r0, r8
   1de9a:	47d0      	blx	sl
   1de9c:	3001      	adds	r0, #1
   1de9e:	d09d      	beq.n	1dddc <_printf_i+0x160>
   1dea0:	3501      	adds	r5, #1
   1dea2:	68e3      	ldr	r3, [r4, #12]
   1dea4:	9903      	ldr	r1, [sp, #12]
   1dea6:	1a5b      	subs	r3, r3, r1
   1dea8:	42ab      	cmp	r3, r5
   1deaa:	dcf2      	bgt.n	1de92 <_printf_i+0x216>
   1deac:	e7eb      	b.n	1de86 <_printf_i+0x20a>
   1deae:	2500      	movs	r5, #0
   1deb0:	f104 0619 	add.w	r6, r4, #25
   1deb4:	e7f5      	b.n	1dea2 <_printf_i+0x226>
   1deb6:	bf00      	nop
   1deb8:	0002806d 	.word	0x0002806d
   1debc:	0002807e 	.word	0x0002807e

0001dec0 <_realloc_r>:
   1dec0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1dec4:	4680      	mov	r8, r0
   1dec6:	4614      	mov	r4, r2
   1dec8:	460e      	mov	r6, r1
   1deca:	b921      	cbnz	r1, 1ded6 <_realloc_r+0x16>
   1decc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1ded0:	4611      	mov	r1, r2
   1ded2:	f7ff bba3 	b.w	1d61c <_malloc_r>
   1ded6:	b92a      	cbnz	r2, 1dee4 <_realloc_r+0x24>
   1ded8:	f7ff fcc0 	bl	1d85c <_free_r>
   1dedc:	4625      	mov	r5, r4
   1dede:	4628      	mov	r0, r5
   1dee0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1dee4:	f000 f86c 	bl	1dfc0 <_malloc_usable_size_r>
   1dee8:	4284      	cmp	r4, r0
   1deea:	4607      	mov	r7, r0
   1deec:	d802      	bhi.n	1def4 <_realloc_r+0x34>
   1deee:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
   1def2:	d812      	bhi.n	1df1a <_realloc_r+0x5a>
   1def4:	4621      	mov	r1, r4
   1def6:	4640      	mov	r0, r8
   1def8:	f7ff fb90 	bl	1d61c <_malloc_r>
   1defc:	4605      	mov	r5, r0
   1defe:	2800      	cmp	r0, #0
   1df00:	d0ed      	beq.n	1dede <_realloc_r+0x1e>
   1df02:	42bc      	cmp	r4, r7
   1df04:	4622      	mov	r2, r4
   1df06:	4631      	mov	r1, r6
   1df08:	bf28      	it	cs
   1df0a:	463a      	movcs	r2, r7
   1df0c:	f7fc f870 	bl	19ff0 <memcpy>
   1df10:	4631      	mov	r1, r6
   1df12:	4640      	mov	r0, r8
   1df14:	f7ff fca2 	bl	1d85c <_free_r>
   1df18:	e7e1      	b.n	1dede <_realloc_r+0x1e>
   1df1a:	4635      	mov	r5, r6
   1df1c:	e7df      	b.n	1dede <_realloc_r+0x1e>
   1df1e:	Address 0x000000000001df1e is out of bounds.


0001df20 <memchr>:
   1df20:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   1df24:	2a10      	cmp	r2, #16
   1df26:	db2b      	blt.n	1df80 <memchr+0x60>
   1df28:	f010 0f07 	tst.w	r0, #7
   1df2c:	d008      	beq.n	1df40 <memchr+0x20>
   1df2e:	f810 3b01 	ldrb.w	r3, [r0], #1
   1df32:	3a01      	subs	r2, #1
   1df34:	428b      	cmp	r3, r1
   1df36:	d02d      	beq.n	1df94 <memchr+0x74>
   1df38:	f010 0f07 	tst.w	r0, #7
   1df3c:	b342      	cbz	r2, 1df90 <memchr+0x70>
   1df3e:	d1f6      	bne.n	1df2e <memchr+0xe>
   1df40:	b4f0      	push	{r4, r5, r6, r7}
   1df42:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   1df46:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   1df4a:	f022 0407 	bic.w	r4, r2, #7
   1df4e:	f07f 0700 	mvns.w	r7, #0
   1df52:	2300      	movs	r3, #0
   1df54:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   1df58:	3c08      	subs	r4, #8
   1df5a:	ea85 0501 	eor.w	r5, r5, r1
   1df5e:	ea86 0601 	eor.w	r6, r6, r1
   1df62:	fa85 f547 	uadd8	r5, r5, r7
   1df66:	faa3 f587 	sel	r5, r3, r7
   1df6a:	fa86 f647 	uadd8	r6, r6, r7
   1df6e:	faa5 f687 	sel	r6, r5, r7
   1df72:	b98e      	cbnz	r6, 1df98 <memchr+0x78>
   1df74:	d1ee      	bne.n	1df54 <memchr+0x34>
   1df76:	bcf0      	pop	{r4, r5, r6, r7}
   1df78:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   1df7c:	f002 0207 	and.w	r2, r2, #7
   1df80:	b132      	cbz	r2, 1df90 <memchr+0x70>
   1df82:	f810 3b01 	ldrb.w	r3, [r0], #1
   1df86:	3a01      	subs	r2, #1
   1df88:	ea83 0301 	eor.w	r3, r3, r1
   1df8c:	b113      	cbz	r3, 1df94 <memchr+0x74>
   1df8e:	d1f8      	bne.n	1df82 <memchr+0x62>
   1df90:	2000      	movs	r0, #0
   1df92:	4770      	bx	lr
   1df94:	3801      	subs	r0, #1
   1df96:	4770      	bx	lr
   1df98:	2d00      	cmp	r5, #0
   1df9a:	bf06      	itte	eq
   1df9c:	4635      	moveq	r5, r6
   1df9e:	3803      	subeq	r0, #3
   1dfa0:	3807      	subne	r0, #7
   1dfa2:	f015 0f01 	tst.w	r5, #1
   1dfa6:	d107      	bne.n	1dfb8 <memchr+0x98>
   1dfa8:	3001      	adds	r0, #1
   1dfaa:	f415 7f80 	tst.w	r5, #256	; 0x100
   1dfae:	bf02      	ittt	eq
   1dfb0:	3001      	addeq	r0, #1
   1dfb2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   1dfb6:	3001      	addeq	r0, #1
   1dfb8:	bcf0      	pop	{r4, r5, r6, r7}
   1dfba:	3801      	subs	r0, #1
   1dfbc:	4770      	bx	lr
   1dfbe:	bf00      	nop

0001dfc0 <_malloc_usable_size_r>:
   1dfc0:	f851 3c04 	ldr.w	r3, [r1, #-4]
   1dfc4:	1f18      	subs	r0, r3, #4
   1dfc6:	2b00      	cmp	r3, #0
   1dfc8:	bfbc      	itt	lt
   1dfca:	580b      	ldrlt	r3, [r1, r0]
   1dfcc:	18c0      	addlt	r0, r0, r3
   1dfce:	4770      	bx	lr

0001dfd0 <OC::autotune_data_default>:
	...

0001dfe8 <OC::bitmap_edit_indicators_8>:
   1dfe8:	6624 66e7 0424 0706 0406 6020 60e0           $f.f$..... `.` 

0001dff7 <OC::bitmap_gate_indicators_8>:
   1dff7:	0000 0000 c0c0 c0c0 f0f0 f0f0 fcfc fcfc     ................
   1e007:	ffff ffff 7525 484d 207a 7525 7375 252b     ....%uMHz %uus+%
   1e017:	7575 0073 4f43 4552 3325 2f75 3325 2f75     uus.CORE%3u/%3u/
   1e027:	3325 2075 3225 2575 0025 4f50 4c4c 3325     %3u %2u%%.POLL%3
   1e037:	2f75 3325 2f75 3325 0075 4955 2020 2120     u/%3u/%3u.UI   !
   1e047:	7525 2320 7525 4300 3156 2520 6435 2520     %u #%u.CV1 %5d %
   1e057:	7535 4300 3256 2520 6435 2520 7535 4300     5u.CV2 %5d %5u.C
   1e067:	3356 2520 6435 2520 7535 4300 3456 2520     V3 %5d %5u.CV4 %
   1e077:	6435 2520 7535 4d00 4e45 2055 3325 2f75     5d %5u.MENU %3u/
   1e087:	3325 2f75 3325 0075 6425 252f 0075 4320     %3u/%3u.%d/%u. C
   1e097:	524f 0045 4720 5846 2000 4441 0043 ffff     ORE. GFX. ADC...
   1e0a7:	                                             .

0001e0a8 <OC::debug_menus>:
   1e0a8:	e095 0001 0ad9 0000 e09b 0001 0c41 0000     ............A...
   1e0b8:	e0a0 0001 0b95 0000 0000 0000 0000 0000     ................

0001e0c8 <OC::DigitalInputs::Init()::pins>:
   1e0c8:	0003 0000 8cfd 1fff 0002 0000 8d09 1fff     ................
   1e0d8:	0001 0000 8d15 1fff 0000 0000 8d21 1fff     ............!...
   1e0e8:	3120 2f56 004f 6c61 6870 0061 6220 7465      1V/O.alpha. bet
   1e0f8:	0061 6167 6d6d 0061 2020 7274 0069 2020     a.gamma.  tri.  
   1e108:	7471 0072 2e31 2f32 004f 3220 2f56 004f     qtr.1.2/O. 2V/O.
   1e118:	7355 7265 642d 6665 6e69 6465 3120 5500     User-defined 1.U
   1e128:	6573 2d72 6564 6966 656e 2064 0032 7355     ser-defined 2.Us
   1e138:	7265 642d 6665 6e69 6465 3320 5500 6573     er-defined 3.Use
   1e148:	2d72 6564 6966 656e 2064 0034 664f 2066     r-defined 4.Off 
   1e158:	5300 6d65 7469 6e6f 0065 6f49 696e 6e61     .Semitone.Ionian
   1e168:	4400 726f 6169 006e 6850 7972 6967 6e61     .Dorian.Phrygian
   1e178:	4c00 6479 6169 006e 694d 6f78 796c 6964     .Lydian.Mixolydi
   1e188:	6e61 4100 6f65 696c 6e61 4c00 636f 6972     an.Aeolian.Locri
   1e198:	6e61 4200 756c 7365 6d20 6a61 726f 4200     an.Blues major.B
   1e1a8:	756c 7365 6d20 6e69 726f 5000 6e65 6174     lues minor.Penta
   1e1b8:	6f74 696e 2063 616d 006a 6550 746e 7461     tonic maj.Pentat
   1e1c8:	6e6f 6369 6d20 6e69 4600 6c6f 006b 614a     onic min.Folk.Ja
   1e1d8:	6170 656e 6573 4700 6d61 6c65 6e61 4700     panese.Gamelan.G
   1e1e8:	7079 7973 4100 6172 6962 6e61 4600 616c     ypsy.Arabian.Fla
   1e1f8:	656d 636e 006f 6857 6c6f 2065 6f74 656e     menco.Whole tone
   1e208:	5000 7479 6168 6f67 6572 6e61 4500 2f42     .Pythagorean.EB/
   1e218:	0034 2045 342f 4500 2f41 0034 6842 6961     4.E /4.EA/4.Bhai
   1e228:	6172 0076 7547 616e 726b 0069 614d 7772     rav.Gunakri.Marw
   1e238:	0061 6853 6572 2065 435b 6d61 6c65 005d     a.Shree [Camel].
   1e248:	7550 7672 0069 6942 616c 6177 006c 6159     Purvi.Bilawal.Ya
   1e258:	616d 006e 614b 6966 4200 6968 706d 6c61     man.Kafi.Bhimpal
   1e268:	7361 6572 0065 6144 6272 7261 0069 6152     asree.Darbari.Ra
   1e278:	6567 6873 6572 0065 684b 6d61 6a61 4200     geshree.Khamaj.B
   1e288:	6961 6172 6967 4200 5420 646f 0069 6843     airagi.B Todi.Ch
   1e298:	6e61 7264 6461 6565 0070 614b 7375 6968     andradeep.Kaushi
   1e2a8:	206b 6f54 6964 4a00 676f 7365 7768 7261     k Todi.Jogeshwar
   1e2b8:	0069 6154 7472 2d2e 6156 6c6c 746f 6974     i.Tart.-Vallotti
   1e2c8:	3100 6f33 3266 7432 5445 6567 3d6e 0035     .13of22tETgen=5.
   1e2d8:	614d 646e 6c65 6162 6d75 4d00 6761 6369     Mandelbaum.Magic
   1e2e8:	692d 2d6e 3431 7435 5445 5100 6175 7472     -in-145tET.Quart
   1e2f8:	6d61 6e69 726f 7233 7364 4100 6d72 646f     aminor3rds.Armod
   1e308:	6575 7320 6d65 2d69 7165 4800 7269 6a61     ue semi-eq.Hiraj
   1e318:	736f 6968 5300 6f63 2074 6162 7067 7069     oshi.Scot bagpip
   1e328:	7365 5400 6168 2069 6172 616e 0074 6553     es.Thai ranat.Se
   1e338:	6976 6873 3231 6e6f 3133 4445 004f 3131     vish12on31EDO.11
   1e348:	6574 4d74 6361 6968 656e 0036 3331 6574     tetMachine6.13te
   1e358:	4674 7461 6568 3872 3100 7435 7465 6c42     tFather8.15tetBl
   1e368:	6361 776b 3164 0030 3631 6574 4d74 7661     ackwd10.16tetMav
   1e378:	6c69 3761 3100 7436 7465 614d 6976 616c     ila7.16tetMavila
   1e388:	0039 3731 6574 5374 7075 7072 7479 3168     9.17tetSuprpyth1
   1e398:	0032 6f42 6c68 6e65 502d 6569 6372 2065     2.Bohlen-Pierce 
   1e3a8:	003d 6f42 6c68 6e65 502d 6569 6372 2065     =.Bohlen-Pierce 
   1e3b8:	006a 6f42 6c68 6e65 502d 6569 6372 2065     j.Bohlen-Pierce 
   1e3c8:	006c 5355 5245 0031 5355 5245 0032 5355     l.USER1.USER2.US
   1e3d8:	5245 0033 5355 5245 0034 464f 2046 5300     ER3.USER4.OFF .S
   1e3e8:	4d45 0049 4f49 494e 4400 524f 0049 4850     EMI.IONI.DORI.PH
   1e3f8:	5952 4c00 4459 0049 494d 4f58 4100 4f45     RY.LYDI.MIXO.AEO
   1e408:	004c 4f4c 5243 4200 554c 002b 4c42 2d55     L.LOCR.BLU+.BLU-
   1e418:	5000 4e45 002b 4550 2d4e 4600 4c4f 004b     .PEN+.PEN-.FOLK.
   1e428:	414a 4150 4700 4d41 0045 5947 5350 4100     JAPA.GAME.GYPS.A
   1e438:	4152 0042 4c46 4d41 5700 4f48 004c 5950     RAB.FLAM.WHOL.PY
   1e448:	4854 4200 4148 0049 5547 414e 4d00 5241     TH.BHAI.GUNA.MAR
   1e458:	0057 4853 4952 5000 5255 0056 4942 414c     W.SHRI.PURV.BILA
   1e468:	5900 4d41 0041 414b 4946 4200 4948 004d     .YAMA.KAFI.BHIM.
   1e478:	4144 4252 5200 4741 0045 484b 4d41 4200     DARB.RAGE.KHAM.B
   1e488:	4941 0052 5442 444f 4300 4148 004e 544b     AIR.BTOD.CHAN.KT
   1e498:	444f 4a00 474f 0045 4156 4c4c 3100 3233     OD.JOGE.VALL.132
   1e4a8:	0032 414d 464e 4d00 4741 0043 5551 5241     2.MANF.MAGC.QUAR
   1e4b8:	4100 4d52 004f 4948 4152 5300 4f43 0054     .ARMO.HIRA.SCOT.
   1e4c8:	4854 4941 5300 5645 0049 414d 4843 4600     THAI.SEVI.MACH.F
   1e4d8:	5441 0048 4c42 4341 4d00 5641 0037 414d     ATH.BLAC.MAV7.MA
   1e4e8:	3956 5300 5950 0054 2d42 6550 4200 502d     V9.SPYT.B-Pe.B-P
   1e4f8:	006a 2d42 6c50 ff00                         j.B-Pl..

0001e500 <OC::scale_names>:
   1e500:	e118 0001 e127 0001 e136 0001 e145 0001     ....'...6...E...
   1e510:	e154 0001 e159 0001 e162 0001 e169 0001     T...Y...b...i...
   1e520:	e170 0001 e179 0001 e180 0001 e18b 0001     p...y...........
   1e530:	e193 0001 e19b 0001 e1a7 0001 e1b3 0001     ................
   1e540:	e1c2 0001 e1d1 0001 e1d6 0001 e1df 0001     ................
   1e550:	e1e7 0001 e1ed 0001 e1f5 0001 e1fe 0001     ................
   1e560:	e209 0001 e215 0001 e21a 0001 e21f 0001     ................
   1e570:	e224 0001 e22c 0001 e234 0001 e23a 0001     $...,...4...:...
   1e580:	e248 0001 e24e 0001 e256 0001 e25c 0001     H...N...V...\...
   1e590:	e261 0001 e26e 0001 e276 0001 e280 0001     a...n...v.......
   1e5a0:	e287 0001 e28f 0001 e296 0001 e2a2 0001     ................
   1e5b0:	e2af 0001 e2ba 0001 e2c9 0001 e2d8 0001     ................
   1e5c0:	e2e3 0001 e2f3 0001 e303 0001 e313 0001     ................
   1e5d0:	e31d 0001 e32b 0001 e336 0001 e346 0001     ....+...6...F...
   1e5e0:	e354 0001 e361 0001 e370 0001 e37d 0001     T...a...p...}...
   1e5f0:	e38a 0001 e39a 0001 e3aa 0001 e3ba 0001     ................

0001e600 <OC::scale_names_short>:
   1e600:	e3ca 0001 e3d0 0001 e3d6 0001 e3dc 0001     ................
   1e610:	e3e2 0001 e3e7 0001 e3ec 0001 e3f1 0001     ................
   1e620:	e3f6 0001 e3fb 0001 e400 0001 e405 0001     ................
   1e630:	e40a 0001 e40f 0001 e414 0001 e419 0001     ................
   1e640:	e41e 0001 e423 0001 e428 0001 e42d 0001     ....#...(...-...
   1e650:	e432 0001 e437 0001 e43c 0001 e441 0001     2...7...<...A...
   1e660:	e446 0001 e215 0001 e21a 0001 e21f 0001     F...............
   1e670:	e44b 0001 e450 0001 e455 0001 e45a 0001     K...P...U...Z...
   1e680:	e45f 0001 e464 0001 e469 0001 e46e 0001     _...d...i...n...
   1e690:	e473 0001 e478 0001 e47d 0001 e482 0001     s...x...}.......
   1e6a0:	e487 0001 e48c 0001 e491 0001 e496 0001     ................
   1e6b0:	e49b 0001 e4a0 0001 e4a5 0001 e4aa 0001     ................
   1e6c0:	e4af 0001 e4b4 0001 e4b9 0001 e4be 0001     ................
   1e6d0:	e4c3 0001 e4c8 0001 e4cd 0001 e4d2 0001     ................
   1e6e0:	e4d7 0001 e4dc 0001 e4e1 0001 e4e6 0001     ................
   1e6f0:	e4eb 0001 e4f0 0001 e4f5 0001 e4fa 0001     ................

0001e700 <OC::Scales::NUM_SCALES>:
   1e700:	0040 0000                                   @...

0001e704 <braids::scales>:
	...
   1e72c:	0600 0000 000c 0000 0000 0080 0100 0180     ................
   1e73c:	0200 0280 0300 0380 0400 0480 0500 0580     ................
	...
   1e754:	0600 0000 0007 0000 0000 0100 0200 0280     ................
   1e764:	0380 0480 0580 0000 0000 0000 0000 0000     ................
	...
   1e77c:	0600 0000 0007 0000 0000 0100 0180 0280     ................
   1e78c:	0380 0480 0500 0000 0000 0000 0000 0000     ................
	...
   1e7a4:	0600 0000 0007 0000 0000 0080 0180 0280     ................
   1e7b4:	0380 0400 0500 0000 0000 0000 0000 0000     ................
	...
   1e7cc:	0600 0000 0007 0000 0000 0100 0200 0300     ................
   1e7dc:	0380 0480 0580 0000 0000 0000 0000 0000     ................
	...
   1e7f4:	0600 0000 0007 0000 0000 0100 0200 0280     ................
   1e804:	0380 0480 0500 0000 0000 0000 0000 0000     ................
	...
   1e81c:	0600 0000 0007 0000 0000 0100 0180 0280     ................
   1e82c:	0380 0400 0500 0000 0000 0000 0000 0000     ................
	...
   1e844:	0600 0000 0007 0000 0000 0080 0180 0280     ................
   1e854:	0300 0400 0500 0000 0000 0000 0000 0000     ................
	...
   1e86c:	0600 0000 0006 0000 0000 0180 0200 0380     ................
   1e87c:	0480 0500 0000 0000 0000 0000 0000 0000     ................
	...
   1e894:	0600 0000 0006 0000 0000 0180 0280 0300     ................
   1e8a4:	0380 0500 0000 0000 0000 0000 0000 0000     ................
	...
   1e8bc:	0600 0000 0005 0000 0000 0100 0200 0380     ................
   1e8cc:	0480 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1e8e4:	0600 0000 0005 0000 0000 0180 0280 0380     ................
   1e8f4:	0500 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1e90c:	0600 0000 0008 0000 0000 0080 0180 0200     ................
   1e91c:	0280 0380 0400 0500 0000 0000 0000 0000     ................
	...
   1e934:	0600 0000 0005 0000 0000 0080 0280 0380     ................
   1e944:	0400 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1e95c:	0600 0000 0005 0000 0000 0080 0180 0380     ................
   1e96c:	0400 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1e984:	0600 0000 0007 0000 0000 0100 0180 0300     ................
   1e994:	0380 0400 0580 0000 0000 0000 0000 0000     ................
	...
   1e9ac:	0600 0000 0007 0000 0000 0080 0200 0280     ................
   1e9bc:	0380 0400 0580 0000 0000 0000 0000 0000     ................
	...
   1e9d4:	0600 0000 0007 0000 0000 0080 0200 0280     ................
   1e9e4:	0380 0400 0500 0000 0000 0000 0000 0000     ................
	...
   1e9fc:	0600 0000 0006 0000 0000 0100 0200 0300     ................
   1ea0c:	0400 0500 0000 0000 0000 0000 0000 0000     ................
	...
   1ea24:	0600 0000 000c 0000 0000 0073 0105 0178     ..........s...x.
   1ea34:	020a 027d 030f 0383 03f6 0488 04fb 058d     ..}.............
	...
   1ea4c:	0600 0000 000c 0000 0000 0080 0100 0180     ................
   1ea5c:	01c0 0280 0300 0380 0400 0480 0500 0540     ..............@.
	...
   1ea74:	0600 0000 000c 0000 0000 0080 0100 0180     ................
   1ea84:	01c0 0280 0300 0380 0400 0480 0500 0580     ................
	...
   1ea9c:	0600 0000 000c 0000 0000 0080 0100 0180     ................
   1eaac:	01c0 0280 0300 0380 0400 0440 0500 0580     ..........@.....
	...
   1eac4:	0600 0000 0007 0000 0000 0073 01ee 027d     ..........s...}.
   1ead4:	0383 03f6 0571 0000 0000 0000 0000 0000     ....q...........
	...
   1eaec:	0600 0000 0005 0000 0000 008f 027d 0383     ............}...
   1eafc:	0412 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1eb14:	0600 0000 0006 0000 0000 008f 01ee 02f3     ................
   1eb24:	046c 0571 0000 0000 0000 0000 0000 0000     l.q.............
	...
   1eb3c:	0600 0000 0007 0000 0000 0073 01ee 02f3     ..........s.....
   1eb4c:	0383 03f6 0571 0000 0000 0000 0000 0000     ....q...........
	...
   1eb64:	0600 0000 0007 0000 0000 008f 01ee 02f3     ................
   1eb74:	0383 0412 0571 0000 0000 0000 0000 0000     ....q...........
	...
   1eb8c:	0600 0000 0007 0000 0000 0105 01ee 027d     ..............}.
   1eb9c:	0383 0488 0571 0000 0000 0000 0000 0000     ....q...........
	...
   1ebb4:	0600 0000 0007 0000 0000 0105 020a 030f     ................
   1ebc4:	0383 0488 058d 0000 0000 0000 0000 0000     ................
	...
   1ebdc:	0600 0000 0007 0000 0000 00e9 0178 027d     ............x.}.
   1ebec:	0383 046c 04fb 0000 0000 0000 0000 0000     ..l.............
	...
   1ec04:	0600 0000 0007 0000 0000 0105 0194 027d     ..............}.
   1ec14:	0383 0488 0517 0000 0000 0000 0000 0000     ................
	...
   1ec2c:	0600 0000 0007 0000 0000 0105 0178 027d     ............x.}.
   1ec3c:	0383 03f6 04fb 0000 0000 0000 0000 0000     ................
	...
   1ec54:	0600 0000 0007 0000 0000 0105 01ee 027d     ..............}.
   1ec64:	0383 046c 04fb 0000 0000 0000 0000 0000     ..l.............
	...
   1ec7c:	0600 0000 0008 0000 0000 0105 01ee 027d     ..............}.
   1ec8c:	0383 0488 04fb 058d 0000 0000 0000 0000     ................
	...
   1eca4:	0600 0000 0005 0000 0000 0073 027d 0383     ..........s.}...
   1ecb4:	04fb 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1eccc:	0600 0000 0005 0000 0000 0073 0178 0383     ..........s.x...
   1ecdc:	04fb 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1ecf4:	0600 0000 0005 0000 0000 0178 027d 0383     ..........x.}...
   1ed04:	04fb 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1ed1c:	0600 0000 0005 0000 0000 0178 027d 02f3     ..........x.}...
   1ed2c:	03f6 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1ed44:	0600 0000 0006 0000 0000 0178 01ee 027d     ..........x...}.
   1ed54:	046c 04fb 0000 0000 0000 0000 0000 0000     l...............
	...
   1ed6c:	0600 0000 000c 0000 0000 0078 00fb 017d     ..........x...}.
   1ed7c:	01f6 0283 02f6 037d 03fb 0478 0500 0573     ......}...x...s.
	...
   1ed94:	0600 0000 000d 0000 0000 008c 0117 01a3     ................
   1eda4:	01e9 0274 0300 0346 03d1 045d 04a3 052f     ..t...F...].../.
   1edb4:	05ba 0000 0000 0000 0600 0000 000d 0000     ................
   1edc4:	0000 00a2 00f3 0194 01e5 0287 02d8 0379     ..............y.
   1edd4:	03ca 046c 04bd 055e 05af 0000 0000 0000     ..l...^.........
   1ede4:	0600 0000 0010 0000 0000 00bf 0109 0153     ..............S.
   1edf4:	019d 01e7 0231 02f0 033a 0384 03cf 0419     ....1...:.......
   1ee04:	04d7 0522 056c 05b6 0600 0000 0010 0000     ..".l...........
   1ee14:	0000 0063 00c7 012a 018e 01f1 0255 02b8     ..c...*.....U...
   1ee24:	031c 037f 03e3 0446 04a9 050d 0570 05d4     ......F.....p...
   1ee34:	0600 0000 0010 0000 0000 0063 00c6 0129     ..........c...).
   1ee44:	018c 01ef 0253 02b6 0319 037c 03df 0442     ....S.....|...B.
   1ee54:	04a5 04d7 053a 059d 0600 0000 0005 0000     ....:...........
   1ee64:	0000 00ed 01af 036a 03f3 0000 0000 0000     ......j.........
	...
   1ee84:	0600 0000 0007 0000 0000 00fc 01b4 027a     ..............z.
   1ee94:	0384 0444 050c 0000 0000 0000 0000 0000     ..D.............
	...
   1eeac:	0600 0000 0007 0000 0000 00ce 01bb 02a1     ................
   1eebc:	036e 044f 0525 0000 0000 0000 0000 0000     n.O.%...........
	...
   1eed4:	0600 0000 000c 0000 0000 0095 0129 018c     ............)...
   1eee4:	0221 0284 0319 03ad 0411 04a5 0508 059d     !...............
	...
   1eefc:	0600 0000 0006 0000 0000 0117 022f 02ba     ............/...
   1ef0c:	03d1 04e9 0000 0000 0000 0000 0000 0000     ................
	...
   1ef24:	0600 0000 0008 0000 0000 00ec 01d9 024f     ..............O.
   1ef34:	033b 0427 049e 058a 0000 0000 0000 0000     ;.'.............
	...
   1ef4c:	0600 0000 000a 0000 0000 00cd 0133 0200     ............3...
   1ef5c:	0266 0333 039a 0466 04cd 059a 0000 0000     f.3...f.........
	...
   1ef74:	0600 0000 0007 0000 0000 00c0 0180 02a0     ................
   1ef84:	0360 0420 04e0 0000 0000 0000 0000 0000     `. .............
	...
   1ef9c:	0600 0000 0009 0000 0000 0060 0120 01e0     ..........`. ...
   1efac:	02a0 0300 03c0 0480 0540 0000 0000 0000     ........@.......
	...
   1efc4:	0600 0000 000c 0000 0000 005a 00b5 0169     ..........Z...i.
   1efd4:	01c4 0278 02d3 032d 03e2 043c 04f1 054b     ..x...-...<...K.
	...
   1efec:	0600 0000 000d 0000 0000 0076 00ec 0162     ..........v...b.
   1effc:	01d9 024f 02c5 033b 03b1 0427 049e 0514     ..O...;...'.....
   1f00c:	058a 0000 0000 0000 0600 0000 000d 0000     ................
   1f01c:	0000 006c 00f4 015f 01d6 0253 02ca 0336     ..l..._...S...6.
   1f02c:	03ad 042a 04a1 050c 0594 0000 0000 0000     ..*.............
   1f03c:	0600 0000 0009 0000 0000 00f4 015f 01d6     ............_...
   1f04c:	02ca 0336 042a 04a1 0594 0000 0000 0000     ..6.*...........
	...
   1f064:	6749 6f6e 0072 6f48 6f6e 0072 6f4e 656e     Ignor.Honor.None
   1f074:	5300 0050 4c53 0050 4c53 7200 676e 6c00     .SP.SLP.SL.rng.l
   1f084:	6e65 7000 6272 3000 302e 0035 2e30 3031     en.prb.0.05.0.10
   1f094:	3000 312e 0035 2e30 3032 3000 322e 0035     .0.15.0.20.0.25.
   1f0a4:	2e30 3033 3000 332e 0035 2e30 3034 3000     0.30.0.35.0.40.0
   1f0b4:	342e 0035 2e30 3035 3000 352e 0035 2e30     .45.0.50.0.55.0.
   1f0c4:	3036 3000 362e 0035 2e30 3037 3000 372e     60.0.65.0.70.0.7
   1f0d4:	0035 2e30 3038 3000 382e 0035 2e30 3039     5.0.80.0.85.0.90
   1f0e4:	3000 392e 0035 2e31 3030 3100 302e 0035     .0.95.1.00.1.05.
   1f0f4:	2e31 3031 3100 312e 0035 2e31 3032 3100     1.10.1.15.1.20.1
   1f104:	322e 0035 2e31 3033 3100 332e 0035 2e31     .25.1.30.1.35.1.
   1f114:	3034 3100 342e 0035 2e31 3035 3100 352e     40.1.45.1.50.1.5
   1f124:	0035 2e31 3036 3100 362e 0035 2e31 3037     5.1.60.1.65.1.70
   1f134:	3100 372e 0035 2e31 3038 3100 382e 0035     .1.75.1.80.1.85.
   1f144:	2e31 3039 3100 392e 0035 2e32 3030 5100     1.90.1.95.2.00.Q
   1f154:	7300 6977 676e 6c00 6f6f 0070 6970 7600     .swing.loop.pi.v
   1f164:	456e 6b63 7300 6473 006e 7244 7365 0073     nEck.ssdn.Dress.
   1f174:	4e50 6e69 0066 7344 6d75 4400 7573 346d     PNinf.Dsum.Dsum4
   1f184:	4400 7573 356d 4300 6e44 0032 7246 7463     .Dsum5.CDn2.Frct
   1f194:	0069 694c 006e 7551 7261 0074 6953 656e     i.Lin.Quart.Sine
   1f1a4:	4c00 6465 6567 4300 696c 6666 4200 4467     .Ledge.Cliff.BgD
   1f1b4:	7069 4d00 4465 7069 4c00 4474 7069 5700     ip.MeDip.LtDip.W
   1f1c4:	6769 6c67 6800 706f 0065 6f6c 6576 6c00     iggl.hope.love.l
   1f1d4:	6669 0065 6c63 7379 006d 6f6d 6b6e 4e00     ife.clysm.monk.N
   1f1e4:	5245 0056 7254 7275 006c 6950 7872 5300     ERV.Trurl.Pirx.S
   1f1f4:	616e 7475 4800 7261 0069 724b 7369 5400     naut.Hari.Kris.T
   1f204:	6369 7968 4200 6572 6767 4100 6f76 006e     ichy.Bregg.Avon.
   1f214:	724f 6361 6f00 6666 3100 3032 7375 3200     Orac.off.120us.2
   1f224:	3034 7375 3300 3036 7375 3400 3038 7375     40us.360us.480us
   1f234:	3100 736d 3200 736d 3400 736d 6e00 726f     .1ms.2ms.4ms.nor
   1f244:	616d 006c 204c 6572 6576 7372 6465 4c00     mal.L reversed.L
   1f254:	2052 6572 6576 7372 6465 7300 6163 696c     R reversed.scali
   1f264:	676e 0020 6f4e 5900 7365 2300 0041 4223     ng .No.Yes.#A.#B
   1f274:	2300 0043 4423 5400 3152 5400 3252 5400     .#C.#D.TR1.TR2.T
   1f284:	3352 5400 3452 4400 0023 2346 4700 0023     R3.TR4.D#.F#.G#.
   1f294:	2341 4300 0020 2044 4500 0020 2047 4100     A#.C .D .E .G .A
   1f2a4:	0020 2042 3e00 3123 3e00 3223 3e00 3323      .B .>#1.>#2.>#3
   1f2b4:	3e00 3423 2000 3123 2000 3223 2000 3323     .>#4. #1. #2. #3
   1f2c4:	2000 3423 6600 6477 7200 7665 7000 646e     . #4.fwd.rev.pnd
   1f2d4:	0031 6e70 3264 7200 646e 6200 7772 006e     1.pnd2.rnd.brwn.
   1f2e4:	6e63 2b74 6300 746e 002d 2d20 5300 5145     cnt+.cnt-. -.SEQ
   1f2f4:	312b 5300 5145 322b 5300 5145 332b 5400     +1.SEQ+2.SEQ+3.T
   1f304:	2b52 0031 5254 322b 5400 2b52 0033 5241     R+1.TR+2.TR+3.AR
   1f314:	0050 2b53 2348 0031 2b53 2348 0032 2b53     P.S+H#1.S+H#2.S+
   1f324:	2348 0033 2b53 2348 0034 5643 3123 4300     H#3.S+H#4.CV#1.C
   1f334:	2356 0032 5643 3323 4300 2356 0034 ffff     V#2.CV#3.CV#4...

0001f344 <OC::Strings::note_names>:
   1f344:	f297 0001 1b9b 0002 f29a 0001 f28b 0001     ................
   1f354:	f29d 0001 e3e4 0001 f28e 0001 f2a0 0001     ................
   1f364:	f291 0001 f2a3 0001 f294 0001 f2a6 0001     ................

0001f374 <OC::Strings::note_names_unpadded>:
   1f374:	127f 0002 1b9b 0002 1b74 0002 f28b 0001     ........t.......
   1f384:	e480 0001 807c 0002 f28e 0001 03c0 0002     ....|...........
   1f394:	f291 0001 1283 0002 f294 0001 1b62 0002     ............b...

0001f3a4 <OC::Strings::no_yes>:
   1f3a4:	f268 0001 f26b 0001                         h...k...

0001f3ac <OC::Ui::Init()::button_pins>:
   1f3ac:	0004 0000 0005 0000 000e 0000 0017 0000     ................
   1f3bc:	0009 0000                                   ....

0001f3c0 <bjorklund_patterns>:
   1f3c0:	0000 0000 0001 0000 0003 0000 0000 0000     ................
	...
   1f448:	0001 0000 0003 0000 0007 0000 0000 0000     ................
	...
   1f4cc:	0001 0000 0005 0000 0007 0000 000f 0000     ................
	...
   1f550:	0001 0000 0005 0000 0015 0000 000f 0000     ................
   1f560:	001f 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1f5d4:	0001 0000 0009 0000 0015 0000 001b 0000     ................
   1f5e4:	001f 0000 003f 0000 0000 0000 0000 0000     ....?...........
	...
   1f658:	0001 0000 0009 0000 0015 0000 0055 0000     ............U...
   1f668:	005b 0000 003f 0000 007f 0000 0000 0000     [...?...........
	...
   1f6dc:	0001 0000 0011 0000 0049 0000 0055 0000     ........I...U...
   1f6ec:	006d 0000 0077 0000 007f 0000 00ff 0000     m...w...........
	...
   1f760:	0001 0000 0011 0000 0049 0000 0055 0000     ........I...U...
   1f770:	0155 0000 00db 0000 0177 0000 00ff 0000     U.......w.......
   1f780:	01ff 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1f7e4:	0001 0000 0021 0000 0049 0000 00a5 0000     ....!...I.......
   1f7f4:	0155 0000 02b5 0000 02db 0000 01ef 0000     U...............
   1f804:	01ff 0000 03ff 0000 0000 0000 0000 0000     ................
	...
   1f868:	0001 0000 0021 0000 0111 0000 0249 0000     ....!.......I...
   1f878:	0155 0000 0555 0000 036d 0000 03bb 0000     U...U...m.......
   1f888:	05ef 0000 03ff 0000 07ff 0000 0000 0000     ................
	...
   1f8ec:	0001 0000 0041 0000 0111 0000 0249 0000     ....A.......I...
   1f8fc:	04a5 0000 0555 0000 06b5 0000 06db 0000     ....U...........
   1f90c:	0777 0000 07df 0000 07ff 0000 0fff 0000     w...............
	...
   1f970:	0001 0000 0041 0000 0111 0000 0249 0000     ....A.......I...
   1f980:	0529 0000 0555 0000 1555 0000 15ad 0000     )...U...U.......
   1f990:	16db 0000 1777 0000 17df 0000 0fff 0000     ....w...........
   1f9a0:	1fff 0000 0000 0000 0000 0000 0000 0000     ................
	...
   1f9f4:	0001 0000 0081 0000 0421 0000 0489 0000     ........!.......
   1fa04:	1249 0000 0a95 0000 1555 0000 2ad5 0000     I.......U....*..
   1fa14:	1b6d 0000 2ddb 0000 1ef7 0000 1fbf 0000     m....-..........
   1fa24:	1fff 0000 3fff 0000 0000 0000 0000 0000     .....?..........
	...
   1fa78:	0001 0000 0081 0000 0421 0000 1111 0000     ........!.......
   1fa88:	1249 0000 14a5 0000 1555 0000 5555 0000     I.......U...UU..
   1fa98:	56b5 0000 36db 0000 3bbb 0000 3def 0000     .V...6...;...=..
   1faa8:	5fbf 0000 3fff 0000 7fff 0000 0000 0000     ._...?..........
	...
   1fafc:	0001 0000 0101 0000 0421 0000 1111 0000     ........!.......
   1fb0c:	1249 0000 4949 0000 4a95 0000 5555 0000     I...II...J..UU..
   1fb1c:	6ad5 0000 6d6d 0000 b6db 0000 7777 0000     .j..mm......ww..
   1fb2c:	bdef 0000 7f7f 0000 7fff 0000 ffff 0000     ................
	...
   1fb80:	0001 0000 0101 0000 1041 0000 1111 0000     ........A.......
   1fb90:	4489 0000 9249 0000 94a5 0000 5555 0000     .D..I.......UU..
   1fba0:	5555 0001 d6b5 0000 db6d 0000 eddb 0000     UU......m.......
   1fbb0:	7777 0001 fbef 0000 7f7f 0001 ffff 0000     ww..............
   1fbc0:	ffff 0001 0000 0000 0000 0000 0000 0000     ................
	...
   1fc04:	0001 0000 0201 0000 1041 0000 2211 0000     ........A...."..
   1fc14:	4891 0000 9249 0000 a529 0000 aa55 0000     .H..I...)...U...
   1fc24:	5555 0001 ab55 0002 b5ad 0002 b6db 0001     UU..U...........
   1fc34:	ddbb 0002 ef77 0002 f7df 0001 feff 0001     ....w...........
   1fc44:	ffff 0001 ffff 0003 0000 0000 0000 0000     ................
	...
   1fc88:	0001 0000 0201 0000 1041 0000 8421 0000     ........A...!...
   1fc98:	1111 0001 9249 0000 4949 0001 52a5 0001     ....I...II...R..
   1fca8:	5555 0001 5555 0005 5ab5 0005 6d6d 0005     UU..UU...Z..mm..
   1fcb8:	b6db 0005 bbbb 0003 def7 0003 f7df 0005     ................
   1fcc8:	feff 0005 ffff 0003 ffff 0007 0000 0000     ................
	...
   1fd0c:	0001 0000 0401 0000 4081 0000 8421 0000     .........@..!...
   1fd1c:	1111 0001 2449 0001 9249 0004 94a5 0002     ....I$..I.......
   1fd2c:	aa55 0004 5555 0005 ab55 0006 d6b5 000a     U...UU..U.......
   1fd3c:	db6d 0006 6edb 000b 7777 0007 bdef 0007     m....n..ww......
   1fd4c:	efdf 0007 fdff 0007 ffff 0007 ffff 000f     ................
	...
   1fd90:	0001 0000 0401 0000 4081 0000 8421 0000     .........@..!...
   1fda0:	1111 0001 4489 0002 9249 0004 2929 0009     .....D..I...))..
   1fdb0:	4a95 0005 5555 0005 5555 0015 6ad5 0015     .J..UU..UU...j..
   1fdc0:	adad 000d b6db 000d eddb 0016 7777 0017     ............ww..
   1fdd0:	bdef 0017 dfbf 000f fdff 0017 ffff 000f     ................
   1fde0:	ffff 001f 0000 0000 0000 0000 0000 0000     ................
	...
   1fe14:	0001 0000 0801 0000 4081 0000 0821 0001     .........@..!...
   1fe24:	2211 0004 8911 0008 9249 0004 4a49 0012     ."......I...IJ..
   1fe34:	94a5 0012 a955 000a 5555 0015 ad55 002a     ....U...UU..U.*.
   1fe44:	d6b5 001a 6b6d 001b b6db 002d dbbb 001d     ....mk....-.....
   1fe54:	ef77 001e 7def 002f dfbf 002f fbff 001f     w....}/.../.....
   1fe64:	ffff 001f ffff 003f 0000 0000 0000 0000     ......?.........
	...
   1fe98:	0001 0000 0801 0000 0101 0001 1041 0004     ............A...
   1fea8:	4221 0004 1111 0011 2449 0011 9249 0024     !B......I$..I.$.
   1feb8:	a529 0014 4a95 0025 5555 0015 5555 0055     )....J%.UU..UUU.
   1fec8:	6ad5 0035 b5ad 0056 db6d 0036 6edb 003b     .j5...V.m.6..n;.
   1fed8:	bbbb 003b eef7 005d fbef 003e bfbf 003f     ..;...]...>...?.
   1fee8:	fbff 005f ffff 003f ffff 007f 0000 0000     .._...?.........
	...
   1ff1c:	0001 0000 1001 0000 0101 0001 1041 0004     ............A...
   1ff2c:	8421 0010 1111 0011 4489 0022 9249 0024     !........D".I.$.
   1ff3c:	4949 0049 54a5 004a a955 004a 5555 0055     III..TJ.U.J.UUU.
   1ff4c:	ad55 006a 56b5 006b 6d6d 006d b6db 006d     U.j..Vk.mmm...m.
   1ff5c:	eddb 0076 7777 0077 def7 007b f7df 007d     ..v.www...{...}.
   1ff6c:	7f7f 007f f7ff 007f ffff 007f ffff 00ff     ................
	...
   1ffa0:	0001 0000 1001 0000 0101 0001 1041 0004     ............A...
   1ffb0:	8421 0010 1111 0011 4891 0024 9249 0024     !........H$.I.$.
   1ffc0:	4a49 0052 94a5 0052 2a95 0055 5555 0055     IJR...R..*U.UUU.
   1ffd0:	5555 0155 aad5 0155 d6b5 015a 6b6d 015b     UUU...U...Z.mk[.
   1ffe0:	b6db 016d ddbb 016e 7777 0177 bdef 00f7     ..m...n.www.....
   1fff0:	f7df 017d 7f7f 017f f7ff 017f ffff 00ff     ..}.............
   20000:	ffff 01ff 0000 0000 0000 0000 0000 0000     ................
	...
   20024:	0001 0000 2001 0000 0201 0004 2041 0008     ..... ......A ..
   20034:	8421 0010 2111 0022 8911 0048 2249 0049     !....!"...H.I"I.
   20044:	9249 0124 2529 00a5 52a5 00a9 a555 00aa     I.$.)%...R..U...
   20054:	5555 0155 b555 02aa 5ab5 02ad b5ad 02b5     UUU.U....Z......
   20064:	db6d 01b6 76db 02db dbbb 02dd f777 02ee     m....v......w...
   20074:	bdef 02f7 f7df 02fb ff7f 01fe efff 01ff     ................
   20084:	ffff 01ff ffff 03ff 0000 0000 0000 0000     ................
	...
   200a8:	0001 0000 2001 0000 0201 0004 4081 0020     ..... .......@ .
   200b8:	0821 0041 2211 0044 1111 0111 2489 0092     !.A.."D......$..
   200c8:	9249 0124 4949 0149 94a5 0252 aa55 0154     I.$.III...R.U.T.
   200d8:	5555 0155 5555 0555 ab55 0556 d6b5 035a     UUU.UUU.U.V...Z.
   200e8:	6d6d 056d b6db 036d 6ddb 05b7 bbbb 03bb     mmm...m..m......
   200f8:	ef77 05de 7def 03ef efdf 03f7 feff 03fd     w....}..........
   20108:	efff 05ff ffff 03ff ffff 07ff 0000 0000     ................
	...
   2012c:	0001 0000 4001 0000 0201 0004 4081 0020     .....@.......@ .
   2013c:	0841 0042 4421 0108 1111 0111 4489 0122     A.B.!D.......D".
   2014c:	9249 0124 5249 0492 a529 0294 4a95 02a5     I.$.IR..)....J..
   2015c:	a555 04aa 5555 0555 b555 06aa 6ad5 0ab5     U...UUU.U....j..
   2016c:	b5ad 0ad6 5b6d 06db b6db 0b6d eddb 0b76     ....m[....m...v.
   2017c:	7777 0777 def7 07bd 7bef 0bdf dfbf 07ef     www......{......
   2018c:	feff 0bfd dfff 07ff ffff 07ff ffff 0fff     ................
	...
   201b0:	0001 0000 4001 0000 0401 0010 4081 0020     .....@.......@ .
   201c0:	1041 0104 8421 0210 1111 0111 8891 0444     A...!.........D.
   201d0:	2249 0449 9249 0924 2929 0929 54a5 054a     I"I.I.$.)))..TJ.
   201e0:	aa55 0954 5555 0555 5555 1555 ab55 0d56     U.T.UUU.UUU.U.V.
   201f0:	56b5 156b adad 0dad db6d 0db6 76db 0edb     .Vk.....m....v..
   20200:	ddbb 0eed 7777 1777 def7 0f7b fbef 0fbe     ....www...{.....
   20210:	dfbf 17ef feff 0ffb dfff 17ff ffff 0fff     ................
   20220:	ffff 1fff 0000 0000 0000 0000 0000 0000     ................
   20230:	0000 0000 0001 0000 8001 0000 0401 0010     ................
   20240:	8081 0040 1041 0104 8421 0210 2111 0422     ..@.A...!....!".
   20250:	9111 0888 2449 0491 9249 0924 4949 124a     ....I$..I.$.IIJ.
   20260:	94a5 0a52 4a95 12a5 9555 0aaa 5555 1555     ..R..J..U...UUU.
   20270:	d555 2aaa 6ad5 1ab5 d6b5 2b5a 6d6d 1b6b     U..*.j....Z+mmk.
   20280:	b6db 1b6d 6edb 2dbb bbbb 1ddd f777 1eee     ..m..n.-....w...
   20290:	bdef 1ef7 f7df 1f7d dfbf 2fdf fdff 1ff7     ......}..../....
   202a0:	bfff 1fff ffff 1fff ffff 3fff 0000 0000     ...........?....
	...
   202b8:	0001 0000 8001 0000 0401 0010 0101 0101     ................
   202c8:	1041 0104 8421 0210 2211 0844 1111 1111     A...!...."D.....
   202d8:	4489 1122 9249 0924 5249 1492 2529 24a5     .D".I.$.IR..)%.$
   202e8:	52a5 252a aa55 1552 5555 1555 5555 5555     .R*%U.R.UUU.UUUU
   202f8:	ab55 555a 5ab5 35ab b5ad 36b5 5b6d 56db     U.ZU.Z.5...6m[.V
   20308:	b6db 5b6d eddb 3b76 bbbb 3bbb ef77 3dde     ..m[..v;...;w..=
   20318:	bdef 5ef7 f7df 5f7d bfbf 3fbf fdff 5ff7     ...^..}_...?..._
   20328:	bfff 5fff ffff 3fff ffff 7fff 0000 0000     ..._...?........
   20338:	0000 0000 0001 0000 0001 0001 0801 0040     ..............@.
   20348:	0101 0101 2041 0408 0421 0421 4221 0884     ....A ..!.!.!B..
   20358:	1111 1111 4891 1224 1249 1249 9249 4924     .....H$.I.I.I.$I
   20368:	4949 4949 94a5 4a52 4a95 4a95 9555 4aaa     IIII..RJ.J.JU..J
   20378:	5555 5555 d555 6aaa 6ad5 6ad5 d6b5 6b5a     UUUUU..j.j.j..Zk
   20388:	6d6d 6d6d db6d 6db6 b6db b6db ddbb b76e     mmmmm..m......n.
   20398:	7777 7777 eef7 bbdd bdef bdef f7df 7efb     wwww...........~
   203a8:	7f7f 7f7f fdff 7fef 7fff 7fff ffff 7fff     ................
   203b8:	ffff ffff 4441 4520 0047 3d31 7254 2067     ....AD EG.1=Trg 
   203c8:	3d32 7254 2067 6552 6576 7372 3100 413d     2=Trg Revers.1=A
   203d8:	6d20 646f 3220 443d 6d20 646f 4100 4f3d      mod 2=D mod.A=O
   203e8:	7475 7570 2074 3d42 4f45 0043 7441 6174     utput B=EOC.Atta
   203f8:	6b63 442f 6365 7961 4100 5344 2052 4745     ck/Decay.ADSR EG
   20408:	4700 7461 2065 3d31 6843 2031 3d32 6843     .Gate 1=Ch1 2=Ch
   20418:	0032 6f4d 2064 3d31 7441 2074 3d32 6552     2.Mod 1=Att 2=Re
   20428:	006c 6d41 2070 3d41 6843 2031 3d42 6843     l.Amp A=Ch1 B=Ch
   20438:	0032 2f41 2f44 2f53 0052 4122 5322 0052     2.A/D/S/R."A"SR.
   20448:	3d31 6c43 636f 206b 3d32 7246 6565 657a     1=Clock 2=Freeze
   20458:	3100 433d 2056 3d32 6f4d 2064 6e69 6564     .1=CV 2=Mod inde
   20468:	0078 6e49 6564 2f78 6353 6c61 0065 6e41     x.Index/Scale.An
   20478:	756e 616c 4672 0075 3d31 6c43 636f 206b     nularFu.1=Clock 
   20488:	3d32 6552 6573 0074 6f52 6174 6574 3120     2=Reset.Rotate 1
   20498:	433d 3168 3220 433d 3268 4300 6f6c 6b63     =Ch1 2=Ch2.Clock
   204a8:	4120 433d 3168 4220 433d 3268 4c00 6e65      A=Ch1 B=Ch2.Len
   204b8:	7467 2f68 6948 7374 4320 3168 322c 4100     gth/Hits Ch1,2.A
   204c8:	7474 6e65 664f 0066 5643 4920 706e 7475     ttenOff.CV Input
   204d8:	2073 2c31 0032 754f 7074 7475 2073 2c41     s 1,2.Outputs A,
   204e8:	0042 664f 7366 7465 5620 2f20 4c20 7665     B.Offset V / Lev
   204f8:	6c65 2520 4200 6e69 7261 4379 7274 3100     el %.BinaryCtr.1
   20508:	423d 7469 3320 3220 423d 7469 3220 3100     =Bit 3 2=Bit 2.1
   20518:	423d 7469 3120 3220 423d 7469 3020 4100     =Bit 1 2=Bit 0.A
   20528:	423d 6e69 7261 2079 3d42 6f43 6e75 0074     =Binary B=Count.
   20538:	6f42 746f 4e73 6143 0074 2c31 2032 6c50     BootsNCat.1,2 Pl
   20548:	7961 4100 7474 6e65 202e 3d31 4442 3220     ay.Atten. 1=BD 2
   20558:	533d 0044 3d41 654c 7466 4220 523d 6769     =SD.A=Left B=Rig
   20568:	7468 5000 6572 6573 2f74 6150 006e 7242     ht.Preset/Pan.Br
   20578:	6e61 6863 7265 3100 433d 6f6c 6b63 472f     ancher.1=Clock/G
   20588:	7461 0065 3d31 2070 6f4d 0064 2c41 3d42     ate.1=p Mod.A,B=
   20598:	6c43 636f 2f6b 6147 6574 5300 7465 7020     Clock/Gate.Set p
   205a8:	3100 433d 6f6c 6b63 3220 423d 7275 7473     .1=Clock 2=Burst
   205b8:	3100 4e3d 6d75 6562 2072 3d32 7053 6361     .1=Number 2=Spac
   205c8:	6e69 0067 3d31 7542 7372 2074 3d32 6147     ing.1=Burst 2=Ga
   205d8:	6574 4e00 6d75 6562 2f72 7053 6361 6e69     te.Number/Spacin
   205e8:	2f67 6944 0076 5643 6552 0063 6552 3a63     g/Div.CVRec.Rec:
   205f8:	3120 543d 3172 3220 543d 3272 5000 616c      1=Tr1 2=Tr2.Pla
   20608:	3a79 4120 543d 3172 4220 543d 3272 5200     y: A=Tr1 B=Tr2.R
   20618:	6e61 6567 532f 6f6d 746f 2f68 6552 0063     ange/Smooth/Rec.
   20628:	6143 636c 6c75 7461 0065 6f48 646c 3120     Calculate.Hold 1
   20638:	433d 3156 3220 433d 3256 4100 523d 7365     =CV1 2=CV2.A=Res
   20648:	6c75 3174 4220 523d 7365 0032 704f 7265     ult1 B=Res2.Oper
   20658:	7461 6f69 006e 6143 7072 6765 6967 006f     ation.Carpeggio.
   20668:	3d31 2058 3d32 0059 3d41 7551 6e61 2074     1=X 2=Y.A=Quant 
   20678:	3d42 5828 2959 352f 0056 6f4e 6574 432f     B=(XY)/5V.Note/C
   20688:	6f68 6472 542f 6e72 7073 736f 4300 6f6c     hord/Trnspos.Clo
   20698:	6b63 4420 7669 4400 7669 4d2f 6c75 2074     ck Div.Div/Mult 
   206a8:	6843 2c31 6843 0032 6c43 206b 3d41 6843     Ch1,Ch2.Clk A=Ch
   206b8:	2031 3d42 6843 0032 6944 2c76 754d 746c     1 B=Ch2.Div,Mult
   206c8:	4300 6f6c 6b63 6553 0074 6c43 636f 536b     .ClockSet.ClockS
   206d8:	696b 0070 6c43 636f 206b 6843 2c31 4320     kip.Clock Ch1, C
   206e8:	3268 7000 4d20 646f 4320 3168 202c 6843     h2.p Mod Ch1, Ch
   206f8:	0032 6f43 706d 7261 0065 3d31 5643 2031     2.Compare.1=CV1 
   20708:	3d32 6f4d 2064 654c 6576 006c 3d41 5643     2=Mod Level.A=CV
   20718:	3e31 764c 4220 4c3d 3e76 433d 3156 5300     1>Lv B=Lv>=CV1.S
   20728:	7465 4c20 7665 6c65 4400 4372 7572 6873     et Level.DrCrush
   20738:	7265 3100 443d 6665 6165 0074 3d31 6e49     er.1=Defeat.1=In
   20748:	7570 0074 3d41 7243 7375 2068 3d42 6854     put.A=Crush B=Th
   20758:	7572 5200 7461 2f65 6544 7470 0068 7544     ru.Rate/Depth.Du
   20768:	6c61 7551 6e61 0074 6c43 636f 206b 3d31     alQuant.Clock 1=
   20778:	6843 2031 3d32 6843 0032 5643 3120 433d     Ch1 2=Ch2.CV 1=C
   20788:	3168 3220 433d 3268 5000 7469 6863 4120     h1 2=Ch2.Pitch A
   20798:	433d 3168 4220 433d 3268 5300 6163 656c     =Ch1 B=Ch2.Scale
   207a8:	522f 6f6f 0074 6e45 6769 616d 4a20 0072     /Root.Enigma Jr.
   207b8:	3d31 6c43 636f 006b 3d31 6853 6669 2074     1=Clock.1=Shift 
   207c8:	3d32 724f 6167 696e 657a 5200 6765 502f     2=Organize.Reg/P
   207d8:	6f72 2f62 7341 6973 6e67 4500 766e 6f46     rob/Assign.EnvFo
   207e8:	6c6c 776f 4600 6c6f 6f6c 2f77 7544 6b63     llow.Follow/Duck
   207f8:	4700 6961 2f6e 7341 6973 6e67 4700 7461     .Gain/Assign.Gat
   20808:	4465 6c65 7961 4700 7461 2065 6843 2c31     eDelay.Gate Ch1,
   20818:	0032 6954 656d 4d20 646f 4320 3168 432c     2.Time Mod Ch1,C
   20828:	3268 4400 6c65 7961 4320 3168 322c 5300     h2.Delay Ch1,2.S
   20838:	7465 7420 6d69 0065 6147 6574 2064 4356     et time.Gated VC
   20848:	0041 3d31 2041 6147 6574 3220 423d 5220     A.1=A Gate 2=B R
   20858:	7665 7372 3100 433d 2056 6973 6e67 6c61     evrs.1=CV signal
   20868:	3220 413d 706d 4100 4e3d 726f 206d 666f      2=Amp.A=Norm of
   20878:	2066 3d42 2e4e 6f20 006e 3d54 6d41 2070     f B=N. on.T=Amp 
   20888:	5643 4f20 6666 6573 0074 6f4c 6946 5420     CV Offset.LoFi T
   20898:	7061 0065 6147 6574 3120 503d 7561 6573     ape.Gate 1=Pause
   208a8:	3220 523d 6365 3100 413d 6475 6f69 3220      2=Rec.1=Audio 2
   208b8:	533d 534f 4100 413d 6475 6f69 4220 453d     =SOS.A=Audio B=E
   208c8:	434f 5420 6772 5400 453d 646e 5020 2074     OC Trg.T=End Pt 
   208d8:	3d50 6552 0063 6f4c 6967 0063 3d31 6e49     P=Rec.Logic.1=In
   208e8:	2c31 3220 493d 326e 2d00 5643 3a2d 3d31     1, 2=In2.-CV-:1=
   208f8:	704f 2c31 3220 4f3d 3270 4c00 776f 7265     Op1, 2=Op2.Lower
   20908:	6552 7a6e 3100 523d 7365 7465 3220 463d     Renz.1=Reset 2=F
   20918:	6572 7a65 0065 3d31 7246 7165 3220 523d     reeze.1=Freq 2=R
   20928:	6f68 4100 783d 4220 793d 4600 6572 2f71     ho.A=x B=y.Freq/
   20938:	6852 006f 654d 7274 6e6f 6d6f 0065 3d41     Rho.Metronome.A=
   20948:	754d 746c 7069 796c 4220 423d 6165 0074     Multiply B=Beat.
   20958:	6554 706d 006f 694d 6578 3a72 6142 006c     Tempo.Mixer:Bal.
   20968:	2c31 2032 6953 6e67 6c61 0073 3d41 694d     1,2 Signals.A=Mi
   20978:	2078 754f 2074 3d42 6f43 706d 4200 6c61     x Out B=Comp.Bal
   20988:	6e61 6563 5000 6c61 6d69 7370 7365 0074     ance.Palimpsest.
   20998:	3d31 6c43 636f 206b 3d32 7242 7375 0068     1=Clock 2=Brush.
   209a8:	6f4d 2064 3d31 6f43 706d 736f 2065 3d32     Mod 1=Compose 2=
   209b8:	6544 4100 4f3d 7475 7570 2074 3d42 7254     De.A=Output B=Tr
   209c8:	6769 6567 0072 6f43 706d 442f 6365 6d6f     igger.Comp/Decom
   209d8:	2f70 654c 676e 6874 5200 6e75 6c67 6f42     p/Length.RunglBo
   209e8:	6b6f 3100 533d 6769 616e 006c 3d41 7552     ok.1=Signal.A=Ru
   209f8:	676e 656c 4220 413d 746c 5400 7268 7365     ngle B=Alt.Thres
   20a08:	6f68 646c 5300 6163 656c 7544 7465 3100     hold.ScaleDuet.1
   20a18:	433d 6f6c 6b63 3220 533d 6163 656c 6553     =Clock 2=ScaleSe
   20a28:	006c 3d31 5643 4100 503d 7469 6863 5400     l.1=CV.A=Pitch.T
   20a38:	4e3d 746f 2065 3d50 6f54 6767 656c 5300     =Note P=Toggle.S
   20a48:	6863 696d 7474 7254 4700 7461 2065 754f     chmittTr.Gate Ou
   20a58:	7570 7374 4120 422c 4800 6769 2f68 6f4c     puts A,B.High/Lo
   20a68:	2077 6854 6572 6873 5300 6f63 6570 4300     w Thresh.Scope.C
   20a78:	6b6c 3120 423d 4d50 3220 433d 6379 656c     lk 1=BPM 2=Cycle
   20a88:	0031 3d41 5643 2031 3d42 5643 0032 3d54     1.A=CV1 B=CV2.T=
   20a98:	6d53 6c70 6152 6574 5020 463d 6572 7a65     SmplRate P=Freez
   20aa8:	5300 7165 6575 636e 3565 3100 543d 6172     .Sequence5.1=Tra
   20ab8:	736e 6f70 6573 4100 433d 2056 3d42 6c43     nspose.A=CV B=Cl
   20ac8:	206b 7453 7065 3120 4e00 746f 0065 6853     k Step 1.Note.Sh
   20ad8:	6669 4774 7461 0065 2c31 2032 6147 6574     iftGate.1,2 Gate
   20ae8:	463d 696c 2070 6942 3074 4100 422c 4720     =Flip Bit0.A,B G
   20af8:	7461 2f65 7254 6769 6567 0072 654c 676e     ate/Trigger.Leng
   20b08:	6874 542f 7079 0065 6853 6675 6c66 0065     th/Type.Shuffle.
   20b18:	3d31 644f 2064 6f4d 2064 3d32 7645 6e65     1=Odd Mod 2=Even
   20b28:	4100 433d 6f6c 6b63 4f00 6464 452f 6576     .A=Clock.Odd/Eve
   20b38:	206e 6544 616c 0079 6b53 7765 6465 464c     n Delay.SkewedLF
   20b48:	004f 3d31 6552 6573 0074 6f4d 2064 3d31     O.1=Reset.Mod 1=
   20b58:	6152 6574 3220 533d 656b 0077 3d41 5643     Rate 2=Skew.A=CV
   20b68:	4220 433d 6f6c 6b63 5200 7461 2f65 6b53      B=Clock.Rate/Sk
   20b78:	7765 5300 656c 0077 6544 6566 7461 3120     ew.Slew.Defeat 1
   20b88:	433d 3168 3220 433d 3268 4900 706e 7475     =Ch1 2=Ch2.Input
   20b98:	3120 433d 3168 3220 433d 3268 4100 4c3d      1=Ch1 2=Ch2.A=L
   20ba8:	6e69 6165 2072 3d42 7845 0070 6952 6573     inear B=Exp.Rise
   20bb8:	462f 6c61 006c 7153 6175 636e 0068 3d31     /Fall.Squanch.1=
   20bc8:	6c43 636f 206b 3d32 312b 4f20 7463 4120     Clock 2=+1 Oct A
   20bd8:	3100 533d 6769 616e 206c 3d32 6853 6669     .1=Signal 2=Shif
   20be8:	2074 0042 2c41 3d42 7551 6e61 6974 657a     t B.A,B=Quantize
   20bf8:	0064 6853 6669 2f74 6353 6c61 0065 7753     d.Shift/Scale.Sw
   20c08:	7469 6863 3100 433d 6f6c 6b63 3220 473d     itch.1=Clock 2=G
   20c18:	7461 0065 2c31 3d32 5643 4100 533d 7165     ate.1,2=CV.A=Seq
   20c28:	4220 473d 7461 6465 4f20 7475 5400 204c      B=Gated Out.TL 
   20c38:	654e 7275 6e6f 3100 322c 443d 6e65 7264     Neuron.1,2=Dendr
   20c48:	7469 7365 3120 322c 3200 443d 6e65 7264     ites 1,2.2=Dendr
   20c58:	7469 3365 4100 422c 413d 6f78 206e 754f     ite3.A,B=Axon Ou
   20c68:	7074 7475 5400 533d 7465 5020 533d 6c65     tput.T=Set P=Sel
   20c78:	6365 0074 6853 6669 5274 6765 3100 433d     ect.ShiftReg.1=C
   20c88:	6f6c 6b63 3220 703d 4720 7461 0065 3d31     lock 2=p Gate.1=
   20c98:	654c 676e 6874 3220 703d 4d20 646f 4100     Length 2=p Mod.A
   20ca8:	513d 6175 746e 2d35 6962 2074 3d42 5643     =Quant5-bit B=CV
   20cb8:	0038 654c 676e 6874 502f 6f72 2f62 6353     8.Length/Prob/Sc
   20cc8:	6c61 0065 7254 6e65 6964 676e 3100 322c     ale.Trending.1,2
   20cd8:	533d 6769 616e 006c 2c41 3d42 7341 6973     =Signal.A,B=Assi
   20ce8:	6e67 6261 656c 4100 7373 6769 2f6e 6553     gnable.Assign/Se
   20cf8:	736e 7469 7669 7469 0079 7254 6769 6553     nsitivity.TrigSe
   20d08:	0071 3d31 7753 7061 4120 4226 4020 3320     q.1=Swap A&B @ 3
   20d18:	0056 7254 2067 3d41 6843 2031 3d42 6843     V.Trg A=Ch1 B=Ch
   20d28:	0032 7254 6769 6553 3171 0036 7254 2067     2.TrigSeq16.Trg 
   20d38:	3d41 7254 2067 3d42 6d43 0070 7554 656e     A=Trg B=Cmp.Tune
   20d48:	0072 6556 7463 726f 4745 3100 322c 473d     r.VectorEG.1,2=G
   20d58:	7461 0065 2c41 3d42 754f 0074 7246 7165     ate.A,B=Out.Freq
   20d68:	2f2e 6157 6576 6f66 6d72 5600 6365 6f74     ./Waveform.Vecto
   20d78:	4c72 4f46 3100 322c 533d 6e79 0063 3d31     rLFO.1,2=Sync.1=
   20d88:	7246 7165 2031 3d32 7441 6574 316e 4240     Freq1 2=Atten1@B
   20d98:	4f00 7475 4120 313d 202c 3d42 2b32 0031     .Out A=1, B=2+1.
   20da8:	6556 7463 726f 6f4d 0064 2c31 3d32 7254     VectorMod.1,2=Tr
   20db8:	6769 6567 0072 2c31 3d32 7943 6c63 0065     igger.1,2=Cycle.
   20dc8:	6556 7463 6f4d 7072 0068 2c31 3d32 6850     VectMorph.1,2=Ph
   20dd8:	7361 0065 6850 7361 2f65 6157 6576 6f66     ase.Phase/Wavefo
   20de8:	6d72 5600 6c6f 6174 6567 4700 7461 2065     rm.Voltage.Gate 
   20df8:	2c31 0032 6f56 746c 6761 2065 2c41 0042     1,2.Voltage A,B.
   20e08:	6f56 746c 6761 2f65 6147 6974 676e 4d00     Voltage/Gating.M
   20e18:	4449 4949 006e 494d 4944 4320 2f68 7341     IDIIn.MIDI Ch/As
   20e28:	6973 6e67 4c2f 676f 4d00 4449 4f49 7475     sign/Log.MIDIOut
   20e38:	4100 7466 4200 6e65 0064 6556 6f6c 0063     .Aft.Bend.Veloc.
   20e48:	3d31 6147 6574 3100 503d 7469 6863 3220     1=Gate.1=Pitch 2
   20e58:	413d 7373 6769 006e 6843 542f 7072 412f     =Assign.Ch/Trp/A
   20e68:	7373 6769 2f6e 6f4c 0067 3441 4820 207a     ssign/Log.A4 Hz 
   20e78:	3d50 6552 6573 0074 7544 2065 6f74 6820     P=Reset.Due to h
   20e88:	7261 7764 7261 0065 6f63 736e 7274 6961     ardware.constrai
   20e98:	746e 2c73 7420 6568 5400 6e75 7265 6d20     nts, the.Tuner m
   20ea8:	7375 2074 7572 206e 6e69 6c00 6665 2074     ust run in.left 
   20eb8:	6568 696d 7073 6568 6572 4100 6464 5320     hemisphere.Add S
   20ec8:	6574 0070 6544 206c 7453 7065 5200 6e61     tep.Del Step.Ran
   20ed8:	6567 003a 352d 2056 3e2d 3520 0056 332d     ge:.-5V -> 5V.-3
   20ee8:	2056 3e2d 3720 0056 3020 2056 3e2d 3120     V -> 7V. 0V -> 1
   20ef8:	5630 3e00 0020 6144 6174 4200 6361 756b     0V.> .Data.Backu
   20f08:	2070 202f 6552 7473 726f 0065 6552 6563     p / Restore.Rece
   20f18:	7669 6e69 2e67 2e2e 4c00 7369 6574 696e     iving....Listeni
   20f28:	676e 2e2e 002e 6f44 656e 0021 6552 7473     ng....Done!.Rest
   20f38:	726f 2065 726f 4220 6361 756b 3f70 5b00     ore or Backup?.[
   20f48:	4143 434e 4c45 005d 525b 5345 4f54 4552     CANCEL].[RESTORE
   20f58:	005d 425b 4341 554b 5d50 4200 6361 756b     ].[BACKUP].Backu
   20f68:	3a70 0020 6553 7574 2070 202f 6241 756f     p: .Setup / Abou
   20f78:	0074 6548 696d 7073 6568 6572 5320 6975     t.Hemisphere Sui
   20f88:	6574 7600 2e31 4138 562b 524f 6200 6965     te.v1.8A+VOR.bei
   20f98:	6567 616d 657a 632e 6d6f 682f 0073 435b     gemaze.com/hs.[C
   20fa8:	4c41 4249 4152 4554 205d 2020 525b 5345     ALIBRATE]   [RES
   20fb8:	5445 005d 6552 6967 7473 7265 7000 003d     ET].Register.p=.
   20fc8:	694c 7262 7261 0079 203a 6b54 5400 6172     Library.: Tk.Tra
   20fd8:	6b63 0020 494d 4944 4320 2068 3c00 4c20     ck .MIDI Ch .< L
   20fe8:	6f6f 2070 003e 203c 7453 706f 3e20 5400     oop >.< Stop >.T
   20ff8:	6172 6b63 2000 0078 6150 7375 2f65 6c50     rack. x.Pause/Pl
   21008:	7961 5400 206b 7453 7065 2020 6552 0067     ay.Tk Step  Reg.
   21018:	002f 6e45 6769 616d 2d20 0020 654e 2077     /.Enigma - .New 
   21028:	6f53 676e 4500 6172 6573 7320 6e6f 2067     Song.Erase song 
   21038:	6e61 2064 6572 6573 0074 756f 7074 7475     and reset.output
   21048:	3a73 5320 7275 3f65 5b00 4559 5d53 5b00     s: Sure?.[YES].[
   21058:	4f4e 005d 6944 0067 6e45 0063 6854 3a72     NO].Dig.Enc.Thr:
   21068:	4f00 6666 6573 3a74 4200 4d50 0020 7953     .Offset:.BPM .Sy
   21078:	4573 3a78 0020 6143 7470 6961 206e 494d     sEx: .Captain MI
   21088:	4944 4800 6d65 7369 6870 7265 0065 2e44     DI.Hemisphere.D.
   21098:	5420 6d69 6c65 6e69 0065 6353 6c61 2065      Timeline.Scale 
   210a8:	6445 4500 696e 6d67 0061 6157 6576 6f66     Ed.Enigma.Wavefo
   210b8:	6d72 4520 0064 5f4f 2043 4545 5250 4d4f     rm Ed.O_C EEPROM
   210c8:	4200 6361 756b 0070 654e 7275 6c61 4e20     .Backup.Neural N
   210d8:	7465 4d00 4449 2049 7341 6973 6e67 4d00     et.MIDI Assign.M
   210e8:	4449 2049 6843 6e61 656e 006c 6152 676e     IDI Channel.Rang
   210f8:	2065 6f4c 0077 6152 676e 2065 6948 6867     e Low.Range High
   21108:	5300 7465 7075 0020 2020 2020 2020 2020     .Setup .        
   21118:	2020 2020 2020 2020 2020 2d20 002d 445b                --.[D
   21128:	4d55 5d50 5b00 4f43 5950 005d 6f43 7970     UMP].[COPY].Copy
   21138:	5300 7379 7845 4900 204f 6843 5420 7079     .SysEx.IO Ch Typ
   21148:	2065 5620 6c61 6575 0073 6f54 6767 006c     e  Values.Toggl.
   21158:	6544 206e 4f00 6470 4400 0056 7341 6973     Den .Opd.DV.Assi
   21168:	6e67 4f20 7475 7570 7374 4f00 7475 7570     gn Outputs.Outpu
   21178:	2074 4e00 7565 6f72 206e 5000 6e6f 2067     t .Neuron .Pong 
   21188:	6948 6867 3a20 0020 6f50 676e 5320 6f63     High : .Pong Sco
   21198:	6572 203a 3f00 5b06 664f 7d6d 7f07 0067     re: .?.[Ofm}..g.
   211a8:	6d49 6f70 7472 5b00 4d49 4f50 5452 005d     Import.[IMPORT].
   211b8:	6353 6c61 2065 6445 7469 726f 2020 2020     Scale Editor    
   211c8:	5300 6163 656c 2020 3a20 0020 494d 4944     .Scale   : .MIDI
   211d8:	4f20 7475 203a 2000 2020 2020 6c41 3a74      Out: .     Alt:
   211e8:	0020 2020 2020 4920 206e 203a 5400 6772      .     In : .Trg
   211f8:	472f 7461 3a65 0020 6144 6b72 7365 2074     /Gate: .Darkest 
   21208:	6954 656d 696c 656e 4100 6464 5720 7661     Timeline.Add Wav
   21218:	6665 726f 206d 2800 6143 6e6e 746f 4120     eform .(Cannot A
   21228:	6464 0029 6544 206c 6157 6576 6f66 6d72     dd).Del Waveform
   21238:	0020 4328 6e61 6f6e 2074 6544 296c 5700      .(Cannot Del).W
   21248:	7661 6665 726f 206d 6445 7469 726f 4900     aveform Editor.I
   21258:	646e 7865 203a 4200 2044 6f54 656e 2000     ndex: .BD Tone. 
   21268:	4420 6365 7961 5300 2044 6f54 656e 4200      Decay.SD Tone.B
   21278:	656c 646e 2500 4320 2500 4120 2000 754d     lend.% C.% A. Mu
   21288:	746c 6200 7275 7473 0073 6d53 6f6f 6874     lt.bursts.Smooth
   21298:	4300 6f6c 6b63 5320 7465 7075 4900 746e     .Clock Setup.Int
   212a8:	7265 616e 006c 6f46 7772 7261 0064 4220     ernal.Forward. B
   212b8:	4d50 6b00 7a48 2d00 6962 0074 6f46 6c6c     PM.kHz.-bit.Foll
   212c8:	4600 6572 0071 6353 6c61 2065 0200 0a07     .Freq.Scale ....
   212d8:	120f 1f1a 2722 2f2a 0032 7447 0065 3a43     ...."'*/2.Gte.C:
   212e8:	4100 003a 3a44 4200 003a 003c 3441 203d     .A:.D:.B:.<.A4= 
   212f8:	2000 7a48 5400 6e75 7265 6720 656f 0073     . Hz.Tuner goes.
   21308:	6e69 6c20 6665 0074 2d3c 002d 0060 2020     in left.<--.`.  
   21318:	2d47 6e4f 2000 4720 4f2d 6666 4300 3a68     G-On.  G-Off.Ch:
   21328:	4100 3a20 4300 3a20 4200 3a20 4400 3a20     .A :.C :.B :.D :
   21338:	5400 3a72 6900 3a32 4c00 6765 7461 206f     .Tr:.i2:.Legato 
   21348:	5300 7661 6e69 2e67 2e2e 5300 7465 7075     .Saving....Setup
   21358:	203a 6552 6573 0074 6552 6573 2074 7061     : Reset.Reset ap
   21368:	6c70 6369 7461 6f69 006e 6573 7474 6e69     plication.settin
   21378:	7367 6f20 206e 4545 5250 4d4f 003f 435b     gs on EEPROM?.[C
   21388:	4e41 4543 5d4c 2020 2020 2020 2020 5b20     ANCEL]         [
   21398:	4b4f 005d 764f 7265 7277 7469 3f65 0020     OK].Overwrite? .
   213a8:	6153 6576 203f 4e00 2042 6572 6c70 6361     Save? .NB replac
   213b8:	7365 6520 6978 7473 6e69 2167 4d00 7861     es existing!.Max
   213c8:	5300 6d75 4400 6669 0066 654d 6e61 5300     .Sum.Diff.Mean.S
   213d8:	4826 5200 646e 5800 524f 4e00 4e41 0044     &H.Rnd.XOR.NAND.
   213e8:	4e58 524f 2d00 5643 002d 6f4e 6574 0023     XNOR.-CV-.Note#.
   213f8:	7254 6769 4f00 4326 4320 6c61 6269 6172     Trig.O&C Calibra
   21408:	6974 6e6f 5500 6573 6420 6665 7561 746c     tion.Use default
   21418:	3f73 0020 6543 746e 7265 4420 7369 6c70     s? .Center Displ
   21428:	7961 5000 7869 6c65 6f20 6666 6573 2074     ay.Pixel offset 
   21438:	4400 4341 4120 2020 2e30 2030 6f76 746c     .DAC A  0.0 volt
   21448:	0073 3e2d 3020 302e 3030 2056 4400 4341     s.-> 0.000V .DAC
   21458:	4120 2020 2e31 2030 6f76 746c 0073 3e2d      A  1.0 volts.->
   21468:	3120 302e 3030 2056 4400 4341 4120 2020      1.000V .DAC A  
   21478:	2e32 2030 6f76 746c 0073 3e2d 3220 302e     2.0 volts.-> 2.0
   21488:	3030 2056 4400 4341 4120 2020 2e33 2030     00V .DAC A  3.0 
   21498:	6f76 746c 0073 3e2d 3320 302e 3030 2056     volts.-> 3.000V 
   214a8:	4400 4341 4120 2020 2e34 2030 6f76 746c     .DAC A  4.0 volt
   214b8:	0073 3e2d 3420 302e 3030 2056 4400 4341     s.-> 4.000V .DAC
   214c8:	4120 2020 2e35 2030 6f76 746c 0073 3e2d      A  5.0 volts.->
   214d8:	3520 302e 3030 2056 4400 4341 4120 2020      5.000V .DAC A  
   214e8:	2e36 2030 6f76 746c 0073 3e2d 3620 302e     6.0 volts.-> 6.0
   214f8:	3030 2056 4400 4341 4120 2020 2e37 2030     00V .DAC A  7.0 
   21508:	6f76 746c 0073 3e2d 3720 302e 3030 2056     volts.-> 7.000V 
   21518:	4400 4341 4120 2020 2e38 2030 6f76 746c     .DAC A  8.0 volt
   21528:	0073 3e2d 3820 302e 3030 2056 4400 4341     s.-> 8.000V .DAC
   21538:	4120 2020 2e39 2030 6f76 746c 0073 3e2d      A  9.0 volts.->
   21548:	3920 302e 3030 2056 4400 4341 4120 3120      9.000V .DAC A 1
   21558:	2e30 2030 6f76 746c 0073 3e2d 3120 2e30     0.0 volts.-> 10.
   21568:	3030 5630 0020 4144 2043 2042 3020 302e     000V .DAC B  0.0
   21578:	7620 6c6f 7374 4400 4341 4220 2020 2e31      volts.DAC B  1.
   21588:	2030 6f76 746c 0073 4144 2043 2042 3220     0 volts.DAC B  2
   21598:	302e 7620 6c6f 7374 4400 4341 4220 2020     .0 volts.DAC B  
   215a8:	2e33 2030 6f76 746c 0073 4144 2043 2042     3.0 volts.DAC B 
   215b8:	3420 302e 7620 6c6f 7374 4400 4341 4220      4.0 volts.DAC B
   215c8:	2020 2e35 2030 6f76 746c 0073 4144 2043       5.0 volts.DAC 
   215d8:	2042 3620 302e 7620 6c6f 7374 4400 4341     B  6.0 volts.DAC
   215e8:	4220 2020 2e37 2030 6f76 746c 0073 4144      B  7.0 volts.DA
   215f8:	2043 2042 3820 302e 7620 6c6f 7374 4400     C B  8.0 volts.D
   21608:	4341 4220 2020 2e39 2030 6f76 746c 0073     AC B  9.0 volts.
   21618:	4144 2043 2042 3031 302e 7620 6c6f 7374     DAC B 10.0 volts
   21628:	4400 4341 4320 2020 2e30 2030 6f76 746c     .DAC C  0.0 volt
   21638:	0073 4144 2043 2043 3120 302e 7620 6c6f     s.DAC C  1.0 vol
   21648:	7374 4400 4341 4320 2020 2e32 2030 6f76     ts.DAC C  2.0 vo
   21658:	746c 0073 4144 2043 2043 3320 302e 7620     lts.DAC C  3.0 v
   21668:	6c6f 7374 4400 4341 4320 2020 2e34 2030     olts.DAC C  4.0 
   21678:	6f76 746c 0073 4144 2043 2043 3520 302e     volts.DAC C  5.0
   21688:	7620 6c6f 7374 4400 4341 4320 2020 2e36      volts.DAC C  6.
   21698:	2030 6f76 746c 0073 4144 2043 2043 3720     0 volts.DAC C  7
   216a8:	302e 7620 6c6f 7374 4400 4341 4320 2020     .0 volts.DAC C  
   216b8:	2e38 2030 6f76 746c 0073 4144 2043 2043     8.0 volts.DAC C 
   216c8:	3920 302e 7620 6c6f 7374 4400 4341 4320      9.0 volts.DAC C
   216d8:	3120 2e30 2030 6f76 746c 0073 4144 2043      10.0 volts.DAC 
   216e8:	2044 3020 302e 7620 6c6f 7374 4400 4341     D  0.0 volts.DAC
   216f8:	4420 2020 2e31 2030 6f76 746c 0073 4144      D  1.0 volts.DA
   21708:	2043 2044 3220 302e 7620 6c6f 7374 4400     C D  2.0 volts.D
   21718:	4341 4420 2020 2e33 2030 6f76 746c 0073     AC D  3.0 volts.
   21728:	4144 2043 2044 3420 302e 7620 6c6f 7374     DAC D  4.0 volts
   21738:	4400 4341 4420 2020 2e35 2030 6f76 746c     .DAC D  5.0 volt
   21748:	0073 4144 2043 2044 3620 302e 7620 6c6f     s.DAC D  6.0 vol
   21758:	7374 4400 4341 4420 2020 2e37 2030 6f76     ts.DAC D  7.0 vo
   21768:	746c 0073 4144 2043 2044 3820 302e 7620     lts.DAC D  8.0 v
   21778:	6c6f 7374 4400 4341 4420 2020 2e39 2030     olts.DAC D  9.0 
   21788:	6f76 746c 0073 4144 2043 2044 3031 302e     volts.DAC D 10.0
   21798:	7620 6c6f 7374 3000 302e 3030 3a56 6220      volts.0.000V: b
   217a8:	7069 6c6f 7261 2d00 3e2d 3020 302e 3030     ipolar.--> 0.000
   217b8:	0056 2e30 3030 5630 203a 7361 6d79 002e     V.0.000V: asym..
   217c8:	4441 2043 5643 0031 4441 2043 6176 756c     ADC CV1.ADC valu
   217d8:	2065 7461 3020 0056 4441 2043 5643 0032     e at 0V.ADC CV2.
   217e8:	4441 2043 5643 0033 4441 2043 5643 0034     ADC CV3.ADC CV4.
   217f8:	5643 5320 6163 696c 676e 3120 0056 5643     CV Scaling 1V.CV
   21808:	3a31 4920 706e 7475 3120 2056 4328 2932     1: Input 1V (C2)
   21818:	5b00 5d52 4c20 6e6f 2067 7270 7365 2073     .[R] Long press 
   21828:	6f74 7320 7465 4300 2056 6353 6c61 6e69     to set.CV Scalin
   21838:	2067 5633 4300 3156 203a 6e49 7570 2074     g 3V.CV1: Input 
   21848:	5633 2820 3443 0029 6353 6572 6e65 6173     3V (C4).Screensa
   21858:	6576 0072 6954 656d 756f 2074 7328 0029     ver.Timeout (s).
   21868:	6143 696c 7262 7461 6f69 206e 6f63 706d     Calibration comp
   21878:	656c 6574 5300 7661 2065 6176 756c 7365     lete.Save values
   21888:	203f 5b00 5d52 3d20 203e 6553 656c 7463     ? .[R] => Select
   21898:	5b00 5d52 3d20 203e 6441 756a 7473 5b00     .[R] => Adjust.[
   218a8:	5250 5645 205d 2020 2020 2020 2020 4e5b     PREV]         [N
   218b8:	5845 5d54 5b00 5250 5645 205d 2020 2020     EXT].[PREV]     
   218c8:	2020 2020 455b 4958 5d54 2000 2020 2020         [EXIT].     
   218d8:	2020 2020 2020 2020 5b20 5453 5241 5d54              [START]
   218e8:	5300 6163 656c 4520 6964 6f74 0072 6f50     .Scale Editor.Po
   218f8:	676e 5200 7369 6e69 0067 6146 6c6c 6e69     ng.Rising.Fallin
   21908:	0067 6f4d 6976 676e 5300 6574 6461 0079     g.Moving.Steady.
   21918:	6843 5367 6174 6574 4300 6768 6156 756c     ChgState.ChgValu
   21928:	0065 3631 372e 3800 332e 3500 362e 3400     e.16.7.8.3.5.6.4
   21938:	322e 3300 332e 3200 312e 2e00 0035 614d     .2.3.3.2.1..5.Ma
   21948:	206a 7274 6169 0064 614d 206a 6e69 2076     j triad.Maj inv 
   21958:	0031 614d 206a 6e69 2076 0032 696d 206e     1.Maj inv 2.min 
   21968:	7274 6169 0064 696d 206e 6e69 2076 0031     triad.min inv 1.
   21978:	696d 206e 6e69 2076 0032 6964 206d 7274     min inv 2.dim tr
   21988:	6169 0064 634f 6174 6576 0073 2031 0035     iad.Octaves.1 5.
   21998:	7561 2067 7274 6169 0064 6461 3264 6d00     aug triad.add2.m
   219a8:	6e69 6128 6464 2932 6100 6464 0034 696d     in(add2).add4.mi
   219b8:	286e 342b 0029 7573 3473 2b28 2932 3100     n(+4).sus4(+2).1
   219c8:	3332 3534 3100 6232 3433 0035 6461 2864     2345.12b345.add(
   219d8:	3123 2931 4d00 6a61 0036 696d 366e 4d00     #11).Maj6.min6.M
   219e8:	6a61 0037 7337 7375 0032 7337 7375 0034     aj7.7sus2.7sus4.
   219f8:	696d 376e 6400 6d69 0037 614d 396a 4d00     min7.dim7.Maj9.M
   21a08:	6a61 2f36 0039 614d 236a 3131 3700 6228     aj6/9.Maj#11.7(b
   21a18:	2939 3700 6228 2c39 3162 2933 4d00 7869     9).7(b9,b13).Mix
   21a28:	6c6f 6479 002e 6148 6d72 4d20 6e69 4d00     olyd..Harm Min.M
   21a38:	6c65 4d20 6e69 6d00 6e69 5020 6e65 6174     el Min.min Penta
   21a48:	4d00 6a61 4220 756c 7365 6d00 6e69 4220     .Maj Blues.min B
   21a58:	756c 7365 4200 6265 706f 5700 6f68 656c     lues.Bebop.Whole
   21a68:	6f54 656e 4400 6d69 3120 3120 322f 4400     Tone.Dim 1 1/2.D
   21a78:	6d69 3120 322f 3120 4100 746c 7265 6465     im 1/2 1.Altered
   21a88:	4300 7268 6d6f 7461 6369 4100 6c6c 3420     .Chromatic.All 4
   21a98:	6874 4100 6c6c 3520 6874 5200 6365 3120     th.All 5th.Rec 1
   21aa8:	5200 6365 3220 5200 6365 3120 322b 4900     .Rec 2.Rec 1+2.I
   21ab8:	646e 7865 4d00 4449 2049 6843 6e61 656e     ndex.MIDI Channe
   21ac8:	206c 6c41 0074 494d 4944 4320 6168 6e6e     l Alt.MIDI Chann
   21ad8:	6c65 4920 006e 7254 6769 6567 2072 6350     el In.Trigger Pc
   21ae8:	0074 7453 4400 6769 0031 6944 3267 4400     t.St.Dig1.Dig2.D
   21af8:	6769 0033 6944 3467 4300 2056 0031 5643     ig3.Dig4.CV 1.CV
   21b08:	3220 4300 2056 0033 5643 3420 4e00 7565      2.CV 3.CV 4.Neu
   21b18:	0031 654e 3275 4e00 7565 0033 654e 3475     1.Neu2.Neu3.Neu4
   21b28:	4e00 7565 0035 654e 3675 4f00 004e 464f     .Neu5.Neu6.ON.OF
   21b38:	0046 4f4e 0054 2d44 4646 5400 462d 0046     F.NOT.D-FF.T-FF.
   21b48:	744c 6863 5400 4e4c 0065 494d 4944 3e20     Ltch.TLNe.MIDI >
   21b58:	4120 4d00 4449 2049 203e 0042 494d 4944      A.MIDI > B.MIDI
   21b68:	3e20 4320 4d00 4449 2049 203e 0044 2031      > C.MIDI > D.1 
   21b78:	203e 494d 4944 3200 3e20 4d20 4449 0049     > MIDI.2 > MIDI.
   21b88:	2033 203e 494d 4944 3400 3e20 4d20 4449     3 > MIDI.4 > MID
   21b98:	0049 4343 0023 6944 6761 4c00 6765 002e     I.CC#.Diag.Leg..
   21ba8:	7845 7270 4800 6c6f 0064 7242 6874 7900     Expr.Hold.Brth.y
   21bb8:	7841 7369 5100 7274 3800 6874 3100 7436     Axis.Qtr.8th.16t
   21bc8:	0068 3432 7070 0071 7041 6c70 7465 4920     h.24ppq.Applet I
   21bd8:	2044 004c 7041 6c70 7465 4920 2044 0052     D L.Applet ID R.
   21be8:	6144 6174 4c20 6c20 776f 4400 7461 2061     Data L low.Data 
   21bf8:	2052 6f6c 0077 6144 6174 4c20 6820 6769     R low.Data L hig
   21c08:	0068 6144 6174 5220 6820 6769 0068 6f4e     h.Data R high.No
   21c18:	6574 332d 4e00 746f 2d65 0034 6f4e 6574     te-3.Note-4.Note
   21c28:	352d 4e00 746f 2d65 0036 6f4e 6574 372d     -5.Note-6.Note-7
   21c38:	4e00 746f 2065 2d33 6942 0074 6f4e 6574     .Note 3-Bit.Note
   21c48:	3420 422d 7469 4e00 746f 2065 2d35 6942      4-Bit.Note 5-Bi
   21c58:	0074 6f4e 6574 3620 422d 7469 4e00 746f     t.Note 6-Bit.Not
   21c68:	2065 2d37 6942 0074 6f4d 7564 616c 6974     e 7-Bit.Modulati
   21c78:	6e6f 4500 7078 6572 7373 6f69 006e 3620     on.Expression. 6
   21c88:	2000 0037 3820 2000 0039 3331 3100 0034     . 7. 8. 9.13.14.
   21c98:	2d43 0031 2343 312d 4400 312d 4400 2d23     C-1.C#-1.D-1.D#-
   21ca8:	0031 2d45 0031 2d46 0031 2346 312d 4700     1.E-1.F-1.F#-1.G
   21cb8:	312d 4700 2d23 0031 2d41 0031 2341 312d     -1.G#-1.A-1.A#-1
   21cc8:	4200 312d 4300 0030 2343 0030 3044 4400     .B-1.C0.C#0.D0.D
   21cd8:	3023 4500 0030 3046 4600 3023 4700 0030     #0.E0.F0.F#0.G0.
   21ce8:	2347 0030 3041 4100 3023 4200 0030 3143     G#0.A0.A#0.B0.C1
   21cf8:	4300 3123 4400 0031 2344 0031 3145 4600     .C#1.D1.D#1.E1.F
   21d08:	0031 2346 0031 3147 4700 3123 4100 0031     1.F#1.G1.G#1.A1.
   21d18:	2341 0031 3142 4300 0032 2343 0032 3244     A#1.B1.C2.C#2.D2
   21d28:	4400 3223 4500 0032 3246 4600 3223 4700     .D#2.E2.F2.F#2.G
   21d38:	0032 2347 0032 3241 4100 3223 4200 0032     2.G#2.A2.A#2.B2.
   21d48:	3343 4300 3323 4400 0033 2344 0033 3345     C3.C#3.D3.D#3.E3
   21d58:	4600 0033 2346 0033 3347 4700 3323 4100     .F3.F#3.G3.G#3.A
   21d68:	0033 2341 0033 3342 4300 0034 2343 0034     3.A#3.B3.C4.C#4.
   21d78:	3444 4400 3423 4500 0034 3446 4600 3423     D4.D#4.E4.F4.F#4
   21d88:	4700 0034 2347 0034 3441 4100 3423 4200     .G4.G#4.A4.A#4.B
   21d98:	0034 3543 4300 3523 4400 0035 2344 0035     4.C5.C#5.D5.D#5.
   21da8:	3545 4600 0035 2346 0035 3547 4700 3523     E5.F5.F#5.G5.G#5
   21db8:	4100 0035 2341 0035 3542 4300 0036 2343     .A5.A#5.B5.C6.C#
   21dc8:	0036 3644 4400 3623 4500 0036 3646 4600     6.D6.D#6.E6.F6.F
   21dd8:	3623 4700 0036 2347 0036 3641 4100 3623     #6.G6.G#6.A6.A#6
   21de8:	4200 0036 3743 4300 3723 4400 0037 2344     .B6.C7.C#7.D7.D#
   21df8:	0037 3745 4600 0037 2346 0037 3747 4700     7.E7.F7.F#7.G7.G
   21e08:	3723 4100 0037 2341 0037 3742 4300 0038     #7.A7.A#7.B7.C8.
   21e18:	2343 0038 3844 4400 3823 4500 0038 3846     C#8.D8.D#8.E8.F8
   21e28:	4600 3823 4700 0038 2347 0038 3841 4100     .F#8.G8.G#8.A8.A
   21e38:	3823 4200 0038 3943 4300 3923 4400 0039     #8.B8.C9.C#9.D9.
   21e48:	2344 0039 3945 4600 0039 2346 0039 3947     D#9.E9.F9.F#9.G9
   21e58:	ff00 ffff                                   ....

00021e5c <vtable for Backup>:
	...
   21e64:	52b9 0000 6ed9 0001                         .R...n..

00021e6c <vtable for EnigmaTMWS>:
	...
   21e74:	7585 0000 5aa5 0001 6f3d 0000 7351 0000     .u...Z..=o..Qs..
   21e84:	7a95 0000 7da5 0000 ff80 ffff 0000 0000     .z...}..........
   21e94:	7aab 0000 7ea5 0000                         .z...~..

00021e9c <vtable for HemisphereManager>:
	...
   21ea4:	a4c7 0000 a5b5 0000                         ........

00021eac <vtable for CaptainMIDI>:
	...
   21eb4:	5561 0000 6089 0001 a8c9 0000 5ee7 0001     aU...`.......^..
   21ec4:	4381 0001 ad4d 0000 fff8 ffff 0000 0000     .C..M...........
   21ed4:	a91f 0000 43b3 0001 adf1 0000 5ef5 0001     .....C.......^..

00021ee4 <vtable for NeuralNetwork>:
	...
   21eec:	14e5 0000 3ee5 0001 c061 0000 b8b9 0000     .....>..a.......
   21efc:	5379 0000 58b1 0000 ff80 ffff 0000 0000     yS...X..........
   21f0c:	5445 0000 5969 0000                         ET..iY..

00021f14 <vtable for ScaleEditor>:
	...
   21f1c:	cac5 0000 5cdd 0000 c98d 0000 152b 0000     .....\......+...
   21f2c:	544d 0000 ca1d 0000 ff80 ffff 0000 0000     MT..............
   21f3c:	54c9 0000 cabd 0000                         .T......

00021f44 <vtable for Settings>:
	...
   21f4c:	152d 0000 1531 0000 5dbd 0000 152f 0000     -...1....]../...

00021f5c <vtable for TheDarkestTimeline>:
	...
   21f64:	6011 0000 6575 0001 d261 0000 3e01 0000     .`..ue..a....>..
   21f74:	55e5 0000 5825 0000 ff80 ffff 0000 0000     .U..%X..........
   21f84:	56d9 0000 58a9 0000                         .V...X..

00021f8c <vtable for WaveformEditor>:
	...
   21f94:	da19 0000 5601 0001 e0b9 0000 e17d 0000     .....V......}...
   21fa4:	54e1 0000 57c5 0000 ff80 ffff 0000 0000     .T...W..........
   21fb4:	5559 0000 581d 0000                         YU...X..

00021fbc <vtable for ADEG>:
	...
   21fc4:	1541 0000 1549 0000 9dc9 0000 e4dd 0000     A...I...........
   21fd4:	155d 0000                                   ]...

00021fd8 <vtable for ADSREG>:
	...
   21fe0:	1629 0000 1631 0000 4bad 0001 e67d 0000     )...1....K..}...
   21ff0:	1661 0000                                   a...

00021ff4 <vtable for ASR>:
	...
   21ffc:	172d 0000 6135 0000 54f5 0001 e81d 0000     -...5a...T......
   2200c:	1735 0000                                   5...

00022010 <vtable for AnnularFusion>:
	...
   22018:	17ad 0000 eb19 0000 9d19 0000 ea0d 0000     ................
   22028:	17b5 0000                                   ....

0002202c <vtable for AttenuateOffset>:
	...
   22034:	1851 0000 1859 0000 952d 0000 ed79 0000     Q...Y...-...y...
   22044:	1861 0000                                   a...

00022048 <vtable for Binary>:
	...
   22050:	1935 0000 c51d 0000 4b29 0001 c661 0000     5.......)K..a...
   22060:	193d 0000                                   =...

00022064 <vtable for BootsNCat>:
	...
   2206c:	1985 0000 efaf 0000 d889 0000 ef49 0000     ............I...
   2207c:	198d 0000                                   ....

00022080 <vtable for Brancher>:
	...
   22088:	1a19 0000 1a21 0000 548d 0001 f19d 0000     ....!....T......
   22098:	1a2d 0000                                   -...

0002209c <vtable for Burst>:
	...
   220a4:	1ab1 0000 1ab9 0000 f2ed 0000 f2b1 0000     ................
   220b4:	1add 0000                                   ....

000220b8 <vtable for CVRecV2>:
	...
   220c0:	1b3d 0000 c511 0000 97f9 0000 f5d1 0000     =...............
   220d0:	1b45 0000                                   E...

000220d4 <vtable for Calculate>:
	...
   220dc:	1ce1 0000 1ce9 0000 975f 0000 f655 0000     ........_...U...
   220ec:	1d49 0000                                   I...

000220f0 <vtable for Carpeggio>:
	...
   220f8:	1df9 0000 f885 0000 f957 0000 f801 0000     ........W.......
   22108:	1e01 0000                                   ....

0002210c <vtable for ClockDivider>:
	...
   22114:	1ee9 0000 1ef1 0000 9c25 0000 facd 0000     ........%.......
   22124:	1f11 0000                                   ....

00022128 <vtable for ClockSetup>:
	...
   22130:	2001 0000 2009 0000 200b 0000 fc35 0000     . ... ... ..5...
   22140:	200d 0000                                   . ..

00022144 <vtable for ClockSkip>:
	...
   2214c:	2051 0000 2059 0000 9bb3 0000 8b65 0000     Q ..Y ......e...
   2215c:	2069 0000                                   i ..

00022160 <vtable for Compare>:
	...
   22168:	2115 0000 211d 0000 9f43 0000 fcc9 0000     .!...!..C.......
   22178:	2129 0000                                   )!..

0002217c <vtable for DrCrusher>:
	...
   22184:	218d 0000 2195 0000 4acd 0001 fd99 0000     .!...!...J......
   22194:	2199 0000                                   .!..

00022198 <vtable for DualQuant>:
	...
   221a0:	2209 0000 60d7 0000 96e1 0000 ff69 0000     ."...`......i...
   221b0:	2211 0000                                   ."..

000221b4 <vtable for EnigmaJr>:
	...
   221bc:	22a1 0000 011b 0001 02c9 0001 00e5 0001     ."..............
   221cc:	22a9 0000                                   ."..

000221d0 <vtable for EnvFollow>:
	...
   221d8:	232d 0000 2335 0000 942d 0000 0499 0001     -#..5#..-.......
   221e8:	234d 0000                                   M#..

000221ec <vtable for GateDelay>:
	...
   221f4:	23f9 0000 2401 0000 49dd 0001 053d 0001     .#...$...I..=...
   22204:	2445 0000                                   E$..

00022208 <vtable for GatedVCA>:
	...
   22210:	2515 0000 251d 0000 4979 0001 8c15 0000     .%...%..yI......
   22220:	2525 0000                                   %%..

00022224 <vtable for LoFiPCM>:
	...
   2222c:	2591 0000 2599 0000 48af 0001 0605 0001     .%...%...H......
   2223c:	25ad 0000                                   .%..

00022240 <vtable for Logic>:
	...
   22248:	2665 0000 266d 0000 4841 0001 8c51 0000     e&..m&..AH..Q...
   22258:	26cd 0000                                   .&..

0002225c <vtable for LowerRenz>:
	...
   22264:	2785 0000 278d 0000 5345 0001 07a1 0001     .'...'..ES......
   22274:	2799 0000                                   .'..

00022278 <vtable for Metronome>:
	...
   22280:	2809 0000 2811 0000 9b7b 0000 0915 0001     .(...(..{.......
   22290:	2815 0000                                   .(..

00022294 <vtable for MixerBal>:
	...
   2229c:	2849 0000 2851 0000 94e5 0000 8d11 0000     I(..Q(..........
   222ac:	2859 0000                                   Y(..

000222b0 <vtable for Palimpsest>:
	...
   222b8:	28bd 0000 28c5 0000 51e9 0001 0a4d 0001     .(...(...Q..M...
   222c8:	28dd 0000                                   .(..

000222cc <vtable for RunglBook>:
	...
   222d4:	29c5 0000 29cd 0000 5177 0001 8b31 0000     .)...)..wQ..1...
   222e4:	29d9 0000                                   .)..

000222e8 <vtable for ScaleDuet>:
	...
   222f0:	2a61 0000 60a3 0000 5113 0001 0ba5 0001     a*...`...Q......
   22300:	2a69 0000                                   i*..

00022304 <vtable for Schmitt>:
	...
   2230c:	2b01 0000 2b09 0000 9ee5 0000 0db3 0001     .+...+..........
   2231c:	2b19 0000                                   .+..

00022320 <vtable for Scope>:
	...
   22328:	2bf5 0000 2bfd 0000 9611 0000 8d5d 0000     .+...+......]...
   22338:	2c1d 0000                                   .,..

0002233c <vtable for Sequence5>:
	...
   22344:	2cbd 0000 3b27 0000 9ac5 0000 0e95 0001     .,..';..........
   22354:	2cc5 0000                                   .,..

00022358 <vtable for ShiftGate>:
	...
   22360:	2db9 0000 3aef 0000 a0b3 0000 1091 0001     .-...:..........
   22370:	2dc1 0000                                   .-..

00022374 <vtable for Shuffle>:
	...
   2237c:	2ead 0000 2eb5 0000 9a35 0000 12bd 0001     ........5.......
   2238c:	2ec9 0000                                   ....

00022390 <vtable for SkewedLFO>:
	...
   22398:	2f75 0000 2f7d 0000 143d 0001 13ad 0001     u/..}/..=.......
   223a8:	2f8d 0000                                   ./..

000223ac <vtable for Slew>:
	...
   223b4:	2ff9 0000 3001 0000 47a9 0001 4f45 0001     ./...0...G..EO..
   223c4:	3011 0000                                   .0..

000223c8 <vtable for Squanch>:
	...
   223d0:	30e1 0000 607d 0000 5093 0001 1685 0001     .0..}`...P......
   223e0:	30e9 0000                                   .0..

000223e4 <vtable for Switch>:
	...
   223ec:	3169 0000 3171 0000 503d 0001 8e71 0000     i1..q1..=P..q...
   223fc:	3179 0000                                   y1..

00022400 <vtable for TLNeuron>:
	...
   22408:	31b5 0000 31bd 0000 4715 0001 177b 0001     .1...1...G..{...
   22418:	31c5 0000                                   .1..

0002241c <vtable for TM>:
	...
   22424:	324d 0000 603d 0000 4f5f 0001 4e25 0001     M2..=`.._O..%N..
   22434:	3255 0000                                   U2..

00022438 <vtable for Trending>:
	...
   22440:	32d9 0000 32e1 0000 9fa5 0000 1a77 0001     .2...2......w...
   22450:	3305 0000                                   .3..

00022454 <vtable for TrigSeq>:
	...
   2245c:	3385 0000 3ac1 0000 99b9 0000 1baf 0001     .3...:..........
   2246c:	338d 0000                                   .3..

00022470 <vtable for TrigSeq16>:
	...
   22478:	3485 0000 3a99 0000 993b 0000 1ccd 0001     .4...:..;.......
   22488:	348d 0000                                   .4..

0002248c <vtable for Tuner>:
	...
   22494:	3509 0000 3b4b 0000 4e09 0000 1f31 0001     .5..K;...N..1...
   224a4:	3b75 0000                                   u;..

000224a8 <vtable for VectorEG>:
	...
   224b0:	357d 0000 21bb 0001 46a3 0001 214d 0001     }5...!...F..M!..
   224c0:	3585 0000                                   .5..

000224c4 <vtable for VectorLFO>:
	...
   224cc:	3611 0000 2533 0001 d785 0000 24d5 0001     .6..3%.......$..
   224dc:	3619 0000                                   .6..

000224e0 <vtable for VectorMod>:
	...
   224e8:	36a5 0000 28fb 0001 d72d 0000 2889 0001     .6...(..-....(..
   224f8:	36ad 0000                                   .6..

000224fc <vtable for VectorMorph>:
	...
   22504:	3739 0000 2c69 0001 d4d9 0000 2c15 0001     97..i,.......,..
   22514:	3741 0000                                   A7..

00022518 <vtable for Voltage>:
	...
   22520:	37cd 0000 37d5 0000 4659 0001 2f41 0001     .7...7..YF..A/..
   22530:	37e9 0000                                   .7..

00022534 <vtable for hMIDIIn>:
	...
   2253c:	38bd 0000 8f01 0000 2fa5 0001 33e9 0001     .8......./...3..
   2254c:	38c5 0000                                   .8..

00022550 <vtable for hMIDIOut>:
	...
   22558:	3975 0000 397d 0000 43f5 0001 36d1 0001     u9..}9...C...6..
   22568:	39c1 0000 1a3b 0002 13c5 0002 13c9 0002     .9..;...........
   22578:	13cd 0002 13d2 0002 13d7 0002 13db 0002     ................
   22588:	1c9d 0000 1ca5 0000 1cad 0000 1cbf 0000     ................
   22598:	1cd5 0000 1c9d 0000 1c9d 0000 13e4 0002     ................
   225a8:	13ea 0002 13df 0002 13e3 0002 13e9 0002     ................
   225b8:	13e8 0002 13ed 0002 263d 0000 2641 0000     ........=&..A&..
   225c8:	2645 0000 2649 0000 2651 0000 2659 0000     E&..I&..Q&..Y&..
   225d8:	2661 0000 13f2 0002 13f8 0002 0c91 0002     a&..............
   225e8:	0e42 0002 0590 0002 0e39 0002 0e3d 0002     B.......9...=...
   225f8:	07ba 0002 0008 0000 0001 0000 8019 0000     ................
   22608:	8ff5 0000 86f9 0000 1685 0000 16a1 0000     ................
   22618:	16f1 0000 1709 0000 e561 0000 0022 0000     ........a..."...
   22628:	0001 0000 8001 0000 8fe1 0000 86e5 0000     ................
   22638:	1581 0000 1599 0000 15f5 0000 160d 0000     ................
   22648:	4621 0000 000f 0000 0002 0000 8049 0000     !F..........I...
   22658:	9021 0000 8725 0000 17d9 0000 eb79 0000     !...%.......y...
   22668:	1805 0000 181d 0000 ec9d 0000 002f 0000     ............/...
   22678:	0009 0000 8031 0000 9009 0000 870d 0000     ....1...........
   22688:	1759 0000 615d 0000 1775 0000 178d 0000     Y...]a..u.......
   22698:	45dd 0000 0038 0000 0010 0000 8061 0000     .E..8.......a...
   226a8:	9039 0000 873d 0000 1885 0000 18a5 0000     9...=...........
   226b8:	18f9 0000 190d 0000 4571 0000 0029 0000     ........qE..)...
   226c8:	0041 0000 8075 0000 904d 0000 8751 0000     A...u...M...Q...
   226d8:	1961 0000 1963 0000 1965 0000 197d 0000     a...c...e...}...
   226e8:	1981 0000 0033 0000 0080 0000 808d 0000     ....3...........
   226f8:	9061 0000 8765 0000 19b1 0000 f075 0000     a...e.......u...
   22708:	19cd 0000 19e5 0000 ee05 0000 0004 0000     ................
   22718:	0014 0000 80a5 0000 9079 0000 877d 0000     ........y...}...
   22728:	1a51 0000 1a69 0000 1a89 0000 1aa1 0000     Q...i...........
   22738:	4545 0000 001f 0000 0004 0000 80bd 0000     EE..............
   22748:	908d 0000 8791 0000 3bcd 0000 3bf5 0000     .........;...;..
   22758:	1b01 0000 1b19 0000 44ed 0000 000c 0000     .........D......
   22768:	0010 0000 80ed 0000 90b9 0000 87bd 0000     ................
   22778:	1d6d 0000 1d8d 0000 1dc5 0000 1ddd 0000     m...............
   22788:	4449 0000 0020 0000 000a 0000 8105 0000     ID.. ...........
   22798:	90cd 0000 87d1 0000 f89d 0000 1e25 0000     ............%...
   227a8:	1eb5 0000 1ecd 0000 f8e5 0000 0006 0000     ................
   227b8:	0004 0000 811d 0000 90e1 0000 87e5 0000     ................
   227c8:	1f35 0000 1f55 0000 1fcd 0000 1fe5 0000     5...U...........
   227d8:	4405 0000 001c 0000 0004 0000 814d 0000     .D..........M...
   227e8:	9109 0000 880d 0000 2085 0000 20a1 0000     ......... ... ..
   227f8:	20e1 0000 20f9 0000 43c1 0000 001e 0000     . ... ...C......
   22808:	0010 0000 8165 0000 911d 0000 8821 0000     ....e.......!...
   22818:	4c31 0000 214d 0000 2165 0000 217d 0000     1L..M!..e!..}!..
   22828:	4395 0000 0018 0000 0002 0000 80d5 0000     .C..............
   22838:	90a1 0000 87a5 0000 1b69 0000 1bb1 0000     ........i.......
   22848:	1c61 0000 1c79 0000 448d 0000 0037 0000     a...y....D..7...
   22858:	0080 0000 817d 0000 9131 0000 8835 0000     ....}...1...5...
   22868:	21bd 0000 4c71 0000 21d9 0000 21f1 0000     .!..qL...!...!..
   22878:	488d 0000 0009 0000 0008 0000 8195 0000     .H..............
   22888:	9145 0000 8849 0000 2235 0000 61d5 0000     E...I...5"...a..
   22898:	225d 0000 2275 0000 fe5d 0000 002d 0000     ]"..u"..]...-...
   228a8:	0002 0000 81ad 0000 915d 0000 8861 0000     ........]...a...
   228b8:	22cd 0000 013d 0001 22e9 0000 2301 0000     ."..=...."...#..
   228c8:	0235 0001 002a 0000 0011 0000 81c5 0000     5...*...........
   228d8:	9175 0000 8879 0000 2371 0000 2399 0000     u...y...q#...#..
   228e8:	23e1 0000 4861 0000 431d 0000 001d 0000     .#..aH...C......
   228f8:	0004 0000 81dd 0000 9189 0000 888d 0000     ................
   22908:	2469 0000 2485 0000 24e1 0000 24f9 0000     i$...$...$...$..
   22918:	42d9 0000 0011 0000 0050 0000 81f5 0000     .B......P.......
   22928:	91a1 0000 88a5 0000 4c2b 0000 2549 0000     ........+L..I%..
   22938:	2579 0000 4c11 0000 4c15 0000 0010 0000     y%...L...L......
   22948:	0080 0000 820d 0000 91b5 0000 88b9 0000     ................
   22958:	25d1 0000 25f9 0000 2625 0000 4c17 0000     .%...%..%&...L..
   22968:	4c1b 0000 000a 0000 0044 0000 8225 0000     .L......D...%...
   22978:	91cd 0000 88d1 0000 26f1 0000 2711 0000     .........&...'..
   22988:	2751 0000 2769 0000 4295 0000 0015 0000     Q'..i'...B......
   22998:	0001 0000 823d 0000 91e1 0000 88e5 0000     ....=...........
   229a8:	27bd 0000 3c95 0000 27d5 0000 27ed 0000     .'...<...'...'..
   229b8:	4255 0000 0032 0000 0004 0000 8255 0000     UB..2.......U...
   229c8:	91f5 0000 88f9 0000 4c27 0000 4cd5 0000     ........'L...L..
   229d8:	2831 0000 4845 0000 4d09 0000 0096 0000     1(..EH...M......
   229e8:	0020 0000 84a9 0000 9405 0000 8b09 0000      ...............
   229f8:	38e1 0000 3901 0000 3945 0000 3959 0000     .8...9..E9..Y9..
   22a08:	3ead 0000 001b 0000 0020 0000 84bd 0000     .>...... .......
   22a18:	9419 0000 8b1d 0000 39e5 0000 3a05 0000     .........9...:..
   22a28:	3a61 0000 3a75 0000 3e59 0000 0021 0000     a:..u:..Y>..!...
   22a38:	0010 0000 826d 0000 9209 0000 890d 0000     ....m...........
   22a48:	4c29 0000 287d 0000 2895 0000 28ad 0000     )L..}(...(...(..
   22a58:	4229 0000 0014 0000 0002 0000 8285 0000     )B..............
   22a68:	921d 0000 8921 0000 2901 0000 2925 0000     ....!....)..%)..
   22a78:	2989 0000 29a1 0000 41cd 0000 002c 0000     .)...)...A..,...
   22a88:	0001 0000 829d 0000 9231 0000 8935 0000     ........1...5...
   22a98:	4c25 0000 29fd 0000 2a35 0000 2a4d 0000     %L...)..5*..M*..
   22aa8:	41a1 0000 001a 0000 0008 0000 82b5 0000     .A..............
   22ab8:	9245 0000 8949 0000 6285 0000 2a8d 0000     E...I....b...*..
   22ac8:	2acd 0000 2ae5 0000 62e5 0000 0028 0000     .*...*...b..(...
   22ad8:	0040 0000 82cd 0000 925d 0000 8961 0000     @.......]...a...
   22ae8:	2b3d 0000 2b59 0000 2bcd 0000 2be5 0000     =+..Y+...+...+..
   22af8:	415d 0000 0017 0000 0080 0000 82e5 0000     ]A..............
   22b08:	9271 0000 8975 0000 2c41 0000 2c5d 0000     q...u...A,..],..
   22b18:	2ca5 0000 4c1d 0000 4c21 0000 000e 0000     .,...L..!L......
   22b28:	0002 0000 82fd 0000 9285 0000 8989 0000     ................
   22b38:	2ce9 0000 2d05 0000 2d6d 0000 2d85 0000     .,...-..m-...-..
   22b48:	4105 0000 0030 0000 0045 0000 8315 0000     .A..0...E.......
   22b58:	9299 0000 899d 0000 2de5 0000 2e01 0000     .........-......
   22b68:	2e5d 0000 2e75 0000 0f35 0001 0012 0000     ]...u...5.......
   22b78:	0002 0000 83bd 0000 9329 0000 8a2d 0000     ........)...-...
   22b88:	3279 0000 63e5 0000 3295 0000 32ad 0000     y2...c...2...2..
   22b98:	18a9 0001 0024 0000 0004 0000 832d 0000     ....$.......-...
   22ba8:	92ad 0000 89b1 0000 2eed 0000 2f05 0000     ............./..
   22bb8:	2f41 0000 2f59 0000 40c1 0000 0007 0000     A/..Y/...@......
   22bc8:	0001 0000 8345 0000 92c1 0000 89c5 0000     ....E...........
   22bd8:	2fb1 0000 3cc9 0000 2fc9 0000 2fe1 0000     ./...<.../.../..
   22be8:	4081 0000 0013 0000 0001 0000 835d 0000     .@..........]...
   22bf8:	92d5 0000 89d9 0000 3035 0000 304d 0000     ........50..M0..
   22c08:	30b1 0000 30c9 0000 4041 0000 002e 0000     .0...0..A@......
   22c18:	0008 0000 8375 0000 92e9 0000 89ed 0000     ....u...........
   22c28:	310d 0000 6355 0000 3129 0000 3141 0000     .1..Uc..)1..A1..
   22c38:	1521 0001 0003 0000 0010 0000 838d 0000     !...............
   22c48:	9301 0000 8a05 0000 3dff 0000 4c23 0000     .........=..#L..
   22c58:	319d 0000 3dfb 0000 3df9 0000 000d 0000     .1...=...=......
   22c68:	0040 0000 83a5 0000 9315 0000 8a19 0000     @...............
   22c78:	31e9 0000 3cfd 0000 3209 0000 3221 0000     .1...<...2..!2..
   22c88:	1701 0001 0025 0000 0040 0000 83d5 0000     ....%...@.......
   22c98:	9341 0000 8a45 0000 3329 0000 3d51 0000     A...E...)3..Q=..
   22ca8:	3349 0000 3361 0000 3fe9 0000 000b 0000     I3..a3...?......
   22cb8:	0006 0000 83ed 0000 9355 0000 8a59 0000     ........U...Y...
   22cc8:	33b1 0000 33d5 0000 3445 0000 345d 0000     .3...3..E4..]4..
   22cd8:	3f81 0000 0019 0000 0006 0000 8405 0000     .?..............
   22ce8:	9369 0000 8a6d 0000 34b1 0000 3d99 0000     i...m....4...=..
   22cf8:	34d1 0000 34e9 0000 3f29 0000 0027 0000     .4...4..)?..'...
   22d08:	0080 0000 841d 0000 937d 0000 8a81 0000     ........}.......
   22d18:	3511 0000 3525 0000 3551 0000 3569 0000     .5..%5..Q5..i5..
   22d28:	3efd 0000 0034 0000 0001 0000 8435 0000     .>..4.......5...
   22d38:	9391 0000 8a95 0000 35a9 0000 2201 0001     .........5..."..
   22d48:	35c5 0000 35dd 0000 2301 0001 0031 0000     .5...5...#..1...
   22d58:	0001 0000 844d 0000 93a9 0000 8aad 0000     ....M...........
   22d68:	363d 0000 2631 0001 3659 0000 3671 0000     =6..1&..Y6..q6..
   22d78:	26b5 0001 0035 0000 0001 0000 8465 0000     .&..5.......e...
   22d88:	93c1 0000 8ac5 0000 36d1 0000 2935 0001     .........6..5)..
   22d98:	36ed 0000 3705 0000 2a31 0001 0036 0000     .6...7..1*..6...
   22da8:	0001 0000 847d 0000 93d9 0000 8add 0000     ....}...........
   22db8:	3765 0000 2cb9 0001 3781 0000 3799 0000     e7...,...7...7..
   22dc8:	2dc1 0001 002b 0000 0010 0000 8495 0000     .-..+...........
   22dd8:	93f1 0000 8af5 0000 380d 0000 382d 0000     .........8..-8..
   22de8:	387d 0000 3891 0000 2e4d 0001 270f 0000     }8...8..M....'..
   22df8:	0001 0000 8135 0000 90f5 0000 87f9 0000     ....5...........
   22e08:	201d 0000 7eed 0000 2039 0000 4c0b 0000     . ...~..9 ...L..
   22e18:	4c0f 0000 0002 0003 0004 0005 0103 0104     .L..............
   22e28:	0606 0602 0703 0701 0702 0703 0604 0806     ................
   22e38:	0906 0707 0807 0907 0a07 0306 040a 020a     ................
   22e48:	030b 040b 050b 060b 0700 0800 0900 0a00     ................
   22e58:	0801 0901 0006 0001 0002 0003 0104 0102     ................
   22e68:	0603 0503 0504 0602 0603 0604 0605 0106     ................
   22e78:	0200 0300 0000 0000 0000 0300 0003 0103     ................
   22e88:	0203 0000 0000 0000 0303 0302 0303 0004     ................
   22e98:	0000 0000 0300 0401 0402 0403 0000 0000     ................
   22ea8:	0000 0103 0102 0103 0004 0000 0000 0300     ................
   22eb8:	0001 0101 0201 0000 0000 0000 0103 0202     ................
   22ec8:	0302 0002 0000 0000 0300 0000 2710 0000     .............'..
   22ed8:	03e8 0000 0064 0000 000a 0000 0001 0000     ....d...........
   22ee8:	e2fc ff02 01ff e0c0 e0e0 027f 0814 a0c0     ................
   22ef8:	a0a0 007f 0000 0100 0100 0000 0001 0001     ................
   22f08:	0001 0000 000a 0000 2af8 0000 000a 0000     .........*......
   22f18:	000a 0000 05dc 0000 57c0 0001 0320 0000     .........W.. ...
   22f28:	0320 0000 0005 0000 0005 0000 0000 0000      ...............

00022f38 <CSWTCH.2520>:
   22f38:	0201 0303 0303 0303 0303 0803               ............

00022f44 <Arp_Chords>:
   22f44:	1946 0002 0000 0000 0004 0000 0007 0000     F...............
	...
   22f78:	0003 0000 0001 0000 1950 0002 0004 0000     ........P.......
   22f88:	0007 0000 000c 0000 0000 0000 0000 0000     ................
	...
   22fb4:	0003 0000 0001 0000 195a 0002 0007 0000     ........Z.......
   22fc4:	000c 0000 0010 0000 0000 0000 0000 0000     ................
	...
   22ff0:	0003 0000 0001 0000 1964 0002 0000 0000     ........d.......
   23000:	0003 0000 0007 0000 0000 0000 0000 0000     ................
	...
   2302c:	0003 0000 0001 0000 196e 0002 0003 0000     ........n.......
   2303c:	0007 0000 000c 0000 0000 0000 0000 0000     ................
	...
   23068:	0003 0000 0001 0000 1978 0002 0007 0000     ........x.......
   23078:	000c 0000 000f 0000 0000 0000 0000 0000     ................
	...
   230a4:	0003 0000 0001 0000 1982 0002 0000 0000     ................
   230b4:	0003 0000 0006 0000 0000 0000 0000 0000     ................
	...
   230e0:	0003 0000 0001 0000 198c 0002 0000 0000     ................
	...
   2311c:	0001 0000 0001 0000 1994 0002 0000 0000     ................
   2312c:	0007 0000 0000 0000 0000 0000 0000 0000     ................
	...
   23158:	0002 0000 0001 0000 1998 0002 0000 0000     ................
   23168:	0004 0000 0008 0000 0000 0000 0000 0000     ................
	...
   23194:	0003 0000 0001 0000 19ed 0002 0000 0000     ................
   231a4:	0002 0000 0007 0000 0000 0000 0000 0000     ................
	...
   231d0:	0003 0000 0001 0000 19f3 0002 0000 0000     ................
   231e0:	0005 0000 0007 0000 0000 0000 0000 0000     ................
	...
   2320c:	0003 0000 0001 0000 19a2 0002 0000 0000     ................
   2321c:	0002 0000 0004 0000 0007 0000 0000 0000     ................
	...
   23248:	0004 0000 0001 0000 19a7 0002 0000 0000     ................
   23258:	0002 0000 0003 0000 0007 0000 0000 0000     ................
	...
   23284:	0004 0000 0001 0000 19b1 0002 0000 0000     ................
   23294:	0004 0000 0005 0000 0007 0000 0000 0000     ................
	...
   232c0:	0004 0000 0001 0000 19b6 0002 0000 0000     ................
   232d0:	0003 0000 0005 0000 0007 0000 0000 0000     ................
	...
   232fc:	0004 0000 0001 0000 19be 0002 0000 0000     ................
   2330c:	0002 0000 0006 0000 0007 0000 0000 0000     ................
	...
   23338:	0004 0000 0001 0000 19c7 0002 0000 0000     ................
   23348:	0002 0000 0004 0000 0005 0000 0007 0000     ................
	...
   23374:	0005 0000 0001 0000 19cd 0002 0000 0000     ................
   23384:	0002 0000 0003 0000 0005 0000 0007 0000     ................
	...
   233b0:	0005 0000 0001 0000 19d4 0002 0000 0000     ................
   233c0:	0004 0000 0006 0000 0007 0000 0000 0000     ................
	...
   233ec:	0004 0000 0001 0000 19dd 0002 0000 0000     ................
   233fc:	0004 0000 0007 0000 0009 0000 0000 0000     ................
	...
   23428:	0004 0000 0001 0000 19e2 0002 0000 0000     ................
   23438:	0003 0000 0007 0000 0009 0000 0000 0000     ................
	...
   23464:	0004 0000 0001 0000 19e7 0002 0000 0000     ................
   23474:	0004 0000 0007 0000 000b 0000 0000 0000     ................
	...
   234a0:	0004 0000 0001 0000 1c8a 0002 0000 0000     ................
   234b0:	0004 0000 0007 0000 000a 0000 0000 0000     ................
	...
   234dc:	0004 0000 0001 0000 19ec 0002 0000 0000     ................
   234ec:	0002 0000 0007 0000 000a 0000 0000 0000     ................
	...
   23518:	0004 0000 0001 0000 19f2 0002 0000 0000     ................
   23528:	0005 0000 0007 0000 000a 0000 0000 0000     ................
	...
   23554:	0004 0000 0001 0000 19f8 0002 0000 0000     ................
   23564:	0003 0000 0007 0000 000a 0000 0000 0000     ................
	...
   23590:	0004 0000 0001 0000 19fd 0002 0000 0000     ................
   235a0:	0003 0000 0006 0000 0008 0000 0000 0000     ................
	...
   235cc:	0004 0000 0001 0000 1a02 0002 0000 0000     ................
   235dc:	0004 0000 0007 0000 000b 0000 000e 0000     ................
	...
   23608:	0005 0000 0001 0000 1a07 0002 0000 0000     ................
   23618:	0004 0000 0007 0000 0009 0000 000e 0000     ................
	...
   23644:	0005 0000 0001 0000 1a0e 0002 0000 0000     ................
   23654:	0004 0000 0007 0000 000b 0000 000e 0000     ................
   23664:	0012 0000 0000 0000 0000 0000 0000 0000     ................
	...
   23680:	0006 0000 0002 0000 1c90 0002 0000 0000     ................
   23690:	0004 0000 0007 0000 000a 0000 000e 0000     ................
	...
   236bc:	0005 0000 0001 0000 1a15 0002 0000 0000     ................
   236cc:	0004 0000 0007 0000 000a 0000 000d 0000     ................
	...
   236f8:	0005 0000 0001 0000 1a1b 0002 0000 0000     ................
   23708:	0004 0000 0007 0000 000a 0000 000d 0000     ................
   23718:	0014 0000 0000 0000 0000 0000 0000 0000     ................
	...
   23734:	0006 0000 0002 0000 e162 0001 0000 0000     ........b.......
   23744:	0002 0000 0004 0000 0005 0000 0007 0000     ................
   23754:	0009 0000 000b 0000 0000 0000 0000 0000     ................
	...
   23770:	0007 0000 0001 0000 e169 0001 0000 0000     ........i.......
   23780:	0002 0000 0003 0000 0005 0000 0007 0000     ................
   23790:	0009 0000 000a 0000 0000 0000 0000 0000     ................
	...
   237ac:	0007 0000 0001 0000 e170 0001 0000 0000     ........p.......
   237bc:	0001 0000 0003 0000 0005 0000 0007 0000     ................
   237cc:	0008 0000 000a 0000 0000 0000 0000 0000     ................
	...
   237e8:	0007 0000 0001 0000 e179 0001 0000 0000     ........y.......
   237f8:	0002 0000 0004 0000 0006 0000 0007 0000     ................
   23808:	0009 0000 000b 0000 0000 0000 0000 0000     ................
	...
   23824:	0007 0000 0001 0000 1a25 0002 0000 0000     ........%.......
   23834:	0002 0000 0004 0000 0005 0000 0007 0000     ................
   23844:	0009 0000 000a 0000 0000 0000 0000 0000     ................
	...
   23860:	0007 0000 0001 0000 e18b 0001 0000 0000     ................
   23870:	0002 0000 0003 0000 0005 0000 0007 0000     ................
   23880:	0008 0000 000a 0000 0000 0000 0000 0000     ................
	...
   2389c:	0007 0000 0001 0000 e193 0001 0000 0000     ................
   238ac:	0001 0000 0003 0000 0005 0000 0006 0000     ................
   238bc:	0008 0000 000a 0000 0000 0000 0000 0000     ................
	...
   238d8:	0007 0000 0001 0000 1a2e 0002 0000 0000     ................
   238e8:	0002 0000 0003 0000 0005 0000 0007 0000     ................
   238f8:	0008 0000 000b 0000 0000 0000 0000 0000     ................
	...
   23914:	0007 0000 0001 0000 1a37 0002 0000 0000     ........7.......
   23924:	0002 0000 0003 0000 0005 0000 0007 0000     ................
   23934:	0009 0000 000b 0000 0000 0000 0000 0000     ................
	...
   23950:	0007 0000 0001 0000 1a43 0002 0000 0000     ........C.......
   23960:	0002 0000 0004 0000 0007 0000 0009 0000     ................
	...
   2398c:	0005 0000 0001 0000 1a3f 0002 0000 0000     ........?.......
   2399c:	0003 0000 0005 0000 0007 0000 000a 0000     ................
	...
   239c8:	0005 0000 0001 0000 1a49 0002 0000 0000     ........I.......
   239d8:	0002 0000 0003 0000 0004 0000 0007 0000     ................
   239e8:	0009 0000 0000 0000 0000 0000 0000 0000     ................
	...
   23a04:	0006 0000 0001 0000 1a53 0002 0000 0000     ........S.......
   23a14:	0003 0000 0005 0000 0006 0000 0007 0000     ................
   23a24:	000a 0000 0000 0000 0000 0000 0000 0000     ................
	...
   23a40:	0006 0000 0001 0000 1a5d 0002 0000 0000     ........].......
   23a50:	0002 0000 0004 0000 0005 0000 0007 0000     ................
   23a60:	0009 0000 000a 0000 000b 0000 0000 0000     ................
	...
   23a7c:	0008 0000 0001 0000 1a63 0002 0000 0000     ........c.......
   23a8c:	0002 0000 0004 0000 0006 0000 0008 0000     ................
   23a9c:	000a 0000 0000 0000 0000 0000 0000 0000     ................
	...
   23ab8:	0006 0000 0001 0000 1a6d 0002 0000 0000     ........m.......
   23ac8:	0002 0000 0003 0000 0005 0000 0006 0000     ................
   23ad8:	0008 0000 0009 0000 000b 0000 0000 0000     ................
	...
   23af4:	0008 0000 0001 0000 1a77 0002 0000 0000     ........w.......
   23b04:	0002 0000 0003 0000 0005 0000 0006 0000     ................
   23b14:	0008 0000 0009 0000 000b 0000 0000 0000     ................
	...
   23b30:	0008 0000 0001 0000 1a81 0002 0000 0000     ................
   23b40:	0001 0000 0003 0000 0004 0000 0006 0000     ................
   23b50:	0008 0000 000a 0000 0000 0000 0000 0000     ................
	...
   23b6c:	0007 0000 0001 0000 1a89 0002 0000 0000     ................
   23b7c:	0001 0000 0002 0000 0003 0000 0004 0000     ................
   23b8c:	0005 0000 0006 0000 0007 0000 0008 0000     ................
   23b9c:	0009 0000 000a 0000 000b 0000 000c 0000     ................
   23bac:	0001 0000 1a93 0002 0000 0000 0005 0000     ................
   23bbc:	000a 0000 000f 0000 0014 0000 001a 0000     ................
   23bcc:	001f 0000 0000 0000 0000 0000 0000 0000     ................
	...
   23be4:	0007 0000 0003 0000 1a9b 0002 0000 0000     ................
   23bf4:	0007 0000 000e 0000 0015 0000 001c 0000     ................
   23c04:	0023 0000 0029 0000 0000 0000 0000 0000     #...)...........
	...
   23c20:	0007 0000 0004 0000                         ........

00023c28 <CLOCK_ICON>:
   23c28:	a29c cfc1 a2c9 009c                         ........

00023c30 <LOGIC_ICON>:
   23c30:	2222 7f7f 7f7f 7f7f 083e 0808 2222 7763     ""......>...""cw
   23c40:	7f7f 1c3e 081c 0808 2222 0877 7f77 1c3e     ..>.....""w.w.>.
   23c50:	081c 0808 2222 7f7f 7f7f 7f7f 083e 0c0a     ....""......>...
   23c60:	2222 7763 7f7f 1c3e 081c 0c0a 2222 0877     ""cw..>.....""w.
   23c70:	7f77 1c3e 081c 0c0a                         w.>.....

00023c78 <NOTE4_ICON>:
   23c78:	0000 7060 3f70 0000                         ..`pp?..

00023c80 <PAUSE_ICON>:
   23c80:	7e00 007e 7e00 007e                         .~~..~~.

00023c88 <RESET_ICON>:
   23c88:	7e00 0000 3c18 007e                         .~...<~.

00023c90 <SCALE_ICON>:
   23c90:	7f81 819f 9f7f 7f81                         ........

00023c98 <RECORD_ICON>:
   23c98:	3c00 7e7e 7e7e 003c                         .<~~~~<.

00023ca0 <UP_BTN_ICON>:
   23ca0:	0800 0e0c 0c0e 0008                         ........

00023ca8 <X_NOTE_ICON>:
   23ca8:	a000 a040 021f 000c                         ..@.....

00023cb0 <source_name>:
   23cb0:	1aed 0002 1af2 0002 1af7 0002 1afc 0002     ................
   23cc0:	1b01 0002 1b06 0002 1b0b 0002 1b10 0002     ................
   23cd0:	1b15 0002 1b1a 0002 1b1f 0002 1b24 0002     ............$...
   23ce0:	1b29 0002 1b2e 0002 1b33 0002 1b36 0002     ).......3...6...

00023cf0 <METRO_L_ICON>:
   23cf0:	c200 88b4 8894 c0b0                         ........

00023cf8 <METRO_R_ICON>:
   23cf8:	c000 88b0 8894 c2b4                         ........

00023d00 <SEGMENT_ICON>:
   23d00:	c0c0 1020 0608 0006                         .. .....

00023d08 <UP_DOWN_ICON>:
   23d08:	0000 6624 66ff 0024                         ..$f.f$.

00023d10 <crusher_rate>:
   23d10:	192a 0002 192f 0002 1933 0002 1937 0002     *.../...3...7...
   23d20:	193b 0002 193f 0002 1a7f 0002 1943 0002     ;...?.......C...

00023d30 <AUDITION_ICON>:
   23d30:	6878 7868 4c48 794a                         xhhxHLJy

00023d38 <CHECK_ON_ICON>:
   23d38:	99cb b1b1 8c99 f386                         ........

00023d40 <CVRecV2_MODES>:
   23d40:	0546 0002 1aa3 0002 1aa9 0002 1aaf 0002     F...............

00023d50 <DOWN_BTN_ICON>:
   23d50:	1000 7030 3070 0010                         ..0pp0..

00023d58 <FAVORITE_ICON>:
   23d58:	110e 4221 2142 0e11                         ..!BB!..

00023d60 <NN_LOGIC_ICON>:
	...
   23d70:	0808 7f08 4141 2222 1422 0814 1408 0814     ....AA""".......
   23d80:	2222 7f22 4141 4141 4141 1c22 0808 0808     """.AAAAAA".....
   23d90:	2222 5522 415d 4141 2241 1c22 0808 0808     """U]AAAA"".....
   23da0:	2222 007f 5d63 4141 2241 1c22 0808 0808     ""..c]AAA"".....
   23db0:	2222 7f22 4141 4141 4141 1c22 1408 0814     """.AAAAAA".....
   23dc0:	2222 5522 415d 4141 2241 1c22 1408 0814     """U]AAAA"".....
   23dd0:	2222 007f 5d63 4141 2241 1c22 1408 0814     ""..c]AAA"".....
   23de0:	ff12 a9a9 8191 a5bd bda5 8199 02ff 0202     ................
   23df0:	ff12 a9a9 8191 8585 85bd 8185 02ff 0202     ................
   23e00:	2222 223e 1414 0808 1414 2222 3e22 0202     "">"......""">..
   23e10:	a542 c3a5 a599 99a5 7c92 8244 8282 3844     B........|D...D8

00023e20 <PLAYONCE_ICON>:
   23e20:	1010 1010 3838 1010                         ....88..

00023e28 <ROTATE_L_ICON>:
   23e28:	1e0c 0c3f 080c 0070                         ..?...p.

00023e30 <ROTATE_R_ICON>:
   23e30:	7000 0c08 3f0c 0c1e                         .p...?..

00023e38 <WAVEFORM_ICON>:
   23e38:	0810 0804 2010 0810                         ..... ..

00023e40 <crusher_ticks>:
   23e40:	0001 0000 0002 0000 0003 0000 0004 0000     ................
   23e50:	0005 0000 0008 0000 0010 0000 0020 0000     ............ ...

00023e60 <midi_channels>:
   23e60:	1321 0002 1a7e 0002 1b08 0002 1b0d 0002     !...~...........
   23e70:	1b12 0002 1995 0002 1c86 0002 1c89 0002     ................
   23e80:	1c8c 0002 1c8f 0002 f092 0001 1a12 0002     ................
   23e90:	e397 0001 1c92 0002 1c95 0002 f097 0001     ................
   23ea0:	0d31 0002                                   1...

00023ea4 <midi_messages>:
   23ea4:	0ad1 0002 1321 0002 1b9a 0002 0e39 0002     ....!.......9...
   23eb4:	0e3d 0002 1139 0002 1b9e 0002               =...9.......

00023ec0 <CHECK_OFF_ICON>:
   23ec0:	81ff 8181 8181 ff81                         ........

00023ec8 <MIDI_midi_icon>:
   23ec8:	423c 4591 9145 3c42                         <B.EE.B<

00023ed0 <MIDI_note_icon>:
   23ed0:	e0c0 e0e0 027f 0814                         ........

00023ed8 <AFTERTOUCH_ICON>:
   23ed8:	0000 4220 48f5 0020                         .. B.H .

00023ee0 <LEFT_RIGHT_ICON>:
   23ee0:	3810 107c 7c10 1038                         .8|..|8.

00023ee8 <MIDI_clock_icon>:
   23ee8:	a29c cfc1 a2c9 009c                         ........

00023ef0 <midi_in_functions>:
   23ef0:	1123 0002 0ad1 0002 0c91 0002 13f8 0002     #...............
   23f00:	0e42 0002 0590 0002 0e39 0002 0e3d 0002     B.......9...=...
   23f10:	1ba8 0002 0572 0002 1bad 0002 1bb2 0002     ....r...........
   23f20:	1bb7 0002 1bbd 0002 1bc1 0002 1bc5 0002     ................
   23f30:	1bca 0002                                   ....

00023f34 <midi_note_numbers>:
   23f34:	1c98 0002 1c9c 0002 1ca1 0002 1ca5 0002     ................
   23f44:	1caa 0002 1cae 0002 1cb2 0002 1cb7 0002     ................
   23f54:	1cbb 0002 1cc0 0002 1cc4 0002 1cc9 0002     ................
   23f64:	1ccd 0002 1cd0 0002 1cd4 0002 1cd7 0002     ................
   23f74:	1cdb 0002 1cde 0002 1ce1 0002 1ce5 0002     ................
   23f84:	1ce8 0002 1cec 0002 1cef 0002 1cf3 0002     ................
   23f94:	1cf6 0002 1cf9 0002 1cfd 0002 1d00 0002     ................
   23fa4:	1d04 0002 1d07 0002 1d0a 0002 1d0e 0002     ................
   23fb4:	1d11 0002 1d15 0002 1d18 0002 1d1c 0002     ................
   23fc4:	1d1f 0002 1d22 0002 1d26 0002 1d29 0002     ...."...&...)...
   23fd4:	1d2d 0002 1d30 0002 1d33 0002 1d37 0002     -...0...3...7...
   23fe4:	1d3a 0002 1d3e 0002 1d41 0002 1d45 0002     :...>...A...E...
   23ff4:	1d48 0002 1d4b 0002 1d4f 0002 1d52 0002     H...K...O...R...
   24004:	1d56 0002 1d59 0002 1d5c 0002 1d60 0002     V...Y...\...`...
   24014:	1d63 0002 1d67 0002 1d6a 0002 1d6e 0002     c...g...j...n...
   24024:	1d71 0002 1d74 0002 1d78 0002 1d7b 0002     q...t...x...{...
   24034:	1d7f 0002 1d82 0002 1d85 0002 1d89 0002     ................
   24044:	1d8c 0002 1d90 0002 1d93 0002 1d97 0002     ................
   24054:	1d9a 0002 1d9d 0002 1da1 0002 1da4 0002     ................
   24064:	1da8 0002 1dab 0002 1dae 0002 1db2 0002     ................
   24074:	1db5 0002 1db9 0002 1dbc 0002 1dc0 0002     ................
   24084:	1dc3 0002 1dc6 0002 1dca 0002 1dcd 0002     ................
   24094:	1dd1 0002 1dd4 0002 1dd7 0002 1ddb 0002     ................
   240a4:	1dde 0002 1de2 0002 1de5 0002 1de9 0002     ................
   240b4:	1dec 0002 1def 0002 1df3 0002 1df6 0002     ................
   240c4:	1dfa 0002 1dfd 0002 1e00 0002 1e04 0002     ................
   240d4:	1e07 0002 1e0b 0002 1e0e 0002 1e12 0002     ................
   240e4:	1e15 0002 1e18 0002 1e1c 0002 1e1f 0002     ................
   240f4:	1e23 0002 1e26 0002 1e29 0002 1e2d 0002     #...&...)...-...
   24104:	1e30 0002 1e34 0002 1e37 0002 1e3b 0002     0...4...7...;...
   24114:	1e3e 0002 1e41 0002 1e45 0002 1e48 0002     >...A...E...H...
   24124:	1e4c 0002 1e4f 0002 1e52 0002 1e56 0002     L...O...R...V...

00024134 <midi_out_functions>:
   24134:	1123 0002 0ad1 0002 1ba3 0002 0e42 0002     #...........B...
   24144:	0590 0002 0e39 0002 0e3d 0002 1ba8 0002     ....9...=.......
   24154:	0572 0002 1bad 0002 1bb2 0002 1bb7 0002     r...............

00024164 <Trending_assignments>:
   24164:	18fb 0002 1902 0002 190a 0002 1911 0002     ................
   24174:	1918 0002 1921 0002                         ....!...

0002417c <kCalibrationDefaults>:
   2417c:	0370 1c16 34c6 4d76 66bc 7ecc 9772 b022     p....4vM.f.~r.".
   2418c:	c8d2 e178 fa28 0370 1c16 34c6 4d76 66bc     ..x.(.p....4vM.f
   2419c:	7ecc 9772 b022 c8d2 e178 fa28 0370 1c16     .~r."...x.(.p...
   241ac:	34c6 4d76 66bc 7ecc 9772 b022 c8d2 e178     .4vM.f.~r."...x.
   241bc:	fa28 0370 1c16 34c6 4d76 66bc 7ecc 9772     (.p....4vM.f.~r.
   241cc:	b022 c8d2 e178 fa28 0aaa 0aaa 0aaa 0aaa     "...x.(.........
   241dc:	0000 0000 0002 0000 0000 0000 0019 0000     ................
   241ec:	07d0 0ac8                                   ....

000241f0 <CV_ICON>:
   241f0:	111f 0011 1807 0007                         ........

000241f8 <MOD_ICON>:
   241f8:	0830 0804 2010 0c10                         0.... ..

00024200 <BEND_ICON>:
   24200:	7020 3f70 1420 1c0c                          pp? ...

00024208 <LINK_ICON>:
   24208:	d870 da88 115b 0e1b                         p...[...

00024210 <LOCK_ICON>:
   24210:	f800 f9fe f989 f8fe                         ........

00024218 <LOOP_ICON>:
   24218:	6434 4e4e e4e4 584c                         4dNN..LX

00024220 <MIDI_ICON>:
   24220:	423c 4591 9145 3c42                         <B.EE.B<

00024228 <NOTE_ICON>:
   24228:	e0c0 e0e0 027f 0814                         ........

00024230 <PLAY_ICON>:
   24230:	7e00 3c7e 183c 0018                         .~~<<...

00024238 <STOP_ICON>:
   24238:	7e00 7e7e 7e7e 007e                         .~~~~~~.

00024240 <gate_name>:
   24240:	f070 0001 1b3a 0002 13e4 0002 13ea 0002     p...:...........
   24250:	13df 0002 13e3 0002 13e9 0002 13e8 0002     ................
   24260:	1b3e 0002 1b43 0002 1b48 0002 1b4d 0002     >...C...H...M...

00024270 <settings::SettingsBase<EnigmaTMWS, 150u>::value_attr_>:
	...
   24278:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24290:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   242a8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   242c0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   242d8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   242f0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24308:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24320:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24338:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24350:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24368:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24380:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24398:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   243b0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   243c8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   243e0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   243f8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24410:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24428:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24440:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24458:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24470:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24488:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   244a0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   244b8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   244d0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   244e8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24500:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24518:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24530:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24548:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24560:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24578:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24590:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   245a8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   245c0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   245d8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   245f0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24608:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24620:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24638:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24650:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24668:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24680:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24698:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   246b0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   246c8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   246e0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   246f8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24710:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24728:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24740:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24758:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24770:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24788:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   247a0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   247b8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   247d0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   247e8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24800:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24818:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24830:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24848:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24860:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24878:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24890:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   248a8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   248c0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   248d8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   248f0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24908:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24920:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24938:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24950:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24968:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24980:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24998:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   249b0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   249c8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   249e0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   249f8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24a10:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24a28:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24a40:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24a58:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24a70:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24a88:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24aa0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ab8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ad0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ae8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24b00:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24b18:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24b30:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24b48:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24b60:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24b78:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24b90:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ba8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24bc0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24bd8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24bf0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24c08:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24c20:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24c38:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24c50:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24c68:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24c80:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24c98:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24cb0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24cc8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ce0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24cf8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24d10:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24d28:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24d40:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24d58:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24d70:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24d88:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24da0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24db8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24dd0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24de8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24e00:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24e18:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24e30:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24e48:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24e60:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24e78:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24e90:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ea8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ec0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ed8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ef0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24f08:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24f20:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24f38:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24f50:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24f68:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24f80:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24f98:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24fb0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24fc8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24fe0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   24ff8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   25010:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   25028:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   25040:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   25058:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   25070:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................

00025080 <settings::SettingsBase<CaptainMIDI, 161u>::value_attr_>:
	...
   25088:	0010 0000 1b52 0002 3ef0 0002 0002 0000     ....R....>......
	...
   250a0:	0010 0000 1b5b 0002 3ef0 0002 0002 0000     ....[....>......
	...
   250b8:	0010 0000 1b64 0002 3ef0 0002 0002 0000     ....d....>......
	...
   250d0:	0010 0000 1b6d 0002 3ef0 0002 0002 0000     ....m....>......
	...
   250e8:	000b 0000 1b76 0002 4134 0002 0002 0000     ....v...4A......
	...
   25100:	000b 0000 1b7f 0002 4134 0002 0002 0000     ........4A......
	...
   25118:	000b 0000 1b88 0002 4134 0002 0002 0000     ........4A......
	...
   25130:	000b 0000 1b91 0002 4134 0002 0002 0000     ........4A......
	...
   25148:	0010 0000 1b52 0002 3e60 0002 0002 0000     ....R...`>......
	...
   25160:	0010 0000 1b5b 0002 3e60 0002 0002 0000     ....[...`>......
	...
   25178:	0010 0000 1b64 0002 3e60 0002 0002 0000     ....d...`>......
	...
   25190:	0010 0000 1b6d 0002 3e60 0002 0002 0000     ....m...`>......
	...
   251a8:	0010 0000 1b76 0002 3e60 0002 0002 0000     ....v...`>......
	...
   251c0:	0010 0000 1b7f 0002 3e60 0002 0002 0000     ........`>......
	...
   251d8:	0010 0000 1b88 0002 3e60 0002 0002 0000     ........`>......
	...
   251f0:	0010 0000 1b91 0002 3e60 0002 0002 0000     ........`>......
   25200:	0000 0000 ffe8 ffff 0018 0000 1b52 0002     ............R...
   25210:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25220:	0018 0000 1b5b 0002 0000 0000 0001 0000     ....[...........
   25230:	0000 0000 ffe8 ffff 0018 0000 1b64 0002     ............d...
   25240:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25250:	0018 0000 1b6d 0002 0000 0000 0001 0000     ....m...........
   25260:	0000 0000 ffe8 ffff 0018 0000 1b76 0002     ............v...
   25270:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25280:	0018 0000 1b7f 0002 0000 0000 0001 0000     ................
   25290:	0000 0000 ffe8 ffff 0018 0000 1b88 0002     ................
   252a0:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   252b0:	0018 0000 1b91 0002 0000 0000 0001 0000     ................
	...
   252c8:	007f 0000 1b52 0002 3f34 0002 0002 0000     ....R...4?......
	...
   252e0:	007f 0000 1b5b 0002 3f34 0002 0002 0000     ....[...4?......
	...
   252f8:	007f 0000 1b64 0002 3f34 0002 0002 0000     ....d...4?......
	...
   25310:	007f 0000 1b6d 0002 3f34 0002 0002 0000     ....m...4?......
	...
   25328:	007f 0000 1b76 0002 3f34 0002 0002 0000     ....v...4?......
	...
   25340:	007f 0000 1b7f 0002 3f34 0002 0002 0000     ........4?......
	...
   25358:	007f 0000 1b88 0002 3f34 0002 0002 0000     ........4?......
	...
   25370:	007f 0000 1b91 0002 3f34 0002 0002 0000     ........4?......
	...
   25388:	007f 0000 1b52 0002 3f34 0002 0002 0000     ....R...4?......
	...
   253a0:	007f 0000 1b5b 0002 3f34 0002 0002 0000     ....[...4?......
	...
   253b8:	007f 0000 1b64 0002 3f34 0002 0002 0000     ....d...4?......
	...
   253d0:	007f 0000 1b6d 0002 3f34 0002 0002 0000     ....m...4?......
   253e0:	007f 0000 0000 0000 007f 0000 1b76 0002     ............v...
   253f0:	3f34 0002 0002 0000 007f 0000 0000 0000     4?..............
   25400:	007f 0000 1b7f 0002 3f34 0002 0002 0000     ........4?......
   25410:	007f 0000 0000 0000 007f 0000 1b88 0002     ................
   25420:	3f34 0002 0002 0000 007f 0000 0000 0000     4?..............
   25430:	007f 0000 1b91 0002 3f34 0002 0002 0000     ........4?......
	...
   25448:	0010 0000 1b52 0002 3ef0 0002 0002 0000     ....R....>......
	...
   25460:	0010 0000 1b5b 0002 3ef0 0002 0002 0000     ....[....>......
	...
   25478:	0010 0000 1b64 0002 3ef0 0002 0002 0000     ....d....>......
	...
   25490:	0010 0000 1b6d 0002 3ef0 0002 0002 0000     ....m....>......
	...
   254a8:	000b 0000 1b76 0002 4134 0002 0002 0000     ....v...4A......
	...
   254c0:	000b 0000 1b7f 0002 4134 0002 0002 0000     ........4A......
	...
   254d8:	000b 0000 1b88 0002 4134 0002 0002 0000     ........4A......
	...
   254f0:	000b 0000 1b91 0002 4134 0002 0002 0000     ........4A......
	...
   25508:	0010 0000 1b52 0002 3e60 0002 0002 0000     ....R...`>......
	...
   25520:	0010 0000 1b5b 0002 3e60 0002 0002 0000     ....[...`>......
	...
   25538:	0010 0000 1b64 0002 3e60 0002 0002 0000     ....d...`>......
	...
   25550:	0010 0000 1b6d 0002 3e60 0002 0002 0000     ....m...`>......
	...
   25568:	0010 0000 1b76 0002 3e60 0002 0002 0000     ....v...`>......
	...
   25580:	0010 0000 1b7f 0002 3e60 0002 0002 0000     ........`>......
	...
   25598:	0010 0000 1b88 0002 3e60 0002 0002 0000     ........`>......
	...
   255b0:	0010 0000 1b91 0002 3e60 0002 0002 0000     ........`>......
   255c0:	0000 0000 ffe8 ffff 0018 0000 1b52 0002     ............R...
   255d0:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   255e0:	0018 0000 1b5b 0002 0000 0000 0001 0000     ....[...........
   255f0:	0000 0000 ffe8 ffff 0018 0000 1b64 0002     ............d...
   25600:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25610:	0018 0000 1b6d 0002 0000 0000 0001 0000     ....m...........
   25620:	0000 0000 ffe8 ffff 0018 0000 1b76 0002     ............v...
   25630:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25640:	0018 0000 1b7f 0002 0000 0000 0001 0000     ................
   25650:	0000 0000 ffe8 ffff 0018 0000 1b88 0002     ................
   25660:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25670:	0018 0000 1b91 0002 0000 0000 0001 0000     ................
	...
   25688:	007f 0000 1b52 0002 3f34 0002 0002 0000     ....R...4?......
	...
   256a0:	007f 0000 1b5b 0002 3f34 0002 0002 0000     ....[...4?......
	...
   256b8:	007f 0000 1b64 0002 3f34 0002 0002 0000     ....d...4?......
	...
   256d0:	007f 0000 1b6d 0002 3f34 0002 0002 0000     ....m...4?......
	...
   256e8:	007f 0000 1b76 0002 3f34 0002 0002 0000     ....v...4?......
	...
   25700:	007f 0000 1b7f 0002 3f34 0002 0002 0000     ........4?......
	...
   25718:	007f 0000 1b88 0002 3f34 0002 0002 0000     ........4?......
	...
   25730:	007f 0000 1b91 0002 3f34 0002 0002 0000     ........4?......
	...
   25748:	007f 0000 1b52 0002 3f34 0002 0002 0000     ....R...4?......
	...
   25760:	007f 0000 1b5b 0002 3f34 0002 0002 0000     ....[...4?......
	...
   25778:	007f 0000 1b64 0002 3f34 0002 0002 0000     ....d...4?......
	...
   25790:	007f 0000 1b6d 0002 3f34 0002 0002 0000     ....m...4?......
   257a0:	007f 0000 0000 0000 007f 0000 1b76 0002     ............v...
   257b0:	3f34 0002 0002 0000 007f 0000 0000 0000     4?..............
   257c0:	007f 0000 1b7f 0002 3f34 0002 0002 0000     ........4?......
   257d0:	007f 0000 0000 0000 007f 0000 1b88 0002     ................
   257e0:	3f34 0002 0002 0000 007f 0000 0000 0000     4?..............
   257f0:	007f 0000 1b91 0002 3f34 0002 0002 0000     ........4?......
	...
   25808:	0010 0000 1b52 0002 3ef0 0002 0002 0000     ....R....>......
	...
   25820:	0010 0000 1b5b 0002 3ef0 0002 0002 0000     ....[....>......
	...
   25838:	0010 0000 1b64 0002 3ef0 0002 0002 0000     ....d....>......
	...
   25850:	0010 0000 1b6d 0002 3ef0 0002 0002 0000     ....m....>......
	...
   25868:	000b 0000 1b76 0002 4134 0002 0002 0000     ....v...4A......
	...
   25880:	000b 0000 1b7f 0002 4134 0002 0002 0000     ........4A......
	...
   25898:	000b 0000 1b88 0002 4134 0002 0002 0000     ........4A......
	...
   258b0:	000b 0000 1b91 0002 4134 0002 0002 0000     ........4A......
	...
   258c8:	0010 0000 1b52 0002 3e60 0002 0002 0000     ....R...`>......
	...
   258e0:	0010 0000 1b5b 0002 3e60 0002 0002 0000     ....[...`>......
	...
   258f8:	0010 0000 1b64 0002 3e60 0002 0002 0000     ....d...`>......
	...
   25910:	0010 0000 1b6d 0002 3e60 0002 0002 0000     ....m...`>......
	...
   25928:	0010 0000 1b76 0002 3e60 0002 0002 0000     ....v...`>......
	...
   25940:	0010 0000 1b7f 0002 3e60 0002 0002 0000     ........`>......
	...
   25958:	0010 0000 1b88 0002 3e60 0002 0002 0000     ........`>......
	...
   25970:	0010 0000 1b91 0002 3e60 0002 0002 0000     ........`>......
   25980:	0000 0000 ffe8 ffff 0018 0000 1b52 0002     ............R...
   25990:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   259a0:	0018 0000 1b5b 0002 0000 0000 0001 0000     ....[...........
   259b0:	0000 0000 ffe8 ffff 0018 0000 1b64 0002     ............d...
   259c0:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   259d0:	0018 0000 1b6d 0002 0000 0000 0001 0000     ....m...........
   259e0:	0000 0000 ffe8 ffff 0018 0000 1b76 0002     ............v...
   259f0:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25a00:	0018 0000 1b7f 0002 0000 0000 0001 0000     ................
   25a10:	0000 0000 ffe8 ffff 0018 0000 1b88 0002     ................
   25a20:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25a30:	0018 0000 1b91 0002 0000 0000 0001 0000     ................
	...
   25a48:	007f 0000 1b52 0002 3f34 0002 0002 0000     ....R...4?......
	...
   25a60:	007f 0000 1b5b 0002 3f34 0002 0002 0000     ....[...4?......
	...
   25a78:	007f 0000 1b64 0002 3f34 0002 0002 0000     ....d...4?......
	...
   25a90:	007f 0000 1b6d 0002 3f34 0002 0002 0000     ....m...4?......
	...
   25aa8:	007f 0000 1b76 0002 3f34 0002 0002 0000     ....v...4?......
	...
   25ac0:	007f 0000 1b7f 0002 3f34 0002 0002 0000     ........4?......
	...
   25ad8:	007f 0000 1b88 0002 3f34 0002 0002 0000     ........4?......
	...
   25af0:	007f 0000 1b91 0002 3f34 0002 0002 0000     ........4?......
	...
   25b08:	007f 0000 1b52 0002 3f34 0002 0002 0000     ....R...4?......
	...
   25b20:	007f 0000 1b5b 0002 3f34 0002 0002 0000     ....[...4?......
	...
   25b38:	007f 0000 1b64 0002 3f34 0002 0002 0000     ....d...4?......
	...
   25b50:	007f 0000 1b6d 0002 3f34 0002 0002 0000     ....m...4?......
   25b60:	007f 0000 0000 0000 007f 0000 1b76 0002     ............v...
   25b70:	3f34 0002 0002 0000 007f 0000 0000 0000     4?..............
   25b80:	007f 0000 1b7f 0002 3f34 0002 0002 0000     ........4?......
   25b90:	007f 0000 0000 0000 007f 0000 1b88 0002     ................
   25ba0:	3f34 0002 0002 0000 007f 0000 0000 0000     4?..............
   25bb0:	007f 0000 1b91 0002 3f34 0002 0002 0000     ........4?......
	...
   25bc8:	0010 0000 1b52 0002 3ef0 0002 0002 0000     ....R....>......
	...
   25be0:	0010 0000 1b5b 0002 3ef0 0002 0002 0000     ....[....>......
	...
   25bf8:	0010 0000 1b64 0002 3ef0 0002 0002 0000     ....d....>......
	...
   25c10:	0010 0000 1b6d 0002 3ef0 0002 0002 0000     ....m....>......
	...
   25c28:	000b 0000 1b76 0002 4134 0002 0002 0000     ....v...4A......
	...
   25c40:	000b 0000 1b7f 0002 4134 0002 0002 0000     ........4A......
	...
   25c58:	000b 0000 1b88 0002 4134 0002 0002 0000     ........4A......
	...
   25c70:	000b 0000 1b91 0002 4134 0002 0002 0000     ........4A......
	...
   25c88:	0010 0000 1b52 0002 3e60 0002 0002 0000     ....R...`>......
	...
   25ca0:	0010 0000 1b5b 0002 3e60 0002 0002 0000     ....[...`>......
	...
   25cb8:	0010 0000 1b64 0002 3e60 0002 0002 0000     ....d...`>......
	...
   25cd0:	0010 0000 1b6d 0002 3e60 0002 0002 0000     ....m...`>......
	...
   25ce8:	0010 0000 1b76 0002 3e60 0002 0002 0000     ....v...`>......
	...
   25d00:	0010 0000 1b7f 0002 3e60 0002 0002 0000     ........`>......
	...
   25d18:	0010 0000 1b88 0002 3e60 0002 0002 0000     ........`>......
	...
   25d30:	0010 0000 1b91 0002 3e60 0002 0002 0000     ........`>......
   25d40:	0000 0000 ffe8 ffff 0018 0000 1b52 0002     ............R...
   25d50:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25d60:	0018 0000 1b5b 0002 0000 0000 0001 0000     ....[...........
   25d70:	0000 0000 ffe8 ffff 0018 0000 1b64 0002     ............d...
   25d80:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25d90:	0018 0000 1b6d 0002 0000 0000 0001 0000     ....m...........
   25da0:	0000 0000 ffe8 ffff 0018 0000 1b76 0002     ............v...
   25db0:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25dc0:	0018 0000 1b7f 0002 0000 0000 0001 0000     ................
   25dd0:	0000 0000 ffe8 ffff 0018 0000 1b88 0002     ................
   25de0:	0000 0000 0001 0000 0000 0000 ffe8 ffff     ................
   25df0:	0018 0000 1b91 0002 0000 0000 0001 0000     ................
	...
   25e08:	007f 0000 1b52 0002 3f34 0002 0002 0000     ....R...4?......
	...
   25e20:	007f 0000 1b5b 0002 3f34 0002 0002 0000     ....[...4?......
	...
   25e38:	007f 0000 1b64 0002 3f34 0002 0002 0000     ....d...4?......
	...
   25e50:	007f 0000 1b6d 0002 3f34 0002 0002 0000     ....m...4?......
	...
   25e68:	007f 0000 1b76 0002 3f34 0002 0002 0000     ....v...4?......
	...
   25e80:	007f 0000 1b7f 0002 3f34 0002 0002 0000     ........4?......
	...
   25e98:	007f 0000 1b88 0002 3f34 0002 0002 0000     ........4?......
	...
   25eb0:	007f 0000 1b91 0002 3f34 0002 0002 0000     ........4?......
	...
   25ec8:	007f 0000 1b52 0002 3f34 0002 0002 0000     ....R...4?......
	...
   25ee0:	007f 0000 1b5b 0002 3f34 0002 0002 0000     ....[...4?......
	...
   25ef8:	007f 0000 1b64 0002 3f34 0002 0002 0000     ....d...4?......
	...
   25f10:	007f 0000 1b6d 0002 3f34 0002 0002 0000     ....m...4?......
   25f20:	007f 0000 0000 0000 007f 0000 1b76 0002     ............v...
   25f30:	3f34 0002 0002 0000 007f 0000 0000 0000     4?..............
   25f40:	007f 0000 1b7f 0002 3f34 0002 0002 0000     ........4?......
   25f50:	007f 0000 0000 0000 007f 0000 1b88 0002     ................
   25f60:	3f34 0002 0002 0000 007f 0000 0000 0000     4?..............
   25f70:	007f 0000 1b91 0002 3f34 0002 0002 0000     ........4?......
	...
   25f88:	0001 0000 129f 0002 0000 0000 0002 0000     ................

00025f98 <settings::SettingsBase<NeuralNetwork, 216u>::value_attr_>:
	...
   25fa0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   25fb8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   25fd0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   25fe8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26000:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26018:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26030:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26048:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26060:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26078:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26090:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   260a8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   260c0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   260d8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   260f0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26108:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26120:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26138:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26150:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26168:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26180:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26198:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   261b0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   261c8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   261e0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   261f8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26210:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26228:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26240:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26258:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26270:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26288:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   262a0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   262b8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   262d0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   262e8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26300:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26318:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26330:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26348:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26360:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26378:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26390:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   263a8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   263c0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   263d8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   263f0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26408:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26420:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26438:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26450:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26468:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26480:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26498:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   264b0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   264c8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   264e0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   264f8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26510:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26528:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26540:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26558:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26570:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26588:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   265a0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   265b8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   265d0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   265e8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26600:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26618:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26630:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26648:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26660:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26678:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26690:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   266a8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   266c0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   266d8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   266f0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26708:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26720:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26738:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26750:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26768:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26780:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26798:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   267b0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   267c8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   267e0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   267f8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26810:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26828:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26840:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26858:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26870:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26888:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   268a0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   268b8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   268d0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   268e8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26900:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26918:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26930:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26948:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26960:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26978:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26990:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   269a8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   269c0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   269d8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   269f0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26a08:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26a20:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26a38:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26a50:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26a68:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26a80:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26a98:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ab0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ac8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ae0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26af8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26b10:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26b28:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26b40:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26b58:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26b70:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26b88:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ba0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26bb8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26bd0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26be8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26c00:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26c18:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26c30:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26c48:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26c60:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26c78:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26c90:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ca8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26cc0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26cd8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26cf0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26d08:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26d20:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26d38:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26d50:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26d68:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26d80:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26d98:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26db0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26dc8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26de0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26df8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26e10:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26e28:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26e40:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26e58:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26e70:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26e88:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ea0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26eb8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ed0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ee8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26f00:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26f18:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26f30:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26f48:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26f60:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26f78:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26f90:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26fa8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26fc0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26fd8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   26ff0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27008:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27020:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27038:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27050:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27068:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27080:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27098:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   270b0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   270c8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   270e0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   270f8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27110:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27128:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27140:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27158:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27170:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27188:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   271a0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   271b8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   271d0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   271e8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27200:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27218:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27230:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27248:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27260:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27278:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27290:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   272a8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   272c0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   272d8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   272f0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27308:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27320:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27338:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27350:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27368:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27380:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   27398:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   273b0:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................
	...
   273c8:	00ff 0000 1aea 0002 0000 0000 0002 0000     ................

000273d8 <settings::SettingsBase<HemisphereManager, 6u>::value_attr_>:
	...
   273e0:	00ff 0000 1bd0 0002 0000 0000 0002 0000     ................
	...
   273f8:	00ff 0000 1bdc 0002 0000 0000 0002 0000     ................
	...
   27410:	ffff 0000 1be8 0002 0000 0000 0004 0000     ................
	...
   27428:	ffff 0000 1bf3 0002 0000 0000 0004 0000     ................
	...
   27440:	ffff 0000 1bfe 0002 0000 0000 0004 0000     ................
	...
   27458:	ffff 0000 1c0a 0002 0000 0000 0004 0000     ................

00027468 <streams::lut_lorenz_rate>:
   27468:	0003 0000 0003 0000 0003 0000 0004 0000     ................
   27478:	0004 0000 0004 0000 0004 0000 0004 0000     ................
   27488:	0005 0000 0005 0000 0005 0000 0005 0000     ................
   27498:	0006 0000 0006 0000 0006 0000 0007 0000     ................
   274a8:	0007 0000 0007 0000 0008 0000 0008 0000     ................
   274b8:	0008 0000 0009 0000 0009 0000 000a 0000     ................
   274c8:	000a 0000 000b 0000 000b 0000 000c 0000     ................
   274d8:	000c 0000 000d 0000 000d 0000 000e 0000     ................
   274e8:	000f 0000 000f 0000 0010 0000 0011 0000     ................
   274f8:	0012 0000 0012 0000 0013 0000 0014 0000     ................
   27508:	0015 0000 0016 0000 0017 0000 0018 0000     ................
   27518:	0019 0000 001b 0000 001c 0000 001d 0000     ................
   27528:	001e 0000 0020 0000 0021 0000 0023 0000     .... ...!...#...
   27538:	0024 0000 0026 0000 0028 0000 002a 0000     $...&...(...*...
   27548:	002c 0000 002e 0000 0030 0000 0032 0000     ,.......0...2...
   27558:	0034 0000 0037 0000 0039 0000 003c 0000     4...7...9...<...
   27568:	003f 0000 0042 0000 0045 0000 0048 0000     ?...B...E...H...
   27578:	004b 0000 004e 0000 0052 0000 0056 0000     K...N...R...V...
   27588:	005a 0000 005e 0000 0062 0000 0067 0000     Z...^...b...g...
   27598:	006b 0000 0070 0000 0076 0000 007b 0000     k...p...v...{...
   275a8:	0081 0000 0087 0000 008d 0000 0093 0000     ................
   275b8:	009a 0000 00a1 0000 00a8 0000 00b0 0000     ................
   275c8:	00b8 0000 00c1 0000 00c9 0000 00d3 0000     ................
   275d8:	00dc 0000 00e6 0000 00f1 0000 00fc 0000     ................
   275e8:	0107 0000 0113 0000 0120 0000 012d 0000     ........ ...-...
   275f8:	013b 0000 0149 0000 0158 0000 0168 0000     ;...I...X...h...
   27608:	0179 0000 018a 0000 019c 0000 01af 0000     y...............
   27618:	01c3 0000 01d7 0000 01ed 0000 0203 0000     ................
   27628:	021b 0000 0233 0000 024d 0000 0268 0000     ....3...M...h...
   27638:	0284 0000 02a2 0000 02c1 0000 02e1 0000     ................
   27648:	0302 0000 0326 0000 034b 0000 0371 0000     ....&...K...q...
   27658:	0399 0000 03c3 0000 03ef 0000 041e 0000     ................
   27668:	044e 0000 0480 0000 04b5 0000 04ec 0000     N...............
   27678:	0525 0000 0562 0000 05a1 0000 05e2 0000     %...b...........
   27688:	0627 0000 066f 0000 06ba 0000 0709 0000     '...o...........
   27698:	075b 0000 07b2 0000 080c 0000 086a 0000     [...........j...
   276a8:	08cc 0000 0933 0000 099f 0000 0a0f 0000     ....3...........
   276b8:	0a85 0000 0b00 0000 0b81 0000 0c07 0000     ................
   276c8:	0c94 0000 0d27 0000 0dc1 0000 0e62 0000     ....'.......b...
   276d8:	0f0a 0000 0fba 0000 1072 0000 1132 0000     ........r...2...
   276e8:	11fb 0000 12ce 0000 13aa 0000 1490 0000     ................
   276f8:	1580 0000 167c 0000 1783 0000 1896 0000     ....|...........
   27708:	19b5 0000 1ae2 0000 1c1c 0000 1d65 0000     ............e...
   27718:	1ebd 0000 2025 0000 219d 0000 2326 0000     ....% ...!..&#..
   27728:	24c1 0000 266f 0000 2830 0000 2a06 0000     .$..o&..0(...*..
   27738:	2bf2 0000 2df4 0000 300e 0000 3240 0000     .+...-...0..@2..
   27748:	348b 0000 36f2 0000 3975 0000 3c15 0000     .4...6..u9...<..
   27758:	3ed3 0000 41b2 0000 44b3 0000 47d6 0000     .>...A...D...G..
   27768:	4b1e 0000 4e8d 0000 5224 0000 55e5 0000     .K...N..$R...U..
   27778:	59d1 0000 5dec 0000 6236 0000 66b3 0000     .Y...]..6b...f..
   27788:	6b64 0000 704c 0000 756e 0000 7acb 0000     dk..Lp..nu...z..
   27798:	8068 0000 8646 0000 8c68 0000 92d2 0000     h...F...h.......
   277a8:	9988 0000 a08b 0000 a7e1 0000 af8d 0000     ................
   277b8:	b792 0000 bff5 0000 c8ba 0000 d1e6 0000     ................
   277c8:	db7d 0000 e584 0000 f001 0000 faf8 0000     }...............
   277d8:	0670 0001 126d 0001 1ef7 0001 2c13 0001     p...m........,..
   277e8:	39c9 0001 481f 0001 571d 0001 66ca 0001     .9...H...W...f..
   277f8:	772f 0001 8853 0001 9a40 0001 acfe 0001     /w..S...@.......
   27808:	c098 0001 d517 0001 ea85 0001 00ee 0002     ................
   27818:	185e 0002 30df 0002 4a80 0002 654b 0002     ^....0...J..Ke..
   27828:	8151 0002 9e9e 0002 bd41 0002 dd4b 0002     Q.......A...K...
   27838:	fecc 0002 21d5 0003 4677 0003 6cc6 0003     .....!..wF...l..
   27848:	94d5 0003 beb9 0003 ea86 0003 1854 0004     ............T...
   27858:	483a 0004 7a4f 0004 aeaf 0004 e573 0004     :H..Oz......s...
   27868:	1eb8 0005                                   ....

0002786c <ADC::diff_table_ADC0>:
   2786c:	8022 0324                                   ".$.

00027870 <ADC::diff_table_ADC1>:
   27870:	0322 8024                                   ".$.

00027874 <ADC::channel2sc1aADC0>:
   27874:	0e05 0908 0c0d 0706 040f 1300 1f03 0e05     ................
   27884:	0908 0c0d 0706 040f 1f1f 1f1f 1f1f 1f1f     ................
   27894:	1f1f 5340 5f43 161a 1b17 1e1d               ..@SC_......

000278a0 <ADC::channel2sc1aADC1>:
   278a0:	1f1f 0908 1f1f 1f1f 1f1f 1f03 1300 1f1f     ................
   278b0:	0908 1f1f 1f1f 1f1f 1f1f 0585 0604 8407     ................
   278c0:	1f1f 5f43 5340 121a 1b1f 1e1d               ..C_@S......

000278cc <ssd1306xled_font6x8>:
	...
   278d4:	2f00 0000 0000 0007 0007 1400 147f 147f     ./..............
   278e4:	2400 7f2a 122a 2300 0813 6264 3600 5549     .$*.*..#..db.6IU
   278f4:	5022 0000 0305 0000 0000 221c 0041 0000     "P........."A...
   27904:	2241 001c 1400 3e08 1408 0800 3e08 0808     A".....>.....>..
   27914:	0000 a000 0060 0800 0808 0808 0000 6060     ....`.........``
   27924:	0000 2000 0810 0204 3e00 4141 3e41 0000     ... .....>AAA>..
   27934:	7f42 0040 4200 5161 4649 2100 4541 314b     B.@..BaQIF.!AEK1
   27944:	1800 1214 107f 2700 4545 3945 3c00 494a     .......'EEE9.<JI
   27954:	3049 0100 0971 0305 3600 4949 3649 0600     I0..q....6III6..
   27964:	4949 1e29 0000 3636 0000 0000 3656 0000     II)...66....V6..
   27974:	0800 2214 0041 1400 1414 1414 0000 2241     ..."A.........A"
   27984:	0814 0200 5101 0609 3200 5949 3e51 7c00     .....Q...2IYQ>.|
   27994:	1112 7c12 4100 497f 3649 3e00 4141 2241     ...|.A.II6.>AAA"
   279a4:	7f00 4141 1c22 7f00 4949 4149 7f00 0909     ..AA"...IIIA....
   279b4:	0109 3e00 4941 7a49 7f00 0808 7f08 0000     ...>AIIz........
   279c4:	7f41 0041 2000 4140 013f 7f00 1408 4122     A.A.. @A?....."A
   279d4:	7f00 4040 4040 7f00 0c02 7f02 7f00 0804     ..@@@@..........
   279e4:	7f10 3e00 4141 3e41 7f00 0909 0609 3e00     ...>AAA>.......>
   279f4:	5141 5e21 7f00 1909 4629 4600 4949 3149     AQ!^....)F.FIII1
   27a04:	0100 7f01 0101 3f00 4040 3f40 0700 6018     .......?@@@?...`
   27a14:	0718 3f00 3840 3f40 6300 0814 6314 0700     ...?@8@?.c...c..
   27a24:	7008 0708 6100 4951 4345 0000 417f 0041     .p...aQIEC...AA.
   27a34:	5500 552a 552a 0000 4141 007f 0400 0102     .U*U*U..AA......
   27a44:	0402 4000 4040 4040 0000 110e 000e 2000     ...@@@@@....... 
   27a54:	5454 7854 7f00 4448 3844 3800 4444 2044     TTTx..HDD8.8DDD 
   27a64:	3800 4444 7f48 3800 5454 1854 0800 097e     .8DDH..8TTT...~.
   27a74:	0201 1800 a4a4 7ca4 7f00 0408 7804 0000     .......|.....x..
   27a84:	7d44 0040 4000 8480 007d 7f00 2810 0044     D}@..@..}....(D.
   27a94:	0000 7f41 0040 7c00 1804 7804 7c00 0408     ..A.@..|...x.|..
   27aa4:	7804 3800 4444 3844 fc00 2424 1824 1800     .x.8DDD8..$$$...
   27ab4:	2424 fc18 7c00 0408 0804 4800 5454 2054     $$...|.....HTTT 
   27ac4:	0400 443f 2040 3c00 4040 7c20 1c00 4020     ..?D@ .<@@ |.. @
   27ad4:	1c20 3c00 3040 3c40 4400 1028 4428 1c00      ..<@0@<.D(.(D..
   27ae4:	a0a0 7ca0 4400 5464 444c 1414 1414 1414     ...|.DdTLD......
   27af4:	f06f 037f 7003 7803 f013 0f80 d0fb 4770     o....p.x......pG

00027b04 <CSWTCH.39>:
   27b04:	0c08 090a ff0b ffff                         ........

00027b0c <digital_pin_to_info_PGM>:
   27b0c:	0840 43fe a040 4004 0844 43fe a044 4004     @..C@..@D..CD..@
   27b1c:	1800 43fe c000 4004 0030 43fe 9030 4004     ...C...@0..C0..@
   27b2c:	0034 43fe 9034 4004 181c 43fe c01c 4004     4..C4..@...C...@
   27b3c:	1810 43fe c010 4004 1808 43fe c008 4004     ...C...@...C...@
   27b4c:	180c 43fe c00c 4004 100c 43fe b00c 4004     ...C...@...C...@
   27b5c:	1010 43fe b010 4004 1018 43fe b018 4004     ...C...@...C...@
   27b6c:	101c 43fe b01c 4004 1014 43fe b014 4004     ...C...@...C...@
   27b7c:	1804 43fe c004 4004 1000 43fe b000 4004     ...C...@...C...@
   27b8c:	0800 43fe a000 4004 0804 43fe a004 4004     ...C...@...C...@
   27b9c:	080c 43fe a00c 4004 0808 43fe a008 4004     ...C...@...C...@
   27bac:	1814 43fe c014 4004 1818 43fe c018 4004     ...C...@...C...@
   27bbc:	1004 43fe b004 4004 1008 43fe b008 4004     ...C...@...C...@
   27bcc:	0014 43fe 9014 4004 084c 43fe a04c 4004     ...C...@L..CL..@
   27bdc:	2004 43fe d004 4004 1024 43fe b024 4004     . .C...@$..C$..@
   27bec:	1020 43fe b020 4004 1028 43fe b028 4004      ..C ..@(..C(..@
   27bfc:	102c 43fe b02c 4004 2000 43fe d000 4004     ,..C,..@. .C...@
   27c0c:	0848 43fe a048 4004 0010 43fe 9010 4004     H..CH..@...C...@

00027c1c <_serialEvent_default>:
   27c1c:	ff00 ffff                                   ....

00027c20 <usb_descriptor_list>:
   27c20:	0100 0000 a268 1fff 0012 0000 0200 0000     ....h...........
   27c30:	a1d3 1fff 0095 0000 0305 0409 a296 1fff     ................
   27c40:	0000 0000 0300 0000 a27a 1fff 0000 0000     ........z.......
   27c50:	0301 0409 a27e 1fff 0000 0000 0302 0409     ....~...........
   27c60:	a2a4 1fff 0000 0000 0303 0409 a2bc 1fff     ................
	...

00027c80 <usb_endpoint_config_table>:
   27c80:	1915 1515 ff19 ffff 0f00 3fc9 0f00 4049     ...........?..I@
   27c90:	cb00 4096 0f00 40c9 5300 40fb cb00 4116     ...@...@.S.@...A
   27ca0:	ed00 412f 0f00 4149 3100 4162 5300 417b     ../A..IA.1bA.S{A
   27cb0:	3a00 418a cb00 4196 5c00 41a3 ed00 41af     .:.A...A.\.A...A
   27cc0:	7e00 41bc 0f00 41c9 a000 41d5 3100 41e2     .~.A...A...A.1.A
   27cd0:	c200 41ee 5300 41fb f200 4203 3a00 420a     ...A.S.A...B.:.B
   27ce0:	8300 4210 cb00 4216 1400 421d 5c00 4223     ...B...B...B.\#B
   27cf0:	a500 4229 ed00 422f 3600 4236 7e00 423c     ..)B../B.66B.~<B
   27d00:	c700 4242 0f00 4249 00a2 0000 00f9 0000     ..BB..IB........
   27d10:	0083 0000 006e 0000 004e 0000 0044 0000     ....n...N...D...
   27d20:	0015 0000 0029 0000 00fc 0000 0027 0000     ....).......'...
   27d30:	0057 0000 00d1 0000 00f5 0000 0034 0000     W...........4...
   27d40:	00dd 0000 00c0 0000 00db 0000 0062 0000     ............b...
   27d50:	0095 0000 0099 0000 003c 0000 0043 0000     ........<...C...
   27d60:	0090 0000 0041 0000 00fe 0000 0051 0000     ....A.......Q...
   27d70:	0063 0000 00ab 0000 00de 0000 00bb 0000     c...............
   27d80:	00c5 0000 0061 0000 00b7 0000 0024 0000     ....a.......$...
   27d90:	006e 0000 003a 0000 0042 0000 004d 0000     n...:...B...M...
   27da0:	00d2 0000 00e0 0000 0006 0000 0049 0000     ............I...
   27db0:	002e 0000 00ea 0000 0009 0000 00d1 0000     ................
   27dc0:	0092 0000 001c 0000 00fe 0000 001d 0000     ................
   27dd0:	00eb 0000 001c 0000 00b1 0000 0029 0000     ............)...
   27de0:	00a7 0000 003e 0000 00e8 0000 0082 0000     ....>...........
   27df0:	0035 0000 00f5 0000 002e 0000 00bb 0000     5...............
   27e00:	0044 0000 0084 0000 00e9 0000 009c 0000     D...............
   27e10:	0070 0000 0026 0000 00b4 0000 005f 0000     p...&......._...
   27e20:	007e 0000 0041 0000 0039 0000 0091 0000     ~...A...9.......
   27e30:	00d6 0000 0039 0000 0083 0000 0053 0000     ....9.......S...
   27e40:	0039 0000 00f4 0000 009c 0000 0084 0000     9...............
   27e50:	005f 0000 008b 0000 00bd 0000 00f9 0000     _...............
   27e60:	0028 0000 003b 0000 001f 0000 00f8 0000     (...;...........
   27e70:	0097 0000 00ff 0000 00de 0000 0005 0000     ................
   27e80:	0098 0000 000f 0000 00ef 0000 002f 0000     ............/...
   27e90:	0011 0000 008b 0000 005a 0000 000a 0000     ........Z.......
   27ea0:	006d 0000 001f 0000 006d 0000 0036 0000     m.......m...6...
   27eb0:	007e 0000 00cf 0000 0027 0000 00cb 0000     ~.......'.......
   27ec0:	0009 0000 00b7 0000 004f 0000 0046 0000     ........O...F...
   27ed0:	003f 0000 0066 0000 009e 0000 005f 0000     ?...f......._...
   27ee0:	00ea 0000 002d 0000 0075 0000 0027 0000     ....-...u...'...
   27ef0:	00ba 0000 00c7 0000 00eb 0000 00e5 0000     ................
   27f00:	00f1 0000 007b 0000 003d 0000 0007 0000     ....{...=.......
   27f10:	0039 0000 00f7 0000 008a 0000 0052 0000     9...........R...
   27f20:	0092 0000 00ea 0000 006b 0000 00fb 0000     ........k.......
   27f30:	005f 0000 00b1 0000 001f 0000 008d 0000     _...............
   27f40:	005d 0000 0008 0000 0056 0000 0003 0000     ].......V.......
   27f50:	0030 0000 0046 0000 00fc 0000 007b 0000     0...F.......{...
   27f60:	006b 0000 00ab 0000 00f0 0000 00cf 0000     k...............
   27f70:	00bc 0000 0020 0000 009a 0000 00f4 0000     .... ...........
   27f80:	0036 0000 001d 0000 00a9 0000 00e3 0000     6...............
   27f90:	0091 0000 0061 0000 005e 0000 00e6 0000     ....a...^.......
   27fa0:	001b 0000 0008 0000 0065 0000 0099 0000     ........e.......
   27fb0:	0085 0000 005f 0000 0014 0000 00a0 0000     ...._...........
   27fc0:	0068 0000 0040 0000 008d 0000 00ff 0000     h...@...........
   27fd0:	00d8 0000 0080 0000 004d 0000 0073 0000     ........M...s...
   27fe0:	0027 0000 0031 0000 0006 0000 0006 0000     '...1...........
   27ff0:	0015 0000 0056 0000 00ca 0000 0073 0000     ....V.......s...
   28000:	00a8 0000 00c9 0000 0060 0000 00e2 0000     ........`.......
   28010:	007b 0000 00c0 0000 008c 0000 006b 0000     {...........k...
   28020:	ff00 ffff 0000 3fc9 0000 39f0 0000 37da     .......?...9...7
   28030:	0000 33a2 0000 2e84 0000 2b50 0000 27c2     ...3......P+...'
   28040:	0000 22d0 0000 1fc4 0000 1bc6 0000 1744     ..."..........D.
   28050:	0004 0000 0007 0000 0009 0000 2d23 2b30     ............#-0+
   28060:	0020 6c68 004c 6665 4567 4746 3000 3231      .hlL.efgEFG.012
   28070:	3433 3635 3837 4139 4342 4544 0046 3130     3456789ABCDEF.01
   28080:	3332 3534 3736 3938 6261 6463 6665 ff00     23456789abcdef..

00028090 <_init>:
   28090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28092:	bf00      	nop
   28094:	bcf8      	pop	{r3, r4, r5, r6, r7}
   28096:	bc08      	pop	{r3}
   28098:	469e      	mov	lr, r3
   2809a:	4770      	bx	lr
   2809c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000280a0 <__loop_veneer>:
   280a0:	f85f f000 	ldr.w	pc, [pc]	; 280a4 <__loop_veneer+0x4>
   280a4:	1fff9075 	.word	0x1fff9075

000280a8 <__frame_dummy_init_array_entry>:
   280a8:	00000435 00000519 00000a9d 00000ded     5...............
   280b8:	00001305 000177a9 000191f5              .....w......

Disassembly of section .fini:

000280c4 <_fini>:
   280c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   280c6:	bf00      	nop

Disassembly of section .data:

1fff8c30 <OC::ADC::Scan()>:
/*static*/ void FASTRUN ADC::Scan() {
1fff8c30:	b538      	push	{r3, r4, r5, lr}
  const uint16_t value = adc_.readSingle(ADC_0);
1fff8c32:	482d      	ldr	r0, [pc, #180]	; (1fff8ce8 <OC::ADC::Scan()+0xb8>)
  size_t channel = scan_channel_;
1fff8c34:	4c2d      	ldr	r4, [pc, #180]	; (1fff8cec <OC::ADC::Scan()+0xbc>)
  const uint16_t value = adc_.readSingle(ADC_0);
1fff8c36:	2100      	movs	r1, #0
1fff8c38:	f000 fb66 	bl	1fff9308 <___ZN3ADC10readSingleEa_veneer>
  size_t channel = scan_channel_;
1fff8c3c:	6823      	ldr	r3, [r4, #0]
  const uint16_t value = adc_.readSingle(ADC_0);
1fff8c3e:	4605      	mov	r5, r0
  switch (channel) {
1fff8c40:	2b03      	cmp	r3, #3
1fff8c42:	d815      	bhi.n	1fff8c70 <OC::ADC::Scan()+0x40>
1fff8c44:	e8df f003 	tbb	[pc, r3]
1fff8c48:	3c291602 	.word	0x3c291602
      adc_.startSingleRead(ChannelDesc<ADC_CHANNEL_2>::PIN, ADC_0);
1fff8c4c:	2200      	movs	r2, #0
1fff8c4e:	2114      	movs	r1, #20
1fff8c50:	4825      	ldr	r0, [pc, #148]	; (1fff8ce8 <OC::ADC::Scan()+0xb8>)
1fff8c52:	f000 fb21 	bl	1fff9298 <___ZN3ADC15startSingleReadEha_veneer>

private:

  template <ADC_CHANNEL channel>
  static void update(uint32_t value) {
    value = (value  >> (kAdcScanResolution - kAdcResolution)) << kAdcSmoothBits;
1fff8c56:	4a26      	ldr	r2, [pc, #152]	; (1fff8cf0 <OC::ADC::Scan()+0xc0>)
    raw_[channel] = value;
1fff8c58:	4b26      	ldr	r3, [pc, #152]	; (1fff8cf4 <OC::ADC::Scan()+0xc4>)
    // division should be shift if kAdcSmoothing is power-of-two
    value = (smoothed_[channel] * (kAdcSmoothing - 1) + value) / kAdcSmoothing;
1fff8c5a:	4927      	ldr	r1, [pc, #156]	; (1fff8cf8 <OC::ADC::Scan()+0xc8>)
    value = (value  >> (kAdcScanResolution - kAdcResolution)) << kAdcSmoothBits;
1fff8c5c:	ea02 1205 	and.w	r2, r2, r5, lsl #4
    raw_[channel] = value;
1fff8c60:	601a      	str	r2, [r3, #0]
    value = (smoothed_[channel] * (kAdcSmoothing - 1) + value) / kAdcSmoothing;
1fff8c62:	680b      	ldr	r3, [r1, #0]
1fff8c64:	eb03 0343 	add.w	r3, r3, r3, lsl #1
1fff8c68:	4413      	add	r3, r2
1fff8c6a:	089b      	lsrs	r3, r3, #2
    smoothed_[channel] = value;
1fff8c6c:	600b      	str	r3, [r1, #0]
      ++channel; 
1fff8c6e:	2301      	movs	r3, #1
  scan_channel_ = channel;
1fff8c70:	6023      	str	r3, [r4, #0]
}
1fff8c72:	bd38      	pop	{r3, r4, r5, pc}
      adc_.startSingleRead(ChannelDesc<ADC_CHANNEL_3>::PIN, ADC_0);
1fff8c74:	2200      	movs	r2, #0
1fff8c76:	2112      	movs	r1, #18
1fff8c78:	481b      	ldr	r0, [pc, #108]	; (1fff8ce8 <OC::ADC::Scan()+0xb8>)
1fff8c7a:	f000 fb0d 	bl	1fff9298 <___ZN3ADC15startSingleReadEha_veneer>
    value = (value  >> (kAdcScanResolution - kAdcResolution)) << kAdcSmoothBits;
1fff8c7e:	4a1c      	ldr	r2, [pc, #112]	; (1fff8cf0 <OC::ADC::Scan()+0xc0>)
    raw_[channel] = value;
1fff8c80:	4b1c      	ldr	r3, [pc, #112]	; (1fff8cf4 <OC::ADC::Scan()+0xc4>)
    value = (smoothed_[channel] * (kAdcSmoothing - 1) + value) / kAdcSmoothing;
1fff8c82:	491d      	ldr	r1, [pc, #116]	; (1fff8cf8 <OC::ADC::Scan()+0xc8>)
    value = (value  >> (kAdcScanResolution - kAdcResolution)) << kAdcSmoothBits;
1fff8c84:	ea02 1205 	and.w	r2, r2, r5, lsl #4
    raw_[channel] = value;
1fff8c88:	605a      	str	r2, [r3, #4]
    value = (smoothed_[channel] * (kAdcSmoothing - 1) + value) / kAdcSmoothing;
1fff8c8a:	684b      	ldr	r3, [r1, #4]
1fff8c8c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
1fff8c90:	4413      	add	r3, r2
1fff8c92:	089b      	lsrs	r3, r3, #2
    smoothed_[channel] = value;
1fff8c94:	604b      	str	r3, [r1, #4]
      ++channel; 
1fff8c96:	2302      	movs	r3, #2
  }
1fff8c98:	e7ea      	b.n	1fff8c70 <OC::ADC::Scan()+0x40>
      adc_.startSingleRead(ChannelDesc<ADC_CHANNEL_4>::PIN, ADC_0);
1fff8c9a:	2200      	movs	r2, #0
1fff8c9c:	2113      	movs	r1, #19
1fff8c9e:	4812      	ldr	r0, [pc, #72]	; (1fff8ce8 <OC::ADC::Scan()+0xb8>)
1fff8ca0:	f000 fafa 	bl	1fff9298 <___ZN3ADC15startSingleReadEha_veneer>
    value = (value  >> (kAdcScanResolution - kAdcResolution)) << kAdcSmoothBits;
1fff8ca4:	4a12      	ldr	r2, [pc, #72]	; (1fff8cf0 <OC::ADC::Scan()+0xc0>)
    raw_[channel] = value;
1fff8ca6:	4b13      	ldr	r3, [pc, #76]	; (1fff8cf4 <OC::ADC::Scan()+0xc4>)
    value = (smoothed_[channel] * (kAdcSmoothing - 1) + value) / kAdcSmoothing;
1fff8ca8:	4913      	ldr	r1, [pc, #76]	; (1fff8cf8 <OC::ADC::Scan()+0xc8>)
    value = (value  >> (kAdcScanResolution - kAdcResolution)) << kAdcSmoothBits;
1fff8caa:	ea02 1205 	and.w	r2, r2, r5, lsl #4
    raw_[channel] = value;
1fff8cae:	609a      	str	r2, [r3, #8]
    value = (smoothed_[channel] * (kAdcSmoothing - 1) + value) / kAdcSmoothing;
1fff8cb0:	688b      	ldr	r3, [r1, #8]
1fff8cb2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
1fff8cb6:	4413      	add	r3, r2
1fff8cb8:	089b      	lsrs	r3, r3, #2
    smoothed_[channel] = value;
1fff8cba:	608b      	str	r3, [r1, #8]
      ++channel; 
1fff8cbc:	2303      	movs	r3, #3
  }
1fff8cbe:	e7d7      	b.n	1fff8c70 <OC::ADC::Scan()+0x40>
      adc_.startSingleRead(ChannelDesc<ADC_CHANNEL_1>::PIN, ADC_0);
1fff8cc0:	2200      	movs	r2, #0
1fff8cc2:	2111      	movs	r1, #17
1fff8cc4:	4808      	ldr	r0, [pc, #32]	; (1fff8ce8 <OC::ADC::Scan()+0xb8>)
1fff8cc6:	f000 fae7 	bl	1fff9298 <___ZN3ADC15startSingleReadEha_veneer>
    value = (value  >> (kAdcScanResolution - kAdcResolution)) << kAdcSmoothBits;
1fff8cca:	4a09      	ldr	r2, [pc, #36]	; (1fff8cf0 <OC::ADC::Scan()+0xc0>)
    raw_[channel] = value;
1fff8ccc:	4b09      	ldr	r3, [pc, #36]	; (1fff8cf4 <OC::ADC::Scan()+0xc4>)
    value = (smoothed_[channel] * (kAdcSmoothing - 1) + value) / kAdcSmoothing;
1fff8cce:	490a      	ldr	r1, [pc, #40]	; (1fff8cf8 <OC::ADC::Scan()+0xc8>)
    value = (value  >> (kAdcScanResolution - kAdcResolution)) << kAdcSmoothBits;
1fff8cd0:	ea02 1205 	and.w	r2, r2, r5, lsl #4
    raw_[channel] = value;
1fff8cd4:	60da      	str	r2, [r3, #12]
    value = (smoothed_[channel] * (kAdcSmoothing - 1) + value) / kAdcSmoothing;
1fff8cd6:	68cb      	ldr	r3, [r1, #12]
1fff8cd8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
1fff8cdc:	4413      	add	r3, r2
1fff8cde:	089b      	lsrs	r3, r3, #2
    smoothed_[channel] = value;
1fff8ce0:	60cb      	str	r3, [r1, #12]
      channel = ADC_CHANNEL_1;
1fff8ce2:	2300      	movs	r3, #0
  }
1fff8ce4:	e7c4      	b.n	1fff8c70 <OC::ADC::Scan()+0x40>
1fff8ce6:	bf00      	nop
1fff8ce8:	1fffa348 	.word	0x1fffa348
1fff8cec:	1fffa340 	.word	0x1fffa340
1fff8cf0:	000fff00 	.word	0x000fff00
1fff8cf4:	1fffa4ac 	.word	0x1fffa4ac
1fff8cf8:	1fffa4bc 	.word	0x1fffa4bc

1fff8cfc <tr1_ISR()>:
    clocked_[input] = 1;
1fff8cfc:	4b01      	ldr	r3, [pc, #4]	; (1fff8d04 <tr1_ISR()+0x8>)
1fff8cfe:	2201      	movs	r2, #1
1fff8d00:	601a      	str	r2, [r3, #0]
}  // main clock
1fff8d02:	4770      	bx	lr
1fff8d04:	1fffa5b8 	.word	0x1fffa5b8

1fff8d08 <tr2_ISR()>:
1fff8d08:	4b01      	ldr	r3, [pc, #4]	; (1fff8d10 <tr2_ISR()+0x8>)
1fff8d0a:	2201      	movs	r2, #1
1fff8d0c:	605a      	str	r2, [r3, #4]
}
1fff8d0e:	4770      	bx	lr
1fff8d10:	1fffa5b8 	.word	0x1fffa5b8

1fff8d14 <tr3_ISR()>:
1fff8d14:	4b01      	ldr	r3, [pc, #4]	; (1fff8d1c <tr3_ISR()+0x8>)
1fff8d16:	2201      	movs	r2, #1
1fff8d18:	609a      	str	r2, [r3, #8]
}
1fff8d1a:	4770      	bx	lr
1fff8d1c:	1fffa5b8 	.word	0x1fffa5b8

1fff8d20 <tr4_ISR()>:
1fff8d20:	4b01      	ldr	r3, [pc, #4]	; (1fff8d28 <tr4_ISR()+0x8>)
1fff8d22:	2201      	movs	r2, #1
1fff8d24:	60da      	str	r2, [r3, #12]
}
1fff8d26:	4770      	bx	lr
1fff8d28:	1fffa5b8 	.word	0x1fffa5b8

1fff8d2c <OC::Ui::_Poke()>:
void FASTRUN Ui::_Poke() {
1fff8d2c:	b508      	push	{r3, lr}
  event_queue_.Poke();
1fff8d2e:	306c      	adds	r0, #108	; 0x6c
1fff8d30:	f000 fac6 	bl	1fff92c0 <___ZN2UI10EventQueueILj16EE4PokeEv_veneer>
}
1fff8d34:	bd08      	pop	{r3, pc}

1fff8d36 <OC::Ui::Poll()>:
void FASTRUN Ui::Poll() {
1fff8d36:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t now = ++ticks_;
1fff8d3a:	6807      	ldr	r7, [r0, #0]
  for (size_t i = 0; i < CONTROL_BUTTON_LAST; ++i) {
1fff8d3c:	2600      	movs	r6, #0
  uint32_t now = ++ticks_;
1fff8d3e:	3701      	adds	r7, #1
void FASTRUN Ui::Poll() {
1fff8d40:	4604      	mov	r4, r0
  uint32_t now = ++ticks_;
1fff8d42:	6007      	str	r7, [r0, #0]
  uint16_t button_state = 0;
1fff8d44:	4635      	mov	r5, r6
  return 1 << i;
1fff8d46:	f04f 0901 	mov.w	r9, #1
    if (buttons_[i].Poll())
1fff8d4a:	46b0      	mov	r8, r6
1fff8d4c:	3601      	adds	r6, #1
1fff8d4e:	eb04 00c6 	add.w	r0, r4, r6, lsl #3
1fff8d52:	f000 fab1 	bl	1fff92b8 <___ZN2UI6Button4PollEv_veneer>
1fff8d56:	b128      	cbz	r0, 1fff8d64 <OC::Ui::Poll()+0x2e>
1fff8d58:	fa09 f808 	lsl.w	r8, r9, r8
      button_state |= control_mask(i);
1fff8d5c:	ea45 0808 	orr.w	r8, r5, r8
1fff8d60:	fa1f f588 	uxth.w	r5, r8
  for (size_t i = 0; i < CONTROL_BUTTON_LAST; ++i) {
1fff8d64:	2e05      	cmp	r6, #5
1fff8d66:	d1f0      	bne.n	1fff8d4a <OC::Ui::Poll()+0x14>
1fff8d68:	f104 0830 	add.w	r8, r4, #48	; 0x30
  for (size_t i = 0; i < CONTROL_BUTTON_LAST; ++i) {
1fff8d6c:	2600      	movs	r6, #0
  inline bool pressed() const {
    return state_ == 0x00;
  }

  inline bool just_pressed() const {
    return state_ == 0x80;
1fff8d6e:	f104 090c 	add.w	r9, r4, #12
1fff8d72:	f04f 0a01 	mov.w	sl, #1
1fff8d76:	f819 3036 	ldrb.w	r3, [r9, r6, lsl #3]
    if (button.just_pressed()) {
1fff8d7a:	2b80      	cmp	r3, #128	; 0x80
1fff8d7c:	f040 809e 	bne.w	1fff8ebc <OC::Ui::Poll()+0x186>
      button_press_time_[i] = now;
1fff8d80:	f8c8 7000 	str.w	r7, [r8]
  for (size_t i = 0; i < CONTROL_BUTTON_LAST; ++i) {
1fff8d84:	3601      	adds	r6, #1
1fff8d86:	2e05      	cmp	r6, #5
1fff8d88:	f108 0804 	add.w	r8, r8, #4
1fff8d8c:	d1f3      	bne.n	1fff8d76 <OC::Ui::Poll()+0x40>
			return (CORE_PIN22_PINREG & CORE_PIN22_BITMASK) ? 1 : 0;
1fff8d8e:	485c      	ldr	r0, [pc, #368]	; (1fff8f00 <OC::Ui::Poll()+0x1ca>)
    pin_state_[0] = (pin_state_[0] << 1) | digitalReadFast(PINA);
1fff8d90:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
1fff8d94:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
1fff8d98:	f894 6068 	ldrb.w	r6, [r4, #104]	; 0x68
1fff8d9c:	f3c3 0340 	ubfx	r3, r3, #1, #1
1fff8da0:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
1fff8da4:	b2db      	uxtb	r3, r3
1fff8da6:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
			return (CORE_PIN21_PINREG & CORE_PIN21_BITMASK) ? 1 : 0;
1fff8daa:	f8d0 10d0 	ldr.w	r1, [r0, #208]	; 0xd0
    pin_state_[1] = (pin_state_[1] << 1) | digitalReadFast(PINB);
1fff8dae:	f894 2059 	ldrb.w	r2, [r4, #89]	; 0x59
1fff8db2:	f3c1 1180 	ubfx	r1, r1, #6, #1
1fff8db6:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
1fff8dba:	b2c9      	uxtb	r1, r1
1fff8dbc:	f884 1059 	strb.w	r1, [r4, #89]	; 0x59
			return (CORE_PIN16_PINREG & CORE_PIN16_BITMASK) ? 1 : 0;
1fff8dc0:	6d02      	ldr	r2, [r0, #80]	; 0x50
1fff8dc2:	f002 0201 	and.w	r2, r2, #1
    pin_state_[0] = (pin_state_[0] << 1) | digitalReadFast(PINA);
1fff8dc6:	ea42 0246 	orr.w	r2, r2, r6, lsl #1
1fff8dca:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
			return (CORE_PIN15_PINREG & CORE_PIN15_BITMASK) ? 1 : 0;
1fff8dce:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
    pin_state_[1] = (pin_state_[1] << 1) | digitalReadFast(PINB);
1fff8dd2:	f894 0069 	ldrb.w	r0, [r4, #105]	; 0x69
1fff8dd6:	f002 0201 	and.w	r2, r2, #1
1fff8dda:	ea42 0240 	orr.w	r2, r2, r0, lsl #1
  }

  inline int32_t Read() {

    int32_t acceleration = acceleration_;
    if (acceleration_enabled_ && acceleration) {
1fff8dde:	f894 004c 	ldrb.w	r0, [r4, #76]	; 0x4c
    pin_state_[1] = (pin_state_[1] << 1) | digitalReadFast(PINB);
1fff8de2:	f884 2069 	strb.w	r2, [r4, #105]	; 0x69
    int32_t acceleration = acceleration_;
1fff8de6:	6d62      	ldr	r2, [r4, #84]	; 0x54
    if (acceleration_enabled_ && acceleration) {
1fff8de8:	b118      	cbz	r0, 1fff8df2 <OC::Ui::Poll()+0xbc>
1fff8dea:	b112      	cbz	r2, 1fff8df2 <OC::Ui::Poll()+0xbc>
      acceleration -= kAccelerationDec;
1fff8dec:	3a10      	subs	r2, #16
1fff8dee:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    // Find direction by detecting state change and evaluating the other pin.
    // 0x02 == b10 == rising edge on pin
    // Should also work just checking for falling edge on PINA and checking
    // PINB state.
    int32_t i = 0;
    const uint8_t a = pin_state_[0] & kPinMask;
1fff8df2:	f003 0303 	and.w	r3, r3, #3
    const uint8_t b = pin_state_[1] & kPinMask;
    if (a == kPinEdge && b == 0x00) {
1fff8df6:	2b02      	cmp	r3, #2
    const uint8_t b = pin_state_[1] & kPinMask;
1fff8df8:	f001 0103 	and.w	r1, r1, #3
    if (a == kPinEdge && b == 0x00) {
1fff8dfc:	d101      	bne.n	1fff8e02 <OC::Ui::Poll()+0xcc>
1fff8dfe:	2900      	cmp	r1, #0
1fff8e00:	d071      	beq.n	1fff8ee6 <OC::Ui::Poll()+0x1b0>
      i = 1;
    } else if (b == kPinEdge && a == 0x00) {
1fff8e02:	2902      	cmp	r1, #2
1fff8e04:	d173      	bne.n	1fff8eee <OC::Ui::Poll()+0x1b8>
1fff8e06:	2b00      	cmp	r3, #0
1fff8e08:	d171      	bne.n	1fff8eee <OC::Ui::Poll()+0x1b8>
      i = -1;
1fff8e0a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    }

    if (i) {
      if (reversed_)
1fff8e0e:	f894 104d 	ldrb.w	r1, [r4, #77]	; 0x4d
1fff8e12:	b101      	cbz	r1, 1fff8e16 <OC::Ui::Poll()+0xe0>
        i = -i;
1fff8e14:	425b      	negs	r3, r3
      if (acceleration_enabled_) {
1fff8e16:	2800      	cmp	r0, #0
1fff8e18:	d067      	beq.n	1fff8eea <OC::Ui::Poll()+0x1b4>
        if (i != last_dir_) {
1fff8e1a:	6d21      	ldr	r1, [r4, #80]	; 0x50
1fff8e1c:	4299      	cmp	r1, r3
1fff8e1e:	d164      	bne.n	1fff8eea <OC::Ui::Poll()+0x1b4>
          // We've stored the pre-acceleration value so don't need to actually check the signs.
          // 1001 ways to check if sign bit is different are left as an exercise for the reader ;)
          acceleration = 0;
        } else {
          acceleration += kAccelerationInc;
1fff8e20:	32d0      	adds	r2, #208	; 0xd0
1fff8e22:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
1fff8e26:	bfa8      	it	ge
1fff8e28:	f44f 5280 	movge.w	r2, #4096	; 0x1000
      } else {
        acceleration = 0;
      }

      last_dir_ = i;
      i += i * (acceleration >> 8);
1fff8e2c:	1211      	asrs	r1, r2, #8
      last_dir_ = i;
1fff8e2e:	6523      	str	r3, [r4, #80]	; 0x50
      i += i * (acceleration >> 8);
1fff8e30:	fb01 3303 	mla	r3, r1, r3, r3
    }

    acceleration_ = acceleration;
1fff8e34:	6562      	str	r2, [r4, #84]	; 0x54
  if (increment)
1fff8e36:	b133      	cbz	r3, 1fff8e46 <OC::Ui::Poll()+0x110>
    PushEvent(UI::EVENT_ENCODER, CONTROL_ENCODER_R, increment, button_state);
1fff8e38:	9500      	str	r5, [sp, #0]
1fff8e3a:	b21b      	sxth	r3, r3
1fff8e3c:	2240      	movs	r2, #64	; 0x40
1fff8e3e:	2103      	movs	r1, #3
1fff8e40:	4620      	mov	r0, r4
1fff8e42:	f000 fa41 	bl	1fff92c8 <___ZN2OC2Ui9PushEventEN2UI9EventTypeEtst_veneer>
    if (acceleration_enabled_ && acceleration) {
1fff8e46:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
    int32_t acceleration = acceleration_;
1fff8e4a:	6e62      	ldr	r2, [r4, #100]	; 0x64
    if (acceleration_enabled_ && acceleration) {
1fff8e4c:	b118      	cbz	r0, 1fff8e56 <OC::Ui::Poll()+0x120>
1fff8e4e:	b112      	cbz	r2, 1fff8e56 <OC::Ui::Poll()+0x120>
      acceleration -= kAccelerationDec;
1fff8e50:	3a10      	subs	r2, #16
1fff8e52:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    const uint8_t a = pin_state_[0] & kPinMask;
1fff8e56:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
    const uint8_t b = pin_state_[1] & kPinMask;
1fff8e5a:	f894 1069 	ldrb.w	r1, [r4, #105]	; 0x69
    const uint8_t a = pin_state_[0] & kPinMask;
1fff8e5e:	f003 0303 	and.w	r3, r3, #3
    if (a == kPinEdge && b == 0x00) {
1fff8e62:	2b02      	cmp	r3, #2
    const uint8_t b = pin_state_[1] & kPinMask;
1fff8e64:	f001 0103 	and.w	r1, r1, #3
    if (a == kPinEdge && b == 0x00) {
1fff8e68:	d101      	bne.n	1fff8e6e <OC::Ui::Poll()+0x138>
1fff8e6a:	2900      	cmp	r1, #0
1fff8e6c:	d041      	beq.n	1fff8ef2 <OC::Ui::Poll()+0x1bc>
    } else if (b == kPinEdge && a == 0x00) {
1fff8e6e:	2902      	cmp	r1, #2
1fff8e70:	d143      	bne.n	1fff8efa <OC::Ui::Poll()+0x1c4>
1fff8e72:	2b00      	cmp	r3, #0
1fff8e74:	d141      	bne.n	1fff8efa <OC::Ui::Poll()+0x1c4>
      i = -1;
1fff8e76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
      if (reversed_)
1fff8e7a:	f894 105d 	ldrb.w	r1, [r4, #93]	; 0x5d
1fff8e7e:	b101      	cbz	r1, 1fff8e82 <OC::Ui::Poll()+0x14c>
        i = -i;
1fff8e80:	425b      	negs	r3, r3
      if (acceleration_enabled_) {
1fff8e82:	2800      	cmp	r0, #0
1fff8e84:	d037      	beq.n	1fff8ef6 <OC::Ui::Poll()+0x1c0>
        if (i != last_dir_) {
1fff8e86:	6e21      	ldr	r1, [r4, #96]	; 0x60
1fff8e88:	4299      	cmp	r1, r3
1fff8e8a:	d134      	bne.n	1fff8ef6 <OC::Ui::Poll()+0x1c0>
          acceleration += kAccelerationInc;
1fff8e8c:	32d0      	adds	r2, #208	; 0xd0
1fff8e8e:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
1fff8e92:	bfa8      	it	ge
1fff8e94:	f44f 5280 	movge.w	r2, #4096	; 0x1000
      i += i * (acceleration >> 8);
1fff8e98:	1211      	asrs	r1, r2, #8
      last_dir_ = i;
1fff8e9a:	6623      	str	r3, [r4, #96]	; 0x60
      i += i * (acceleration >> 8);
1fff8e9c:	fb01 3303 	mla	r3, r1, r3, r3
    acceleration_ = acceleration;
1fff8ea0:	6662      	str	r2, [r4, #100]	; 0x64
  if (increment)
1fff8ea2:	b133      	cbz	r3, 1fff8eb2 <OC::Ui::Poll()+0x17c>
    PushEvent(UI::EVENT_ENCODER, CONTROL_ENCODER_L, increment, button_state);
1fff8ea4:	9500      	str	r5, [sp, #0]
1fff8ea6:	b21b      	sxth	r3, r3
1fff8ea8:	2220      	movs	r2, #32
1fff8eaa:	2103      	movs	r1, #3
1fff8eac:	4620      	mov	r0, r4
1fff8eae:	f000 fa0b 	bl	1fff92c8 <___ZN2OC2Ui9PushEventEN2UI9EventTypeEtst_veneer>
  button_state_ = button_state;
1fff8eb2:	f8a4 5044 	strh.w	r5, [r4, #68]	; 0x44
}
1fff8eb6:	b002      	add	sp, #8
1fff8eb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    } else if (button.released()) {
1fff8ebc:	2b7f      	cmp	r3, #127	; 0x7f
1fff8ebe:	f47f af61 	bne.w	1fff8d84 <OC::Ui::Poll()+0x4e>
      if (now - button_press_time_[i] < kLongPressTicks)
1fff8ec2:	f8d8 3000 	ldr.w	r3, [r8]
        PushEvent(UI::EVENT_BUTTON_PRESS, control_mask(i), 0, button_state);
1fff8ec6:	9500      	str	r5, [sp, #0]
      if (now - button_press_time_[i] < kLongPressTicks)
1fff8ec8:	1afb      	subs	r3, r7, r3
1fff8eca:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
1fff8ece:	fa0a f206 	lsl.w	r2, sl, r6
1fff8ed2:	b292      	uxth	r2, r2
        PushEvent(UI::EVENT_BUTTON_PRESS, control_mask(i), 0, button_state);
1fff8ed4:	f04f 0300 	mov.w	r3, #0
1fff8ed8:	bf34      	ite	cc
1fff8eda:	2101      	movcc	r1, #1
        PushEvent(UI::EVENT_BUTTON_LONG_PRESS, control_mask(i), 0, button_state);
1fff8edc:	2102      	movcs	r1, #2
1fff8ede:	4620      	mov	r0, r4
1fff8ee0:	f000 f9f2 	bl	1fff92c8 <___ZN2OC2Ui9PushEventEN2UI9EventTypeEtst_veneer>
1fff8ee4:	e74e      	b.n	1fff8d84 <OC::Ui::Poll()+0x4e>
      i = 1;
1fff8ee6:	2301      	movs	r3, #1
1fff8ee8:	e791      	b.n	1fff8e0e <OC::Ui::Poll()+0xd8>
        acceleration = 0;
1fff8eea:	2200      	movs	r2, #0
1fff8eec:	e79e      	b.n	1fff8e2c <OC::Ui::Poll()+0xf6>
    int32_t i = 0;
1fff8eee:	2300      	movs	r3, #0
1fff8ef0:	e7a0      	b.n	1fff8e34 <OC::Ui::Poll()+0xfe>
      i = 1;
1fff8ef2:	2301      	movs	r3, #1
1fff8ef4:	e7c1      	b.n	1fff8e7a <OC::Ui::Poll()+0x144>
        acceleration = 0;
1fff8ef6:	2200      	movs	r2, #0
1fff8ef8:	e7ce      	b.n	1fff8e98 <OC::Ui::Poll()+0x162>
    int32_t i = 0;
1fff8efa:	2300      	movs	r3, #0
1fff8efc:	e7d0      	b.n	1fff8ea0 <OC::Ui::Poll()+0x16a>
1fff8efe:	bf00      	nop
1fff8f00:	400ff000 	.word	0x400ff000

1fff8f04 <CORE_timer_ISR()>:
void FASTRUN CORE_timer_ISR() {
1fff8f04:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  CycleMeasurement() : start_(ARM_DWT_CYCCNT) {
1fff8f06:	4b29      	ldr	r3, [pc, #164]	; (1fff8fac <CORE_timer_ISR()+0xa8>)
    }
  }

  bool Flush() {
    display_driver::Flush();
    if (current_page_index_ < display_driver::kNumPages) {
1fff8f08:	4c29      	ldr	r4, [pc, #164]	; (1fff8fb0 <CORE_timer_ISR()+0xac>)
1fff8f0a:	685b      	ldr	r3, [r3, #4]
  : dest_(dest)
1fff8f0c:	4f29      	ldr	r7, [pc, #164]	; (1fff8fb4 <CORE_timer_ISR()+0xb0>)
  CycleMeasurement() : start_(ARM_DWT_CYCCNT) {
1fff8f0e:	9301      	str	r3, [sp, #4]
  : dest_(dest)
1fff8f10:	9700      	str	r7, [sp, #0]
    display_driver::Flush();
1fff8f12:	f000 fa01 	bl	1fff9318 <___ZN20SH1106_128x64_Driver5FlushEv_veneer>
    if (current_page_index_ < display_driver::kNumPages) {
1fff8f16:	6823      	ldr	r3, [r4, #0]
1fff8f18:	2b07      	cmp	r3, #7
1fff8f1a:	d908      	bls.n	1fff8f2e <CORE_timer_ISR()+0x2a>
    ++read_ptr_;
1fff8f1c:	4a26      	ldr	r2, [pc, #152]	; (1fff8fb8 <CORE_timer_ISR()+0xb4>)
      return false;
    } else {
      current_page_index_ = 0;
1fff8f1e:	2300      	movs	r3, #0
1fff8f20:	6023      	str	r3, [r4, #0]
      current_page_data_ = NULL;
1fff8f22:	6063      	str	r3, [r4, #4]
1fff8f24:	f8d2 380c 	ldr.w	r3, [r2, #2060]	; 0x80c
1fff8f28:	3301      	adds	r3, #1
1fff8f2a:	f8c2 380c 	str.w	r3, [r2, #2060]	; 0x80c
  OC::DAC::Update();
1fff8f2e:	f000 f9e3 	bl	1fff92f8 <___ZN2OC3DAC6UpdateEv_veneer>
      return true;
    }
  }

  bool frame_valid() const {
    return NULL != current_page_data_;
1fff8f32:	6865      	ldr	r5, [r4, #4]
		frame_buffer.read();
}

static inline void Update() __attribute__((always_inline));
static inline void Update() {
  if (driver.frame_valid()) {
1fff8f34:	b345      	cbz	r5, 1fff8f88 <CORE_timer_ISR()+0x84>
    uint_fast8_t page = current_page_index_;
1fff8f36:	6826      	ldr	r6, [r4, #0]
    if (page < display_driver::kNumPages) {
1fff8f38:	2e07      	cmp	r6, #7
1fff8f3a:	d807      	bhi.n	1fff8f4c <CORE_timer_ISR()+0x48>
      display_driver::SendPage(page, data);
1fff8f3c:	4629      	mov	r1, r5
1fff8f3e:	4630      	mov	r0, r6
      current_page_data_ = data + display_driver::kPageSize;
1fff8f40:	3580      	adds	r5, #128	; 0x80
      current_page_index_ = page + 1;
1fff8f42:	3601      	adds	r6, #1
      display_driver::SendPage(page, data);
1fff8f44:	f000 f9cc 	bl	1fff92e0 <___ZN20SH1106_128x64_Driver8SendPageEjPKh_veneer>
      current_page_index_ = page + 1;
1fff8f48:	6026      	str	r6, [r4, #0]
      current_page_data_ = data + display_driver::kPageSize;
1fff8f4a:	6065      	str	r5, [r4, #4]
  ++OC::CORE::ticks;
1fff8f4c:	4c1b      	ldr	r4, [pc, #108]	; (1fff8fbc <CORE_timer_ISR()+0xb8>)
  OC::ADC::Scan();
1fff8f4e:	f7ff fe6f 	bl	1fff8c30 <OC::ADC::Scan()>
  OC::DigitalInputs::Scan();
1fff8f52:	f000 f9c9 	bl	1fff92e8 <___ZN2OC13DigitalInputs4ScanEv_veneer>
  ++OC::CORE::ticks;
1fff8f56:	6823      	ldr	r3, [r4, #0]
1fff8f58:	3301      	adds	r3, #1
1fff8f5a:	6023      	str	r3, [r4, #0]
  if (OC::CORE::app_isr_enabled)
1fff8f5c:	4b18      	ldr	r3, [pc, #96]	; (1fff8fc0 <CORE_timer_ISR()+0xbc>)
1fff8f5e:	781b      	ldrb	r3, [r3, #0]
1fff8f60:	b12b      	cbz	r3, 1fff8f6e <CORE_timer_ISR()+0x6a>

  void Init(bool reset_settings);

  inline void ISR() __attribute__((always_inline));
  inline void ISR() {
    if (current_app && current_app->isr)
1fff8f62:	4b18      	ldr	r3, [pc, #96]	; (1fff8fc4 <CORE_timer_ISR()+0xc0>)
1fff8f64:	681b      	ldr	r3, [r3, #0]
1fff8f66:	b113      	cbz	r3, 1fff8f6e <CORE_timer_ISR()+0x6a>
1fff8f68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
1fff8f6a:	b103      	cbz	r3, 1fff8f6e <CORE_timer_ISR()+0x6a>
      current_app->isr();
1fff8f6c:	4798      	blx	r3
  OC_DEBUG_RESET_CYCLES(OC::CORE::ticks, 16384, OC::DEBUG::ISR_cycles);
1fff8f6e:	6823      	ldr	r3, [r4, #0]
1fff8f70:	f3c3 030d 	ubfx	r3, r3, #0, #14
1fff8f74:	b91b      	cbnz	r3, 1fff8f7e <CORE_timer_ISR()+0x7a>
    min_ = 0xffffffff;
1fff8f76:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fff8f7a:	607a      	str	r2, [r7, #4]
    max_ = 0;
1fff8f7c:	60bb      	str	r3, [r7, #8]
}
1fff8f7e:	4668      	mov	r0, sp
1fff8f80:	f000 f992 	bl	1fff92a8 <___ZN5debug22ScopedCycleMeasurementD1Ev_veneer>
1fff8f84:	b003      	add	sp, #12
1fff8f86:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return write_ptr_ - read_ptr_;
1fff8f88:	4a0b      	ldr	r2, [pc, #44]	; (1fff8fb8 <CORE_timer_ISR()+0xb4>)
1fff8f8a:	f8d2 1808 	ldr.w	r1, [r2, #2056]	; 0x808
1fff8f8e:	f8d2 380c 	ldr.w	r3, [r2, #2060]	; 0x80c
    driver.Update();
  } else {
    if (frame_buffer.readable())
1fff8f92:	4299      	cmp	r1, r3
1fff8f94:	d0da      	beq.n	1fff8f4c <CORE_timer_ISR()+0x48>
    return frame_buffers_[read_ptr_ % frames];
1fff8f96:	f8d2 380c 	ldr.w	r3, [r2, #2060]	; 0x80c
    current_page_index_ = 0;
1fff8f9a:	6025      	str	r5, [r4, #0]
1fff8f9c:	f003 0301 	and.w	r3, r3, #1
1fff8fa0:	f503 7300 	add.w	r3, r3, #512	; 0x200
    current_page_data_ = frame;
1fff8fa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1fff8fa8:	6063      	str	r3, [r4, #4]
  }
1fff8faa:	e7cf      	b.n	1fff8f4c <CORE_timer_ISR()+0x48>
1fff8fac:	e0001000 	.word	0xe0001000
1fff8fb0:	200065d8 	.word	0x200065d8
1fff8fb4:	1fffa588 	.word	0x1fffa588
1fff8fb8:	20005dc8 	.word	0x20005dc8
1fff8fbc:	200046cc 	.word	0x200046cc
1fff8fc0:	200046c8 	.word	0x200046c8
1fff8fc4:	1fff9d90 	.word	0x1fff9d90

1fff8fc8 <UI_timer_ISR()>:
void FASTRUN UI_timer_ISR() {
1fff8fc8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  CycleMeasurement() : start_(ARM_DWT_CYCCNT) {
1fff8fca:	4b0b      	ldr	r3, [pc, #44]	; (1fff8ff8 <UI_timer_ISR()+0x30>)
  OC::ui.Poll();
1fff8fcc:	4d0b      	ldr	r5, [pc, #44]	; (1fff8ffc <UI_timer_ISR()+0x34>)
1fff8fce:	685b      	ldr	r3, [r3, #4]
  : dest_(dest)
1fff8fd0:	4c0b      	ldr	r4, [pc, #44]	; (1fff9000 <UI_timer_ISR()+0x38>)
  CycleMeasurement() : start_(ARM_DWT_CYCCNT) {
1fff8fd2:	9301      	str	r3, [sp, #4]
1fff8fd4:	4628      	mov	r0, r5
  : dest_(dest)
1fff8fd6:	9400      	str	r4, [sp, #0]
1fff8fd8:	f7ff fead 	bl	1fff8d36 <OC::Ui::Poll()>
  OC_DEBUG_RESET_CYCLES(OC::ui.ticks(), 2048, OC::DEBUG::UI_cycles);
1fff8fdc:	682b      	ldr	r3, [r5, #0]
1fff8fde:	f3c3 030a 	ubfx	r3, r3, #0, #11
1fff8fe2:	b91b      	cbnz	r3, 1fff8fec <UI_timer_ISR()+0x24>
    min_ = 0xffffffff;
1fff8fe4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fff8fe8:	6062      	str	r2, [r4, #4]
    max_ = 0;
1fff8fea:	60a3      	str	r3, [r4, #8]
}
1fff8fec:	4668      	mov	r0, sp
1fff8fee:	f000 f95b 	bl	1fff92a8 <___ZN5debug22ScopedCycleMeasurementD1Ev_veneer>
1fff8ff2:	b003      	add	sp, #12
1fff8ff4:	bd30      	pop	{r4, r5, pc}
1fff8ff6:	bf00      	nop
1fff8ff8:	e0001000 	.word	0xe0001000
1fff8ffc:	1fffa7cc 	.word	0x1fffa7cc
1fff9000:	1fffa5a8 	.word	0x1fffa5a8

1fff9004 <HEMISPHERE_isr()>:
void FASTRUN HEMISPHERE_isr() {
1fff9004:	b570      	push	{r4, r5, r6, lr}
        if (midi_in_hemisphere == -1) {
1fff9006:	4c19      	ldr	r4, [pc, #100]	; (1fff906c <HEMISPHERE_isr()+0x68>)
1fff9008:	f8d4 3858 	ldr.w	r3, [r4, #2136]	; 0x858
1fff900c:	3301      	adds	r3, #1
1fff900e:	d10a      	bne.n	1fff9026 <HEMISPHERE_isr()+0x22>
		return usb_midi_read(channel);
1fff9010:	2000      	movs	r0, #0
1fff9012:	f000 f945 	bl	1fff92a0 <__usb_midi_read_veneer>
            if (usbMIDI.read() && usbMIDI.getType() == 7) {
1fff9016:	b130      	cbz	r0, 1fff9026 <HEMISPHERE_isr()+0x22>
                return usb_midi_msg_type;
1fff9018:	4b15      	ldr	r3, [pc, #84]	; (1fff9070 <HEMISPHERE_isr()+0x6c>)
1fff901a:	781b      	ldrb	r3, [r3, #0]
1fff901c:	2b07      	cmp	r3, #7
1fff901e:	d102      	bne.n	1fff9026 <HEMISPHERE_isr()+0x22>
                OnReceiveSysEx();
1fff9020:	4620      	mov	r0, r4
1fff9022:	f000 f959 	bl	1fff92d8 <___ZN17HemisphereManager14OnReceiveSysExEv_veneer>
        if (clock_setup) ClockSetup.Controller(LEFT_HEMISPHERE, clock_m->IsForwarded());
1fff9026:	f894 3850 	ldrb.w	r3, [r4, #2128]	; 0x850
1fff902a:	b133      	cbz	r3, 1fff903a <HEMISPHERE_isr()+0x36>
    bool IsForwarded() {return forwarded;}
1fff902c:	f8d4 2864 	ldr.w	r2, [r4, #2148]	; 0x864
1fff9030:	f8d4 3828 	ldr.w	r3, [r4, #2088]	; 0x828
1fff9034:	7d51      	ldrb	r1, [r2, #21]
1fff9036:	2000      	movs	r0, #0
1fff9038:	4798      	blx	r3
            available_applets[index].Controller(h, clock_m->IsForwarded());
1fff903a:	f8d4 3844 	ldr.w	r3, [r4, #2116]	; 0x844
1fff903e:	f8d4 2864 	ldr.w	r2, [r4, #2148]	; 0x864
1fff9042:	2528      	movs	r5, #40	; 0x28
1fff9044:	fb03 5305 	mla	r3, r3, r5, r5
1fff9048:	4423      	add	r3, r4
1fff904a:	7d51      	ldrb	r1, [r2, #21]
1fff904c:	689b      	ldr	r3, [r3, #8]
1fff904e:	2000      	movs	r0, #0
1fff9050:	4798      	blx	r3
1fff9052:	f8d4 3848 	ldr.w	r3, [r4, #2120]	; 0x848
1fff9056:	f8d4 2864 	ldr.w	r2, [r4, #2148]	; 0x864
1fff905a:	fb03 5505 	mla	r5, r3, r5, r5
1fff905e:	442c      	add	r4, r5
1fff9060:	7d51      	ldrb	r1, [r2, #21]
1fff9062:	68a3      	ldr	r3, [r4, #8]
1fff9064:	2001      	movs	r0, #1
}
1fff9066:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            available_applets[index].Controller(h, clock_m->IsForwarded());
1fff906a:	4718      	bx	r3
1fff906c:	200051b8 	.word	0x200051b8
1fff9070:	20006884 	.word	0x20006884

1fff9074 <loop>:

/*  ---------    main loop  --------  */

void FASTRUN loop() {
1fff9074:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  OC::CORE::app_isr_enabled = true;
1fff9078:	4b3e      	ldr	r3, [pc, #248]	; (1fff9174 <loop+0x100>)
  uint32_t menu_redraws = 0;
  while (true) {

    // don't change current_app while it's running
    if (OC::UI_MODE_APP_SETTINGS == ui_mode) {
1fff907a:	4d3f      	ldr	r5, [pc, #252]	; (1fff9178 <loop+0x104>)
      OC::ui.AppSettings();
1fff907c:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 1fff917c <loop+0x108>
  OC::CORE::app_isr_enabled = true;
1fff9080:	2201      	movs	r2, #1
void FASTRUN loop() {
1fff9082:	b085      	sub	sp, #20
  OC::CORE::app_isr_enabled = true;
1fff9084:	701a      	strb	r2, [r3, #0]
  uint32_t menu_redraws = 0;
1fff9086:	f04f 0800 	mov.w	r8, #0
    if (OC::UI_MODE_APP_SETTINGS == ui_mode) {
1fff908a:	782b      	ldrb	r3, [r5, #0]
1fff908c:	2b02      	cmp	r3, #2
1fff908e:	d104      	bne.n	1fff909a <loop+0x26>
      OC::ui.AppSettings();
1fff9090:	4648      	mov	r0, r9
1fff9092:	f000 f935 	bl	1fff9300 <___ZN2OC2Ui11AppSettingsEv_veneer>
      ui_mode = OC::UI_MODE_MENU;
1fff9096:	2301      	movs	r3, #1
1fff9098:	702b      	strb	r3, [r5, #0]
    }

    // Refresh display
    if (MENU_REDRAW) {
1fff909a:	4f39      	ldr	r7, [pc, #228]	; (1fff9180 <loop+0x10c>)
1fff909c:	4e39      	ldr	r6, [pc, #228]	; (1fff9184 <loop+0x110>)
1fff909e:	683b      	ldr	r3, [r7, #0]
1fff90a0:	f8df b0e4 	ldr.w	fp, [pc, #228]	; 1fff9188 <loop+0x114>
1fff90a4:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 1fff918c <loop+0x118>
1fff90a8:	2b00      	cmp	r3, #0
1fff90aa:	d03f      	beq.n	1fff912c <loop+0xb8>
    return write_ptr_ - read_ptr_;
1fff90ac:	4c38      	ldr	r4, [pc, #224]	; (1fff9190 <loop+0x11c>)
1fff90ae:	f8d4 2808 	ldr.w	r2, [r4, #2056]	; 0x808
1fff90b2:	f8d4 380c 	ldr.w	r3, [r4, #2060]	; 0x80c
      GRAPHICS_BEGIN_FRAME(false); // Don't busy wait
1fff90b6:	1a9b      	subs	r3, r3, r2
1fff90b8:	3302      	adds	r3, #2
1fff90ba:	d037      	beq.n	1fff912c <loop+0xb8>
    return frame_buffers_[write_ptr_ % frames];
1fff90bc:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
1fff90c0:	f003 0301 	and.w	r3, r3, #1
1fff90c4:	f503 7300 	add.w	r3, r3, #512	; 0x200
1fff90c8:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
1fff90cc:	b371      	cbz	r1, 1fff912c <loop+0xb8>
1fff90ce:	4831      	ldr	r0, [pc, #196]	; (1fff9194 <loop+0x120>)
1fff90d0:	2201      	movs	r2, #1
1fff90d2:	f000 f8dd 	bl	1fff9290 <___ZN6weegfx8Graphics5BeginEPhb_veneer>
        if (OC::UI_MODE_MENU == ui_mode) {
1fff90d6:	782b      	ldrb	r3, [r5, #0]
1fff90d8:	2b01      	cmp	r3, #1
1fff90da:	d117      	bne.n	1fff910c <loop+0x98>
          OC_DEBUG_RESET_CYCLES(menu_redraws, 512, OC::DEBUG::MENU_draw_cycles);
1fff90dc:	f3c8 0208 	ubfx	r2, r8, #0, #9
1fff90e0:	4b2d      	ldr	r3, [pc, #180]	; (1fff9198 <loop+0x124>)
1fff90e2:	b91a      	cbnz	r2, 1fff90ec <loop+0x78>
    min_ = 0xffffffff;
1fff90e4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
1fff90e8:	6059      	str	r1, [r3, #4]
    max_ = 0;
1fff90ea:	609a      	str	r2, [r3, #8]
  : dest_(dest)
1fff90ec:	9302      	str	r3, [sp, #8]
  CycleMeasurement() : start_(ARM_DWT_CYCCNT) {
1fff90ee:	4b2b      	ldr	r3, [pc, #172]	; (1fff919c <loop+0x128>)
1fff90f0:	685b      	ldr	r3, [r3, #4]
1fff90f2:	9303      	str	r3, [sp, #12]
          OC_DEBUG_PROFILE_SCOPE(OC::DEBUG::MENU_draw_cycles);
          OC::apps::current_app->DrawMenu();
1fff90f4:	6833      	ldr	r3, [r6, #0]
1fff90f6:	6a1b      	ldr	r3, [r3, #32]
1fff90f8:	4798      	blx	r3
          ++menu_redraws;

          #ifdef VOR
          // JEJ:On app screens, show the bias popup, if necessary
          VBiasManager *vbias_m = vbias_m->get();
1fff90fa:	f000 f8d9 	bl	1fff92b0 <___ZN12VBiasManager3getEv_veneer>
          vbias_m->DrawPopupPerhaps();
1fff90fe:	f000 f8f7 	bl	1fff92f0 <___ZN12VBiasManager16DrawPopupPerhapsEv_veneer>
          #endif

        } else {
1fff9102:	a802      	add	r0, sp, #8
          ++menu_redraws;
1fff9104:	f108 0801 	add.w	r8, r8, #1
        } else {
1fff9108:	f000 f8ce 	bl	1fff92a8 <___ZN5debug22ScopedCycleMeasurementD1Ev_veneer>
          //Blank the screen instead of drawing the screensaver (chysn 9/2/2018)
          //OC::apps::current_app->DrawScreensaver();
        }
        MENU_REDRAW = 0;
1fff910c:	2300      	movs	r3, #0
1fff910e:	603b      	str	r3, [r7, #0]
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
1fff9110:	f8db 3000 	ldr.w	r3, [fp]
1fff9114:	9300      	str	r3, [sp, #0]
	return ret;
1fff9116:	9b00      	ldr	r3, [sp, #0]
        LAST_REDRAW_TIME = millis();
      GRAPHICS_END_FRAME();
1fff9118:	481e      	ldr	r0, [pc, #120]	; (1fff9194 <loop+0x120>)
        LAST_REDRAW_TIME = millis();
1fff911a:	f8ca 3000 	str.w	r3, [sl]
      GRAPHICS_END_FRAME();
1fff911e:	f000 f8d7 	bl	1fff92d0 <___ZN6weegfx8Graphics3EndEv_veneer>
    ++write_ptr_;
1fff9122:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
1fff9126:	3301      	adds	r3, #1
1fff9128:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808
    }

    // Run current app
    OC::apps::current_app->loop();
1fff912c:	6833      	ldr	r3, [r6, #0]
1fff912e:	69db      	ldr	r3, [r3, #28]
1fff9130:	4798      	blx	r3

    // UI events
    OC::UiMode mode = OC::ui.DispatchEvents(OC::apps::current_app);
1fff9132:	6831      	ldr	r1, [r6, #0]
1fff9134:	4648      	mov	r0, r9
1fff9136:	f000 f8eb 	bl	1fff9310 <___ZN2OC2Ui14DispatchEventsEPNS_3AppE_veneer>

    // State transition for app
    if (mode != ui_mode) {
1fff913a:	782b      	ldrb	r3, [r5, #0]
1fff913c:	4283      	cmp	r3, r0
    OC::UiMode mode = OC::ui.DispatchEvents(OC::apps::current_app);
1fff913e:	4604      	mov	r4, r0
    if (mode != ui_mode) {
1fff9140:	d005      	beq.n	1fff914e <loop+0xda>
      if (OC::UI_MODE_SCREENSAVER == mode)
1fff9142:	b980      	cbnz	r0, 1fff9166 <loop+0xf2>
        OC::apps::current_app->HandleAppEvent(OC::APP_EVENT_SCREENSAVER_ON);
1fff9144:	6833      	ldr	r3, [r6, #0]
1fff9146:	699b      	ldr	r3, [r3, #24]
1fff9148:	2002      	movs	r0, #2
      else if (OC::UI_MODE_SCREENSAVER == ui_mode)
        OC::apps::current_app->HandleAppEvent(OC::APP_EVENT_SCREENSAVER_OFF);
1fff914a:	4798      	blx	r3
      ui_mode = mode;
1fff914c:	702c      	strb	r4, [r5, #0]
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
1fff914e:	f8db 3000 	ldr.w	r3, [fp]
1fff9152:	9301      	str	r3, [sp, #4]
	return ret;
1fff9154:	9b01      	ldr	r3, [sp, #4]
    }

    if (millis() - LAST_REDRAW_TIME > REDRAW_TIMEOUT_MS)
1fff9156:	f8da 2000 	ldr.w	r2, [sl]
1fff915a:	1a9b      	subs	r3, r3, r2
1fff915c:	2b01      	cmp	r3, #1
1fff915e:	d994      	bls.n	1fff908a <loop+0x16>
      MENU_REDRAW = 1;
1fff9160:	2301      	movs	r3, #1
1fff9162:	603b      	str	r3, [r7, #0]
1fff9164:	e791      	b.n	1fff908a <loop+0x16>
      else if (OC::UI_MODE_SCREENSAVER == ui_mode)
1fff9166:	2b00      	cmp	r3, #0
1fff9168:	d1f0      	bne.n	1fff914c <loop+0xd8>
        OC::apps::current_app->HandleAppEvent(OC::APP_EVENT_SCREENSAVER_OFF);
1fff916a:	6833      	ldr	r3, [r6, #0]
1fff916c:	2003      	movs	r0, #3
1fff916e:	699b      	ldr	r3, [r3, #24]
1fff9170:	e7eb      	b.n	1fff914a <loop+0xd6>
1fff9172:	bf00      	nop
1fff9174:	200046c8 	.word	0x200046c8
1fff9178:	1fffa0b8 	.word	0x1fffa0b8
1fff917c:	1fffa7cc 	.word	0x1fffa7cc
1fff9180:	1fff9324 	.word	0x1fff9324
1fff9184:	1fff9d90 	.word	0x1fff9d90
1fff9188:	20006600 	.word	0x20006600
1fff918c:	1ffff050 	.word	0x1ffff050
1fff9190:	20005dc8 	.word	0x20005dc8
1fff9194:	200065e0 	.word	0x200065e0
1fff9198:	1fffa598 	.word	0x1fffa598
1fff919c:	e0001000 	.word	0xe0001000

1fff91a0 <port_E_isr>:
PORT_ISR_FUNCTION_CLZ(E)
1fff91a0:	b538      	push	{r3, r4, r5, lr}
1fff91a2:	4b09      	ldr	r3, [pc, #36]	; (1fff91c8 <port_E_isr+0x28>)
1fff91a4:	4d09      	ldr	r5, [pc, #36]	; (1fff91cc <port_E_isr+0x2c>)
1fff91a6:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0
1fff91aa:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
1fff91ae:	b14c      	cbz	r4, 1fff91c4 <port_E_isr+0x24>
1fff91b0:	fa94 f3a4 	rbit	r3, r4
1fff91b4:	fab3 f383 	clz	r3, r3
1fff91b8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff91bc:	4798      	blx	r3
1fff91be:	1e63      	subs	r3, r4, #1
1fff91c0:	401c      	ands	r4, r3
1fff91c2:	d1f4      	bne.n	1fff91ae <port_E_isr+0xe>
1fff91c4:	bd38      	pop	{r3, r4, r5, pc}
1fff91c6:	bf00      	nop
1fff91c8:	4004d000 	.word	0x4004d000
1fff91cc:	1fffa1c4 	.word	0x1fffa1c4

1fff91d0 <port_D_isr>:
PORT_ISR_FUNCTION_CLZ(D)
1fff91d0:	b538      	push	{r3, r4, r5, lr}
1fff91d2:	4b09      	ldr	r3, [pc, #36]	; (1fff91f8 <port_D_isr+0x28>)
1fff91d4:	4d09      	ldr	r5, [pc, #36]	; (1fff91fc <port_D_isr+0x2c>)
1fff91d6:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0
1fff91da:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
1fff91de:	b14c      	cbz	r4, 1fff91f4 <port_D_isr+0x24>
1fff91e0:	fa94 f3a4 	rbit	r3, r4
1fff91e4:	fab3 f383 	clz	r3, r3
1fff91e8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff91ec:	4798      	blx	r3
1fff91ee:	1e63      	subs	r3, r4, #1
1fff91f0:	401c      	ands	r4, r3
1fff91f2:	d1f4      	bne.n	1fff91de <port_D_isr+0xe>
1fff91f4:	bd38      	pop	{r3, r4, r5, pc}
1fff91f6:	bf00      	nop
1fff91f8:	4004c000 	.word	0x4004c000
1fff91fc:	1fffa1a4 	.word	0x1fffa1a4

1fff9200 <port_C_isr>:
PORT_ISR_FUNCTION_CLZ(C)
1fff9200:	b538      	push	{r3, r4, r5, lr}
1fff9202:	4b09      	ldr	r3, [pc, #36]	; (1fff9228 <port_C_isr+0x28>)
1fff9204:	4d09      	ldr	r5, [pc, #36]	; (1fff922c <port_C_isr+0x2c>)
1fff9206:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0
1fff920a:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
1fff920e:	b14c      	cbz	r4, 1fff9224 <port_C_isr+0x24>
1fff9210:	fa94 f3a4 	rbit	r3, r4
1fff9214:	fab3 f383 	clz	r3, r3
1fff9218:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff921c:	4798      	blx	r3
1fff921e:	1e63      	subs	r3, r4, #1
1fff9220:	401c      	ands	r4, r3
1fff9222:	d1f4      	bne.n	1fff920e <port_C_isr+0xe>
1fff9224:	bd38      	pop	{r3, r4, r5, pc}
1fff9226:	bf00      	nop
1fff9228:	4004b000 	.word	0x4004b000
1fff922c:	1fffa174 	.word	0x1fffa174

1fff9230 <port_B_isr>:
PORT_ISR_FUNCTION_CLZ(B)
1fff9230:	b538      	push	{r3, r4, r5, lr}
1fff9232:	4b09      	ldr	r3, [pc, #36]	; (1fff9258 <port_B_isr+0x28>)
1fff9234:	4d09      	ldr	r5, [pc, #36]	; (1fff925c <port_B_isr+0x2c>)
1fff9236:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0
1fff923a:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
1fff923e:	b14c      	cbz	r4, 1fff9254 <port_B_isr+0x24>
1fff9240:	fa94 f3a4 	rbit	r3, r4
1fff9244:	fab3 f383 	clz	r3, r3
1fff9248:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff924c:	4798      	blx	r3
1fff924e:	1e63      	subs	r3, r4, #1
1fff9250:	401c      	ands	r4, r3
1fff9252:	d1f4      	bne.n	1fff923e <port_B_isr+0xe>
1fff9254:	bd38      	pop	{r3, r4, r5, pc}
1fff9256:	bf00      	nop
1fff9258:	4004a000 	.word	0x4004a000
1fff925c:	1fffa124 	.word	0x1fffa124

1fff9260 <port_A_isr>:
PORT_ISR_FUNCTION_CLZ(A)
1fff9260:	b538      	push	{r3, r4, r5, lr}
1fff9262:	4b09      	ldr	r3, [pc, #36]	; (1fff9288 <port_A_isr+0x28>)
1fff9264:	4d09      	ldr	r5, [pc, #36]	; (1fff928c <port_A_isr+0x2c>)
1fff9266:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0
1fff926a:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
1fff926e:	b14c      	cbz	r4, 1fff9284 <port_A_isr+0x24>
1fff9270:	fa94 f3a4 	rbit	r3, r4
1fff9274:	fab3 f383 	clz	r3, r3
1fff9278:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff927c:	4798      	blx	r3
1fff927e:	1e63      	subs	r3, r4, #1
1fff9280:	401c      	ands	r4, r3
1fff9282:	d1f4      	bne.n	1fff926e <port_A_isr+0xe>
1fff9284:	bd38      	pop	{r3, r4, r5, pc}
1fff9286:	bf00      	nop
1fff9288:	40049000 	.word	0x40049000
1fff928c:	1fffa0ec 	.word	0x1fffa0ec

1fff9290 <___ZN6weegfx8Graphics5BeginEPhb_veneer>:
1fff9290:	f85f f000 	ldr.w	pc, [pc]	; 1fff9294 <___ZN6weegfx8Graphics5BeginEPhb_veneer+0x4>
1fff9294:	00019273 	.word	0x00019273

1fff9298 <___ZN3ADC15startSingleReadEha_veneer>:
1fff9298:	f85f f000 	ldr.w	pc, [pc]	; 1fff929c <___ZN3ADC15startSingleReadEha_veneer+0x4>
1fff929c:	00018d29 	.word	0x00018d29

1fff92a0 <__usb_midi_read_veneer>:
1fff92a0:	f85f f000 	ldr.w	pc, [pc]	; 1fff92a4 <__usb_midi_read_veneer+0x4>
1fff92a4:	0001af15 	.word	0x0001af15

1fff92a8 <___ZN5debug22ScopedCycleMeasurementD1Ev_veneer>:
1fff92a8:	f85f f000 	ldr.w	pc, [pc]	; 1fff92ac <___ZN5debug22ScopedCycleMeasurementD1Ev_veneer+0x4>
1fff92ac:	00004f61 	.word	0x00004f61

1fff92b0 <___ZN12VBiasManager3getEv_veneer>:
1fff92b0:	f85f f000 	ldr.w	pc, [pc]	; 1fff92b4 <___ZN12VBiasManager3getEv_veneer+0x4>
1fff92b4:	0000507d 	.word	0x0000507d

1fff92b8 <___ZN2UI6Button4PollEv_veneer>:
1fff92b8:	f85f f000 	ldr.w	pc, [pc]	; 1fff92bc <___ZN2UI6Button4PollEv_veneer+0x4>
1fff92bc:	00000f99 	.word	0x00000f99

1fff92c0 <___ZN2UI10EventQueueILj16EE4PokeEv_veneer>:
1fff92c0:	f85f f000 	ldr.w	pc, [pc]	; 1fff92c4 <___ZN2UI10EventQueueILj16EE4PokeEv_veneer+0x4>
1fff92c4:	000011d5 	.word	0x000011d5

1fff92c8 <___ZN2OC2Ui9PushEventEN2UI9EventTypeEtst_veneer>:
1fff92c8:	f85f f000 	ldr.w	pc, [pc]	; 1fff92cc <___ZN2OC2Ui9PushEventEN2UI9EventTypeEtst_veneer+0x4>
1fff92cc:	00001209 	.word	0x00001209

1fff92d0 <___ZN6weegfx8Graphics3EndEv_veneer>:
1fff92d0:	f85f f000 	ldr.w	pc, [pc]	; 1fff92d4 <___ZN6weegfx8Graphics3EndEv_veneer+0x4>
1fff92d4:	0001928f 	.word	0x0001928f

1fff92d8 <___ZN17HemisphereManager14OnReceiveSysExEv_veneer>:
1fff92d8:	f85f f000 	ldr.w	pc, [pc]	; 1fff92dc <___ZN17HemisphereManager14OnReceiveSysExEv_veneer+0x4>
1fff92dc:	0000a5b5 	.word	0x0000a5b5

1fff92e0 <___ZN20SH1106_128x64_Driver8SendPageEjPKh_veneer>:
1fff92e0:	f85f f000 	ldr.w	pc, [pc]	; 1fff92e4 <___ZN20SH1106_128x64_Driver8SendPageEjPKh_veneer+0x4>
1fff92e4:	00019179 	.word	0x00019179

1fff92e8 <___ZN2OC13DigitalInputs4ScanEv_veneer>:
1fff92e8:	f85f f000 	ldr.w	pc, [pc]	; 1fff92ec <___ZN2OC13DigitalInputs4ScanEv_veneer+0x4>
1fff92ec:	00000e99 	.word	0x00000e99

1fff92f0 <___ZN12VBiasManager16DrawPopupPerhapsEv_veneer>:
1fff92f0:	f85f f000 	ldr.w	pc, [pc]	; 1fff92f4 <___ZN12VBiasManager16DrawPopupPerhapsEv_veneer+0x4>
1fff92f4:	00005099 	.word	0x00005099

1fff92f8 <___ZN2OC3DAC6UpdateEv_veneer>:
1fff92f8:	f85f f000 	ldr.w	pc, [pc]	; 1fff92fc <___ZN2OC3DAC6UpdateEv_veneer+0x4>
1fff92fc:	000008ed 	.word	0x000008ed

1fff9300 <___ZN2OC2Ui11AppSettingsEv_veneer>:
1fff9300:	f85f f000 	ldr.w	pc, [pc]	; 1fff9304 <___ZN2OC2Ui11AppSettingsEv_veneer+0x4>
1fff9304:	00016f69 	.word	0x00016f69

1fff9308 <___ZN3ADC10readSingleEa_veneer>:
1fff9308:	f85f f000 	ldr.w	pc, [pc]	; 1fff930c <___ZN3ADC10readSingleEa_veneer+0x4>
1fff930c:	00018db1 	.word	0x00018db1

1fff9310 <___ZN2OC2Ui14DispatchEventsEPNS_3AppE_veneer>:
1fff9310:	f85f f000 	ldr.w	pc, [pc]	; 1fff9314 <___ZN2OC2Ui14DispatchEventsEPNS_3AppE_veneer+0x4>
1fff9314:	00000fd1 	.word	0x00000fd1

1fff9318 <___ZN20SH1106_128x64_Driver5FlushEv_veneer>:
1fff9318:	f85f f000 	ldr.w	pc, [pc]	; 1fff931c <___ZN20SH1106_128x64_Driver5FlushEv_veneer+0x4>
1fff931c:	00018f55 	.word	0x00018f55

1fff9320 <__dso_handle>:
1fff9320:	00000000                                ....

1fff9324 <MENU_REDRAW>:
1fff9324:	00000001                                ....

1fff9328 <calibration_steps>:
1fff9328:	00000000 000213fd 0002140d 00000000     ................
	...
1fff9344:	0001f3a4 00000000 00000001 00000001     ................
1fff9354:	0002141c 0002142b 00000000 00000000     ....+...........
1fff9364:	00000007 00000000 00000000 00000000     ................
1fff9374:	00000002 00000002 00021439 0002144a     ........9...J...
	...
1fff938c:	00000001 00000000 00000000 00000000     ................
1fff939c:	0000ffff 00000003 00021455 00021466     ........U...f...
	...
1fff93b4:	00000001 00000001 00000000 00000000     ................
1fff93c4:	0000ffff 00000004 00021471 00021482     ........q.......
	...
1fff93dc:	00000001 00000002 00000000 00000000     ................
1fff93ec:	0000ffff 00000005 0002148d 0002149e     ................
	...
1fff9404:	00000001 00000003 00000000 00000000     ................
1fff9414:	0000ffff 00000006 000214a9 000214ba     ................
	...
1fff942c:	00000001 00000004 00000000 00000000     ................
1fff943c:	0000ffff 00000007 000214c5 000214d6     ................
	...
1fff9454:	00000001 00000005 00000000 00000000     ................
1fff9464:	0000ffff 00000008 000214e1 000214f2     ................
	...
1fff947c:	00000001 00000006 00000000 00000000     ................
1fff948c:	0000ffff 00000009 000214fd 0002150e     ................
	...
1fff94a4:	00000001 00000007 00000000 00000000     ................
1fff94b4:	0000ffff 0000000a 00021519 0002152a     ............*...
	...
1fff94cc:	00000001 00000008 00000000 00000000     ................
1fff94dc:	0000ffff 0000000b 00021535 00021546     ........5...F...
	...
1fff94f4:	00000001 00000009 00000000 00000000     ................
1fff9504:	0000ffff 0000000c 00021551 00021562     ........Q...b...
	...
1fff951c:	00000001 0000000a 00000000 00000000     ................
1fff952c:	0000ffff 0000000d 0002156e 0002144a     ........n...J...
	...
1fff9544:	00000001 00000000 00000000 00000000     ................
1fff9554:	0000ffff 0000000e 0002157f 00021466     ............f...
	...
1fff956c:	00000001 00000001 00000000 00000000     ................
1fff957c:	0000ffff 0000000f 00021590 00021482     ................
	...
1fff9594:	00000001 00000002 00000000 00000000     ................
1fff95a4:	0000ffff 00000010 000215a1 0002149e     ................
	...
1fff95bc:	00000001 00000003 00000000 00000000     ................
1fff95cc:	0000ffff 00000011 000215b2 000214ba     ................
	...
1fff95e4:	00000001 00000004 00000000 00000000     ................
1fff95f4:	0000ffff 00000012 000215c3 000214d6     ................
	...
1fff960c:	00000001 00000005 00000000 00000000     ................
1fff961c:	0000ffff 00000013 000215d4 000214f2     ................
	...
1fff9634:	00000001 00000006 00000000 00000000     ................
1fff9644:	0000ffff 00000014 000215e5 0002150e     ................
	...
1fff965c:	00000001 00000007 00000000 00000000     ................
1fff966c:	0000ffff 00000015 000215f6 0002152a     ............*...
	...
1fff9684:	00000001 00000008 00000000 00000000     ................
1fff9694:	0000ffff 00000016 00021607 00021546     ............F...
	...
1fff96ac:	00000001 00000009 00000000 00000000     ................
1fff96bc:	0000ffff 00000017 00021618 00021562     ............b...
	...
1fff96d4:	00000001 0000000a 00000000 00000000     ................
1fff96e4:	0000ffff 00000018 00021629 0002144a     ........)...J...
	...
1fff96fc:	00000001 00000000 00000000 00000000     ................
1fff970c:	0000ffff 00000019 0002163a 00021466     ........:...f...
	...
1fff9724:	00000001 00000001 00000000 00000000     ................
1fff9734:	0000ffff 0000001a 0002164b 00021482     ........K.......
	...
1fff974c:	00000001 00000002 00000000 00000000     ................
1fff975c:	0000ffff 0000001b 0002165c 0002149e     ........\.......
	...
1fff9774:	00000001 00000003 00000000 00000000     ................
1fff9784:	0000ffff 0000001c 0002166d 000214ba     ........m.......
	...
1fff979c:	00000001 00000004 00000000 00000000     ................
1fff97ac:	0000ffff 0000001d 0002167e 000214d6     ........~.......
	...
1fff97c4:	00000001 00000005 00000000 00000000     ................
1fff97d4:	0000ffff 0000001e 0002168f 000214f2     ................
	...
1fff97ec:	00000001 00000006 00000000 00000000     ................
1fff97fc:	0000ffff 0000001f 000216a0 0002150e     ................
	...
1fff9814:	00000001 00000007 00000000 00000000     ................
1fff9824:	0000ffff 00000020 000216b1 0002152a     .... .......*...
	...
1fff983c:	00000001 00000008 00000000 00000000     ................
1fff984c:	0000ffff 00000021 000216c2 00021546     ....!.......F...
	...
1fff9864:	00000001 00000009 00000000 00000000     ................
1fff9874:	0000ffff 00000022 000216d3 00021562     ....".......b...
	...
1fff988c:	00000001 0000000a 00000000 00000000     ................
1fff989c:	0000ffff 00000023 000216e4 0002144a     ....#.......J...
	...
1fff98b4:	00000001 00000000 00000000 00000000     ................
1fff98c4:	0000ffff 00000024 000216f5 00021466     ....$.......f...
	...
1fff98dc:	00000001 00000001 00000000 00000000     ................
1fff98ec:	0000ffff 00000025 00021706 00021482     ....%...........
	...
1fff9904:	00000001 00000002 00000000 00000000     ................
1fff9914:	0000ffff 00000026 00021717 0002149e     ....&...........
	...
1fff992c:	00000001 00000003 00000000 00000000     ................
1fff993c:	0000ffff 00000027 00021728 000214ba     ....'...(.......
	...
1fff9954:	00000001 00000004 00000000 00000000     ................
1fff9964:	0000ffff 00000028 00021739 000214d6     ....(...9.......
	...
1fff997c:	00000001 00000005 00000000 00000000     ................
1fff998c:	0000ffff 00000029 0002174a 000214f2     ....)...J.......
	...
1fff99a4:	00000001 00000006 00000000 00000000     ................
1fff99b4:	0000ffff 0000002a 0002175b 0002150e     ....*...[.......
	...
1fff99cc:	00000001 00000007 00000000 00000000     ................
1fff99dc:	0000ffff 0000002b 0002176c 0002152a     ....+...l...*...
	...
1fff99f4:	00000001 00000008 00000000 00000000     ................
1fff9a04:	0000ffff 0000002c 0002177d 00021546     ....,...}...F...
	...
1fff9a1c:	00000001 00000009 00000000 00000000     ................
1fff9a2c:	0000ffff 0000002d 0002178e 00021562     ....-.......b...
	...
1fff9a44:	00000001 0000000a 00000000 00000000     ................
1fff9a54:	0000ffff 0000002e 0002179f 000217af     ................
	...
1fff9a6c:	00000002 00000000 00000000 00000000     ................
1fff9a7c:	00000fff 0000002f 000217ba 000217af     ..../...........
	...
1fff9a94:	00000003 00000000 00000000 00000000     ................
1fff9aa4:	00000fff 00000030 000217c8 000217d0     ....0...........
	...
1fff9abc:	00000004 00000000 00000000 00000000     ................
1fff9acc:	00000fff 00000031 000217e0 000217d0     ....1...........
	...
1fff9ae4:	00000004 00000001 00000000 00000000     ................
1fff9af4:	00000fff 00000032 000217e8 000217d0     ....2...........
	...
1fff9b0c:	00000004 00000002 00000000 00000000     ................
1fff9b1c:	00000fff 00000033 000217f0 000217d0     ....3...........
	...
1fff9b34:	00000004 00000003 00000000 00000000     ................
1fff9b44:	00000fff 00000034 000217f8 00021806     ....4...........
1fff9b54:	00021819 00000000 00000005 00000000     ................
	...
1fff9b70:	00000035 0002182f 0002183d 00021819     5.../...=.......
1fff9b80:	00000000 00000006 00000000 00000000     ................
	...
1fff9b98:	00000036 00021850 0002185c 00000000     6...P...\.......
1fff9ba8:	00000000 00000008 00000000 00000000     ................
1fff9bb8:	00000002 00000078 00000037 00021868     ....x...7...h...
1fff9bc8:	0002187d 00000000 00000000 00000000     }...............
1fff9bd8:	00000000 0001f3a4 00000000 00000001     ................

1fff9be8 <HS::library_waveforms>:
1fff9be8:	01ffff02 ff020100 010000ff 0000ff02     ................
1fff9bf8:	ff0c01ff 01ee01c0 01ee01ff 018001c0     ................
1fff9c08:	01120140 01120100 01800140 0140ff0c     @.......@.....@.
1fff9c18:	01000112 01400112 01c00180 01ff01ee     ......@.........
1fff9c28:	01c001ee ff040180 01ff00ff 01000000     ................
1fff9c38:	00ffff04 000002ff ff040100 03ff00ff     ................
1fff9c48:	01000000 00ffff04 000004ff ff030100     ................
1fff9c58:	03ff01ff ff0b0100 018001ff 018001b0     ................
1fff9c68:	010001ff 01500180 01000180 ff0a0180     ......P.........
1fff9c78:	01a000a0 011e001e 01ff00ff 01640064     ............d.d.
1fff9c88:	01000000 00ffff0c 01fb01fe 01ed01f3     ................
1fff9c98:	01cf01e2 018d01b3 01000154 ff0c0000     ........T.......
1fff9ca8:	01ba00ff 0165018b 0135014b 01120123     ......e.K.5.#...
1fff9cb8:	01040107 00000100 01ffff08 01c00000     ................
1fff9cc8:	01800000 01400000 ff090000 01ff00ff     ......@.........
1fff9cd8:	01c000c0 01800080 01400040 ff040000     ........@.@.....
1fff9ce8:	028000ff 02000180 01ffff04 01800280     ................
1fff9cf8:	ff050200 01ff00da 01c00180 ff020100     ................
1fff9d08:	018001ff 00ffff02 ff020180 01ff0080     ................
1fff9d18:	00ffff04 008001ff ff0c0180 01890180     ................
1fff9d28:	01c001a0 01f701e0 01f701ff 01c001e0     ................
1fff9d38:	018901a0 01c0ff07 01ff01ee 01bf01ee     ................
1fff9d48:	06800180 01ffff03 01800180 01ffff03     ................
1fff9d58:	02800180 01ffff03 04800180 02ffff03     ................
1fff9d68:	01800280 01ffff05 01dc0180 04800180     ................
1fff9d78:	03ffff03 02800180 0094ff06 02fa05b4     ................
1fff9d88:	02b401ff 00000594                       ........

1fff9d90 <OC::apps::current_app>:
1fff9d90:	1fff9e54                                T...

1fff9d94 <settings::SettingsBase<TheDarkestTimeline, 8u>::value_attr_>:
1fff9d94:	00000010 00000001 00000020 000209da     ........ .......
1fff9da4:	00000000 00000002 00000000 00000000     ................
1fff9db4:	0000001f 00021ab7 00000000 00000002     ................
1fff9dc4:	00000005 00000000 00000000 00020cc6     ................
1fff9dd4:	00000000 00000002 00000000 00000000     ................
1fff9de4:	0000000c 000207a9 00000000 00000002     ................
	...
1fff9dfc:	00000010 000210e7 00000000 00000002     ................
	...
1fff9e14:	00000010 00021abd 00000000 00000002     ................
	...
1fff9e2c:	00000010 00021ace 00000000 00000002     ................
	...
1fff9e44:	00000064 00021ade 00000000 00000002     d...............

1fff9e54 <available_apps>:
1fff9e54:	00004853 0002108b 0000a695 000014cd     SH..............
1fff9e64:	00015d91 00015e25 0000a531 00004c69     .]..%^..1...iL..
1fff9e74:	0000a2f9 00004c6b 0000a359 0000a19d     ....kL..Y.......
1fff9e84:	1fff9005 00004d49 0002107e 0000a925     ....IM..~...%...
1fff9e94:	000014d9 000162c5 0001636d 000055d5     .....b..mc...U..
1fff9ea4:	00004c61 00005b6d 00004c63 00015f9d     aL..m[..cL..._..
1fff9eb4:	000160f5 00005c7d 00004432 00021200     .`..}\..2D......
1fff9ec4:	00005b25 00001535 00016b81 00016c29     %[..5....k..)l..
1fff9ed4:	000056e1 00004c53 00005bad 00004c55     .V..SL...[..UL..
1fff9ee4:	0000d28d 000169b5 00005cbd 0000454e     .....i...\..NE..
1fff9ef4:	000210ab 00005ae5 000014c1 00015bed     .....Z.......[..
1fff9f04:	00015c85 00007ab1 00004c65 00005b5d     .\...z..eL..][..
1fff9f14:	00004c67 00007b61 000076a1 00005c6d     gL..a{...v..m\..
1fff9f24:	00004e4e 000210d0 00005af5 000014fd     NN.......Z......
1fff9f34:	00016499 00016531 0000b8c1 00004c5d     .d..1e......]L..
1fff9f44:	00005b7d 00004c5f 0000b44d 000046c5     }[.._L..M....F..
1fff9f54:	00005c8d 00005343 000218e9 00005b05     .\..CS.......[..
1fff9f64:	00004c41 00004bf3 00004bf7 000054d1     AL...K...K...T..
1fff9f74:	00004c57 00005b8d 00004c59 0000cc31     WL...[..YL..1...
1fff9f84:	0000ce05 00005c9d 00005741 00021247     .....\..AW..G...
1fff9f94:	00005b35 00004c2d 00004c03 00004c07     5[..-L...L...L..
1fff9fa4:	0000e1a5 00004c4d 00005bbd 00004c4f     ....ML...[..OL..
1fff9fb4:	0000e251 0000ddc1 00005ccd 0000504f     Q........\..OP..
1fff9fc4:	000218f6 0000c0fd 00004c3d 00004beb     ........=L...K..
1fff9fd4:	00004bef 00001529 0000c2d5 0000c191     .K..)...........
1fff9fe4:	00004c5b 0000c3b9 0000c3e9 00001509     [L..............
1fff9ff4:	00004252 00020f03 000014a7 000014a9     RB..............
1fffa004:	000014ad 000046c1 000014b1 00004c6d     .....F......mL..
1fffa014:	00005ab1 00005ac1 00005349 00003bb5     .Z...Z..IS...;..
1fffa024:	00005245 00005345 00020f6c 00005b15     ER..ES..l....[..
1fffa034:	00004c45 00004bfb 00004bff 00004c49     EL...K...K..IL..
1fffa044:	00004c4b 00005b9d 00004c51 00017779     KL...[..QL..yw..
1fffa054:	00001533 00005cad                       3....\..

1fffa05c <default_footer>:
1fffa05c:	000218a7                                ....

1fffa060 <default_help_r>:
1fffa060:	00021899                                ....

1fffa064 <end_footer>:
1fffa064:	000218bd                                ....

1fffa068 <enigma_type_names>:
1fffa068:	00021c39 00021c44 00021c4f 00021c5a     9...D...O...Z...
1fffa078:	00021c65 00021c70 00021c7b 00020afc     e...p...{.......
1fffa088:	00020c91                                ....

1fffa08c <enigma_type_short_names>:
1fffa08c:	00021c16 00021c1d 00021c24 00021c2b     ........$...+...
1fffa09c:	00021c32 00020590 00021ba8 00020afc     2...............
1fffa0ac:	00020c91                                ....

1fffa0b0 <select_help>:
1fffa0b0:	0002188b                                ....

1fffa0b4 <start_footer>:
1fffa0b4:	000218d3                                ....

1fffa0b8 <ui_mode>:
1fffa0b8:	                                         .

1fffa0b9 <SH1106_init_seq>:
1fffa0b9:	a880d5ae 4000d33f 0020148d 12dac0a0     ....?..@.. .....
1fffa0c9:	f1d9cf81 a42e40db                        .....@...

1fffa0d2 <SH1106_data_start_seq>:
1fffa0d2:	                                         ...

1fffa0d5 <SH1106_display_on_seq>:
1fffa0d5:	                                         ...

1fffa0d8 <funct_table>:
1fffa0d8:	00019d5d 00019d5d 00019d5d 00019d5d     ]...]...]...]...

1fffa0e8 <__brkval>:
1fffa0e8:	20006a14                                .j. 

1fffa0ec <isr_table_portA>:
1fffa0ec:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa0fc:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa10c:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa11c:	0001a259 0001a259                       Y...Y...

1fffa124 <isr_table_portB>:
1fffa124:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa134:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa144:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa154:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa164:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...

1fffa174 <isr_table_portC>:
1fffa174:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa184:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa194:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...

1fffa1a4 <isr_table_portD>:
1fffa1a4:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...
1fffa1b4:	0001a259 0001a259 0001a259 0001a259     Y...Y...Y...Y...

1fffa1c4 <isr_table_portE>:
1fffa1c4:	0001a259 0001a259                       Y...Y...

1fffa1cc <usb_buffer_available>:
1fffa1cc:	ffffffff                                ....

1fffa1d0 <yield_active_check_flags>:
1fffa1d0:	                                         .

1fffa1d1 <analog_config_bits>:
1fffa1d1:	                                         .

1fffa1d2 <analog_num_average>:
1fffa1d2:	                                         .

1fffa1d3 <config_descriptor>:
1fffa1d3:	00950209 c0000103 000b0832 01020202     ........2.......
1fffa1e3:	00040900 02020100 24050001 05011000     ...........$....
1fffa1f3:	01010124 06022404 00062405 81050701     $....$...$......
1fffa203:	40001003 00010409 00000a02 02050700     ...@............
1fffa213:	00004002 02830507 09000040 02000204     .@......@.......
1fffa223:	00000301 00012407 06002501 01010224     .....$...%..$...
1fffa233:	02240605 09050202 03010324 05010201     ..$.....$.......
1fffa243:	02032409 01010104 05050905 00004002     .$...........@..
1fffa253:	25050000 09010101 40028405 00000000     ...%.......@....
1fffa263:	01012505                                 .%...

1fffa268 <device_descriptor>:
1fffa268:	01100112 40000000 048916c0 02010275     .......@....u...
1fffa278:	                                         ..

1fffa27a <string0>:
1fffa27a:	04090304                                ....

1fffa27e <usb_string_manufacturer_name_default>:
1fffa27e:	00540318 00650065 0073006e 00640079     ..T.e.e.n.s.y.d.
1fffa28e:	00690075 006f006e                       u.i.n.o.

1fffa296 <usb_string_midi_port1_default>:
1fffa296:	0050030e 0072006f 00200074               ..P.o.r.t. .1.

1fffa2a4 <usb_string_product_name_default>:
1fffa2a4:	00540318 00650065 0073006e 00200079     ..T.e.e.n.s.y. .
1fffa2b4:	0049004d 00490044                       M.I.D.I.

1fffa2bc <usb_string_serial_number_default>:
1fffa2bc:	0000030c 00000000 00000000 00000000     ................
	...

1fffa2d4 <_impure_data>:
1fffa2d4:	00000000 200068d4 2000693c 200069a4     .....h. <i. .i. 
	...

1fffa320 <_impure_ptr>:
1fffa320:	1fffa2d4                                ....
